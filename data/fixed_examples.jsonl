{"title": "Automated Bottle Filling Line Control", "description": "Design a function block (FB) to control an automated bottle filling production line. The line handles washing, filling, capping, and packing bottles, with each step controlled by PLC and triggered by sensors and operator inputs.\n\nControl logic:\n1. When the bottleSensor detects a bottle, start the cleaning pump.\n2. After cleaning, the operator presses cleaningConfirmButton to confirm completion, triggering the filling valve.\n3. After filling, the operator presses fillingConfirmButton to confirm completion, triggering the capping machine.\n4. After capping, the operator presses cappingConfirmButton to confirm completion, triggering the packing machine.\n5. After packing, the operator presses packingConfirmButton to confirm completion, turning on the completion light.\n6. Once the operator removes the packed bottle and presses finishedButton, reset the light and prepare for the next bottle.\n\nThe function block ensures proper sequencing and prevents operation out of order.", "type": "FUNCTION_BLOCK", "name": "FB_BottleProcessing", "input": [{"name": "bottleSensor", "type": "Bool", "description": "Detects when a bottle arrives, triggering the cleaning process"}, {"name": "cleaningConfirmButton", "type": "Bool", "description": "Operator confirms cleaning completion"}, {"name": "fillingConfirmButton", "type": "Bool", "description": "Operator confirms filling completion"}, {"name": "cappingConfirmButton", "type": "Bool", "description": "Operator confirms capping completion"}, {"name": "packingConfirmButton", "type": "Bool", "description": "Operator confirms packing completion"}, {"name": "finishedButton", "type": "Bool", "description": "Operator confirms bottle removal"}], "output": [{"name": "Pump_Motor", "type": "Bool", "description": "Controls the cleaning pump"}, {"name": "Filling_Valve", "type": "Bool", "description": "Controls the filling valve"}, {"name": "Capping_Machine", "type": "Bool", "description": "Controls the capping machine"}, {"name": "Packing_Machine", "type": "Bool", "description": "Controls the packing machine"}, {"name": "Completion_Light", "type": "Bool", "description": "Indicates packing completion"}], "in/out": [], "answer": "FUNCTION_BLOCK \"FB_BottleProcessing\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n VAR_INPUT \n bottleSensor : Bool;\n cleaningConfirmButton : Bool;\n fillingConfirmButton : Bool;\n cappingConfirmButton : Bool;\n packingConfirmButton : Bool;\n finishedButton : Bool;\n END_VAR\n\n VAR_OUTPUT \n Pump_Motor : Bool;\n Filling_Valve : Bool;\n Capping_Machine : Bool;\n Packing_Machine : Bool;\n Completion_Light : Bool;\n END_VAR\n\n VAR \n statBottleDetected : Bool := FALSE;\n statCleaningFinished : Bool := FALSE;\n statFillingFinished : Bool := FALSE;\n statCappingFinished : Bool := FALSE;\n statPackingFinished : Bool := FALSE;\n END_VAR\n\nBEGIN\n\t// Detect bottle and start cleaning pump\n\tIF bottleSensor AND NOT statBottleDetected THEN\n\t statBottleDetected := TRUE;\n\t Pump_Motor := TRUE;\n\tEND_IF;\n\t\n\t// Cleaning confirmation triggers filling\n\tIF cleaningConfirmButton AND statBottleDetected THEN\n\t statCleaningFinished := TRUE;\n\t Pump_Motor := FALSE;\n\t Filling_Valve := TRUE;\n\tEND_IF;\n\t\n\t// Filling confirmation triggers capping\n\tIF fillingConfirmButton AND statCleaningFinished THEN\n\t statFillingFinished := TRUE;\n\t Filling_Valve := FALSE;\n\t Capping_Machine := TRUE;\n\tEND_IF;\n\t\n\t// Capping confirmation triggers packing\n\tIF cappingConfirmButton AND statFillingFinished THEN\n\t statCappingFinished := TRUE;\n\t Capping_Machine := FALSE;\n\t Packing_Machine := TRUE;\n\tEND_IF;\n\t\n\t// Packing confirmation lights completion indicator\n\tIF packingConfirmButton AND statCappingFinished THEN\n\t statPackingFinished := TRUE;\n\t Packing_Machine := FALSE;\n\t Completion_Light := TRUE;\n\tEND_IF;\n\t\n\t// Reset after bottle removal\n\tIF finishedButton AND statPackingFinished THEN\n\t statBottleDetected := FALSE;\n\t statCleaningFinished := FALSE;\n\t statFillingFinished := FALSE;\n\t statCappingFinished := FALSE;\n\t statPackingFinished := FALSE;\n\t Completion_Light := FALSE;\n\tEND_IF;\nEND_FUNCTION_BLOCK", "ID": 0, "score": 118}
{"title": "Calculate the Day of the Year", "description": "In some automation systems, it may be necessary to calculate which day of the year corresponds to the current date. This can be used for tracking production cycles, maintenance schedules, or other situations requiring date information.\nControl requirements:\nThe system needs to receive date inputs, including year, month, and day.\nBased on the input date, calculate and output which day of the year it is.\nConsidering that February may have different numbers of days in different years (28 days in a common year, 29 days in a leap year), the system needs to recognize leap years and calculate accordingly.\nThe output should be an integer representing the day of the year.\nIf the input date is invalid (e.g., February 30, April 31, etc.), the system should output an error status and error code.\nNotes:\n1. The input year Year should be between 1000 and 3000 (inclusive); otherwise, output error status error=true and error code status=16#8001. If the input month Month is invalid, output error status error=true and error code status=16#8002. If the input day Day is invalid, output error status error=true and error code status=16#8003.\n2. The calculated result should be output through DayOfYear.", "type": "FUNCTION_BLOCK", "name": "FB_CalculateDayOfYear", "input": [{"name": "Year", "type": "Int", "description": "Year input"}, {"name": "Month", "type": "Int", "description": "Month input"}, {"name": "Day", "type": "Int", "description": "Day input"}], "output": [{"name": "DayOfYear", "type": "Int", "description": "Day of the year output"}, {"name": "error", "type": "Bool", "description": "Error status indicator FALSE: no error TRUE: execution error"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [], "ID": 1, "is_sample": false, "cot": "1. First, check whether the input year, month, and day are valid. If invalid, set the error status and error code, then exit.\n2. Then, determine whether the input year is a leap year. If it is a leap year, February has 29 days; otherwise, it has 28 days.\n3. Finally, based on the input month and day, calculate which day of the year it is.\n4. Note: If variables like STATUS_FINISHED_NO_ERROR are needed, they must be defined in VAR CONSTANT first; undefined variables cannot be used.\n5. Note: Array assignments must be done at declaration. That is, definition and assignment must be in VAR, not in the code block, and not in VAR CONSTANT. Correct example:\nscl\nVAR\n A : ARRAY[1..10] OF Int := [1,1,1,1,1,1,1,1,1,1];\nEND_VAR\n\n6. Note: The SUM function must not be used in the program; SCL language does not support it.\n7. Note: Loop variables must not use Month, as it is a program input variable. Define a separate loop variable, e.g., i.\n8. Note: Check for leap year first, then validate the input day Day. If it is a leap year, first modify the previously defined array, then check whether the input Day is valid.", "answer": "FUNCTION_BLOCK \"FB_CalculateDayOfYear\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT\n      Year : Int;\n      Month : Int;\n      Day : Int;\n   END_VAR\n\n   VAR_OUTPUT\n      DayOfYear : Int;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR\n      daysPerMonth : Array[1..12] of Int := [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n   END_VAR\n\n   VAR_TEMP\n      isLeapYear : Bool;\n      tempMonth : Int;\n   END_VAR\n\n   VAR CONSTANT\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_INVALID_YEAR : Word := 16#8001;\n      ERR_INVALID_MONTH : Word := 16#8002;\n      ERR_INVALID_DAY : Word := 16#8003;\n   END_VAR\n\n\nBEGIN\n\t// Check if year is within valid range\n\tIF (#Year < 1000) OR (#Year > 3000) THEN\n\t  #error := TRUE;\n\t  #status := #ERR_INVALID_YEAR;\n\t  RETURN;\n\tEND_IF;\n\n\t// Check if month is valid\n\tIF (#Month < 1) OR (#Month > 12) THEN\n\t  #error := TRUE;\n\t  #status := #ERR_INVALID_MONTH;\n\t  RETURN;\n\tEND_IF;\n\n\t// Check for leap year\n\t#isLeapYear := (#Year MOD 4 = 0) AND (#Year MOD 100 <> 0) OR (#Year MOD 400 = 0);\n\tIF #isLeapYear THEN\n\t  #daysPerMonth[2] := 29;\n\tEND_IF;\n\n\t// Check if day is valid\n\tIF (#Day < 1) OR (#Day > #daysPerMonth[#Month]) THEN\n\t  #error := TRUE;\n\t  #status := #ERR_INVALID_DAY;\n\t  RETURN;\n\tEND_IF;\n\n\t// Calculate DayOfYear\n\t#DayOfYear := 0;\n\tFOR #tempMonth := 1 TO #Month - 1 DO\n\t  #DayOfYear += #daysPerMonth[#tempMonth];\n\tEND_FOR;\n\t#DayOfYear += #Day;\n\n\t// Set outputs\n\t#error := FALSE;\n\t#status := #STATUS_NO_ERROR;\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        Year : Int;\n        Month : Int;\n        Day : Int;\n    END_VAR\n\n    VAR_OUTPUT\n        DayOfYear : Int;\n        error : Bool;\n        status : Word;\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR", "score": 120}
{"title": "Console Indicator Light Sequence Control", "description": "A console is equipped with 3 indicator lights: green, red, and yellow. These lights need to be controlled in a cycle using a control button.\nControl requirements:\nUse an input parameter controlButton to represent the state of the control button. This button is a pulse signal, generating a transition from 0 to 1 each time it is triggered.\nUse three output parameters greenLight, redLight, and yellowLight to control the corresponding green, red, and yellow indicator lights.\nThe sequence of button triggers and the corresponding indicator light states are as follows:\n1st trigger: only the green light greenLight is on.\n2nd trigger: only the red light redLight is on.\n3rd trigger: only the yellow light yellowLight is on.\n4th trigger: all three lights are on.\n5th trigger: all three lights are off.\n6th trigger and beyond: repeat the above cycle.", "type": "FUNCTION_BLOCK", "name": "FB_ColorLightControl", "input": [{"name": "controlButton", "type": "Bool", "description": "Control button switch, pulse signal"}], "output": [{"name": "greenLight", "type": "Bool", "description": "Green indicator light"}, {"name": "redLight", "type": "Bool", "description": "Red indicator light"}, {"name": "yellowLight", "type": "Bool", "description": "Yellow indicator light"}], "in/out": [], "return_value": [], "ID": 2, "is_sample": false, "cot": "1. Define a variable count to record the number of times the control button is triggered.\n2. When the control button transitions from 0 to 1, increment count by 1.\n3. Control the indicator light states based on the value of count.\n4. Note: Int type variables must not be directly operated with Bool type variables; only Bool type variables can perform And operations with other Bool type variables.\n5. Note: To detect the pulse signal, a Bool type variable PrecontrolButton should be defined and initialized to FALSE, and used together with the controlButton variable to implement pulse detection.", "answer": "FUNCTION_BLOCK \"FB_ColorLightControl\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      controlButton : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      greenLight : Bool;\n      redLight : Bool;\n      yellowLight : Bool;\n   END_VAR\n\n   VAR \n      StepCounter : Int := 0;\n      LastButtonState : Bool := FALSE;\n   END_VAR\n\n\nBEGIN\n\t// Check if the control button was pressed (rising edge)\n\tIF (#controlButton AND NOT #LastButtonState) THEN\n\t    // Increment the step counter\n\t    #StepCounter := #StepCounter + 1;\n\t    \n\t    // If the step counter exceeds 5, reset it to 1\n\t    IF (#StepCounter > 5) THEN\n\t        #StepCounter := 1;\n\t    END_IF;\n\t    \n\t    // Update the light states based on the step counter\n\t    CASE #StepCounter OF\n\t        1:\n\t            #greenLight := TRUE;\n\t            #redLight := FALSE;\n\t            #yellowLight := FALSE;\n\t        2:\n\t            #greenLight := FALSE;\n\t            #redLight := TRUE;\n\t            #yellowLight := FALSE;\n\t        3:\n\t            #greenLight := FALSE;\n\t            #redLight := FALSE;\n\t            #yellowLight := TRUE;\n\t        4:\n\t            #greenLight := TRUE;\n\t            #redLight := TRUE;\n\t            #yellowLight := TRUE;\n\t        5:\n\t            #greenLight := FALSE;\n\t            #redLight := FALSE;\n\t            #yellowLight := FALSE;\n\t    END_CASE;\n\tEND_IF;\n\t\n\t// Update the last button state\n\t#LastButtonState := #controlButton;\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        controlButton : Bool;\n    END_VAR\n\n    VAR_OUTPUT\n        greenLight : Bool;    //Green indicator light\n        redLight : Bool;    //Red indicator light\n        yellowLight : Bool;    //Yellow indicator light\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR", "score": 77}
{"title": "PLC Database Data Storage and Management System", "description": "In some automation applications, a PLC needs to collect and store large amounts of data, such as sensor readings, production counts, or other process variables. These data are usually stored in the PLC's internal database or an external database system.\nControl requirements:\nThe system needs to receive a set of data dataInput, constructed as a byte array. The first byte of this data, dataInput[0], represents the length of the data to be stored.\nThe storage operation is triggered by the input storeTrigger.\nData needs to be stored in the database sequentially, and each data set may have different lengths.\nWhen the remaining space in the database is insufficient to store a new data set, the system should trigger an error (error).\nThe system should provide a reset function via the input resetTrigger to clear the database and reset the error.\nThe system should be able to output the current usage and remaining space of the database.\nNotes:\n1. When the storeTrigger is activated, first check the data input length information (i.e., the first byte of the array dataInput[0]). If it is less than or equal to 0 or greater than 5, output error status error=true and error code status=16#8001. If the remaining space in the database is insufficient for the new data, output error status error=true and error code status=16#8002. If there are no errors, extract the data starting from the second byte of the input array and store it in the database. Data must not overwrite existing database contents; store sequentially after existing data.\n2. When the resetTrigger is activated, clear all data in the database and reset the error status error=0 and status=0.\n3. The database's used space and remaining space should be output through usedSpace and remainingSpace, respectively.", "type": "FUNCTION_BLOCK", "name": "FB_DatabaseManager", "input": [{"name": "dataInput", "type": "Array[0..5] of Byte", "description": "Data input, byte array"}, {"name": "storeTrigger", "type": "Bool", "description": "Storage trigger signal"}, {"name": "resetTrigger", "type": "Bool", "description": "Reset trigger signal"}], "output": [{"name": "usedSpace", "type": "Int", "description": "Database used space"}, {"name": "remainingSpace", "type": "Int", "description": "Database remaining space"}, {"name": "error", "type": "Bool", "description": "Error status indicator FALSE: no error TRUE: execution error"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "dataBase", "type": "Array[1..20] of Byte", "description": "Database, byte array"}], "return_value": [], "ID": 3, "is_sample": false, "cot": "1. Check the storage trigger signal storeTrigger; if true, perform the storage operation.\n2. Check the data input length information; if it is less than or equal to 0 or greater than 5, output error status and error code.\n3. Check the remaining space in the database; if insufficient to store new data, output error status and error code.\n4. If there are no errors, extract the data from the second byte of the input array and store it in the database.\n5. Check the reset trigger signal resetTrigger; if true, clear the database and reset the error status.\n6. Output the database's used space and remaining space.", "answer": "FUNCTION_BLOCK \"FB_DatabaseManager\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      dataInput : Array[0..5] of Byte;\n      storeTrigger : Bool;\n      resetTrigger : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      usedSpace : Int;\n      remainingSpace : Int;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      dataBase : Array[1..20] of Byte;\n   END_VAR\n\n   VAR \n      statDataBaseIndex : Int := 1;\n      statError : Bool;\n      statStatus : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempDataLength : Int;\n      tempDataIndex : Int;\n   END_VAR\n\n   VAR CONSTANT \n      DATABASE_SIZE : Int := 20;\n      STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_ILLEGAL_DATA_LENGTH : Word := 16#8001;\n      STATUS_DATABASE_FULL : Word := 16#8002;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            FB_DatabaseManager\n\t  // Comment/Function: PLC database data storage and management system\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Initialization and input data processing\n\t  // Reset the database when the reset trigger is activated\n\t  IF #resetTrigger THEN\n\t    #statDataBaseIndex := 1;\n\t    #statError := false;\n\t    #statStatus := #STATUS_NO_ERROR;\n\t    \n\t    FOR #tempDataIndex := 1 TO #DATABASE_SIZE DO\n\t      #dataBase[#tempDataIndex] := 0;\n\t    END_FOR;\n\t    \n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Data storage\n\t  // Check if the store trigger is activated\n\t  IF #storeTrigger THEN\n\t    \n\t    // Read the data length from the first byte of the input array\n\t    #tempDataLength := #dataInput[0];\n\t    \n\t    // Check if the data length is illegal\n\t    IF (#tempDataLength <= 0) OR (#tempDataLength > 5) THEN\n\t      #statError := true;\n\t      #statStatus := #STATUS_ILLEGAL_DATA_LENGTH;\n\t      \n\t      RETURN;\n\t    END_IF;\n\t    \n\t    // Check if there is enough space in the database\n\t    IF (#statDataBaseIndex + #tempDataLength - 1 > #DATABASE_SIZE) THEN\n\t      #statError := true;\n\t      #statStatus := #STATUS_DATABASE_FULL;\n\t      \n\t      RETURN;\n\t    END_IF;\n\t    \n\t    // Store the data in the database\n\t    FOR #tempDataIndex := 1 TO #tempDataLength DO\n\t      #dataBase[#statDataBaseIndex] := #dataInput[#tempDataIndex];\n\t      #statDataBaseIndex += 1;\n\t    END_FOR;\n\t    \n\t    // Update the error and status\n\t    #statError := false;\n\t    #statStatus := #STATUS_NO_ERROR;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Outputs\n\t  // Calculate the used and remaining space\n\t  #usedSpace := #statDataBaseIndex - 1;\n\t  #remainingSpace := #DATABASE_SIZE - #usedSpace;\n\t  \n\t  // Update the error and status outputs\n\t  #error := #statError;\n\t  #status := #statStatus;\n\t  \n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        dataInput : Array[0..5] of Byte;\n        storeTrigger : Bool;\n        resetTrigger : Bool;\n    END_VAR\n\n    VAR_OUTPUT\n        usedSpace : Int;\n        remainingSpace : Int;\n        error : Bool;\n        status : Word;\n    END_VAR\n\n    VAR_IN_OUT\n        dataBase : Array[1..20] of Byte;\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR", "score": 167}
{"title": "Floating-Point Interval Linearization Conversion", "description": "In some automation control systems, it may be necessary to convert a measured physical quantity (such as temperature, pressure, etc.) into another linearized or standardized value for processing by control algorithms or for display. For example, a sensor may measure a physical quantity that varies within a specific nonlinear range, but the control system requires a linearized value for calculation.\nControl requirements:\nThe system needs to receive a floating-point number as input, representing the original measured value.\nBased on the magnitude of the input value, convert it to different linear intervals and output the converted linearized value.\nWhen the input value is between 1200 and 3600, convert it to the range 150 to 240.\nWhen the input value is between 3600 and 4800, convert it to the range 240 to 560.\nWhen the input value is between 4800 and 7000, convert it to the range 560 to 720.\nIf the input value is less than 1200 or greater than 7000, the converted value should correspond to the linearized value for 1200 or 7000, and output error status Error=1, Status=16#8001.", "type": "FUNCTION_BLOCK", "name": "FB_LinearizeValue", "input": [{"name": "InputValue", "type": "Real", "description": "Floating-point input, original measured value"}], "output": [{"name": "LinearizedValue", "type": "Real", "description": "Converted linearized value"}, {"name": "Error", "type": "Bool", "description": "Error status indicator FALSE: no error TRUE: execution error"}, {"name": "Status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [], "ID": 4, "is_sample": false, "cot": "1. Determine the magnitude of the input value and perform linearization conversion according to different intervals.\n2. If the input value is less than 1200 or greater than 7000, the converted value should correspond to the linearized value for 1200 or 7000, and output error status Error=1, Status=16#8001.\n3. Output the converted linearized value.", "answer": "FUNCTION_BLOCK \"FB_LinearizeValue\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      InputValue : Real;\n   END_VAR\n\n   VAR_OUTPUT \n      LinearizedValue : Real;\n      Error : Bool;\n      Status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempInputValue : Real;\n      tempSlope1 : Real;\n      tempSlope2 : Real;\n      tempSlope3 : Real;\n      tempIntercept1 : Real;\n      tempIntercept2 : Real;\n      tempIntercept3 : Real;\n   END_VAR\n\n   VAR CONSTANT \n      INPUT_MIN : Real := 1200.0;\n      INPUT_MAX : Real := 7000.0;\n      INPUT_RANGE1 : Real := 2400.0;\n      INPUT_RANGE2 : Real := 1200.0;\n      INPUT_RANGE3 : Real := 2200.0;\n      OUTPUT_MIN : Real := 150.0;\n      OUTPUT_MAX : Real := 720.0;\n      OUTPUT_RANGE1 : Real := 90.0;\n      OUTPUT_RANGE2 : Real := 320.0;\n      OUTPUT_RANGE3 : Real := 160.0;\n      STATUS_ERROR : Word := 16#8001;\n   END_VAR\n\n\nBEGIN\n\n\t#tempInputValue := #InputValue;\n\t#tempSlope1 := #OUTPUT_RANGE1 / #INPUT_RANGE1;\n\t#tempSlope2 := #OUTPUT_RANGE2 / #INPUT_RANGE2;\n\t#tempSlope3 := #OUTPUT_RANGE3 / #INPUT_RANGE3;\n\t#tempIntercept1 := #OUTPUT_MIN - (#tempSlope1 * #INPUT_MIN);\n\t#tempIntercept2 := #OUTPUT_MIN - (#tempSlope2 * #INPUT_MIN);\n\t#tempIntercept3 := #OUTPUT_MAX - (#tempSlope3 * #INPUT_MAX);\n\t\n\tIF #tempInputValue < #INPUT_MIN THEN\n\t    #LinearizedValue := #OUTPUT_MIN;\n\t    #Error := TRUE;\n\t    #Status := #STATUS_ERROR;\n\tELSIF #tempInputValue < (#INPUT_MIN + #INPUT_RANGE1) THEN\n\t    #LinearizedValue := (#tempSlope1 * #tempInputValue) + #tempIntercept1;\n\t    #Error := FALSE;\n\t    #Status := 16#0000;\n\tELSIF #tempInputValue < (#INPUT_MIN + #INPUT_RANGE1 + #INPUT_RANGE2) THEN\n\t    #LinearizedValue := (#tempSlope2 * #tempInputValue) + #tempIntercept2;\n\t    #Error := FALSE;\n\t    #Status := 16#0000;\n\tELSIF #tempInputValue <= #INPUT_MAX THEN\n\t    #LinearizedValue := (#tempSlope3 * #tempInputValue) + #tempIntercept3;\n\t    #Error := FALSE;\n\t    #Status := 16#0000;\n\tELSE\n\t    #LinearizedValue := #OUTPUT_MAX;\n\t    #Error := TRUE;\n\t    #Status := #STATUS_ERROR;\n\tEND_IF;\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        InputValue : Real;\n    END_VAR\n\n    VAR_OUTPUT\n        LinearizedValue : Real;\n        Error : Bool;\n        Status : Word;\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR", "score": 115}
{"title": "Automated Production Line Control", "description": "A simple automated production line consists of three workstations: Workstation A, Workstation B, and Workstation C. A product must pass through these three stations sequentially to be considered fully completed. The production line has a motor responsible for moving the product from one workstation to the next, following the sequence from Workstation A to Workstation B, and then to Workstation C. Each workstation has a sensor (to detect whether the product has arrived) and a button (to trigger the processing completion signal for that station).\nControl requirements:\n1. Mode switching: The switch (Mode) is used to switch the production line between manual and automatic modes.\n2. Manual mode: In manual mode, the motor forward button (ForwardButton) controls the motor's forward rotation, and the motor reverse button (ReverseButton) controls the motor's reverse rotation. Forward and reverse operations are interlocked and cannot occur simultaneously.\n3. Automatic mode:\n - When the product arrives at Workstation A, SensorA detects the product, and the operator triggers the processing completion signal via ButtonA. Then the motor starts forward rotation to move the product to Workstation B.\n - When the product arrives at Workstation B, SensorB detects the product, the motor stops, and the operator triggers the processing completion signal via ButtonB. Then the motor starts forward rotation to move the product to Workstation C.\n - When the product arrives at Workstation C, SensorC detects the product, the motor stops, and the operator triggers the processing completion signal via ButtonC. The CompletionLight turns on to indicate the product is finished. When the product is removed, i.e., SensorC no longer detects the product, the CompletionLight turns off.", "type": "FUNCTION_BLOCK", "name": "FB_ProductionLineControl", "input": [{"name": "Mode", "type": "Bool", "description": "Used to switch the production line between manual and automatic modes, 0=Manual Mode, 1=Automatic Mode"}, {"name": "ForwardButton", "type": "Bool", "description": "Forward rotation button"}, {"name": "ReverseButton", "type": "Bool", "description": "Reverse rotation button"}, {"name": "SensorA", "type": "Bool", "description": "Sensor A"}, {"name": "SensorB", "type": "Bool", "description": "Sensor B"}, {"name": "SensorC", "type": "Bool", "description": "Sensor C"}, {"name": "ButtonA", "type": "Bool", "description": "Button A"}, {"name": "ButtonB", "type": "Bool", "description": "Button B"}, {"name": "ButtonC", "type": "Bool", "description": "Button C"}], "output": [{"name": "MotorForward", "type": "Bool", "description": "Motor forward output"}, {"name": "MotorReverse", "type": "Bool", "description": "Motor reverse output"}, {"name": "CompletionLight", "type": "Bool", "description": "Product completion indicator light"}], "in/out": [], "return_value": [], "ID": 5, "is_sample": false, "cot": "1. Define input and output variables\n2. Determine whether the current mode is manual or automatic based on the Mode switch\n3. If in manual mode, control the motor's forward and reverse rotation based on the states of ForwardButton and ReverseButton\n4. If in automatic mode, control the motor's forward rotation and the CompletionLight based on the states of the sensors and buttons", "answer": "FUNCTION_BLOCK \"FB_ProductionLineControl\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      Mode : Bool;\n      ForwardButton : Bool;\n      ReverseButton : Bool;\n      SensorA : Bool;\n      SensorB : Bool;\n      SensorC : Bool;\n      ButtonA : Bool;\n      ButtonB : Bool;\n      ButtonC : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      MotorForward : Bool;\n      MotorReverse : Bool;\n      CompletionLight : Bool;\n   END_VAR\n\n   VAR \n      statSensorA : Bool;\n      statSensorB : Bool;\n      statSensorC : Bool;\n      statButtonA : Bool;\n      statButtonB : Bool;\n      statButtonC : Bool;\n   END_VAR\n\n   VAR_TEMP \n      tempEdges : Struct\n         SensorA : Bool;\n         SensorB : Bool;\n         SensorC : Bool;\n         ButtonA : Bool;\n         ButtonB : Bool;\n         ButtonC : Bool;\n      END_STRUCT;\n   END_VAR\n\n   VAR CONSTANT \n      MANUAL_MODE : Bool := FALSE;\n      AUTO_MODE : Bool := TRUE;\n      FORWARD : Bool := TRUE;\n      REVERSE : Bool := FALSE;\n      COMPLETED : Bool := TRUE;\n      INCOMPLETE : Bool := FALSE;\n   END_VAR\n\n\nBEGIN\n\tIF #Mode = #MANUAL_MODE THEN\n\t    #MotorForward := #ForwardButton AND NOT #ReverseButton;\n\t    #MotorReverse := #ReverseButton AND NOT #ForwardButton;\n\t    \n\tELSE\n\t    #statSensorA := #SensorA;\n\t    #statSensorB := #SensorB;\n\t    #statSensorC := #SensorC;\n\t    \n\t    #statButtonA := #ButtonA;\n\t    #statButtonB := #ButtonB;\n\t    #statButtonC := #ButtonC;\n\t    \n\t    IF #statSensorA AND #statButtonA THEN\n\t        #MotorForward := #FORWARD;\n\t        \n\t    ELSIF #statSensorB AND #statButtonB THEN\n\t        #MotorForward := #FORWARD;\n\t        \n\t    ELSE\n\t        #MotorForward := #INCOMPLETE;\n\t        \n\t    END_IF;\n\t    \n\t    // 加工完成指示灯逻辑\n\t    IF #statSensorC AND #statButtonC THEN\n\t        #CompletionLight := #COMPLETED;\n\t        \n\t    ELSE\n\t        #CompletionLight := #INCOMPLETE;\n\t        \n\t    END_IF;\n\t    \n\tEND_IF;\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        Mode : Bool;\n        ForwardButton : Bool;\n        ReverseButton : Bool;\n        SensorA : Bool;\n        SensorB : Bool;\n        SensorC : Bool;\n        ButtonA : Bool;\n        ButtonB : Bool;\n        ButtonC : Bool;\n    END_VAR\n\n    VAR_OUTPUT\n        MotorForward : Bool;\n        MotorReverse : Bool;\n        CompletionLight : Bool;\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR", "score": 122}
{"title": "Recipe Management System", "description": "A factory production line needs to produce multiple products based on different recipes. The control center of the production line requires a recipe management system that allows operators to add, delete, modify, and query recipe data.\nControl requirements:\nRecipe data should include recipe ID, ingredient type, ingredient ratio, and production temperature.\nThe system should allow input of new recipe data and store it in the recipe database.\nThe system should allow deletion or modification of existing recipe data based on recipe ID.\nThe system should allow querying recipe details by recipe ID and output the recipe.\nNotes:\n1. Recipes are constructed using the Struct data type, including recipeID, ingredientType, ingredientRatio, and productionTemperature. The recipe database can store up to 10 recipes, implemented as Array[1..10] of Struct. Recipe IDs must be unique; recipeID=0 indicates a free position.\n2. When the queryRecipe signal is triggered, first compare the recipeID of the input recipeIn with all recipes in the database. If the ID does not exist, output error status error=true and error code status=16#8001. If it exists, output the recipe to recipeQueryResult.\n3. When the addRecipe signal is triggered, first compare the recipeID of recipeIn with all recipes in the database. If a duplicate exists, output error status error=true and error code status=16#8002. If there is no free space in the database, output error status error=true and error code status=16#8003. If no errors exist, store recipeIn into the database, preferring the lowest-numbered free position.\n4. When the deleteRecipe signal is triggered, first compare the recipeID of recipeIn with all recipes in the database. If the ID does not exist, output error status error=true and error code status=16#8004. If it exists, delete the recipe by setting recipeID to 0.\n5. When the modifyRecipe signal is triggered, first compare the recipeID of recipeIn with all recipes in the database. If the ID does not exist, output error status error=true and error code status=16#8005. If it exists, replace the recipe with recipeIn.", "type": "FUNCTION_BLOCK", "name": "FB_RecipeManager", "input": [{"name": "addRecipe", "type": "Bool", "description": "Add recipe request signal"}, {"name": "deleteRecipe", "type": "Bool", "description": "Delete recipe request signal"}, {"name": "modifyRecipe", "type": "Bool", "description": "Modify recipe request signal"}, {"name": "queryRecipe", "type": "Bool", "description": "Query recipe request signal"}, {"name": "recipeIn", "type": "Struct", "description": "Input recipe", "fields": [{"name": "recipeID", "type": "Int", "description": "Recipe ID"}, {"name": "ingredientType", "type": "Int", "description": "Ingredient type"}, {"name": "ingredientRatio", "type": "Real", "description": "Ingredient ratio"}, {"name": "productionTemperature", "type": "Real", "description": "Production temperature"}]}], "output": [{"name": "recipeAdded", "type": "Bool", "description": "Recipe added successfully indicator"}, {"name": "recipeDeleted", "type": "Bool", "description": "Recipe deleted successfully indicator"}, {"name": "recipeModified", "type": "Bool", "description": "Recipe modified successfully indicator"}, {"name": "recipeQueryResult", "type": "Struct", "description": "Recipe query result output", "fields": [{"name": "recipeID", "type": "Int", "description": "Recipe ID"}, {"name": "ingredientType", "type": "Int", "description": "Ingredient type"}, {"name": "ingredientRatio", "type": "Real", "description": "Ingredient ratio"}, {"name": "productionTemperature", "type": "Real", "description": "Production temperature"}]}, {"name": "error", "type": "Bool", "description": "Error status indicator FALSE: no error TRUE: execution error"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "recipe", "type": "Array[1..10] of Struct", "description": "Recipe database", "fields": [{"name": "recipeID", "type": "Int", "description": "Recipe ID"}, {"name": "ingredientType", "type": "Int", "description": "Ingredient type"}, {"name": "ingredientRatio", "type": "Real", "description": "Ingredient ratio"}, {"name": "productionTemperature", "type": "Real", "description": "Production temperature"}]}], "return_value": [], "ID": 6, "is_sample": false, "cot": "1. Define recipe struct and recipe database\n2. Query recipe functionality\n3. Add recipe functionality\n4. Delete recipe functionality\n5. Modify recipe functionality", "answer": "FUNCTION_BLOCK \"FB_RecipeManager\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      addRecipe : Bool;\n      deleteRecipe : Bool;\n      modifyRecipe : Bool;\n      queryRecipe : Bool;\n      recipeIn : Struct\n         recipeID : DInt;\n         ingredientType : String;\n         ingredientRatio : Real;\n         productionTemperature : Real;\n      END_STRUCT;\n   END_VAR\n\n   VAR_OUTPUT \n      recipeAdded : Bool;\n      recipeDeleted : Bool;\n      recipeModified : Bool;\n      recipeQueryResult : Struct\n         recipeID : DInt;\n         ingredientType : String;\n         ingredientRatio : Real;\n         productionTemperature : Real;\n      END_STRUCT;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      recipe : Array[1..10] of Struct\n         recipeID : DInt;\n         ingredientType : String;\n         ingredientRatio : Real;\n         productionTemperature : Real;\n      END_STRUCT;\n   END_VAR\n\n   VAR \n      statRecipeIndex : Int := 0;\n      statRecipeFound : Bool := false;\n   END_VAR\n\n   VAR_TEMP \n      tempRecipeIndex : Int;\n      tempRecipeID : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_DUPLICATE_ID : Word := 16#8002;\n      ERR_NO_EMPTY_SLOT : Word := 16#8003;\n      ERR_ID_NOT_FOUND : Word := 16#8004;\n      ERR_ID_NOT_FOUND_MODIFY : Word := 16#8005;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            FB_RecipeManager\n\t  // Comment/Function: This function block manages recipes for a production line.\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Initialization\n\t  // Initialize outputs\n\t  #recipeAdded := false;\n\t  #recipeDeleted := false;\n\t  #recipeModified := false;\n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  \n\t  // Initialize temp variables\n\t  #tempRecipeIndex := 0;\n\t  #tempRecipeID := 0;\n\tEND_REGION\n\t\n\tREGION Recipe management logic\n\t  // Check for query request\n\t  IF #queryRecipe THEN\n\t      // Search for recipe in database\n\t      FOR #tempRecipeIndex := 1 TO 10 DO\n\t          IF #recipe[#tempRecipeIndex].recipeID = #recipeIn.recipeID THEN\n\t              // Recipe found, copy to output\n\t              #recipeQueryResult := #recipe[#tempRecipeIndex];\n\t              #statRecipeFound := true;\n\t              EXIT;\n\t          END_IF;\n\t      END_FOR;\n\t      \n\t      // If recipe not found, set error\n\t      IF NOT #statRecipeFound THEN\n\t          #error := true;\n\t          #status := #ERR_ID_NOT_FOUND;\n\t      END_IF;\n\t      \n\t  // Check for add request\n\t  ELSIF #addRecipe THEN\n\t      // Search for empty slot in database\n\t      FOR #tempRecipeIndex := 1 TO 10 DO\n\t          IF #recipe[#tempRecipeIndex].recipeID = 0 THEN\n\t              // Empty slot found, add recipe\n\t              #recipe[#tempRecipeIndex] := #recipeIn;\n\t              #recipeAdded := true;\n\t              EXIT;\n\t          ELSIF #recipe[#tempRecipeIndex].recipeID = #recipeIn.recipeID THEN\n\t              // Duplicate ID found, set error\n\t              #error := true;\n\t              #status := #ERR_DUPLICATE_ID;\n\t              EXIT;\n\t          END_IF;\n\t      END_FOR;\n\t      \n\t      // If no empty slot found, set error\n\t      IF #tempRecipeIndex = 11 THEN\n\t          #error := true;\n\t          #status := #ERR_NO_EMPTY_SLOT;\n\t      END_IF;\n\t      \n\t  // Check for delete request\n\t  ELSIF #deleteRecipe THEN\n\t      // Search for recipe in database\n\t      FOR #tempRecipeIndex := 1 TO 10 DO\n\t          IF #recipe[#tempRecipeIndex].recipeID = #recipeIn.recipeID THEN\n\t              // Recipe found, delete\n\t              #recipe[#tempRecipeIndex].recipeID := 0;\n\t              #recipeDeleted := true;\n\t              EXIT;\n\t          END_IF;\n\t      END_FOR;\n\t      \n\t      // If recipe not found, set error\n\t      IF #tempRecipeIndex = 11 THEN\n\t          #error := true;\n\t          #status := #ERR_ID_NOT_FOUND;\n\t      END_IF;\n\t      \n\t  // Check for modify request\n\t  ELSIF #modifyRecipe THEN\n\t      // Search for recipe in database\n\t      FOR #tempRecipeIndex := 1 TO 10 DO\n\t          IF #recipe[#tempRecipeIndex].recipeID = #recipeIn.recipeID THEN\n\t              // Recipe found, modify\n\t              #recipe[#tempRecipeIndex] := #recipeIn;\n\t              #recipeModified := true;\n\t              EXIT;\n\t          END_IF;\n\t      END_FOR;\n\t      \n\t      // If recipe not found, set error\n\t      IF #tempRecipeIndex = 11 THEN\n\t          #error := true;\n\t          #status := #ERR_ID_NOT_FOUND_MODIFY;\n\t      END_IF;\n\t      \n\t  END_IF;\n\tEND_REGION\n\t\n\t\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        addRecipe : Bool;\n        deleteRecipe : Bool;\n        modifyRecipe : Bool;\n        queryRecipe : Bool;\n        recipeIn : Struct\n            recipeID : Int;\n            ingredientType : Int;\n            ingredientRatio : Real;\n            productionTemperature : Real;\n        END_STRUCT;\n    END_VAR\n\n    VAR_OUTPUT\n        recipeAdded : Bool;\n        recipeDeleted : Bool;\n        recipeModified : Bool;\n        recipeQueryResult : Struct\n            recipeID : Int;\n            ingredientType : Int;\n            ingredientRatio : Real;\n            productionTemperature : Real;\n        END_STRUCT;\n        error : Bool;\n        status : Word;\n    END_VAR\n\n    VAR_IN_OUT\n        recipe : Array[1..10] of Struct\n            recipeID : Int;\n            ingredientType : Int;\n            ingredientRatio : Real;\n            productionTemperature : Real;\n        END_STRUCT;\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR", "score": 261}
{"title": "Digit Separation Display", "description": "In some automation systems, it may be necessary to separate each digit of an integer for display or further processing. For example, in some counters or production counting applications, the current count value needs to be separated into ones, tens, hundreds, and thousands.\nControl requirements:\nThe system should receive an integer input with up to four digits.\nBased on the input integer, calculate and output its ones, tens, hundreds, and thousands digits.\nIf the input integer has fewer than four digits, display 0 in the missing higher digits.\nThe output should be four independent integers representing the ones, tens, hundreds, and thousands digits.\nNotes:\n1. The input integer InputNumber must be greater than or equal to 0 and less than 10000, otherwise output error status error=true and error code status=16#8001.\n2. After calculating the ones, tens, hundreds, and thousands digits, compare the non-zero digit values and output the minimum to Min; if InputNumber=0, then output Min=0.", "type": "FUNCTION_BLOCK", "name": "FB_SplitNumber", "input": [{"name": "InputNumber", "type": "Int", "description": "Four-digit integer input"}], "output": [{"name": "Thousands", "type": "Byte", "description": "Thousands digit output"}, {"name": "Hundreds", "type": "Byte", "description": "Hundreds digit output"}, {"name": "Tens", "type": "Byte", "description": "Tens digit output"}, {"name": "Ones", "type": "Byte", "description": "Ones digit output"}, {"name": "Min", "type": "Byte", "description": "Minimum of the non-zero digits"}, {"name": "error", "type": "Bool", "description": "Error status indicator FALSE: no error TRUE: execution error"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [], "ID": 7, "is_sample": false, "cot": "1. Check whether the input integer is between 0 and 9999. If not, set error status to TRUE and status code to 16#8001, then exit.\n2. Use division and modulo operations to separate the input integer into ones, tens, hundreds, and thousands.\n3. Compare the non-zero values among the four digits to find the minimum.\n4. Output the separated digits and the minimum value.\n5. Note: No need to use a function to convert Int to Byte; SCL can do this automatically.\n6. Note: Conditional assignment statements should not be used, as SCL does not support this structure.\n7. Note: Do not use a variable with the same name as the function block, e.g., FB_SplitNumber.\n8. Note: Do not use any data type conversion functions; BYTE_TO_BYTE is not allowed, minor precision loss is acceptable.", "answer": "FUNCTION_BLOCK \"FB_SplitNumber\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      InputNumber : Int;\n   END_VAR\n\n   VAR_OUTPUT \n      Thousands : Byte;\n      Hundreds : Byte;\n      Tens : Byte;\n      Ones : Byte;\n      Min : Byte;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempInputNumber : Int;\n      tempThousands : Int;\n      tempHundreds : Int;\n      tempTens : Int;\n      tempOnes : Int;\n      tempMin : Byte;\n   END_VAR\n\n   VAR CONSTANT \n      MAX_INPUT_NUMBER : Int := 9999;\n      MIN_INPUT_NUMBER : Int := 0;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_WRONG_INPUT_NUMBER : Word := 16#8001;\n      DIVISOR_THOUSANDS : Int := 1000;\n      DIVISOR_HUNDREDS : Int := 100;\n      DIVISOR_TENS : Int := 10;\n   END_VAR\n\n\nBEGIN\n\tREGION Initialization\n\t  #tempInputNumber := #InputNumber;\n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERROR;\n\tEND_REGION\n\t\n\tREGION Validation of input\n\t  IF (#tempInputNumber < #MIN_INPUT_NUMBER) OR (#tempInputNumber > #MAX_INPUT_NUMBER) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_WRONG_INPUT_NUMBER;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of digits\n\t  #tempThousands := #tempInputNumber / #DIVISOR_THOUSANDS;\n\t  #tempHundreds := (#tempInputNumber MOD #DIVISOR_THOUSANDS) / #DIVISOR_HUNDREDS;\n\t  #tempTens := (#tempInputNumber MOD #DIVISOR_HUNDREDS) / #DIVISOR_TENS;\n\t  #tempOnes := #tempInputNumber MOD #DIVISOR_TENS;\n\tEND_REGION\n\t\n\tREGION Output results\n\t  #Thousands := #tempThousands;\n\t  #Hundreds := #tempHundreds;\n\t  #Tens := #tempTens;\n\t  #Ones := #tempOnes;\n\tEND_REGION\n\t\n\tREGION Calculation of minimum digit\n\t  #tempMin := #Ones;\n\t  \n\t  IF (#tempTens <> 0) AND (#tempTens < #tempMin) THEN\n\t    #tempMin := #tempTens;\n\t  END_IF;\n\t  \n\t  IF (#tempHundreds <> 0) AND (#tempHundreds < #tempMin) THEN\n\t    #tempMin := #tempHundreds;\n\t  END_IF;\n\t  \n\t  IF (#tempThousands <> 0) AND (#tempThousands < #tempMin) THEN\n\t    #tempMin := #tempThousands;\n\t  END_IF;\n\t  \n\t  #Min := #tempMin;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        InputNumber : Int;\n    END_VAR\n\n    VAR_OUTPUT\n        Thousands : Byte;\n        Hundreds : Byte;\n        Tens : Byte;\n        Ones : Byte;\n        Min : Byte;\n        error : Bool;\n        status : Word;\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR", "score": 177}
{"title": "Decompose 16-bit Binary Number into Four 4-bit Binary Numbers", "description": "In some data processing and communication applications, it may be necessary to decompose a 16-bit binary number into four independent 4-bit binary numbers. For example, during data encoding, decoding, or data exchange with external systems, such decomposition may be required.\nControl requirements:\nThe system should receive a 16-bit binary number InputWord as input.\nDecompose the input 16-bit binary number into four 4-bit binary numbers, corresponding to the least significant to the most significant bits of the input.\nOutput these four 4-bit binary numbers to independent variables Byte0~Byte3.\nAt the same time, calculate the average of the non-zero variables among Byte0~Byte3 and output it to average.\nFor example, if InputWord=16#1203, then Byte0=3, Byte1=0, Byte2=2, Byte3=1, so the average = (1+2+3)/3.", "type": "FUNCTION_BLOCK", "name": "FB_SplitWordIntoBytes", "input": [{"name": "InputWord", "type": "Word", "description": "16-bit binary number input"}], "output": [{"name": "Byte0", "type": "Byte", "description": "Lowest 4-bit binary number output"}, {"name": "Byte1", "type": "Byte", "description": "Second lowest 4-bit binary number output"}, {"name": "Byte2", "type": "Byte", "description": "Second highest 4-bit binary number output"}, {"name": "Byte3", "type": "Byte", "description": "Highest 4-bit binary number output"}, {"name": "average", "type": "Real", "description": "Average value of non-zero bytes among the four bytes"}], "in/out": [], "return_value": [], "ID": 8, "is_sample": false, "cot": "1. Decompose the input 16-bit binary number into four 4-bit binary numbers, corresponding to the least significant to the most significant bits.\n2. Output these four 4-bit binary numbers to independent variables Byte0~Byte3.\n3. Calculate the average of the non-zero variables among Byte0~Byte3 and output to average.\n4. Note: The following example shows the usage of the SHR function. You must strictly follow this usage. It assigns the second lowest 4 bits of InputWord to Byte1:\nscl```\nByte1 := SHR(IN := #InputWord, N := 4) AND 16#0F; // Second lowest 4 bits\n```", "answer": "FUNCTION_BLOCK \"FB_SplitWordIntoBytes\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT\n      InputWord : Word;\n   END_VAR\n\n   VAR_OUTPUT\n      Byte0 : Byte;\n      Byte1 : Byte;\n      Byte2 : Byte;\n      Byte3 : Byte;\n      average : Real;\n   END_VAR\n\n   VAR_TEMP\n      tempSum : Real := 0.0;\n      tempCount : Int := 0;\n   END_VAR\n\n   VAR CONSTANT\n      BYTE_SIZE : Int := 4;\n      WORD_SIZE : Int := 16;\n      DIVISOR : Real := 16.0;\n   END_VAR\n\n\nBEGIN\n   #Byte0 := #InputWord AND 16#0F;\n   #Byte1 := SHR(IN := #InputWord, N := #BYTE_SIZE) AND 16#0F;\n   #Byte2 := SHR(IN := #InputWord, N := #BYTE_SIZE * 2) AND 16#0F;\n   #Byte3 := SHR(IN := #InputWord, N := #BYTE_SIZE * 3) AND 16#0F;\n\n   IF #Byte0 <> 0 THEN\n      #tempSum += #Byte0;\n      #tempCount += 1;\n   END_IF;\n   IF #Byte1 <> 0 THEN\n      #tempSum += #Byte1;\n      #tempCount += 1;\n   END_IF;\n   IF #Byte2 <> 0 THEN\n      #tempSum += #Byte2;\n      #tempCount += 1;\n   END_IF;\n   IF #Byte3 <> 0 THEN\n      #tempSum += #Byte3;\n      #tempCount += 1;\n   END_IF;\n\n   IF #tempCount > 0 THEN\n      #average := #tempSum / #tempCount;\n   ELSE\n      #average := 0.0;\n   END_IF;\n\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        InputWord : Word;\n    END_VAR\n\n    VAR_OUTPUT\n        Byte0 : Byte;\n        Byte1 : Byte;\n        Byte2 : Byte;\n        Byte3 : Byte;\n        average : Real;\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR", "score": 92}
{"title": "Automated Warehouse Shelf Position Management System", "description": "An automated warehouse requires a system to manage the storage positions of workpieces, ensuring they can be efficiently stored and retrieved. The warehouse has a shelf with 9 levels, each numbered from 1 to 9, and each level can store only one workpiece.\nControl requirements:\n1. The system needs to maintain the storage status of the shelf, recording whether each level contains a workpiece.\n2. When a workpiece is stored:\n - Check the storage status of the shelf.\n - If there is a free position, store it in the highest numbered available position.\n - If all positions are occupied, output error status error=1 and error code status=16#8001.\n3. When a workpiece is retrieved:\n - Check the storage status of the shelf.\n - If the shelf has workpieces, retrieve the one from the lowest numbered occupied position.\n - If all positions are empty, output error status error=1 and error code status=16#8002.\n4. The system should output the current number of workpieces in stock and the number of free positions on the shelf.", "type": "FUNCTION_BLOCK", "name": "FB_WarehouseManagement", "input": [{"name": "requestIn", "type": "Bool", "description": "Storage request signal"}, {"name": "requestOut", "type": "Bool", "description": "Retrieval request signal"}], "output": [{"name": "productNum", "type": "Int", "description": "Number of workpieces in stock"}, {"name": "libFreeNum", "type": "Int", "description": "Number of free shelf positions"}, {"name": "error", "type": "Bool", "description": "FALSE: No error occurred TRUE: Execution error"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "library", "type": "Array[1..9] of Bool", "description": "Occupancy status of each shelf level, 1 indicates occupied, 0 indicates free"}], "return_value": [], "ID": 9, "is_sample": false, "cot": "1. Initialize variables.\n2. Check storage and retrieval request signals.\n3. If there is a storage request, check the shelf status and find the highest available free position. If no free position exists, set error status and error code.\n4. If there is a retrieval request, check the shelf status and find the lowest occupied position. If no occupied position exists, set error status and error code.\n5. Calculate and output the current number of workpieces in stock and the number of free shelf positions.\n6. Note: To make a FOR loop count from high to low, use the following format instead of DOWNTO. Correct example:\nscl\nFOR loopVar := startValue TO endValue BY -1 DO\n statement\nEND_FOR;\n\n7. Note: The following format is not allowed; SCL does not accept it:\nscl\nFOR loopVar := startValue DOWNTO endValue DO\n statement\nEND_FOR;\n", "answer": "FUNCTION_BLOCK \"FB_WarehouseManagement\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      requestIn : Bool;\n      requestOut : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      productNum : Int;\n      libFreeNum : Int;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      library : Array[1..9] of Bool;\n   END_VAR\n\n   VAR \n      statProductCount : Int;\n      statFreeCount : Int;\n   END_VAR\n\n   VAR_TEMP \n      tempIndex : Int;\n   END_VAR\n\n   VAR CONSTANT \n      MAX_LEVEL : Int := 9;\n      STATUS_OK : Word := 16#0000;\n      STATUS_NO_SPACE : Word := 16#8001;\n      STATUS_NO_PRODUCT : Word := 16#8002;\n   END_VAR\n\n\nBEGIN\n\t#statProductCount := 0;\n\t#statFreeCount := 0;\n\t\n\tFOR #tempIndex := 1 TO #MAX_LEVEL DO\n\t    IF #library[#tempIndex] THEN\n\t        #statProductCount += 1;\n\t    ELSE\n\t        #statFreeCount += 1;\n\t    END_IF;\n\tEND_FOR;\n\t\n\tIF #requestIn THEN\n\t    \n\t    IF #statFreeCount > 0 THEN\n\t        \n\t        FOR #tempIndex := #MAX_LEVEL TO 1 BY -1 DO\n\t            IF NOT #library[#tempIndex] THEN\n\t                #library[#tempIndex] := TRUE;\n\t                #statProductCount += 1;\n\t                #statFreeCount -= 1;\n\t                EXIT;\n\t            END_IF;\n\t        END_FOR;\n\t        \n\t    ELSE\n\t        #error := TRUE;\n\t        #status := #STATUS_NO_SPACE;\n\t        RETURN;\n\t        \n\t    END_IF;\n\t    \n\tELSIF #requestOut THEN\n\t    \n\t    IF #statProductCount > 0 THEN\n\t        \n\t        FOR #tempIndex := 1 TO #MAX_LEVEL DO\n\t            IF #library[#tempIndex] THEN\n\t                #library[#tempIndex] := FALSE;\n\t                #statProductCount -= 1;\n\t                #statFreeCount += 1;\n\t                EXIT;\n\t            END_IF;\n\t        END_FOR;\n\t        \n\t    ELSE\n\t        #error := TRUE;\n\t        #status := #STATUS_NO_PRODUCT;\n\t        RETURN;\n\t        \n\t    END_IF;\n\t    \n\tEND_IF;\n\t\n\t#productNum := #statProductCount;\n\t#libFreeNum := #statFreeCount;\n\t#error := FALSE;\n\t#status := #STATUS_OK;\n\t\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        requestIn : Bool;\n        requestOut : Bool;\n    END_VAR\n\n    VAR_OUTPUT\n        productNum : Int;\n        libFreeNum : Int;\n        error : Bool;\n        status : Word;\n    END_VAR\n\n    VAR_IN_OUT\n        library : Array[1..9] of Bool;\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR", "score": 170}
