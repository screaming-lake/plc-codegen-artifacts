{"title": "BitReset", "description": "This block resets a bit at a predefined position in a variable of the data type DWORD. Alternatively, Word and Byte can be used instead of DWord by converting the passed parameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE.", "type": "FUNCTION", "name": "LGF_BitReset", "vars": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be reset"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to reset in \"value\" parameter"}, {"name": "Ret_Val", "type": "DWord", "description": "Tag with reset bit"}], "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be reset"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to reset in \"value\" parameter"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_BitReset\" : DWord\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_SIMATIC_Systems_Support\nFAMILY : LGF\nNAME : LGF_BitReset\n   VAR_INPUT \n      value : DWord;\n      bitNo : USInt;\n   END_VAR\n\n   VAR CONSTANT \n      BINARY_ONES : DWord := 16#FFFFFFFF;\n      TRUE_BOOL_BIT : DWord := 16#0001;\n      MAX_NO_OF_BITS : USInt := 32;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_BitReset\n\t  // Comment/Function: Reset bit in elementary datatype - DWord\n\t  //                   can be used for Word and Byte as well, by convert\n\t  //                   the passed paramter and the result using for e.g. Dword_to_Byte\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO not in use, set to true, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge         | Changes applied\n\t  // 01.00.00 | 06.06.2015 | Siemens Industry Support | first release\n\t  // 03.00.00 | 23.04.2020 | Siemens Industry Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 19.01.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Logic\n\t  // reset the bit in tag\n\t  // shift one true bit into given position\n\t  // concatenate value then with XOR and biary ones\n\t  // using this result with AND and value will result in the previous value and the reseted bit in position\n\t  #LGF_BitReset := #value AND (#BINARY_ONES XOR SHL(IN := #TRUE_BOOL_BIT, N := (#bitNo MOD #MAX_NO_OF_BITS)));\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DWord"}]}
{"title": "BitSet", "description": "This block sets a bit at a given position in a variable of the data type DWORD. Alternatively, Word and Byte can be used instead of DWord by converting the passed parameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE.", "type": "FUNCTION", "name": "LGF_BitSet", "vars": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be set"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to set in \"value\" parameter"}, {"name": "Ret_Val", "type": "DWord", "description": "Tag with the set bit"}], "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be set"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to set in \"value\" parameter"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_BitSet\" : DWord\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_SIMATIC_Systems_Support\nFAMILY : LGF\nNAME : LGF_BitSet\n   VAR_INPUT \n      value : DWord;\n      bitNo : USInt;\n   END_VAR\n\n   VAR CONSTANT \n      TRUE_BOOL_BIT : DWord := 16#0001;\n      MAX_NO_OF_BITS : USInt := 32;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_BitSet\n\t  // Comment/Function: Set bit in elementary datatype - DWord\n\t  //                   cam be used for Word and Byte as well, by convert\n\t  //                   the passed paramter and the result using for e.g. Dword_to_Byte\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO not in use, set to true, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge         | Changes applied\n\t  // 01.00.00 | 06.06.2015 | Siemens Industry Support | first release\n\t  // 03.00.00 | 23.04.2020 | Siemens Industry Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 19.01.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Logic\n\t  // set the bit in tag\n\t  // shift one true bit into given position\n\t  // concatenate value then with OR will result in the previous value and the set bit in position\n\t  #LGF_BitSet := #value OR SHL(IN := #TRUE_BOOL_BIT, N := (#bitNo MOD #MAX_NO_OF_BITS));\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DWord"}]}
{"title": "BitSetTo", "description": "This block sets a bit to TRUE or FALSE at a predefined position in a variable of the data type DWORD. Alternatively, Word and Byte can be used instead of DWord by converting the passed parameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE.", "type": "FUNCTION", "name": "LGF_BitSetTo", "vars": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be set / reset"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to set in \"value\" parameter"}, {"name": "setTo", "type": "Bool", "description": "Set bit to FALSE / TRUE"}, {"name": "Ret_Val", "type": "DWord", "description": "Tag with set bit"}], "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be set / reset"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to set in \"value\" parameter"}, {"name": "setTo", "type": "Bool", "description": "Set bit to FALSE / TRUE"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_BitSetTo\" : DWord\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_SIMATIC_Systems_Support\nFAMILY : LGF\nNAME : LGF_BitSetTo\n   VAR_INPUT \n      value : DWord;\n      bitNo : USInt;\n      setTo : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      BINARY_ONES : DWord := 16#FFFFFFFF;\n      TRUE_BOOL_BIT : DWord := 16#0001;\n      MAX_NO_OF_BITS : USInt := 32;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_BitSetTo\n\t  // Comment/Function: Set bit in elemtary datatype DWord to FALSE or TRUE,\n\t  //                   along to the given value in \"setTo\" parameter\n\t  //                   can be used for Word and Byte as well, by convert\n\t  //                   the passed paramter and the result using for e.g. Dword_to_Byte\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO not in use, set to true, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge         | Changes applied\n\t  // 01.00.00 | 06.06.2015 | Siemens Industry Support | first release\n\t  // 03.00.00 | 23.04.2020 | Siemens Industry Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 19.01.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION logic\n\t  // check th value we wont TO use - TRUE / FALSE\n\t  IF #setTo THEN\n\t    // set the bit in tag\n\t    // shift one true bit into given position\n\t    // concatenate value then with OR will result in the previous value and the set bit in position\n\t    #LGF_BitSetTo := #value OR SHL(IN := #TRUE_BOOL_BIT, N := (#bitNo MOD #MAX_NO_OF_BITS));\n\t  ELSE\n\t    // reset the bit in tag\n\t    // shift one true bit into given position\n\t    // concatenate value then with XOR and biary ones\n\t    // using this result with AND and value will result in the previous value and the reseted bit in position\n\t    #LGF_BitSetTo := #value AND (#BINARY_ONES XOR SHL(IN := #TRUE_BOOL_BIT, N := (#bitNo MOD #MAX_NO_OF_BITS)));\n\t  END_IF;\n\tEND_REGION\nEND_FUNCTION", "return_value": [{"type": "DWord"}]}
{"title": "BitTest", "description": "This block checks whether a bit is TRUE or FALSE at a given position in a variable of the data type DWORD. Alternatively, Word and Byte can be used instead of DWord by converting the passed parameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE.", "type": "FUNCTION", "name": "LGF_BitTest", "vars": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be tested"}, {"name": "bitNo", "type": "USInt", "description": "bit number to test in \"value\" parameter"}, {"name": "Ret_Val", "type": "Bool", "description": "Value of the checked bit."}], "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be tested"}, {"name": "bitNo", "type": "USInt", "description": "bit number to test in \"value\" parameter"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_BitTest\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_SIMATIC_Systems_Support\nFAMILY : LGF\nNAME : LGF_BitTest\n   VAR_INPUT \n      value : DWord;\n      bitNo : USInt;\n   END_VAR\n\n   VAR CONSTANT \n      BINARY_ZERO : DWord := 16#0000;\n      TRUE_BOOL_BIT : DWord := 16#0001;\n      MAX_NO_OF_BITS : USInt := 32;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_BitTest\n\t  // Comment/Function: Test bit in DWord if it is 1 or 0 respectively\n\t  //                   returning TRUE or FALSE\n\t  //                   can be used for Word and Byte as well, by convert\n\t  //                   the passed paramter and the result using for e.g. Dword_to_Byte\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO not in use, set to true, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge         | Changes applied\n\t  // 01.00.00 | 06.06.2015 | Siemens Industry Support | first release\n\t  // 03.00.00 | 23.04.2020 | Siemens Industry Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 19.01.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Logic\n\t  // test the bit in tag\n\t  // shift one true bit into the selected position\n\t  // compare with input value with \"AND\" logic and check if different to zero\n\t  // result is true if bit is true, otherwise it is false\n\t  #LGF_BitTest := (#BINARY_ZERO <> (#value AND SHL(IN := #TRUE_BOOL_BIT, N := (#bitNo MOD #MAX_NO_OF_BITS))));\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "BitToggle", "description": "This block toggles (from TRUE to FALSE and vice versa) a bit at a predefined position in a variable of the data type DWORD. Alternatively, Word and Byte can be used instead of DWord by converting the passed parameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE", "type": "FUNCTION", "name": "LGF_BitToggle", "vars": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be toggled"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to be toggled in the “value” parameter."}, {"name": "Ret_Val", "type": "DWord", "description": "Tag with toggled bit"}], "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be toggled"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to be toggled in the “value” parameter."}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_BitToggle\" : DWord\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_SIMATIC_Systems_Support\nFAMILY : LGF\nNAME : LGF_BitToggle\n   VAR_INPUT \n      value : DWord;\n      bitNo : USInt;\n   END_VAR\n\n   VAR CONSTANT \n      TRUE_BOOL_BIT : DWord := 16#0001;\n      MAX_NO_OF_BITS : USInt := 32;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_BitToggle\n\t  // Comment/Function: Toggle bit in elementary datatype - DWord\n\t  //                   can be used for Word and Byte as well, by convert\n\t  //                   the passed paramter and the result using for e.g. Dword_to_Byte\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO not in use, set to true, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge         | Changes applied\n\t  // 01.00.00 | 06.06.2015 | Siemens Industry Support | first release\n\t  // 03.00.00 | 23.04.2020 | Siemens Industry Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 19.01.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Logic\n\t  // toggle the bit in tag\n\t  // shift one true bit into given position\n\t  // concatenate value then with XOR resets the bit on the given position\n\t  #LGF_BitToggle := #value XOR SHL(IN := #TRUE_BOOL_BIT, N := (#bitNo MOD #MAX_NO_OF_BITS));\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DWord"}]}
{"title": "IecTimerOnOff", "description": "The Block implements an IEC_Timer TON and TOF", "type": "FUNCTION_BLOCK", "name": "LGF_IecTimerOnOff", "vars": [{"name": "in", "type": "Bool", "description": "Boolean Input value"}, {"name": "timeOnDelay", "type": "Time", "description": "Preset Time on Delay"}, {"name": "timeOffDelay", "type": "Time", "description": "Preset Time off Delay"}, {"name": "out", "type": "Bool", "description": "Delayed Input signal from input `in`"}], "input": [{"name": "in", "type": "Bool", "description": "Boolean Input value"}, {"name": "timeOnDelay", "type": "Time", "description": "Preset Time on Delay"}, {"name": "timeOffDelay", "type": "Time", "description": "Preset Time off Delay"}], "output": [{"name": "out", "type": "Bool", "description": "Delayed Input signal from input `in`"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_IecTimerOnOff\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Industry Support'\nFAMILY : LGF\nNAME : LGF_IecTimerOnOff\n   VAR_INPUT \n      in : Bool;\n      timeOnDelay : Time;\n      timeOffDelay : Time;\n   END_VAR\n\n   VAR_OUTPUT \n      out { ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR \n      instOnDelay {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;\n      instOffDelay {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_IecTimerOnOff\n\t  // Comment/Function: The Block implements an IEC_Timer TON and TOF\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO not in use, set to true, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge         | Changes applied\n\t  //----------|------------|--------------------------|-----------------------------\n\t  // 01.00.00 | 2022-05-01 | Siemens Industry Support | First released version\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t(/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION PROGRAM LOGIC\n\t  #instOnDelay.TON(IN := #in,\n\t               PT := #timeOnDelay);\n\t  \n\t  #instOffDelay.TOF(IN := #instOnDelay.Q,\n\t                PT := #timeOffDelay);\n\t  \n\t  #out := #instOffDelay.Q;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION PROGRAM LOGIC\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "PulseRelay", "description": "This block corresponds to an impulse relay or a toggle flip-flop including set and reset input. Pulse relay, Surge relay, Toggle-Flip-Flop, Frequency divider reset is leading / prior to set or trigger", "type": "FUNCTION_BLOCK", "name": "LGF_PulseRelay", "vars": [{"name": "trigger", "type": "Bool", "description": "Trigger to toggle output signal (rising edge)"}, {"name": "set", "type": "Bool", "description": "Set output signal. rising edge"}, {"name": "reset", "type": "Bool", "description": "Reset signal, rising edge (prior to set)"}, {"name": "out", "type": "Bool", "description": "Ooutput signal"}], "input": [{"name": "trigger", "type": "Bool", "description": "Trigger to toggle output signal (rising edge)"}, {"name": "set", "type": "Bool", "description": "Set output signal. rising edge"}, {"name": "reset", "type": "Bool", "description": "Reset signal, rising edge (prior to set)"}], "output": [{"name": "out", "type": "Bool", "description": "Ooutput signal"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_PulseRelay\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_PulseRelay\n   VAR_INPUT \n      trigger : Bool;\n      set : Bool;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      out { ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR \n      statTriggerOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;\n      statSetOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;\n      statResetOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;\n      statOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_PulseRelay\n\t  // Comment/Function: Pulse relay, Surge relay, Toggle-Flip-Flop, Frequency divider\n\t  //                   Reset is leading / prior to Set or Trigger\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO not in use, set to true, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  // 01.00.00 06.06.2015 Siemens Industry Online Support\n\t  //                     First released version\n\t  // 01.00.01 02.01.2017 Siemens Industry Online Support\n\t  //                     Upgrade: TIA V14 Update 1\n\t  // 01.00.02 02.01.2017 Siemens Industry Online Support\n\t  //                     Comment correction                  \n\t  // 01.00.03 17.08.2018 Siemens Industry Online Support\n\t  //                     Upgrade: TIA V15 Update 2\n\t  // 01.00.04 23.11.2018 Siemens Industry Online Support\n\t  //                     Upgrade: TIA V15.1\n\t  // 01.00.05 24.05.2019 Simatic Systems Support\n\t  //                     Refactoring and performance improvement\n\t  //                     add ENO handling\n\t  // 03.00.00 23.04.2020 Simatic Systems Support\n\t  //                     Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 19.01.2021 Simatic Systems Support\n\t  //                     Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION PROGRAM LOGIC\n\t  REGION toggle output\n\t    // Scan for rising edge \"trigger\"  - toggle static Output\n\t    IF #trigger AND NOT #statTriggerOld THEN\n\t      // toggle static output memory\n\t      #statOut := NOT #statOut;\n\t    END_IF;\n\t    // store trigger input for edge dedection\n\t    #statTriggerOld := #trigger;\n\t  END_REGION\n\t  \n\t  REGION set output\n\t    // Scan for rising edge \"set\" - static Output: set\n\t    IF #set AND NOT #statSetOld THEN\n\t      // set static output memory\n\t      #statOut := TRUE;\n\t    END_IF;\n\t    // store set input for edge dedection\n\t    #statSetOld := #set;\n\t  END_REGION\n\t  \n\t  REGION reset output    \n\t    // Scan for rising edge \"reset\" - static Output: reset\n\t    IF #reset AND NOT #statResetOld THEN\n\t      // store trigger input for edge dedection\n\t      #statOut := FALSE;\n\t    END_IF;\n\t    // store reset input for edge dedection\n\t    #statResetOld := #reset;\n\t  END_REGION\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  // write the Output value\n\t  #out := #statOut;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "GetCalendarDay", "description": "This function uses the specified date to calculate the number of days that have passed since the beginning of the year (1st January). The function is used in the functions “LGF_GetCalendarWeek_ISO” and “LGF_GetCalendarWeek_US”.", "type": "FUNCTION", "name": "LGF_GetCalendarDay", "vars": [{"name": "date", "type": "DTL", "description": "Date for the calculation of the calendar days since 1 January."}, {"name": "Ret_Val", "type": "DInt", "description": "Days past since January 1st."}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}], "input": [{"name": "date", "type": "DTL", "description": "Date for the calculation of the calendar days since 1 January."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_GetCalendarDay\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_GetCalendarDay\n   VAR_INPUT \n      \"date\" {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempDaysPassed : DInt;\n      tempDate {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n   END_VAR\n\n   VAR CONSTANT \n      FIRST_DAY : USInt := 1;\n      LAST_DAY : USInt := 31;\n      JANUARY : USInt := 1;\n      DECEMBER : USInt := 12;\n      TIME_ZERO_FORCE_UPDATE : Time := t#0d;\n      ONE_DAY : DInt := 1;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_LIM_DATE : Word := 16#8201;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_GetCalendarDay\n\t  // Comment/Function: This function calculates for a date the passed days since 1st January.\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 16.07.2019  Simatic Systems Support\n\t  //                      First release\n\t  //                      ENO used for internal error handling, interface has error and status\n\t  //                      temp tag naming, insert constant\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 19.01.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION INITIALISATION\n\t  #tempDate := #date;\n\t  #tempDaysPassed := 0;\n\tEND_REGION\n\t\n\tREGION COUNT DAYS\n\t  // Check #date\n\t  // adding zero forces the PLC to update the tag and eno check\n\t  #tempDate := #tempDate + #TIME_ZERO_FORCE_UPDATE;\n\t  IF ENO = FALSE THEN\n\t    #error := TRUE;\n\t    #status := #ERR_LIM_DATE;\n\t    #LGF_GetCalendarDay := #tempDaysPassed;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Weekday of 1st January in the current year\n\t  #tempDate.MONTH := #JANUARY;\n\t  #tempDate.DAY := #FIRST_DAY;\n\t  // adding zero forces the PLC to update the tag\n\t  // in this case especially the weekday\n\t  #tempDate := #tempDate + #TIME_ZERO_FORCE_UPDATE;\n\t  \n\t  // Days passed in the year since 1st January, \"date\" included\n\t  #tempDaysPassed := DATE_TO_DINT(DTL_TO_DATE(#date)) - DATE_TO_DINT(DTL_TO_DATE(#tempDate)) + #ONE_DAY;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERROR;\n\t  #LGF_GetCalendarDay := #tempDaysPassed;\n\t  \n\t  // ENO is not used, forced to TRUE\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DInt"}]}
{"title": "GetCalendarWeek", "description": "This function uses the specified date to calculate the calendar week and the number of days that have passed since the beginning of the year for ISO 8601 European countries.", "type": "FUNCTION", "name": "LGF_GetCalendarWeek_ISO", "vars": [{"name": "date", "type": "DTL", "description": "Date used to calculate the calendar week and days since 1 January"}, {"name": "Ret_Val", "type": "DInt", "description": "Number of the calendar week."}, {"name": "calendarDay", "type": "DInt", "description": "Days past since January 1st on given date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}], "input": [{"name": "date", "type": "DTL", "description": "Date used to calculate the calendar week and days since 1 January"}], "output": [{"name": "calendarDay", "type": "DInt", "description": "Days past since January 1st on given date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_GetCalendarWeek_ISO\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_GetCalendarWeek_ISO\n   VAR_INPUT \n      \"date\" {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n   END_VAR\n\n   VAR_OUTPUT \n      calendarDay : DInt;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempDate {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempCurrentYearWeekday1Jan : UDInt;\n      tempNextYearWeekday1Jan : UDInt;\n      tempCurrentYearWeekday31Dec : UDInt;\n      tempPrevYearWeekday1Jan : UDInt;\n      tempPrevYearWeekday31Dec : UDInt;\n      tempDaysCorr : DInt;\n      tempWeek : DInt;\n      tempDays : DInt;\n      tempCurrentYearIsLeapyear : Bool;\n      tempPrevYearIsLeapyear : Bool;\n      tempYearCurrentYear : UInt;\n      tempPreviousYear : UInt;\n      tempNextYear : UInt;\n      tempIsCurrentYearWith53Weeks : Bool;\n      tempIsPrevYearWith53Weeks : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      SUNDAY : UDInt := 1;\n      MONDAY : UDInt := 2;\n      TUESDAY : UDInt := 3;\n      WEDNESDAY : UDInt := 4;\n      THURSDAY : UDInt := 5;\n      FRIDAY : UDInt := 6;\n      SATURDAY : UDInt := 7;\n      FIRST_DAY : USInt := 1;\n      LAST_DAY : USInt := 31;\n      JANUARY : USInt := 1;\n      DECEMBER : USInt := 12;\n      ONE_YEAR : UInt := 1;\n      ONE_DAY : DInt := 1;\n      TWO_DAYS : DInt := 2;\n      THREE_DAYS : DInt := 3;\n      FOUR_DAYS : DInt := 4;\n      FIVE_DAYS : DInt := 5;\n      SEVEN_DAYS : DInt := 7;\n      ONE_WEEK : DInt := 1;\n      WEEK_1 : DInt := 1;\n      WEEK_52 : DInt := 52;\n      WEEK_53 : DInt := 53;\n      WEEK_54 : DInt := 54;\n      LEAP_YEAR_CHECK_4 : UInt := 4;\n      LEAP_YEAR_CHECK_100 : UInt := 100;\n      LEAP_YEAR_CHECK_400 : UInt := 400;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_LIM_DATE : Word := 16#8201;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_GetCalendarWeek_ISO\n\t  // Comment/Function: This function calculates the week number for ISO 8601 following countries\n\t  //                   - new week starts whith Monday\n\t  //                   - the week number 1, is the week which contains the first Thursday of the Year\n\t  //                   - a year has 52 or 53 weeks\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 Upd 1\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 27.01.2017  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.03 16.07.2019  Simatic Systems Support\n\t  //                      Renamed from LGF_CalenderWeek to LGF_CalenderWeek_ISO\n\t  //                      Function split into week for ISO and US Format and as well day counter.\n\t  //                      Result passed as return value.\n\t  //                      Standard header implemented\n\t  //                      Constant, temp variable naming\n\t  //                      Update function call of CalendarDay\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 19.01.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION\n\t  #tempDays := 0;\n\t  #tempWeek := 0;\n\tEND_REGION\n\t\n\tREGION COUNT DAYS\n\t  // Days passed in the year since 1st January, \"date\" included\n\t  #tempDays := \"LGF_GetCalendarDay\"(\"date\" := #date, error => #error, status => #status);\n\t  IF #error THEN\n\t    #LGF_GetCalendarWeek_ISO := #tempWeek;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION COUNT WEEKS\n\t  // Year of actual year, previous year and next year\n\t  #tempYearCurrentYear := #date.YEAR;\n\t  #tempPreviousYear := #date.YEAR - #ONE_YEAR;\n\t  #tempNextYear := #date.YEAR + #ONE_YEAR;\n\t  \n\t  // Check if current year is a leap year (29. February/366 days)\n\t  #tempCurrentYearIsLeapyear := (((#tempYearCurrentYear MOD #LEAP_YEAR_CHECK_4 = 0) AND NOT (#tempYearCurrentYear MOD #LEAP_YEAR_CHECK_100 = 0)) OR (#tempYearCurrentYear MOD #LEAP_YEAR_CHECK_400 = 0));\n\t  // Check if previous year is a leap year (29. February/366 days)\n\t  #tempPrevYearIsLeapyear := (((#tempPreviousYear MOD #LEAP_YEAR_CHECK_4 = 0) AND NOT (#tempPreviousYear MOD #LEAP_YEAR_CHECK_100 = 0)) OR (#tempPreviousYear MOD #LEAP_YEAR_CHECK_400 = 0));\n\t  \n\t  // Weekday of 1st January in the current year\n\t  #tempDate := #date;\n\t  #tempDate.MONTH := #JANUARY;\n\t  #tempDate.DAY := #FIRST_DAY;\n\t  #tempDate := #tempDate + T#0ms;\n\t  #tempCurrentYearWeekday1Jan := #tempDate.WEEKDAY;\n\t  \n\t  // Weekday of 1st January in the next year\n\t  #tempDate.YEAR := #tempNextYear;\n\t  #tempDate.MONTH := #JANUARY;\n\t  #tempDate.DAY := #FIRST_DAY;\n\t  #tempDate := #tempDate + T#0ms;\n\t  #tempNextYearWeekday1Jan := #tempDate.WEEKDAY;\n\t  \n\t  // Weekday of 31st December in the current year\n\t  #tempDate := #date;\n\t  #tempDate.MONTH := #DECEMBER;\n\t  #tempDate.DAY := #LAST_DAY;\n\t  #tempDate := #tempDate + T#0ms;\n\t  #tempCurrentYearWeekday31Dec := #tempDate.WEEKDAY;\n\t  \n\t  // Weekday of 1st January in the previous year\n\t  #tempDate.YEAR := #tempPreviousYear;\n\t  #tempDate.MONTH := #JANUARY;\n\t  #tempDate.DAY := #FIRST_DAY;\n\t  #tempDate := #tempDate + T#0ms;\n\t  #tempPrevYearWeekday1Jan := #tempDate.WEEKDAY;\n\t  \n\t  // Weekday of 31st December in the previous year\n\t  #tempDate.YEAR := #tempPreviousYear;\n\t  #tempDate.MONTH := #DECEMBER;\n\t  #tempDate.DAY := #LAST_DAY;\n\t  #tempDate := #tempDate + T#0ms;\n\t  #tempPrevYearWeekday31Dec := #tempDate.WEEKDAY;\n\t  \n\t  // Calculate the week number for european countries (ISO 8601)\n\t  // - new week begins whith Monday\n\t  // - the week number 1, is the week which contains the first Thursday of the Year\n\t  // - a year has 52 or 53 weeks\n\t  \n\t  // Check if previous year had 53 weeks\n\t  #tempIsPrevYearWith53Weeks := (#tempPrevYearWeekday1Jan = #THURSDAY AND #tempPrevYearWeekday31Dec = #THURSDAY AND (NOT #tempPrevYearIsLeapyear))\n\t  OR (#tempPrevYearIsLeapyear AND ((#tempPrevYearWeekday1Jan = #WEDNESDAY AND #tempPrevYearWeekday31Dec = #THURSDAY) OR (#tempPrevYearWeekday1Jan = #THURSDAY AND #tempPrevYearWeekday31Dec = #FRIDAY)));\n\t  // Check if current year has 53 weeks\n\t  #tempIsCurrentYearWith53Weeks := (#tempCurrentYearWeekday1Jan = #THURSDAY AND #tempCurrentYearWeekday31Dec = #THURSDAY AND (NOT #tempCurrentYearIsLeapyear))\n\t  OR (#tempCurrentYearIsLeapyear AND ((#tempCurrentYearWeekday1Jan = #WEDNESDAY AND #tempCurrentYearWeekday31Dec = #THURSDAY) OR (#tempCurrentYearWeekday1Jan = #THURSDAY AND #tempCurrentYearWeekday31Dec = #FRIDAY)));\n\t  \n\t  // Correction of the number of #tempDays depending on the weekday of 1st January \n\t  CASE #tempCurrentYearWeekday1Jan OF\n\t    #SUNDAY:\n\t      #tempDaysCorr := #tempDays - #TWO_DAYS;\n\t    #MONDAY:\n\t      #tempDaysCorr := #tempDays - #ONE_DAY;\n\t    #TUESDAY:\n\t      #tempDaysCorr := #tempDays;\n\t    #WEDNESDAY:\n\t      #tempDaysCorr := #tempDays + #ONE_DAY;\n\t    #THURSDAY:\n\t      #tempDaysCorr := #tempDays + #TWO_DAYS;\n\t    #FRIDAY:\n\t      #tempDaysCorr := #tempDays - #FOUR_DAYS;\n\t    #SATURDAY:\n\t      #tempDaysCorr := #tempDays - #THREE_DAYS;\n\t    ELSE\n\t      ;\n\t  END_CASE;\n\t  \n\t  IF #tempDaysCorr < 0 THEN\n\t    // 1., 2. and 3. January can belong to the last week of the previous year\n\t    IF #tempIsPrevYearWith53Weeks THEN\n\t      #tempWeek := #WEEK_53;\n\t    ELSE\n\t      #tempWeek := #WEEK_52;\n\t    END_IF;\n\t  ELSE\n\t    // calculate the number of the week\n\t    #tempWeek := #tempDaysCorr / #SEVEN_DAYS + #ONE_WEEK;\n\t    \n\t    // 29., 30. and 31. December can belong to the first week of the next year\n\t    IF #tempWeek = #WEEK_53 THEN\n\t      IF #tempIsCurrentYearWith53Weeks THEN\n\t        #tempWeek := #WEEK_53;\n\t      ELSE\n\t        #tempWeek := #WEEK_1;\n\t      END_IF;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #calendarDay := #tempDays;\n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERROR;\n\t  #LGF_GetCalendarWeek_ISO := #tempWeek;\n\t  \n\t  // ENO is not used, forced to TRUE\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DInt"}]}
{"title": "GetCalendarWeek", "description": "This function uses the specified date to calculate the calendar week and the number of days that have passed since the beginning of the year for the USA and many other countries.", "type": "FUNCTION", "name": "LGF_GetCalendarWeek_US", "vars": [{"name": "date", "type": "DTL", "description": "Date used to calculate the calendar week and days since 1 January"}, {"name": "Ret_Val", "type": "DInt", "description": "Number of the calendar week."}, {"name": "calendarDay", "type": "DInt", "description": "Days past since January 1st on given date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}], "input": [{"name": "date", "type": "DTL", "description": "Date used to calculate the calendar week and days since 1 January"}], "output": [{"name": "calendarDay", "type": "DInt", "description": "Days past since January 1st on given date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_GetCalendarWeek_US\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_GetCalendarWeek_US\n   VAR_INPUT \n      \"date\" {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n   END_VAR\n\n   VAR_OUTPUT \n      calendarDay : DInt;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempDate {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempCurrentYearWeekday1Jan : UDInt;\n      tempNextYearWeekday1Jan : UDInt;\n      tempCurrentYearWeekday31Dec : UDInt;\n      tempPrevYearWeekday1Jan : UDInt;\n      tempPrevYearWeekday31Dec : UDInt;\n      tempDaysCorr : DInt;\n      tempWeek : DInt;\n      tempDays : DInt;\n      tempCurrentYearIsLeapyear : Bool;\n      tempPrevYearIsLeapyear : Bool;\n      tempYearCurrentYear : UInt;\n      tempYearPrevYear : UInt;\n      tempYearNextYear : UInt;\n      tempIsCurrentYearWith53Weeks : Bool;\n      tempIsPrevYearWith53Weeks : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      SUNDAY : UDInt := 1;\n      MONDAY : UDInt := 2;\n      TUESDAY : UDInt := 3;\n      WEDNESDAY : UDInt := 4;\n      THURSDAY : UDInt := 5;\n      FRIDAY : UDInt := 6;\n      SATURDAY : UDInt := 7;\n      FIRST_DAY : USInt := 1;\n      LAST_DAY : USInt := 31;\n      JANUARY : USInt := 1;\n      DECEMBER : USInt := 12;\n      ONE_YEAR : UInt := 1;\n      ONE_DAY : DInt := 1;\n      TWO_DAYS : DInt := 2;\n      THREE_DAYS : DInt := 3;\n      FOUR_DAYS : DInt := 4;\n      FIVE_DAYS : DInt := 5;\n      SEVEN_DAYS : DInt := 7;\n      ONE_WEEK : DInt := 1;\n      WEEK_1 : DInt := 1;\n      WEEK_52 : DInt := 52;\n      WEEK_53 : DInt := 53;\n      WEEK_54 : DInt := 54;\n      LEAP_YEAR_CHECK_4 : UInt := 4;\n      LEAP_YEAR_CHECK_100 : UInt := 100;\n      LEAP_YEAR_CHECK_400 : UInt := 400;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_LIM_DATE : Word := 16#8201;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_GetCalendarWeek_US\n\t  // Comment/Function: This function calculates the week number for USA and other countries.\n\t  //                   - new week starts with Sunday\n\t  //                   - the week wich contains the 1st January is always week number 1\n\t  //                   - a year has 52 or 53 weeks\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 Upd 1\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 13.11.2019  Simatic Systems Support\n\t  //                      First release\n\t  //                      based on spli from  LGF_CalenderWeek (previously LGF_CalenderWeek_ISO)\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 19.01.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION\n\t  #tempDays := 0;\n\t  #tempWeek := 0;\n\tEND_REGION\n\t\n\tREGION COUNT DAYS\n\t  // Days passed in the year since 1st January, \"date\" included\n\t  #tempDays := \"LGF_GetCalendarDay\"(\"date\" := #date, error => #error, status => #status);\n\t  IF #error THEN\n\t    #LGF_GetCalendarWeek_US := #tempWeek;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION COUNT WEEKS\n\t  // Year of actual year, previous year and next year\n\t  #tempYearCurrentYear := #date.YEAR;\n\t  #tempYearPrevYear := #date.YEAR - #ONE_YEAR;\n\t  #tempYearNextYear := #date.YEAR + #ONE_YEAR;\n\t  \n\t  // Check if current year is a leap year (29. February/366 days)\n\t  #tempCurrentYearIsLeapyear := (((#tempYearCurrentYear MOD #LEAP_YEAR_CHECK_4 = 0) AND NOT (#tempYearCurrentYear MOD #LEAP_YEAR_CHECK_100 = 0)) OR (#tempYearCurrentYear MOD #LEAP_YEAR_CHECK_400 = 0));\n\t  // Check if previous year is a leap year (29. February/366 days)\n\t  #tempPrevYearIsLeapyear := (((#tempYearPrevYear MOD #LEAP_YEAR_CHECK_4 = 0) AND NOT (#tempYearPrevYear MOD #LEAP_YEAR_CHECK_100 = 0)) OR (#tempYearPrevYear MOD #LEAP_YEAR_CHECK_400 = 0));\n\t  \n\t  // Weekday of 1st January in the current year\n\t  #tempDate := #date;\n\t  #tempDate.MONTH := #JANUARY;\n\t  #tempDate.DAY := #FIRST_DAY;\n\t  #tempDate := #tempDate + T#0ms;\n\t  #tempCurrentYearWeekday1Jan := #tempDate.WEEKDAY;\n\t  \n\t  // Weekday of 1st January in the next year\n\t  #tempDate.YEAR := #tempYearNextYear;\n\t  #tempDate.MONTH := #JANUARY;\n\t  #tempDate.DAY := #FIRST_DAY;\n\t  #tempDate := #tempDate + T#0ms;\n\t  #tempNextYearWeekday1Jan := #tempDate.WEEKDAY;\n\t  \n\t  // Weekday of 31st December in the current year\n\t  #tempDate := #date;\n\t  #tempDate.MONTH := #DECEMBER;\n\t  #tempDate.DAY := #LAST_DAY;\n\t  #tempDate := #tempDate + T#0ms;\n\t  #tempCurrentYearWeekday31Dec := #tempDate.WEEKDAY;\n\t  \n\t  // Weekday of 1st January in the previous year\n\t  #tempDate.YEAR := #tempYearPrevYear;\n\t  #tempDate.MONTH := #JANUARY;\n\t  #tempDate.DAY := #FIRST_DAY;\n\t  #tempDate := #tempDate + T#0ms;\n\t  #tempPrevYearWeekday1Jan := #tempDate.WEEKDAY;\n\t  \n\t  // Weekday of 31st December in the previous year\n\t  #tempDate.YEAR := #tempYearPrevYear;\n\t  #tempDate.MONTH := #DECEMBER;\n\t  #tempDate.DAY := #LAST_DAY;\n\t  #tempDate := #tempDate + T#0ms;\n\t  #tempPrevYearWeekday31Dec := #tempDate.WEEKDAY;\n\t  \n\t  // Calculate the week number for USA and other countries\n\t  // - new week begins whith Sunday\n\t  // - the week wich contains the 1st January is allways week number 1\n\t  // - a year has 52 or 53 weeks\n\t  \n\t  // Correction of the number of #tempDays depending on the weekday of 1st January\n\t  CASE #tempCurrentYearWeekday1Jan OF\n\t    #SUNDAY:\n\t      #tempDaysCorr := #tempDays - #ONE_DAY;\n\t    #MONDAY:\n\t      #tempDaysCorr := #tempDays;\n\t    #TUESDAY:\n\t      #tempDaysCorr := #tempDays + #ONE_DAY;\n\t    #WEDNESDAY:\n\t      #tempDaysCorr := #tempDays + #TWO_DAYS;\n\t    #THURSDAY:\n\t      #tempDaysCorr := #tempDays + #THREE_DAYS;\n\t    #FRIDAY:\n\t      #tempDaysCorr := #tempDays + #FOUR_DAYS;\n\t    #SATURDAY:\n\t      #tempDaysCorr := #tempDays + #FIVE_DAYS;\n\t  END_CASE;\n\t  // calculate the number of the week\n\t  #tempWeek := #tempDaysCorr / #SEVEN_DAYS + #ONE_WEEK;\n\t  \n\t  // Check if current year has 53 weeks\n\t  #tempIsCurrentYearWith53Weeks := (NOT #tempCurrentYearIsLeapyear AND (#tempCurrentYearWeekday1Jan = #SATURDAY AND #tempCurrentYearWeekday31Dec = #SATURDAY)) OR\n\t  (#tempCurrentYearIsLeapyear AND ((#tempCurrentYearWeekday1Jan = #SATURDAY AND #tempCurrentYearWeekday31Dec = #SUNDAY) OR (#tempCurrentYearWeekday1Jan = #FRIDAY AND #tempCurrentYearWeekday31Dec = #SATURDAY)));\n\t  \n\t  // Correct the week number depending on wheter the current year has 53 weeks\n\t  IF #tempWeek = #WEEK_53 THEN\n\t    IF #tempIsCurrentYearWith53Weeks THEN\n\t      #tempWeek := #WEEK_53;\n\t    ELSE\n\t      #tempWeek := #WEEK_1;\n\t    END_IF;\n\t  END_IF;\n\t  \n\t  IF #tempWeek = #WEEK_54 THEN\n\t    #tempWeek := #WEEK_1;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #calendarDay := #tempDays;\n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERROR;\n\t  #LGF_GetCalendarWeek_US := #tempWeek;\n\t  \n\t  // ENO is not used, forced to TRUE\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DInt"}]}
{"title": "IsGermanHoliday", "description": "The function determines whether a given date is a public holiday. All public holidays in Germany are taken into account. Holidays that are NOT uniform nationwide can be switched on or off", "type": "FUNCTION", "name": "LGF_IsGermanHoliday", "vars": [{"name": "date", "type": "DTL", "description": "Date, which has to be evaluated"}, {"name": "threeKings", "type": "Bool", "description": "Three Kings"}, {"name": "roseMonday", "type": "Bool", "description": "Rose Monday"}, {"name": "ascension", "type": "Bool", "description": "Ascension"}, {"name": "corpusChristi", "type": "Bool", "description": "Corpus Christi"}, {"name": "augsburgerFriedensfest", "type": "Bool", "description": "Augsburger Friedensfest"}, {"name": "assumptionOfMary", "type": "Bool", "description": "Assumption Of Mary"}, {"name": "reformationDay", "type": "Bool", "description": "Reformation Day"}, {"name": "allSaintDay", "type": "Bool", "description": "All Saint Day"}, {"name": "bussUndBettag", "type": "Bool", "description": "Day of Prayer and Repentance (Buss und Bettag)"}, {"name": "Ret_Val", "type": "Bool", "description": "If the date at the input parameter is a public holiday - returningTRUE, otherwise returning FALSE"}], "input": [{"name": "date", "type": "DTL", "description": "Date, which has to be evaluated"}, {"name": "threeKings", "type": "Bool", "description": "Three Kings"}, {"name": "roseMonday", "type": "Bool", "description": "Rose Monday"}, {"name": "ascension", "type": "Bool", "description": "Ascension"}, {"name": "corpusChristi", "type": "Bool", "description": "Corpus Christi"}, {"name": "augsburgerFriedensfest", "type": "Bool", "description": "Augsburger Friedensfest"}, {"name": "assumptionOfMary", "type": "Bool", "description": "Assumption Of Mary"}, {"name": "reformationDay", "type": "Bool", "description": "Reformation Day"}, {"name": "allSaintDay", "type": "Bool", "description": "All Saint Day"}, {"name": "bussUndBettag", "type": "Bool", "description": "Day of Prayer and Repentance (Buss und Bettag)"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_IsGermanHoliday\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_IsGermanHoliday\n   VAR_INPUT \n      \"date\" {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      threeKings : Bool;\n      roseMonday : Bool;\n      ascension : Bool;\n      corpusChristi : Bool;\n      augsburgerFriedensfest : Bool;\n      assumptionOfMary : Bool;\n      reformationDay : Bool;\n      allSaintDay : Bool;\n      bussUndBettag : Bool;\n   END_VAR\n\n   VAR_TEMP \n      tempDaysPassedToActDay : DInt;\n      tempOday : UInt;\n      tempEasterInternal {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempDaysPassedToEaster : DInt;\n      tempDTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempEasterPartialCalc : UInt;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : UInt := 0;\n      CLEAR_DTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      JANUARY : USInt := 1;\n      MARCH : USInt := 3;\n      APRIL : USInt := 4;\n      MAY : USInt := 5;\n      AUGUST : USInt := 8;\n      OCTOBER : USInt := 10;\n      NOVEMBER : USInt := 11;\n      DECEMBER : USInt := 12;\n      DAY_1 : USInt := 1;\n      DAY_3 : USInt := 3;\n      DAY_6 : USInt := 6;\n      DAY_8 : USInt := 8;\n      DAY_15 : USInt := 15;\n      DAY_23 : USInt := 23;\n      DAY_25 : USInt := 25;\n      DAY_26 : USInt := 26;\n      DAY_31 : USInt := 31;\n      WEDNESDAY : USInt := 4;\n      DAYS_BEFORE_EASTER_48 : USInt := 48;\n      DAYS_BEFORE_EASTER_2 : USInt := 2;\n      DAYS_AFTER_EASTER_1 : USInt := 1;\n      DAYS_AFTER_EASTER_39 : USInt := 39;\n      DAYS_AFTER_EASTER_49 : USInt := 49;\n      DAYS_AFTER_EASTER_50 : USInt := 50;\n      DAYS_AFTER_EASTER_60 : USInt := 60;\n      EASTER_COEFF_1 : USInt := 1;\n      EASTER_COEFF_3 : USInt := 3;\n      EASTER_COEFF_4 : USInt := 4;\n      EASTER_COEFF_7 : USInt := 7;\n      EASTER_COEFF_11 : USInt := 11;\n      EASTER_COEFF_13 : USInt := 13;\n      EASTER_COEFF_19 : USInt := 19;\n      EASTER_COEFF_27 : USInt := 27;\n      EASTER_COEFF_28 : USInt := 28;\n      EASTER_COEFF_30 : USInt := 30;\n      EASTER_COEFF_204 : USInt := 204;\n      BIT_SHIFT_BY_TWO : USInt := 2;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_IsGermanHoliday\n\t  // Comment/Function: Function determines whether a given date is a public holiday\n\t  //                   All public holidays in Germany are taken into account\n\t  //                   Holidays that are NOT uniform nationwide can be switched on or off\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 SP1 Upd 5\n\t  // Restrictions:     ENO disabled - no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.03 17.07.2019  Simatic Systems Support\n\t  //                      Standard header, comments, style updated\n\t  //                      refactoring code\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 19.01.2020  Simatic Systems Support\n\t  //                      fix bug in Constant \"DAYS_AFTER_EASTER_60\" from 6 to 60\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION\n\t  #tempEasterPartialCalc := #ZERO;\n\t  #tempDaysPassedToEaster := #ZERO;\n\t  #tempOday := #ZERO;\n\t  #tempDaysPassedToActDay := #ZERO;\n\t  #tempDTL := #CLEAR_DTL;\n\t  #tempEasterInternal := #CLEAR_DTL;\n\tEND_REGION\n\t\n\tREGION CALC OF EASTER SUNDAY\n\t  // Calculation of Easter Sunday\n\t  #tempEasterPartialCalc := (#EASTER_COEFF_204 - #EASTER_COEFF_11 * (#date.YEAR MOD #EASTER_COEFF_19)) MOD #EASTER_COEFF_30;\n\t  \n\t  IF #tempEasterPartialCalc > #EASTER_COEFF_27 THEN\n\t    #tempEasterPartialCalc := #tempEasterPartialCalc - #EASTER_COEFF_1;\n\t  END_IF;\n\t  \n\t  #tempOday := #EASTER_COEFF_28 + #tempEasterPartialCalc - ((#date.YEAR + WORD_TO_UINT(SHR(IN := UINT_TO_WORD(#date.YEAR), N := #BIT_SHIFT_BY_TWO)) + #tempEasterPartialCalc - #EASTER_COEFF_13) MOD #EASTER_COEFF_7);\n\t  \n\t  IF #tempOday > #DAY_31 THEN\n\t    #tempEasterInternal.YEAR := #date.YEAR;\n\t    #tempEasterInternal.MONTH := #APRIL;\n\t    #tempEasterInternal.DAY := UINT_TO_USINT(#tempOday - #DAY_31);\n\t  ELSE\n\t    #tempEasterInternal.YEAR := #date.YEAR;\n\t    #tempEasterInternal.MONTH := #MARCH;\n\t    #tempEasterInternal.DAY := UINT_TO_USINT(#tempOday);\n\t  END_IF;\n\t  \n\t  // Calculation of the days from Jan 1st till Easter Sunday and from Jan 1st to the actual day. \n\t  #tempDTL := #date;\n\t  #tempDTL.MONTH := #APRIL;\n\t  #tempDTL.DAY := #DAY_1;\n\t  \n\t  #tempDaysPassedToEaster := DATE_TO_DINT(DTL_TO_DATE(#tempEasterInternal)) - DATE_TO_DINT(DTL_TO_DATE(#tempDTL)) + #DAY_1;\n\t  #tempDaysPassedToActDay := DATE_TO_DINT(DTL_TO_DATE(#date)) - DATE_TO_DINT(DTL_TO_DATE(#tempDTL)) + #DAY_1;\n\tEND_REGION\n\t\n\tREGION GERMAN HOLIDAYS\n\t  // Check if actual day is holiday in Germany\n\t  // Change here for other countries than germany\n\t  IF (#date.MONTH = #JANUARY AND #date.DAY = #DAY_1) OR                             // 1st of January\n\t    (#date.MONTH = #JANUARY AND #date.DAY = #DAY_6 AND #threeKings) OR              // 6 of January (Holy Kings)\n\t    (#date.MONTH = #MAY AND #date.DAY = #DAY_1) OR                                  // 1st of May\n\t    (#date.MONTH = #AUGUST AND #date.DAY = #DAY_8 AND #augsburgerFriedensfest) OR   // Augsburger Friedensfest\n\t    (#date.MONTH = #AUGUST AND #date.DAY = #DAY_15 AND #assumptionOfMary) OR        // Assumption of Mary\n\t    (#date.MONTH = #OCTOBER AND #date.DAY = #DAY_3) OR                              // 3rd of October\n\t    (#date.MONTH = #OCTOBER AND #date.DAY = #DAY_31 AND #reformationDay) OR         // Reformation day\n\t    (#date.MONTH = #NOVEMBER AND #date.DAY = #DAY_1 AND #allSaintDay) OR            // 1st of November (all saints day)\n\t    (#date.MONTH = #NOVEMBER AND #date.WEEKDAY = #WEDNESDAY AND #date.DAY > #DAY_15 AND #date.DAY < #DAY_23 AND #bussUndBettag) OR //Buß- und Bettag (Day of Repentance and Prayer)\n\t    (#date.MONTH = #DECEMBER AND #date.DAY = #DAY_25) OR                              // 25th of December (1st christmas)\n\t    (#date.MONTH = #DECEMBER AND #date.DAY = #DAY_26) OR                              // 26th of December (2nd christmas)\n\t    (#tempDaysPassedToActDay = #tempDaysPassedToEaster - #DAYS_BEFORE_EASTER_48 AND #roseMonday) OR     // Rose Monday\n\t    (#tempDaysPassedToActDay = #tempDaysPassedToEaster - #DAYS_BEFORE_EASTER_2) OR                      // Good Friday\n\t    (#tempDaysPassedToActDay = #tempDaysPassedToEaster) OR                                              // Easter Sunday\n\t    (#tempDaysPassedToActDay = #tempDaysPassedToEaster + #DAYS_AFTER_EASTER_1) OR                       // Easter Monday\n\t    (#tempDaysPassedToActDay = #tempDaysPassedToEaster + #DAYS_AFTER_EASTER_39 AND #ascension) OR       // Feast of the Ascension\n\t    (#tempDaysPassedToActDay = #tempDaysPassedToEaster + #DAYS_AFTER_EASTER_49) OR                      // Pentecost\n\t    (#tempDaysPassedToActDay = #tempDaysPassedToEaster + #DAYS_AFTER_EASTER_50) OR                      // Pentecost Monday\n\t    (#tempDaysPassedToActDay = #tempDaysPassedToEaster + #DAYS_AFTER_EASTER_60 AND #corpusChristi) THEN // Corpus Christi\n\t    \n\t    #LGF_IsGermanHoliday := TRUE;\n\t  ELSE\n\t    #LGF_IsGermanHoliday := FALSE;\n\t  END_IF;\n\t  \n\t  // ENO is not used, forced to TRUE\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "AstroClock", "description": "This function calculates the times of sunrise and sunset based on the local time for a specific place on Earth. The exact position is transferred in the form of geographical GPS coordinates (longitude and latitude).", "type": "FUNCTION_BLOCK", "name": "LGF_AstroClock", "vars": [{"name": "enable", "type": "Bool", "description": "TRUE: Activates the functionality of the FB"}, {"name": "positionGps", "type": "LGF_typeGPS_DD", "description": "GPS position to calculate the time of sunrise and\nsunset"}, {"name": "offsetSunrise", "type": "Time", "description": "Offset to sunrise (added to sunrise time, considered at\n`isDaytime`, negative time allowed)"}, {"name": "offsetSunset", "type": "Time", "description": "Offset to sunset (added to sunset time, considered at\n`isDaytime`, negative time allowed)"}, {"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "actualLocalTime", "type": "DTL", "description": "Current time (local time)"}, {"name": "sunriseTime", "type": "DTL", "description": "Sunrise time (localtime)"}, {"name": "sunsetTime", "type": "DTL", "description": "Sunset time (localtime)"}, {"name": "isDaytime", "type": "Bool", "description": "TRUE: If the local time of the controller is between “sunrise” and\n“sunset”."}, {"name": "latitude", "type": "Real", "description": "Degrees latitude with decimal places\n(Unit: degree decimal), North = positive; South =\nnegative)\nvalid value range [-90.00000..90.00000]"}, {"name": "longitude", "type": "Real", "description": "Degrees longitude in degrees with decimal places\n(Unit: degree decimal), East = positive; West =\nnegative)\nvalid range [-180.0000..180.0000]"}], "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Activates the functionality of the FB"}, {"name": "positionGps", "type": "LGF_typeGPS_DD", "description": "GPS position to calculate the time of sunrise and\nsunset"}, {"name": "offsetSunrise", "type": "Time", "description": "Offset to sunrise (added to sunrise time, considered at\n`isDaytime`, negative time allowed)"}, {"name": "offsetSunset", "type": "Time", "description": "Offset to sunset (added to sunset time, considered at\n`isDaytime`, negative time allowed)"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "actualLocalTime", "type": "DTL", "description": "Current time (local time)"}, {"name": "sunriseTime", "type": "DTL", "description": "Sunrise time (localtime)"}, {"name": "sunsetTime", "type": "DTL", "description": "Sunset time (localtime)"}, {"name": "isDaytime", "type": "Bool", "description": "TRUE: If the local time of the controller is between “sunrise” and\n“sunset”."}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_AstroClock\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_AstroClock\n   VAR_INPUT \n      enable : Bool;\n      positionGps : \"LGF_typeGPS_DD\";\n      offsetSunrise : Time;\n      offsetSunset : Time;\n   END_VAR\n\n   VAR_OUTPUT \n      valid { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      subFunctionStatus { ExternalWritable := 'False'} : Word;\n      actualLocalTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;\n      sunriseTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;\n      sunsetTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;\n      isDaytime { ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR \n      statEnableOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statBusy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      statSubfunctionStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statLongitudeHour { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;\n      statLatitudeRadiant { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;\n   END_VAR\n\n   VAR_TEMP \n      tempRetval : Word;\n      tempSysTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempOfficLocTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempDate1Jan {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempSunrise {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempSunset {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempTimeZone : Real;\n      tempDayOfYear : Real;\n      tempAproximateTime : Real;\n      tempSunMeanAnomaly : Real;\n      tempSunLongitude : Real;\n      tempSunMeanRad : Real;\n      tempSunLongitudeRadiant : Real;\n      tempSunAscension : Real;\n      tempSunAscensRad : Real;\n      tempSinDeclination : Real;\n      tempCosDeclination : Real;\n      tempCosLocHourAngle : Real;\n      tempLocalHourAngle : Real;\n      tempLocalMeanTime : Real;\n      tempUTC : Real;\n      tempLocalTime : Real;\n   END_VAR\n\n   VAR CONSTANT \n      SUBSTATUS_DAYLIGHT_SAVING_TIME : Word := 16#0001;\n      NO_ERROR : Word := 16#0000;\n      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_IN_OPERATION : Word := 16#7001;\n      ERR_LATITUDE_VALUE : Word := 16#8204;\n      ERR_LONGITUDE_VALUE : Word := 16#8205;\n      ERR_RD_SYS_T : Word := 16#8601;\n      ERR_RD_LOC_T : Word := 16#8602;\n      DEGREE_0 : Real := 0.0;\n      DEGREE_15 : Real := 15.0;\n      DEGREE_90 : Real := 90.0;\n      DEGREE_180 : Real := 180.0;\n      DEGREE_360 : Real := 360.0;\n      PI : Real := 3.141593;\n      DEGREE_TO_RADIANT : Real := 0.01745329;\n      RADIANT_TO_DEGREE : Real := 57.29578;\n      SUN_ZENIT : LReal := 1.58534073722818;\n      MAX_MIN_OR_SEC_59 : UInt := 59;\n      SECONDS_PER_HOUR : Real := 3600.0;\n      MINUTES_PER_HOUR : Real := 60.0;\n      HOURS_PER_DAY : Real := 24.0;\n      MS_PER_HOUR : Real := 3600000.0;\n      TIME_ZERO {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      FIRST_MONTH_AND_DAY : USInt := 1;\n      APPROXIMATE_TIME_6 : Int := 6;\n      APPROXIMATE_TIME_18 : Int := 18;\n      SUN_MEAN_ANOMALY_0_9856 : Real := 0.9856;\n      SUN_MEAN_ANOMALY_3_289 : Real := 3.289;\n      SUN_TRUE_LONGITUDE_0_02 : Real := 0.02;\n      SUN_TRUE_LONGITUDE_1_916 : Real := 1.916;\n      SUN_TRUE_LONGITUDE_2_0 : Real := 2.0;\n      SUN_TRUE_LONGITUDE_282_634 : Real := 282.634;\n      SUN_RIGHT_ASCENSION_0_91764 : Real := 0.91764;\n      SUN_RIGHT_ASCENSION_2_0 : Real := 2.0;\n      SUN_RIGHT_ASCENSION_2_PI : Real := 6.283185;\n      SUN_DECLINATION_0_39782 : Real := 0.39782;\n      SUM_LOCAL_HOUR_ANGLE : Real := 1.0;\n      LOCAL_MEAN_TIME_0_06571 : Real := 0.06571;\n      LOCAL_MEAN_TIME_6_622 : Real := 6.622;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_AstroClock\n\t  // Comment/Function: Astronomical clock, optional offset, input format DD\n\t  //                   \"LGF_typeGPS_DD\" - GPS position as decimal degree\n\t  // Library/Family:   LGF\n\t  // Author:           Siemens Industry Online Support\n\t  // Tested with:      CPU1214C DC/DC/DC FW:V4.3\n\t  // Engineering:      TIA Portal (V15.1)\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 01.10.2015  Siemens Industry Online Support\n\t  //                      T_ADD instruction is replaced with \"+\"\n\t  // 01.00.02 16.11.2015  Siemens Industry Online Support\n\t  //                      \"offsetSunrise\", \"offsetSunset\" is calculated in\n\t  //                      \"daytime\"\n\t  //                      Bug fix at \"Adjust back TO UTC\"\n\t  // 01.01.00 07.06.2015  Siemens Industry Online Support\n\t  //                      Add output actSystemTime and actLocalTime\n\t  // 01.01.01 15.06.2015  Siemens Industry Online Support\n\t  //                      Add comments\n\t  // 01.01.02 04.01.2017  Siemens Industry Online Support\n\t  //                      Bug fix at calculation sunrise and sunset\n\t  // 01.01.03 20.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V14 Update 1\n\t  // 01.01.04 22.02.2017  Siemens Industry Online Support\n\t  //                      Code optimization\n\t  // 01.01.05 09.07.2018  Siemens Industry Online Support\n\t  //                      Initialize #tempIntSunrise, #tempIntSunset,#tempDate1Jan \n\t  // 01.01.06 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.01.07 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.08 30.08.2019  Simatic Systems Support\n\t  //                      Rename from Astro to AstroClock\n\t  //                      Update Type name to positionGps - \"LGF_typeGPS_DD\" - GPS position as decimal degree\n\t  //                      Refactoring of interface\n\t  //                      - one input type for GPS data\n\t  //                      - refactored for better usability\n\t  //                      - refactoring of whole block to \"ENABLE\" behavior\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Bug fix - not enabled - block still running\n\t  //                      Insert documentation\n\t  //===============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Extended description\n\t  // Function:\n\t  // Your position may be entered at LatitudeDD/LongitudeDD\n\t  // Format signed degree(decimal)\n\t  // \n\t  // OffsetSunrise is added to Latitude and output at Sunrise\n\t  // OffsetSunset is added to Longitude and output at Sunset\n\t  // \n\t  // daytime is set when the actual time is inbetween Sunrise and Sunset\n\t  // ============================================================================\n\t  // Advice:\n\t  // please take care that the system time is permanently synchronizes anyhow\n\t  // ============================================================================\n\t  // Abbreviations\n\t  // lon: Longitude\n\t  // lat: Latitude\n\t  // dir: direction (valid characters: n, N, s, S, e, E, w, W)\n\t  // DD: decimal degrees (type Real)\n\t  //=============================================================================\n\t  // If a faulty value is entered at LatitudeDD\n\t  // then the value of Sunrise is set to zero\n\t  // and the value of Sunset is set to zero\n\t  // and daytime is set to zero\n\tEND_REGION\n\t\n\tREGION Block processing\n\t  // rising edge at enable\n\t  IF (#enable AND NOT #statEnableOld) AND (#statStatus = #STATUS_NO_CALL) THEN // Enable FB\n\t    // First call; initialize FB - set BUSY to TRUE\n\t    #statBusy := TRUE;\n\t    #statStatus := #STATUS_IN_OPERATION;\n\t    #statSubfunctionStatus := #NO_ERROR;\n\t    \n\t    // falling edge at enable\n\t  ELSIF (NOT #enable AND #statEnableOld) THEN  // Disable FB \n\t    // disbaling FB; set BUSY to FALSE\n\t    #statBusy := FALSE;\n\t    #statStatus := #STATUS_NO_CALL;\n\t    #statSubfunctionStatus := #NO_ERROR;\n\t    \n\t    // just if block is in operation,\n\t    // otherwise jump over region -> End here to reduce \"system load\"\n\t  ELSIF (#enable AND #statEnableOld) THEN\n\t    REGION Process astro clock calculation\n\t      // reset internal status storage\n\t      #statStatus := #STATUS_IN_OPERATION;\n\t      #statSubfunctionStatus := #NO_ERROR;\n\t      \n\t      REGION System time, local time, time zone\n\t        // Reading system time UTC\n\t        #tempRetval := INT_TO_WORD(RD_SYS_T(#tempSysTime));\n\t        \n\t        IF (#tempRetval <> #NO_ERROR) THEN\n\t          #statStatus := #ERR_RD_SYS_T;\n\t          #statSubfunctionStatus := #tempRetval;\n\t        END_IF;\n\t        \n\t        // Reading official actual local time\n\t        #tempRetval := INT_TO_WORD(RD_LOC_T(#tempOfficLocTime));\n\t        \n\t        IF (#tempRetval <> #NO_ERROR) AND (#tempRetval <> #SUBSTATUS_DAYLIGHT_SAVING_TIME) THEN\n\t          #statStatus := #ERR_RD_LOC_T;\n\t          #statSubfunctionStatus := #tempRetval;\n\t        END_IF;\n\t        \n\t        // Calculation of time difference #tempSysTime - #tempOfficLocTime\n\t        #tempTimeZone := DINT_TO_REAL(TIME_TO_DINT(T_DIFF(IN1 := #tempSysTime, IN2 := #tempOfficLocTime))) / #MS_PER_HOUR;\n\t      END_REGION System time, local time, time zone\n\t      \n\t      REGION Day of the year\n\t        #tempDate1Jan.YEAR := #tempOfficLocTime.YEAR;\n\t        #tempDate1Jan.MONTH := #FIRST_MONTH_AND_DAY;\n\t        #tempDate1Jan.DAY := #FIRST_MONTH_AND_DAY;\n\t        #tempDayOfYear := UDINT_TO_REAL(DATE_TO_UDINT(DTL_TO_DATE(#tempOfficLocTime)) - DATE_TO_UDINT(DTL_TO_DATE(#tempDate1Jan)) + 1);\n\t      END_REGION Day of the year\n\t      \n\t      REGION input value check\n\t        // input latitude DD > 90°, set fault\n\t        IF (ABS(#positionGps.latitude) > #DEGREE_90) THEN\n\t          #statStatus := #ERR_LATITUDE_VALUE;\n\t        END_IF;\n\t        \n\t        // input longitude DD > 180°, set fault\n\t        IF (ABS(#positionGps.longitude) > #DEGREE_180) THEN\n\t          #statStatus := #ERR_LONGITUDE_VALUE;\n\t        END_IF;\n\t        \n\t        // Copy GPS DD values to work variables and the convert to work units\n\t        #statLatitudeRadiant := #positionGps.latitude * #DEGREE_TO_RADIANT;\n\t        #statLongitudeHour := #positionGps.longitude / #DEGREE_15;\n\t      END_REGION input value check      \n\t      \n\t      REGION Calculate Sunrise\n\t        // Aproximate time \n\t        #tempAproximateTime := #tempDayOfYear + (#APPROXIMATE_TIME_6 - #statLongitudeHour) / #HOURS_PER_DAY;\n\t        \n\t        // Sun's mean anomaly\n\t        #tempSunMeanAnomaly := #SUN_MEAN_ANOMALY_0_9856 * #tempAproximateTime - #SUN_MEAN_ANOMALY_3_289;\n\t        #tempSunMeanRad := #tempSunMeanAnomaly * #DEGREE_TO_RADIANT;\n\t        \n\t        // Sun's true longitude\n\t        #tempSunLongitude := #tempSunMeanAnomaly + #SUN_TRUE_LONGITUDE_282_634\n\t        + #SUN_TRUE_LONGITUDE_1_916 * SIN(#tempSunMeanRad)\n\t        + #SUN_TRUE_LONGITUDE_0_02 * SIN(#SUN_TRUE_LONGITUDE_2_0 * #tempSunMeanRad);\n\t        \n\t        WHILE #tempSunLongitude > #DEGREE_360 DO\n\t          #tempSunLongitude -= #DEGREE_360;\n\t        END_WHILE;\n\t        \n\t        WHILE #tempSunLongitude < #DEGREE_0 DO\n\t          #tempSunLongitude += #DEGREE_360;\n\t        END_WHILE;\n\t        \n\t        #tempSunLongitudeRadiant := #tempSunLongitude * #DEGREE_TO_RADIANT;\n\t        \n\t        // Sun's right ascension\n\t        #tempSunAscensRad := ATAN(#SUN_RIGHT_ASCENSION_0_91764 * TAN(#tempSunLongitudeRadiant));\n\t        \n\t        WHILE #tempSunAscensRad > #SUN_RIGHT_ASCENSION_2_PI DO\n\t          #tempSunAscensRad -= #SUN_RIGHT_ASCENSION_2_PI;\n\t        END_WHILE;\n\t        \n\t        WHILE #tempSunAscensRad < #DEGREE_0 DO\n\t          #tempSunAscensRad += #SUN_RIGHT_ASCENSION_2_PI;\n\t        END_WHILE;\n\t        \n\t        #tempSunAscension := #tempSunAscensRad * #RADIANT_TO_DEGREE;\n\t        #tempSunAscension := (#tempSunAscension\n\t        + DINT_TO_REAL(FLOOR(#tempSunLongitude / #DEGREE_90)) * #DEGREE_90\n\t        - DINT_TO_REAL(FLOOR(#tempSunAscension / #DEGREE_90)) * #DEGREE_90)\n\t        / #DEGREE_15;\n\t        \n\t        // Sun's declination\n\t        #tempSinDeclination := #SUN_DECLINATION_0_39782 * SIN(#tempSunLongitudeRadiant);\n\t        #tempCosDeclination := COS(ASIN(#tempSinDeclination));\n\t        \n\t        // Sun's local hour angle angle\n\t        #tempCosLocHourAngle := LREAL_TO_REAL(\n\t                                              (COS(#SUN_ZENIT) - REAL_TO_LREAL(#tempSinDeclination * SIN(#statLatitudeRadiant)))\n\t                                              / (#tempCosDeclination * COS(#statLatitudeRadiant))\n\t        );\n\t        \n\t        IF (#tempCosLocHourAngle > #SUM_LOCAL_HOUR_ANGLE) THEN\n\t          #tempCosLocHourAngle := #SUM_LOCAL_HOUR_ANGLE;\n\t        ELSIF (#tempCosLocHourAngle < - #SUM_LOCAL_HOUR_ANGLE) THEN\n\t          #tempCosLocHourAngle := - #SUM_LOCAL_HOUR_ANGLE;\n\t        END_IF;\n\t        \n\t        // Calculate local hour angle for sunrise\n\t        #tempLocalHourAngle := (#DEGREE_360 - ACOS(#tempCosLocHourAngle) * #RADIANT_TO_DEGREE) / #DEGREE_15;\n\t        \n\t        // Local mean time of rising/setting\n\t        #tempLocalMeanTime := #tempLocalHourAngle + #tempSunAscension - (#LOCAL_MEAN_TIME_0_06571 * #tempAproximateTime) - #LOCAL_MEAN_TIME_6_622;\n\t        \n\t        // Adjust back TO UTC\n\t        #tempUTC := #tempLocalMeanTime - #statLongitudeHour;\n\t        \n\t        IF (#tempUTC > #HOURS_PER_DAY) THEN\n\t          #tempUTC -= #HOURS_PER_DAY;\n\t        ELSIF (#tempUTC < 0) THEN\n\t          #tempUTC += #HOURS_PER_DAY;\n\t        END_IF;\n\t        \n\t        #tempLocalTime := #tempUTC - #tempTimeZone;\n\t        \n\t        IF (#tempLocalTime >= #HOURS_PER_DAY) THEN\n\t          #tempLocalTime -= DINT_TO_REAL(TRUNC(#tempLocalTime / #HOURS_PER_DAY)) * #HOURS_PER_DAY;\n\t        ELSIF (#tempLocalTime < 0) THEN\n\t          #tempLocalTime += #HOURS_PER_DAY;\n\t        END_IF;\n\t        \n\t        // Convert #tempLocalTime to DTL (#tempIntSunrise) and add offset\n\t        #tempSunrise.YEAR := #tempOfficLocTime.YEAR;\n\t        #tempSunrise.MONTH := #tempOfficLocTime.MONTH;\n\t        #tempSunrise.DAY := #tempOfficLocTime.DAY;\n\t        #tempSunrise := #tempSunrise + UDINT_TO_TIME(REAL_TO_UDINT(#tempLocalTime * #MS_PER_HOUR));\n\t        #tempSunrise.NANOSECOND := 0;\n\t        #tempSunrise += #offsetSunrise;\n\t      END_REGION Calculate Sunrise\n\t      \n\t      REGION Calculate Sunset\n\t        // Aproximate time \n\t        #tempAproximateTime := #tempDayOfYear + (#APPROXIMATE_TIME_18 - #statLongitudeHour) / #HOURS_PER_DAY;\n\t        \n\t        // Sun's mean anomaly\n\t        #tempSunMeanAnomaly := #SUN_MEAN_ANOMALY_0_9856 * #tempAproximateTime - #SUN_MEAN_ANOMALY_3_289;\n\t        #tempSunMeanRad := #tempSunMeanAnomaly * #DEGREE_TO_RADIANT;\n\t        \n\t        // Sun's true longitude\n\t        #tempSunLongitude := #tempSunMeanAnomaly + #SUN_TRUE_LONGITUDE_282_634\n\t        + #SUN_TRUE_LONGITUDE_1_916 * SIN(#tempSunMeanRad)\n\t        + #SUN_TRUE_LONGITUDE_0_02 * SIN(#SUN_TRUE_LONGITUDE_2_0 * #tempSunMeanRad);\n\t        \n\t        WHILE #tempSunLongitude > #DEGREE_360 DO\n\t          #tempSunLongitude -= #DEGREE_360;\n\t        END_WHILE;\n\t        \n\t        WHILE #tempSunLongitude < #DEGREE_0 DO\n\t          #tempSunLongitude += #DEGREE_360;\n\t        END_WHILE;\n\t        \n\t        #tempSunLongitudeRadiant := #tempSunLongitude * #DEGREE_TO_RADIANT;\n\t        \n\t        // Sun's right ascension\n\t        #tempSunAscensRad := ATAN(#SUN_RIGHT_ASCENSION_0_91764 * TAN(#tempSunLongitudeRadiant));\n\t        \n\t        WHILE #tempSunAscensRad > #SUN_RIGHT_ASCENSION_2_PI DO\n\t          #tempSunAscensRad -= #SUN_RIGHT_ASCENSION_2_PI;\n\t        END_WHILE;\n\t        \n\t        WHILE #tempSunAscensRad < #DEGREE_0 DO\n\t          #tempSunAscensRad += #SUN_RIGHT_ASCENSION_2_PI;\n\t        END_WHILE;\n\t        \n\t        #tempSunAscension := #tempSunAscensRad * #RADIANT_TO_DEGREE;\n\t        #tempSunAscension := (#tempSunAscension\n\t        + DINT_TO_REAL(FLOOR(#tempSunLongitude / #DEGREE_90)) * #DEGREE_90\n\t        - DINT_TO_REAL(FLOOR(#tempSunAscension / #DEGREE_90)) * #DEGREE_90)\n\t        / #DEGREE_15;\n\t        \n\t        // Sun's declination\n\t        #tempSinDeclination := #SUN_DECLINATION_0_39782 * SIN(#tempSunLongitudeRadiant);\n\t        #tempCosDeclination := COS(ASIN(#tempSinDeclination));\n\t        \n\t        // Sun's local hour angle\n\t        #tempCosLocHourAngle := LREAL_TO_REAL(\n\t                                              (COS(#SUN_ZENIT) - REAL_TO_LREAL(#tempSinDeclination * SIN(#statLatitudeRadiant)))\n\t                                              / (#tempCosDeclination * COS(#statLatitudeRadiant))\n\t        );\n\t        \n\t        IF (#tempCosLocHourAngle > #SUM_LOCAL_HOUR_ANGLE) THEN\n\t          #tempCosLocHourAngle := #SUM_LOCAL_HOUR_ANGLE;\n\t        ELSIF (#tempCosLocHourAngle < - #SUM_LOCAL_HOUR_ANGLE) THEN\n\t          #tempCosLocHourAngle := - #SUM_LOCAL_HOUR_ANGLE;\n\t        END_IF;\n\t        \n\t        // Calculation local hour angle for sunset\n\t        #tempLocalHourAngle := ACOS(#tempCosLocHourAngle) * #RADIANT_TO_DEGREE / #DEGREE_15;\n\t        \n\t        // Local mean time of rising/setting\n\t        #tempLocalMeanTime := #tempLocalHourAngle + #tempSunAscension - (#LOCAL_MEAN_TIME_0_06571 * #tempAproximateTime) - #LOCAL_MEAN_TIME_6_622;\n\t        \n\t        // Adjust back TO UTC\n\t        #tempUTC := #tempLocalMeanTime - #statLongitudeHour;\n\t        \n\t        IF (#tempUTC > #HOURS_PER_DAY) THEN\n\t          #tempUTC -= #HOURS_PER_DAY;\n\t        ELSIF (#tempUTC < 0) THEN\n\t          #tempUTC += #HOURS_PER_DAY;\n\t        END_IF;\n\t        \n\t        #tempLocalTime := #tempUTC - #tempTimeZone;\n\t        \n\t        IF (#tempLocalTime >= #HOURS_PER_DAY) THEN\n\t          #tempLocalTime -= DINT_TO_REAL(TRUNC(#tempLocalTime / #HOURS_PER_DAY)) * #HOURS_PER_DAY;\n\t        ELSIF (#tempLocalTime < 0) THEN\n\t          #tempLocalTime += #HOURS_PER_DAY;\n\t        END_IF;\n\t        \n\t        // Convert #tempLocalTime to DTL (#tempIntSunset) and add offset\n\t        #tempSunset.YEAR := #tempOfficLocTime.YEAR;\n\t        #tempSunset.MONTH := #tempOfficLocTime.MONTH;\n\t        #tempSunset.DAY := #tempOfficLocTime.DAY;\n\t        #tempSunset := #tempSunset + UDINT_TO_TIME(REAL_TO_UDINT(#tempLocalTime * #MS_PER_HOUR));\n\t        #tempSunset.NANOSECOND := 0;\n\t        #tempSunset += #offsetSunset;\n\t      END_REGION Calculate Sunset\n\t      \n\t    END_REGION Process astro clock calculation\n\t  END_IF;\n\t  \n\t  // Edge detection store 'enable' input to memory\n\t  #statEnableOld := #enable;\n\tEND_REGION Block processing\n\t\n\tREGION OUTPUTS\n\t  // Write application specific values to outputs\n\t  #actualLocalTime := #tempOfficLocTime;\n\t  #sunriseTime := #tempSunrise;\n\t  #sunsetTime := #tempSunset;\n\t  // Evaluate Day (between Sunrise and Sunset)\n\t  #isDaytime := (#tempOfficLocTime >= #tempSunrise) AND (#tempOfficLocTime <= #tempSunset);\n\t  \n\t  // Write static values to outputs\n\t  #valid := NOT #statStatus.%X15 AND #statBusy;\n\t  #busy := #statBusy;\n\t  #error := #statStatus.%X15;\n\t  #status := #statStatus;\n\t  #subFunctionStatus := #statSubfunctionStatus;\n\t  \n\t  // ENO is not used, forced to TRUE\n\t  ENO := TRUE;\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "DelayProgram", "description": "Blocking delay to increase/extent PLC Load to simulate program load.", "type": "FUNCTION_BLOCK", "name": "LGF_DelayProgram", "vars": [{"name": "delay", "type": "Time", "description": "Time by which the program is delayed"}], "input": [{"name": "delay", "type": "Time", "description": "Time by which the program is delayed"}], "output": [], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_DelayProgram\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Simatic Systems Support'\nFAMILY : LGF\nNAME : LGF_DelayProgram\n   VAR_INPUT \n      delay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#1MS;\n   END_VAR\n\n   VAR \n      instDelay {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Siemens AG / (c)Copyright 2020\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_DelayProgram\n\t  // Comment/Function: Blocking delay to increase/extent PLC Load to simulate program load.\n\t  // Library/Family:   LGF - Library of general functions\n\t  // Author:           Simatic Systems Support\n\t  // Tested with:      S7-1500\n\t  // Engineering:      TIA Portal V19\n\t  // Restrictions:     ENO mechanism is NOT used - forced TO true.\n\t  // Requirements:     PLC S7-1500 / S7-1200\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge | Changes applied\n\t  //----------|------------|------------------|------------------------------------\n\t  // 01.00.00 | 19.05.2024 | SAG BG           | First Release\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t(/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Processing\n\t  // Call timer with false to ensure a rising edge in operation\n\t  #instDelay.TON(IN := FALSE,\n\t                 PT := #delay);\n\t  \n\t  // Call timer iin Loop to Block Programm\n\t  WHILE NOT #instDelay.Q DO\n\t    #instDelay.TON(IN := TRUE,\n\t                   PT := #delay);\n\t  END_WHILE;\n\t  \n\t  // Call timer with false to reset\n\t  #instDelay.TON(IN := FALSE,\n\t                 PT := #delay);\n\t  \n\t  // ENO NOT IN USE HERE\n\t  ENO := FALSE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "GetClockState", "description": "This function reads the local time, the system time and returns the NTP status.", "type": "FUNCTION_BLOCK", "name": "LGF_GetClockState", "vars": [{"name": "localTime", "type": "DTL", "description": "Local time"}, {"name": "systemTime", "type": "DTL", "description": "System time (UTC)"}, {"name": "isDaylightSavingTime", "type": "Bool", "description": "Daylight saving time active"}, {"name": "ntpActivated", "type": "Bool", "description": "NTP Client activated"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostics information of FB"}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [], "output": [{"name": "localTime", "type": "DTL", "description": "Local time"}, {"name": "systemTime", "type": "DTL", "description": "System time (UTC)"}, {"name": "isDaylightSavingTime", "type": "Bool", "description": "Daylight saving time active"}, {"name": "ntpActivated", "type": "Bool", "description": "NTP Client activated"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostics information of FB"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_GetClockState\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Simatic Systems Support'\nFAMILY : LGF\nNAME : LGF_GetClockState\n   VAR_OUTPUT \n      localTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;\n      systemTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;\n      isDaylightSavingTime { ExternalWritable := 'False'} : Bool;\n      ntpActivated { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR \n      statEmptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_FINISHED_NO_ERROR, (), ());\n   END_VAR\n\n   VAR_TEMP \n      tempResult : Word;\n      tempClockStatus : Word;\n   END_VAR\n\n   VAR CONSTANT \n      IS_DAYLIGHT_SAVING : Word := 16#0001;\n      IS_NTP_ACTIVATED : Word := 16#0002;\n      IS_NTP_SYNC_MISSED : Word := 16#0003;\n      IS_NTP_SYNC_DAYLIGHT_SAVING : Word := 16#0006;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_NTP_SERVER_SYNC_MISSING : Word := 16#8401;\n      ERR_READ_LOCAL_TIME : Word := 16#8601;\n      ERR_READ_SYSTEM_TIME : Word := 16#8602;\n      ERR_READ_CLOCK_STATE : Word := 16#8610;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //================================================================================\n\t  // (C)Copyright Siemens 2025\n\t  //--------------------------------------------------------------------------------\n\t  // Library:       LGF (Library General Functions) \n\t  // Tested with:   S7-1510SP-F\n\t  // Engineering:   TIA Portal V15\n\t  // Restrictions:  ---\n\t  // Requirements:  S7-1500/S7-1500T FW 2.5\n\t  // Functionality: This function reads the local time, the system time and returns the NTP status.\n\t  //--------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  //----------|------------|-------------------------|------------------------------\n\t  // 01.00.00 | 06.05.2025 | Simatic Systems Support | First released version\n\t  //================================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION\n\t  #diagnostics := #statEmptyDiagnostics;\n\t  \n\t  #isDaylightSavingTime := FALSE;\n\t  #ntpActivated := FALSE;\n\tEND_REGION INITIALISATION  \n\t\n\tREGION PROGRAM LOGIC\n\t  #tempResult := INT_TO_WORD(RD_LOC_T(#localTime));\n\t  IF #tempResult.%X15 THEN\n\t    #diagnostics.status := #ERR_READ_LOCAL_TIME;\n\t    #diagnostics.subfunctionStatus := #tempResult;\n\t  ELSE\n\t    #isDaylightSavingTime := (#tempResult = #IS_DAYLIGHT_SAVING);\n\t  END_IF;\n\t  \n\t  #tempResult := INT_TO_WORD(RD_SYS_T(#systemTime));\n\t  IF #tempResult.%X15 THEN\n\t    #diagnostics.status := #ERR_READ_SYSTEM_TIME;\n\t    #diagnostics.subfunctionStatus := #tempResult;\n\t  END_IF;\n\t  \n\t  #tempResult := INT_TO_WORD(GetClockStatus(#tempClockStatus));\n\t  IF #tempResult.%X15 THEN\n\t    #diagnostics.status := #ERR_READ_CLOCK_STATE;\n\t    #diagnostics.subfunctionStatus := #tempResult;\n\t    \n\t  ELSIF (#tempClockStatus AND #IS_NTP_SYNC_MISSED) = #IS_NTP_SYNC_MISSED THEN\n\t    #diagnostics.status := #ERR_NTP_SERVER_SYNC_MISSING;\n\t    #diagnostics.subfunctionStatus := #tempClockStatus;\n\t  END_IF;\n\t  \n\t  #ntpActivated := (#tempClockStatus AND #IS_NTP_ACTIVATED) = #IS_NTP_ACTIVATED;\n\t  #isDaylightSavingTime := #isDaylightSavingTime OR ((#tempClockStatus AND #IS_NTP_SYNC_DAYLIGHT_SAVING) = #IS_NTP_SYNC_DAYLIGHT_SAVING);\n\tEND_REGION PROGRAM LOGIC\n\t\n\tREGION OUTPUTS\n\t  #error := #diagnostics.status.%X15;\n\t  #status := #diagnostics.status;\n\t  ENO := NOT #diagnostics.status.%X15;\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "SetTime", "description": "This block combines the functions of system time, local time, and set time zone.", "type": "FUNCTION_BLOCK", "name": "LGF_SetTime", "vars": [{"name": "execute", "type": "Bool", "description": "Rising edge starts action once"}, {"name": "systemTime", "type": "DTL", "description": "System time to be set in PLC"}, {"name": "isLocalTime", "type": "Bool", "description": "TRUE: `systemTime` is local time, FALSE:\n`systemTime` is UTC time"}, {"name": "timeZone", "type": "Int", "description": "Timezones HHMM [-1200.. -330.. 0.. 930.. 1200.. 1300]"}, {"name": "isDaylightSavingTime", "type": "Bool", "description": "Daylight saving time changeover, TRUE: activated,\nFALSE: deactivated (more infos at \"Adjusting\nparameters in the `statTimeZone` variable\")"}, {"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "lastSetTimeZone", "type": "String", "description": "Time zone that was set last by this block"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts action once"}, {"name": "systemTime", "type": "DTL", "description": "System time to be set in PLC"}, {"name": "isLocalTime", "type": "Bool", "description": "TRUE: `systemTime` is local time, FALSE:\n`systemTime` is UTC time"}, {"name": "timeZone", "type": "Int", "description": "Timezones HHMM [-1200.. -330.. 0.. 930.. 1200.. 1300]"}, {"name": "isDaylightSavingTime", "type": "Bool", "description": "Daylight saving time changeover, TRUE: activated,\nFALSE: deactivated (more infos at \"Adjusting\nparameters in the `statTimeZone` variable\")"}], "output": [{"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "lastSetTimeZone", "type": "String", "description": "Time zone that was set last by this block"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_SetTime\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_SetTime\n   VAR_INPUT \n      execute : Bool;\n      systemTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      isLocalTime : Bool;\n      timeZone : Int;\n      isDaylightSavingTime : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      done { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      lastSetTimeZone { ExternalWritable := 'False'} : String;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      subFunctionStatus { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR \n      statExecuteOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statBusy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      statSubFunctionStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statFBState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;\n      instSetTimeZone {InstructionName := 'SET_TIMEZONE'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : SET_TIMEZONE;\n      statTimeZone {InstructionName := 'TimeTransformationRule'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TimeTransformationRule := (0, 60, 3, 5, 1, 2, 0, 10, 5, 1, 3, 0, 'not even set by LGF_TimeZone');\n   END_VAR\n\n   VAR_TEMP \n      tempExecute : Bool;\n      tempSetTimeZoneDone : Bool;\n      tempSetTimeZoneBusy : Bool;\n      tempSetTimeZoneError : Bool;\n      tempSetTimeZoneStatus : Word;\n      tempResultSetTime : Word;\n   END_VAR\n\n   VAR CONSTANT \n      FB_STATE_NO_PROCESSING : DInt := 0;\n      FB_STATE_SET_TIME : DInt := 1;\n      FB_STATE_SET_TIMEZONE : DInt := 2;\n      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n      ERR_WRONG_TIMEZONE : Word := 16#8601;\n      ERR_SET_TIME_LOCAL : Word := 16#8201;\n      ERR_SET_TIME_UTC : Word := 16#8202;\n      ERR_SET_TIMEZONE : Word := 16#8203;\n      UTC_MINUS_1200 : Int := -1200;\n      UTC_MINUS_1200_BIAS : Int := -720;\n      UTC_MINUS_1200_NAME : String := '(UTC -12:00)';\n      UTC_MINUS_1100 : Int := -1100;\n      UTC_MINUS_1100_BIAS : Int := -660;\n      UTC_MINUS_1100_NAME : String := '(UTC -11:00)';\n      UTC_MINUS_1000 : Int := -1000;\n      UTC_MINUS_1000_BIAS : Int := -600;\n      UTC_MINUS_1000_NAME : String := '(UTC -10:00)';\n      UTC_MINUS_0930 : Int := -930;\n      UTC_MINUS_0930_BIAS : Int := -570;\n      UTC_MINUS_0930_NAME : String := '(UTC -09:30)';\n      UTC_MINUS_0900 : Int := -900;\n      UTC_MINUS_0900_BIAS : Int := -540;\n      UTC_MINUS_0900_NAME : String := '(UTC -09:00)';\n      UTC_MINUS_0800 : Int := -800;\n      UTC_MINUS_0800_BIAS : Int := -480;\n      UTC_MINUS_0800_NAME : String := '(UTC -08:00)';\n      UTC_MINUS_0700 : Int := -700;\n      UTC_MINUS_0700_BIAS : Int := -420;\n      UTC_MINUS_0700_NAME : String := '(UTC -07:00)';\n      UTC_MINUS_0600 : Int := -600;\n      UTC_MINUS_0600_BIAS : Int := -360;\n      UTC_MINUS_0600_NAME : String := '(UTC -06:00)';\n      UTC_MINUS_0500 : Int := -500;\n      UTC_MINUS_0500_BIAS : Int := -300;\n      UTC_MINUS_0500_NAME : String := '(UTC -05:00)';\n      UTC_MINUS_0400 : Int := -400;\n      UTC_MINUS_0400_BIAS : Int := -240;\n      UTC_MINUS_0400_NAME : String := '(UTC -04:00)';\n      UTC_MINUS_0330 : Int := -0330;\n      UTC_MINUS_0330_BIAS : Int := -210;\n      UTC_MINUS_0330_NAME : String := '(UTC -03:30)';\n      UTC_MINUS_0300 : Int := -300;\n      UTC_MINUS_0300_BIAS : Int := -180;\n      UTC_MINUS_0300_NAME : String := '(UTC -03:00)';\n      UTC_MINUS_0200 : Int := -200;\n      UTC_MINUS_0200_BIAS : Int := -120;\n      UTC_MINUS_0200_NAME : String := '(UTC -02:00)';\n      UTC_MINUS_0100 : Int := -100;\n      UTC_MINUS_0100_BIAS : Int := -60;\n      UTC_MINUS_0100_NAME : String := '(UTC -01:00)';\n      UTC_0 : Int := 0;\n      UTC_0_BIAS : Int := 0;\n      UTC_0_NAME : String := '(UTC)';\n      UTC_100 : Int := 100;\n      UTC_100_BIAS : Int := 60;\n      UTC_100_NAME : String := '(UTC +01:00)';\n      UTC_200 : Int := 200;\n      UTC_200_BIAS : Int := 120;\n      UTC_200_NAME : String := '(UTC +02:00)';\n      UTC_300 : Int := 300;\n      UTC_300_BIAS : Int := 180;\n      UTC_300_NAME : String := '(UTC +03:00)';\n      UTC_330 : Int := 330;\n      UTC_330_BIAS : Int := 210;\n      UTC_330_NAME : String := '(UTC +03:30)';\n      UTC_400 : Int := 400;\n      UTC_400_BIAS : Int := 240;\n      UTC_400_NAME : String := '(UTC +04:00)';\n      UTC_430 : Int := 430;\n      UTC_430_BIAS : Int := 270;\n      UTC_430_NAME : String := '(UTC +04:30)';\n      UTC_500 : Int := 500;\n      UTC_500_BIAS : Int := 300;\n      UTC_500_NAME : String := '(UTC +05:00)';\n      UTC_530 : Int := 530;\n      UTC_530_BIAS : Int := 330;\n      UTC_530_NAME : String := '(UTC +05:30)';\n      UTC_545 : Int := 545;\n      UTC_545_BIAS : Int := 345;\n      UTC_545_NAME : String := '(UTC +05:45)';\n      UTC_600 : Int := 600;\n      UTC_600_BIAS : Int := 360;\n      UTC_600_NAME : String := '(UTC +06:00)';\n      UTC_630 : Int := 630;\n      UTC_630_BIAS : Int := 390;\n      UTC_630_NAME : String := '(UTC +06:30)';\n      UTC_700 : Int := 700;\n      UTC_700_BIAS : Int := 420;\n      UTC_700_NAME : String := '(UTC +07:00)';\n      UTC_800 : Int := 800;\n      UTC_800_BIAS : Int := 480;\n      UTC_800_NAME : String := '(UTC +08:00)';\n      UTC_830 : Int := 830;\n      UTC_830_BIAS : Int := 510;\n      UTC_830_NAME : String := '(UTC +08:30)';\n      UTC_845 : Int := 845;\n      UTC_845_BIAS : Int := 525;\n      UTC_845_NAME : String := '(UTC +08:45)';\n      UTC_900 : Int := 900;\n      UTC_900_BIAS : Int := 540;\n      UTC_900_NAME : String := '(UTC +09:00)';\n      UTC_930 : Int := 930;\n      UTC_930_BIAS : Int := 570;\n      UTC_930_NAME : String := '(UTC +09:30)';\n      UTC_1000 : Int := 1000;\n      UTC_1000_BIAS : Int := 600;\n      UTC_1000_NAME : String := '(UTC +10:00)';\n      UTC_1030 : Int := 1030;\n      UTC_1030_BIAS : Int := 630;\n      UTC_1030_NAME : String := '(UTC +10:30)';\n      UTC_1100 : Int := 1100;\n      UTC_1100_BIAS : Int := 660;\n      UTC_1100_NAME : String := '(UTC +11:00)';\n      UTC_1200 : Int := 1200;\n      UTC_1200_BIAS : Int := 720;\n      UTC_1200_NAME : String := '(UTC +12:00)';\n      UTC_1245 : Int := 1245;\n      UTC_1245_BIAS : Int := 765;\n      UTC_1245_NAME : String := '(UTC +12:45)';\n      UTC_1300 : Int := 1300;\n      UTC_1300_BIAS : Int := 780;\n      UTC_1300_NAME : String := '(UTC +13:00)';\n      UTC_1400 : Int := 1400;\n      UTC_1400_BIAS : Int := 840;\n      UTC_1400_NAME : String := '(UTC +14:00)';\n      DAYLIGHT_BIAS_ON : Int := 60;\n      DAYLIGHT_BIAS_OFF : Int := 0;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_SetTime\n\t  // Comment/Function: Set system / local time, time zone\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 Update 1\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 08.06.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V14 Update 1\n\t  // 01.00.02 02.03.2017  Siemens Industry Online Support\n\t  //                      Bugfix: FB number: automatic\n\t  // 01.00.03 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.04 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.05 20.02.2019  Siemens Industry Online Support\n\t  //                      Bugfix: Rising edge at input REQ of SET_TIMEOUT\n\t  // 01.00.06 23.08.2019  Simatic Systems Support\n\t  //                      Reworked interface to PLC Open \"execute\" behavior\n\t  //                      Magic numbers removed, tag naming added, code reworked\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.02 13.01.2020  Simatic Systems Support\n\t  //                      Bug fix - bias correction for time offsets (330)\n\t  //                      Insert documentation\n\t  // 03.00.03 03.06.2022  Simatic Systems Support\n\t  //                      Bug fix - bias correction for time offsets (200)\n\t  //=============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\t#tempExecute := #execute; // Work with temporary value / create process image\n\t\n\tREGION TRIGGERING\n\t  IF (#tempExecute = TRUE) AND (#statExecuteOld = FALSE) // Check if FB is triggered\n\t    // FB shall finish current job before new job can be started with rising edge of execute\n\t    AND (#statStatus = #STATUS_NO_CALL)\n\t  THEN // First call; initialize FB\n\t    #statDone := FALSE;\n\t    #statBusy := TRUE;\n\t    #statError := FALSE;\n\t    #statStatus := #STATUS_FIRST_CALL;\n\t    #statSubFunctionStatus := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t    // State machine - start processing\n\t    #statFBState := #FB_STATE_SET_TIME;\n\t    \n\t    // Initialize functionality: reset of variables, diagnostics, etc.\n\t    // Set timzone values for systemfunction\n\t    CASE #timeZone OF\n\t      #UTC_MINUS_1200:  // (UTC -12:00) Eniwetok, Kwajalein\n\t        #statTimeZone.Bias := #UTC_MINUS_1200_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_MINUS_1200_NAME;\n\t      #UTC_MINUS_1100:  // (UTC -11:00) Midway Island\n\t        #statTimeZone.Bias := #UTC_MINUS_1100_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_MINUS_1100_NAME;\n\t      #UTC_MINUS_1000:  // (UTC -10:00) Hawaii\n\t        #statTimeZone.Bias := #UTC_MINUS_1000_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_MINUS_1000_NAME;\n\t      #UTC_MINUS_0930:  // (UTC -09:30) (French) Polynesia\n\t        #statTimeZone.Bias := #UTC_MINUS_0930_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_MINUS_0930_NAME;\n\t      #UTC_MINUS_0900:  // (UTC -09:00) Alaska\n\t        #statTimeZone.Bias := #UTC_MINUS_0900_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_MINUS_0900_NAME;\n\t      #UTC_MINUS_0800:  // (UTC -08:00) Tijuana, Los Angeles, Seattle, Vancouver\n\t        #statTimeZone.Bias := #UTC_MINUS_0800_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_MINUS_0800_NAME;\n\t      #UTC_MINUS_0700:  // (UTC -07:00) Arizona, Denver, Salt Lake City, Calgary\n\t        #statTimeZone.Bias := #UTC_MINUS_0700_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_MINUS_0700_NAME;\n\t      #UTC_MINUS_0600:  // (UTC -06:00) Chicago, Dallas, Kansas City, Winnipeg\n\t        #statTimeZone.Bias := #UTC_MINUS_0600_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_MINUS_0600_NAME;\n\t      #UTC_MINUS_0500:  // (UTC -05:00) Eastern Time (USA & Canada)\n\t        #statTimeZone.Bias := #UTC_MINUS_0500_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_MINUS_0500_NAME;\n\t      #UTC_MINUS_0400:  // (UTC -04:00) La Paz, Georgetown\n\t        #statTimeZone.Bias := #UTC_MINUS_0400_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_MINUS_0400_NAME;\n\t      #UTC_MINUS_0330:  // (UTC -03:30) Newfoundland\n\t        #statTimeZone.Bias := #UTC_MINUS_0330_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_MINUS_0330_NAME;\n\t      #UTC_MINUS_0300:  // (UTC -03:00) Brasilia, Buenos Aires\n\t        #statTimeZone.Bias := #UTC_MINUS_0300_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_MINUS_0300_NAME;\n\t      #UTC_MINUS_0200:  // (UTC -02:00) Mid-Atlantic\n\t        #statTimeZone.Bias := #UTC_MINUS_0200_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_MINUS_0200_NAME;\n\t      #UTC_MINUS_0100:  // (UTC -01:00) Azores, Cape Verde Is.\n\t        #statTimeZone.Bias := #UTC_MINUS_0100_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_MINUS_0100_NAME;\n\t      #UTC_0:  // (UTC) Dublin, Edinburgh, Lisbon, London\n\t        #statTimeZone.Bias := #UTC_0_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_0_NAME;\n\t      #UTC_100:  // (UTC +01:00) Berlin, Bern, Brussels, Rome, Stockholm, Vienna\n\t        #statTimeZone.Bias := #UTC_100_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_100_NAME;\n\t      #UTC_200: // (UTC +02:00) Athens, Istanbul, Minsk, Bucharest\n\t        #statTimeZone.Bias := #UTC_200_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_200_NAME;\n\t      #UTC_300: // (UTC +03:00) Moscow, St. Petersburg, Baghdad, Kuwait, Riyadh\n\t        #statTimeZone.Bias := #UTC_300_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_300_NAME;\n\t      #UTC_330: // (UTC +03:00) Iran\n\t        #statTimeZone.Bias := #UTC_330_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_330_NAME;\n\t      #UTC_400: // (UTC +04:00) Abu Dhabi, Muscat\n\t        #statTimeZone.Bias := #UTC_400_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_400_NAME;\n\t      #UTC_430: // (UTC +04:30) Afghanistan\n\t        #statTimeZone.Bias := #UTC_430_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_430_NAME;\n\t      #UTC_500: // (UTC +05:00) Islamabad, Karachi, Tashkent\n\t        #statTimeZone.Bias := #UTC_500_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_500_NAME;\n\t      #UTC_530: // (UTC +05:30) India, Sri Lanka\n\t        #statTimeZone.Bias := #UTC_530_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_530_NAME;\n\t      #UTC_545: // (UTC +05:45) Nepal\n\t        #statTimeZone.Bias := #UTC_545_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_545_NAME;\n\t      #UTC_600: // (UTC +06:00) Astana, Almaty, Dhaka, Colombo, Banglatesh, Butan\n\t        #statTimeZone.Bias := #UTC_600_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_600_NAME;\n\t      #UTC_630: // (UTC +06:30) Coco Island, Mayanmar\n\t        #statTimeZone.Bias := #UTC_630_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_630_NAME;\n\t      #UTC_700: // (UTC +07:00) Bangkok, Hanoi, Jakarta\n\t        #statTimeZone.Bias := #UTC_700_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_700_NAME;\n\t      #UTC_800: // (UTC +08:00) Beijing, Chongqing, Hong Kong, Urumqi\n\t        #statTimeZone.Bias := #UTC_800_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_800_NAME;\n\t      #UTC_830: // (UTC +08:30) North Corea (old)\n\t        #statTimeZone.Bias := #UTC_830_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_830_NAME;\n\t      #UTC_845: // (UTC +08:45) Western Australia, Eucla\n\t        #statTimeZone.Bias := #UTC_845_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_845_NAME;\n\t      #UTC_900: // (UTC +09:00) Yakutsk, Osaka, Sapporo, Tokyo, Seoul\n\t        #statTimeZone.Bias := #UTC_900_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_900_NAME;\n\t      #UTC_930: // (UTC +09:30) Australia: Northern Territory, South Australia\n\t        #statTimeZone.Bias := #UTC_930_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_930_NAME;\n\t      #UTC_1000: // (UTC +10:00) Brisbane, Canberra, Melbourne, Sydney\n\t        #statTimeZone.Bias := #UTC_1000_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_1000_NAME;\n\t      #UTC_1030: // (UTC +10:30) Australia: Lord Howe Island\n\t        #statTimeZone.Bias := #UTC_1030_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_1030_NAME;\n\t      #UTC_1100: // (UTC +11:00) Vladivostok, Magadan, Solomon Is., New Caledonia\n\t        #statTimeZone.Bias := #UTC_1100_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_1100_NAME;\n\t      #UTC_1200: // (UTC +12:00) Auckland, Wellington\n\t        #statTimeZone.Bias := #UTC_1200_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_1200_NAME;\n\t      #UTC_1245: // (UTC +12:45) Chatham Islands\n\t        #statTimeZone.Bias := #UTC_1245_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_1245_NAME;\n\t      #UTC_1300: // (UTC +13:00) Tonga, Samoa, Kiribati (Phoenix isl.)\n\t        #statTimeZone.Bias := #UTC_1300_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_1300_NAME;\n\t      #UTC_1400: // (UTC +13:00) Kiribati (Line isl.)\n\t        #statTimeZone.Bias := #UTC_1400_BIAS;\n\t        #statTimeZone.TimeZoneName := #UTC_1400_NAME;\n\t      ELSE  // Error handling - wronge time zone parmater\n\t        #statStatus := #ERR_WRONG_TIMEZONE;\n\t        #subFunctionStatus := INT_TO_WORD(#timeZone);\n\t        #statFBState := #FB_STATE_NO_PROCESSING;\n\t    END_CASE;\n\t    \n\t    // Select daylight saving time on/off\n\t    IF #isDaylightSavingTime THEN\n\t      #statTimeZone.DaylightBias := #DAYLIGHT_BIAS_ON;\n\t    ELSE\n\t      #statTimeZone.DaylightBias := #DAYLIGHT_BIAS_OFF;\n\t    END_IF;\n\t    \n\t    // Initialize functionality: call subsidiary FBs with FALSE\n\t    #instSetTimeZone(REQ      := FALSE,\n\t                     TimeZone := #statTimeZone,\n\t                     DONE     => #tempSetTimeZoneDone,\n\t                     BUSY     => #tempSetTimeZoneBusy,\n\t                     ERROR    => #tempSetTimeZoneError,\n\t                     STATUS   => #tempSetTimeZoneStatus);\n\t    \n\t  ELSIF (#statStatus = #STATUS_FIRST_CALL) THEN\n\t    #statStatus := #STATUS_SUBSEQUENT_CALL;\n\t  END_IF;\n\t  \n\t  // Edge detection 'execute' input\n\t  #statExecuteOld := #tempExecute;\n\tEND_REGION TRIGGERING\n\t\n\tIF (#statStatus = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION STATE_MACHINE\n\t  CASE #statFBState OF // State machine of FB\n\t    #FB_STATE_NO_PROCESSING: // No processing active (Note: this state must always be present and left empty)\n\t      REGION No processing\n\t        ;\n\t      END_REGION\n\t      \n\t    #FB_STATE_SET_TIME:\n\t      REGION Set time\n\t        IF #isLocalTime THEN\n\t          #tempResultSetTime := INT_TO_WORD(WR_LOC_T(LOCTIME := #systemTime, DST := #isDaylightSavingTime));\n\t          \n\t          // In case of error - set error output an quit\n\t          IF #tempResultSetTime.%X15 = TRUE THEN\n\t            #statStatus := #ERR_SET_TIME_LOCAL;\n\t            #statSubFunctionStatus := #tempResultSetTime;\n\t          ELSE\n\t            #statFBState := #FB_STATE_SET_TIMEZONE;\n\t          END_IF;\n\t          \n\t        ELSE\n\t          #tempResultSetTime := INT_TO_WORD(WR_SYS_T(#systemTime));\n\t          \n\t          // In case of error - set error output an quit\n\t          IF #tempResultSetTime.%X15 = TRUE THEN\n\t            #statStatus := #ERR_SET_TIME_UTC;\n\t            #statSubFunctionStatus := #tempResultSetTime;\n\t          ELSE\n\t            #statFBState := #FB_STATE_SET_TIMEZONE;\n\t          END_IF;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    #FB_STATE_SET_TIMEZONE:\n\t      REGION Set timezone\n\t        // Set time zone by calling the system function\n\t        #instSetTimeZone(REQ      := TRUE,\n\t                         TimeZone := #statTimeZone,\n\t                         DONE     => #tempSetTimeZoneDone,\n\t                         BUSY     => #tempSetTimeZoneBusy,\n\t                         ERROR    => #tempSetTimeZoneError,\n\t                         STATUS   => #tempSetTimeZoneStatus);\n\t        \n\t        // If operation is done\n\t        IF #instSetTimeZone.DONE = TRUE THEN\n\t          // Reset function call\n\t          #instSetTimeZone(REQ      := FALSE,\n\t                           TimeZone := #statTimeZone,\n\t                           DONE     => #tempSetTimeZoneDone,\n\t                           BUSY     => #tempSetTimeZoneBusy,\n\t                           ERROR    => #tempSetTimeZoneError,\n\t                           STATUS   => #tempSetTimeZoneStatus);\n\t          // Next state\n\t          #statStatus := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t        END_IF;\n\t        \n\t        // If operation is done\n\t        IF #instSetTimeZone.ERROR = TRUE THEN\n\t          // Set error message\n\t          #statStatus := #ERR_SET_TIMEZONE;\n\t          #statSubFunctionStatus := #instSetTimeZone.STATUS;\n\t          \n\t          // Reset function call\n\t          #instSetTimeZone(REQ      := FALSE,\n\t                           TimeZone := #statTimeZone,\n\t                           DONE     => #tempSetTimeZoneDone,\n\t                           BUSY     => #tempSetTimeZoneBusy,\n\t                           ERROR    => #tempSetTimeZoneError,\n\t                           STATUS   => #tempSetTimeZoneStatus);\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    ELSE // Undefined state in state machine reached\n\t      #statStatus := #ERR_UNDEFINED_STATE;\n\t  END_CASE;\n\tEND_REGION STATE_MACHINE\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  IF (#statStatus = #STATUS_EXECUTION_FINISHED_NO_ERROR) AND (#statDone = FALSE) THEN // Execution finished without errors\n\t    #statDone := TRUE;\n\t    #statBusy := FALSE;\n\t    #statError := FALSE;\n\t    // Execution aborted --> set state no processing\n\t    #statFBState := #FB_STATE_NO_PROCESSING;\n\t    \n\t  ELSIF (#statStatus.%X15 = TRUE) AND (#statError = FALSE) THEN // Error occurred (#statStatus is 16#8000 to 16#FFFF)\n\t    #statDone := FALSE;\n\t    #statBusy := FALSE;\n\t    #statError := TRUE;\n\t    // Execution aborted --> set state no processing\n\t    #statFBState := #FB_STATE_NO_PROCESSING;\n\t    \n\t  ELSIF (#tempExecute = FALSE) AND ((#statDone = TRUE) OR (#statError = TRUE)) THEN // Reset outputs\n\t    #statDone := FALSE;\n\t    #statBusy := FALSE;\n\t    #statError := FALSE;\n\t    #statStatus := #STATUS_NO_CALL;\n\t  END_IF;\n\t  \n\t  // Write static values to outputs\n\t  #done := #statDone;\n\t  #busy := #statBusy;\n\t  #error := #statError;\n\t  #status := #statStatus;\n\t  #subFunctionStatus := #statSubFunctionStatus;\n\t  // Output the last set time zone\n\t  #lastSetTimeZone := #statTimeZone.TimeZoneName;\n\t  \n\t  // ENO is not used, forced to TRUE\n\t  ENO := TRUE;\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "TimerSwitch", "description": "This block is a timer. It is possible to define daily, weekly, monthly, yearly time switch points and time switch points for working days or weekend days. Mode: Permanently off: 0, Daily: 1, Weekly: 2, Monthly: 3, Yearly: 4, Workday: 5, Weekend: 6, Permanently on: 10 The time value is always compared with the local time of the PLC, therefore the time value specified at the On and Off parameters must be specified as local time.", "type": "FUNCTION_BLOCK", "name": "LGF_TimerSwitch", "vars": [{"name": "onMonth", "type": "USInt", "description": "Month, in which the signal shall be set."}, {"name": "onDay", "type": "USInt", "description": "Day, at which the signal shall be set."}, {"name": "onWeekday", "type": "USInt", "description": "Day of the week on which the signal will be set;\nSunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "onHour", "type": "USInt", "description": "Hour, at which the signal shall be set."}, {"name": "onMinute", "type": "USInt", "description": "Minute, at which the signal shall be set."}, {"name": "offMonth", "type": "USInt", "description": "Month, in which the signal shall be reset."}, {"name": "offDay", "type": "USInt", "description": "Day, at which the signal shall be reset."}, {"name": "offWeekday", "type": "USInt", "description": "Day of the week on which the signal will be reset;\nSunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "offHour", "type": "USInt", "description": "Hour, at which the signal shall be reset."}, {"name": "offMinute", "type": "USInt", "description": "Minute, at which the signal shall be reset."}, {"name": "mode", "type": "USInt", "description": "Specifies the mode (see Principle of operation);\nPermanently off: 0, Daily: 1, Weekly: 2, Monthly: 3,\nYearly: 4, Workday: 5, Weekend: 6, Permanently on:\n10"}, {"name": "signal", "type": "Bool", "description": "Output signal"}, {"name": "actLocalTime", "type": "DTL", "description": "Current local time"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Sub function status code"}], "input": [{"name": "onMonth", "type": "USInt", "description": "Month, in which the signal shall be set."}, {"name": "onDay", "type": "USInt", "description": "Day, at which the signal shall be set."}, {"name": "onWeekday", "type": "USInt", "description": "Day of the week on which the signal will be set;\nSunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "onHour", "type": "USInt", "description": "Hour, at which the signal shall be set."}, {"name": "onMinute", "type": "USInt", "description": "Minute, at which the signal shall be set."}, {"name": "offMonth", "type": "USInt", "description": "Month, in which the signal shall be reset."}, {"name": "offDay", "type": "USInt", "description": "Day, at which the signal shall be reset."}, {"name": "offWeekday", "type": "USInt", "description": "Day of the week on which the signal will be reset;\nSunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "offHour", "type": "USInt", "description": "Hour, at which the signal shall be reset."}, {"name": "offMinute", "type": "USInt", "description": "Minute, at which the signal shall be reset."}, {"name": "mode", "type": "USInt", "description": "Specifies the mode (see Principle of operation);\nPermanently off: 0, Daily: 1, Weekly: 2, Monthly: 3,\nYearly: 4, Workday: 5, Weekend: 6, Permanently on:\n10"}], "output": [{"name": "signal", "type": "Bool", "description": "Output signal"}, {"name": "actLocalTime", "type": "DTL", "description": "Current local time"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Sub function status code"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_TimerSwitch\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_TimerSwitch\n   VAR_INPUT \n      onMonth : USInt;\n      onDay : USInt;\n      onWeekday : USInt;\n      onHour : USInt;\n      onMinute : USInt;\n      offMonth : USInt;\n      offDay : USInt;\n      offWeekday : USInt;\n      offHour : USInt;\n      offMinute : USInt;\n      mode : USInt;\n   END_VAR\n\n   VAR_OUTPUT \n      signal { ExternalWritable := 'False'} : Bool;\n      actLocalTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      subFunctionStatus { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempReadTimeStatus : Word;\n      tempOnTimeDtl {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempOnTimeTod : Time_Of_Day;\n      tempOffTimeDtl {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempOffTimeTod : Time_Of_Day;\n      tempActTimeDtl {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempActTimeTod : Time_Of_Day;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : USInt := 0;\n      CLEAR_DTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_MODE_SELECTED : Word := 16#8200;\n      ERR_RD_LOC_T : Word := 16#8600;\n      MODE_PERMANENTLY_OFF : UInt := 0;\n      MODE_DAILY : UInt := 1;\n      MODE_WEEKLY : UInt := 2;\n      MODE_MONTHLY : UInt := 3;\n      MODE_YEARLY : UInt := 4;\n      MODE_WEEK_DAYS : UInt := 5;\n      MODE_WEEKEND_DAYS : UInt := 6;\n      MODE_PERMANENTLY_ON : UInt := 10;\n      MONTH_JANUARY : USInt := 1;\n      MONTH_DECEMBER : USInt := 12;\n      DAY_MONDAY : USInt := 2;\n      DAY_FRIDAY : USInt := 6;\n      DAY_SATURDAY : USInt := 7;\n      DAY_SUNDAY : USInt := 1;\n      DAY_NEXT_SUNDAY : USInt := 8;\n      DAY_NEXT_MONDAY : USInt := 9;\n      DATE_INCREMENT : USInt := 1;\n      DAY_INCREMENT : Time := T#1d;\n      WEEK_INCREMENT : Time := T#7d;\n      DAYS_PER_WEEK : USInt := 7;\n      DEFAULT_YEAR : UInt := 2015;\n      DEFAULT_MONTH : USInt := 2;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_TimerSwitch\n\t  // Comment/Function: Timer Switch (daily, weekly, monthly, working days, ...)\n\t  //                   Mode: Daily: 1, weekly: 2, monthly: 3, yearly: 4, workday: 5, weekend: 6\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V14 Update 1\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 16.11.2015  Siemens Industry Online Support\n\t  //                      Fix in mode 2\n\t  // 01.01.00 23.05.2016  Siemens Industry Online Support\n\t  //                      New mode 5 + 6\n\t  //                      New output: actLocalTime\n\t  // 01.01.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V14 Update 1\n\t  // 01.01.02 14.09.2018  Siemens Industry Online Support\n\t  //                      Fix in modes 1, 3, 5, 6                    \n\t  // 01.01.03 17.09.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.01.04 10.10.2018  Siemens Industry Online Support\n\t  //                      Connection to type restored\n\t  // 01.01.05 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.01.10 13.11.2019  Simatic Systems Support\n\t  //                      Magic numbers removed, tag naming added, code reworked\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 19.01.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  // 03.01.00 03.06.2022  Simatic Systems Support\n\t  //                      Insert mode `permanently On`: `10`, `permanently Off`: `0`\n\t  //=============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION\n\t  // Time ON init\n\t  #tempOnTimeDtl.HOUR := #onHour;\n\t  #tempOnTimeDtl.MINUTE := #onMinute;\n\t  #tempOnTimeDtl.SECOND := #ZERO;\n\t  #tempOnTimeDtl.NANOSECOND := #ZERO;\n\t  // Time OFF init\n\t  #tempOffTimeDtl.HOUR := #offHour;\n\t  #tempOffTimeDtl.MINUTE := #offMinute;\n\t  #tempOffTimeDtl.SECOND := #ZERO;\n\t  #tempOffTimeDtl.NANOSECOND := #ZERO;\n\tEND_REGION\n\t\n\tREGION READ LOCAL TIME\n\t  #tempReadTimeStatus := INT_TO_WORD(RD_LOC_T(#tempTime));\n\t  \n\t  // check result for error --> 16#8000 / MSB .X15\n\t  IF #tempReadTimeStatus.%X15 THEN\n\t    #error := TRUE;\n\t    #status := #ERR_RD_LOC_T;\n\t    #subFunctionStatus := #tempReadTimeStatus;\n\t    #actLocalTime := #CLEAR_DTL;\n\t    #signal := FALSE;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Store time of the current day\n\t  #tempActTimeDtl := #tempTime;\n\t  #tempActTimeTod := DTL_TO_TOD(#tempTime);\n\tEND_REGION\n\t\n\tREGION TIMER SWITCH LOGIC\n\t  CASE #mode OF\n\t    #MODE_DAILY:\n\t      REGION DAILY MODE\n\t        #tempOnTimeDtl.YEAR := #tempActTimeDtl.YEAR;\n\t        #tempOnTimeDtl.MONTH := #tempActTimeDtl.MONTH;\n\t        #tempOnTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;\n\t        #tempOnTimeDtl.DAY := #tempActTimeDtl.DAY;\n\t        // Store time of the on day\n\t        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);\n\t        \n\t        #tempOffTimeDtl.YEAR := #tempActTimeDtl.YEAR;\n\t        #tempOffTimeDtl.MONTH := #tempActTimeDtl.MONTH;\n\t        #tempOffTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;\n\t        #tempOffTimeDtl.DAY := #tempActTimeDtl.DAY;\n\t        // Store time of the off day\n\t        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);\n\t        \n\t        // Timer setting - overnight\n\t        IF #tempOnTimeTod > #tempOffTimeTod THEN\n\t          // Increase the day of the timeOff when midnight happens\n\t          IF #tempActTimeTod > #tempOffTimeTod THEN\n\t            #tempOffTimeDtl := #tempOffTimeDtl + #DAY_INCREMENT;\n\t          ELSE\n\t            // Decrease the day of the timeOn when midnight happens\n\t            // Activate signal from the midnight\n\t            #tempOnTimeDtl := #tempOnTimeDtl - #DAY_INCREMENT;\n\t          END_IF;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    #MODE_WEEKLY:\n\t      REGION WEEKLY MODE\n\t        // Set the default date\n\t        #tempOnTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempOnTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempOnTimeDtl.DAY := #onWeekday;  // Synchronize DTL.WEEKDAY with date\n\t        \n\t        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);\n\t        \n\t        #tempOffTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempOffTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempOffTimeDtl.DAY := #offWeekday;\n\t        \n\t        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);\n\t        \n\t        #tempActTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempActTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempActTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;\n\t        \n\t        IF #onWeekday > #offWeekday OR\n\t          (#onWeekday = #offWeekday AND #tempOnTimeTod > #tempOffTimeTod) THEN\n\t          #tempOffTimeDtl.DAY := #offWeekday + #DAYS_PER_WEEK;\n\t          \n\t          IF #onWeekday > #tempActTimeDtl.WEEKDAY OR\n\t            (#onWeekday = #offWeekday AND #tempActTimeTod < #tempOffTimeTod) THEN\n\t            #tempActTimeDtl.DAY := #tempActTimeDtl.WEEKDAY + #DAYS_PER_WEEK;\n\t          END_IF;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    #MODE_MONTHLY:\n\t      REGION MONTHLY MODE\n\t        #tempOnTimeDtl.YEAR := #tempActTimeDtl.YEAR;\n\t        #tempOnTimeDtl.MONTH := #tempActTimeDtl.MONTH;\n\t        #tempOnTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;\n\t        #tempOnTimeDtl.DAY := #onDay;\n\t        \n\t        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);\n\t        \n\t        #tempOffTimeDtl.YEAR := #tempActTimeDtl.YEAR;\n\t        #tempOffTimeDtl.MONTH := #tempActTimeDtl.MONTH;\n\t        #tempOffTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;\n\t        #tempOffTimeDtl.DAY := #offDay;\n\t        \n\t        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);\n\t        \n\t        // Timer setting - over new year\n\t        IF #onDay > #offDay OR\n\t          (#onDay = #offDay AND #tempOnTimeTod > #tempOffTimeTod) THEN\n\t          IF #tempActTimeDtl.DAY > #offDay OR\n\t            (#tempActTimeDtl.DAY = #offDay AND #tempActTimeTod > #tempOffTimeTod) THEN\n\t            // Increase the month of the timeOff over new year\n\t            IF #tempOffTimeDtl.MONTH = #MONTH_DECEMBER THEN\n\t              #tempOffTimeDtl.MONTH := #MONTH_JANUARY;\n\t              #tempOffTimeDtl.YEAR := #tempOffTimeDtl.YEAR + #DATE_INCREMENT;\n\t            ELSE\n\t              #tempOffTimeDtl.MONTH := #tempOffTimeDtl.MONTH + #DATE_INCREMENT;\n\t            END_IF;\n\t          ELSE\n\t            // Decrease the month of the timeOn over new year\n\t            IF #tempOnTimeDtl.MONTH = #MONTH_JANUARY THEN\n\t              #tempOnTimeDtl.MONTH := #MONTH_DECEMBER;\n\t              #tempOnTimeDtl.YEAR := #tempOnTimeDtl.YEAR - #DATE_INCREMENT;\n\t            ELSE\n\t              #tempOnTimeDtl.MONTH := #tempOnTimeDtl.MONTH - #DATE_INCREMENT;\n\t            END_IF;\n\t            \n\t          END_IF;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    #MODE_YEARLY:\n\t      REGION YEARLY MODE\n\t        #tempOnTimeDtl.YEAR := #tempActTimeDtl.YEAR;\n\t        #tempOnTimeDtl.MONTH := #onMonth;\n\t        #tempOnTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;\n\t        #tempOnTimeDtl.DAY := #onDay;\n\t        \n\t        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);\n\t        \n\t        #tempOffTimeDtl.YEAR := #tempActTimeDtl.YEAR;\n\t        #tempOffTimeDtl.MONTH := #offMonth;\n\t        #tempOffTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;\n\t        #tempOffTimeDtl.DAY := #offDay;\n\t        \n\t        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);\n\t        \n\t        // Timer setting - over new year\n\t        IF #onMonth > #offMonth OR\n\t          (#onMonth = #offMonth AND #tempOnTimeTod > #tempOffTimeTod) THEN\n\t          IF #tempActTimeDtl.MONTH > #offMonth OR\n\t            (#tempActTimeDtl.MONTH = #offMonth AND #tempActTimeTod > #tempOffTimeTod) THEN\n\t            // Increase the year of the timeOff when new year happens\n\t            #tempOffTimeDtl.YEAR := #tempOffTimeDtl.YEAR + #DATE_INCREMENT;\n\t          ELSE\n\t            // Decrease the year of the timeOn when new year happens\n\t            #tempOnTimeDtl.YEAR := #tempOnTimeDtl.YEAR - #DATE_INCREMENT;\n\t          END_IF;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    #MODE_WEEK_DAYS:  // Working days (Monday - Friday)\n\t      REGION WEEK DAYS MODE  \n\t        #tempOnTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempOnTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempOnTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;\n\t        \n\t        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);\n\t        \n\t        #tempOffTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempOffTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempOffTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;\n\t        \n\t        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);\n\t        \n\t        #tempActTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempActTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempActTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;\n\t        \n\t        // Timer setting - overnight\n\t        IF #tempOnTimeTod > #tempOffTimeTod THEN\n\t          IF #tempActTimeTod > #tempOffTimeTod THEN\n\t            #tempOffTimeDtl := #tempOffTimeDtl + #DAY_INCREMENT;\n\t          ELSE\n\t            #tempOnTimeDtl := #tempOnTimeDtl - #DAY_INCREMENT;\n\t          END_IF;\n\t        END_IF;\n\t        \n\t        IF #tempOnTimeDtl.DAY <= #DAY_MONDAY THEN\n\t          #tempOnTimeDtl.DAY := #DAY_MONDAY;\n\t        ELSIF #tempOnTimeDtl.DAY > #DAY_FRIDAY THEN\n\t          #tempOnTimeDtl.DAY := #DAY_FRIDAY;\n\t        END_IF;\n\t        \n\t        IF #tempOffTimeDtl.DAY > #DAY_FRIDAY AND\n\t          #tempOnTimeTod > #tempOffTimeTod THEN // #tempOffTime > Friday AND crossed midnight\n\t          #tempOffTimeDtl.DAY := #DAY_SATURDAY;\n\t        ELSIF #tempOffTimeDtl.DAY > #DAY_FRIDAY THEN\n\t          #tempOffTimeDtl.DAY := #DAY_FRIDAY;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    #MODE_WEEKEND_DAYS:  // Weekend (Saturday and Sunday)    \n\t      REGION WEEKEND DAYS MODE\n\t        #tempOnTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempOnTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempOnTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;\n\t        \n\t        IF #tempOnTimeDtl.DAY < #DAY_SATURDAY THEN\n\t          #tempOnTimeDtl := #tempOnTimeDtl + #WEEK_INCREMENT;\n\t        END_IF;\n\t        \n\t        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);\n\t        \n\t        #tempOffTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempOffTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempOffTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;\n\t        \n\t        IF #tempOffTimeDtl.DAY < #DAY_SATURDAY THEN\n\t          #tempOffTimeDtl := #tempOffTimeDtl + #WEEK_INCREMENT;\n\t        END_IF;\n\t        \n\t        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);\n\t        \n\t        #tempActTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempActTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempActTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;\n\t        \n\t        IF #tempActTimeDtl.DAY < #DAY_SATURDAY THEN\n\t          #tempActTimeDtl := #tempActTimeDtl + #WEEK_INCREMENT;\n\t        END_IF;\n\t        \n\t        #tempActTimeTod := DTL_TO_TOD(#tempTime);\n\t        \n\t        // Timer setting - overnight\n\t        IF #tempOnTimeTod > #tempOffTimeTod THEN\n\t          IF #tempActTimeTod > #tempOffTimeTod THEN\n\t            #tempOffTimeDtl := #tempOffTimeDtl + #DAY_INCREMENT;\n\t          ELSE\n\t            #tempOnTimeDtl := #tempOnTimeDtl - #DAY_INCREMENT;\n\t          END_IF;\n\t        END_IF;\n\t        \n\t        IF #tempOnTimeDtl.DAY < #DAY_SATURDAY THEN\n\t          #tempOnTimeDtl.DAY := #DAY_SATURDAY;\n\t        ELSIF #tempOnTimeDtl.DAY > #DAY_NEXT_SUNDAY THEN\n\t          #tempOnTimeDtl.DAY := #DAY_NEXT_SUNDAY;\n\t        END_IF;\n\t        \n\t        IF #tempOffTimeDtl.DAY > #DAY_NEXT_SUNDAY AND\n\t          #tempOnTimeTod > #tempOffTimeTod THEN // #tempOffTime.DAY > Sunday AND crossed midnight\n\t          #tempOffTimeDtl.DAY := #DAY_NEXT_MONDAY;\n\t        ELSIF #tempOffTimeDtl.DAY > #DAY_NEXT_SUNDAY THEN\n\t          #tempOffTimeDtl.DAY := #DAY_NEXT_SUNDAY;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    #MODE_PERMANENTLY_ON:\n\t      REGION PERMANENTLY ON\n\t        ;\n\t      END_REGION\n\t      \n\t    #MODE_PERMANENTLY_OFF:\n\t      REGION PERMANENTLY ON\n\t        ;\n\t      END_REGION\n\t      \n\t    ELSE\n\t      #signal := FALSE;\n\t      #actLocalTime := #CLEAR_DTL;\n\t      #error := TRUE;\n\t      #status := #ERR_NO_MODE_SELECTED;\n\t      #subFunctionStatus := USINT_TO_WORD(#mode);\n\t      RETURN;\n\t  END_CASE;\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  #actLocalTime := #tempTime;\n\t  #signal := ((#tempActTimeDtl >= #tempOnTimeDtl) AND (#tempActTimeDtl < #tempOffTimeDtl) AND ((#mode <> #MODE_PERMANENTLY_OFF))) OR (#mode = #MODE_PERMANENTLY_ON);\n\t  \n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  #subFunctionStatus := #STATUS_NO_ERROR;\n\t  \n\t  // ENO is not used, forced to TRUE\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "BitCount", "description": "This block counts in a variable of type DWord how many bits are set (TRUE) and how many are not set (FALSE) and outputs the number at the outputs. Instead of DWord, Word and Byte can also be used by converting the past parameter with e.g. BYTE_TO_DWORD and connecting the corresponding bit length of the data type at the parameter “numberOfBits”. Byte=8, Word=16, DWord=32", "type": "FUNCTION", "name": "LGF_BitCount", "vars": [{"name": "value", "type": "DWord", "description": "Tag where the bit states has to be counted"}, {"name": "numberOfBits", "type": "USInt", "description": "Number of bits in input tag \"value\" (bit size of Datatype), in case of\nByte=8, Word=16, DWord=32"}, {"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "countBitsFalse", "type": "USInt", "description": "Number of bits are FALSE in input tag \"value\""}, {"name": "countBitsTrue", "type": "USInt", "description": "Number of bits are TRUE in input tag \"value\""}], "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit states has to be counted"}, {"name": "numberOfBits", "type": "USInt", "description": "Number of bits in input tag \"value\" (bit size of Datatype), in case of\nByte=8, Word=16, DWord=32"}], "output": [{"name": "countBitsFalse", "type": "USInt", "description": "Number of bits are FALSE in input tag \"value\""}, {"name": "countBitsTrue", "type": "USInt", "description": "Number of bits are TRUE in input tag \"value\""}], "in/out": [], "answer": "FUNCTION \"LGF_BitCount\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : SiemensSIMATICSystemsSupport\nFAMILY : LGF\nNAME : LGF_BitCount\n   VAR_INPUT \n      value : DWord;\n      numberOfBits : USInt;\n   END_VAR\n\n   VAR_OUTPUT \n      countBitsFalse : USInt;\n      countBitsTrue : USInt;\n   END_VAR\n\n   VAR_TEMP \n      tempBinaryValues : DWord;\n      tempLoopIndex : DInt;\n      tempCountBitsTrue : USInt;\n      tempCountBitsFalse : USInt;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : USInt := 0;\n      INCREMENT : USInt := 1;\n      SHIFT_ON_BIT_RIGHT : USInt := 1;\n      START_INDEX : DInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_BitCount\n\t  // Comment/Function: Count bits in elementary datatype - DWord\n\t  //                   count the set (TRUE) and not set (FALSE) bits in a binary datatype \n\t  //                   can be used for Word and Byte as well, by convert\n\t  //                   the past paramter and the result using for e.g. Dword_to_Byte\n\t  //                   \"numberOfBits\" number of bits in input tag \"value\",\n\t  //                   in case of Byte=8, Word=16, Dword=32\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO not in use, set to true, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge         | Changes applied\n\t  // 01.00.00 | 06.06.2015 | Siemens Industry Support | first release\n\t  // 03.00.00 | 23.04.2020 | Siemens Industry Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.02 | 19.01.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Logic\n\t  // init counter tags\n\t  #tempCountBitsFalse := #ZERO;\n\t  #tempCountBitsTrue := #ZERO;\n\t  #tempBinaryValues := #value;\n\t  \n\t  // iterate over input tag\n\t  FOR #tempLoopIndex := #START_INDEX TO USINT_TO_DINT(#numberOfBits) DO\n\t    // check if bit is true or false\n\t    IF #tempBinaryValues.%X0 THEN\n\t      #tempCountBitsTrue += #INCREMENT;\n\t    ELSE\n\t      #tempCountBitsFalse += #INCREMENT;\n\t    END_IF;\n\t    \n\t    // shift input tag one to the right\n\t    #tempBinaryValues := SHR(IN := #tempBinaryValues, N := #SHIFT_ON_BIT_RIGHT);\n\t  END_FOR;\n\t  \n\t  // set output values\n\t  #countBitsFalse := #tempCountBitsFalse;\n\t  #countBitsTrue := #tempCountBitsTrue;\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "CountArrayElements", "description": "Count the number of array elements and returns the number of elements zero based (Array[0..x] of Type).", "type": "FUNCTION", "name": "LGF_CountArrayElements", "vars": [{"name": "array", "type": "Variant", "description": "Input array to check for number of elements"}, {"name": "Ret_Val", "type": "DInt", "description": "Number of elements in array (zero based);Returning `-1` if input variable is not type `array`;Returning `-2` if input variable is type `bool`;"}], "input": [{"name": "array", "type": "Variant", "description": "Input array to check for number of elements"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_CountArrayElements\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Industry Support'\nFAMILY : LGF\nNAME : LGF_CountArrayElements\n   VAR_INPUT \n      \"array\" : Variant;\n   END_VAR\n\n   VAR_TEMP \n      tempBufferSize : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      RETURN_NO_ARRAY : DInt := -1;\n      RETURN_NO_BOOL_ARRAYS_NOT_SUPPORTED : DInt := -2;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS / (c)Copyright 2021\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CountArrayElements\n\t  // Function:         Count the number of array elements and returns the number of elements zero based (Array[0..x] of Type).\n\t  // Library:          LGF(Library General Functions)\n\t  // Author:           Siemens Industry Support\n\t  // Tested with:      CPU 1516-3 PN/DP\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     --\n\t  // Requirements:     S7-1200/1500\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge         | Changes applied\n\t  //----------|------------|--------------------------|----------------------------\n\t  // 01.00.00 | 10-06-2022 | Siemens Industry Support | First released version\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Process\n\t  // Check if the #input is an ARRAY.\n\t  // If so, the number of the ARRAY elements is read out.\n\t  // If it is NOT an ARRAY, an Error is thrown and the result is -1 / -2\n\t  IF IS_ARRAY(#array) AND TypeOfElements(#array) = Bool THEN\n\t    #tempBufferSize := #RETURN_NO_BOOL_ARRAYS_NOT_SUPPORTED;\n\t  ELSIF NOT IS_ARRAY(#array) THEN\n\t    #tempBufferSize := #RETURN_NO_ARRAY;\n\t  ELSE\n\t    #tempBufferSize := UDINT_TO_DINT(CountOfElements(#array));\n\t  END_IF;\n\tEND_REGION Process\n\t\n\tREGION Writing to outputs\n\t  #LGF_CountArrayElements := #tempBufferSize;\n\t  // no error handling by ENO needed\n\t  ENO := true;\n\tEND_REGION Writing to outputs\n\t\nEND_FUNCTION", "return_value": [{"type": "DInt"}]}
{"title": "CountBooleanEdges", "description": "This function evaluates a input signal for different states in a certain amount of time. The states are: • One edge and input present over the whole monitoring time • Single edge • Double edge • N-Edges in between the monitoring time The Output signal is present for at least on cycle after the monitoring time has expired, or as long as the input trigger remains TRUE.", "type": "FUNCTION_BLOCK", "name": "LGF_CountBooleanEdges", "vars": [{"name": "trigger", "type": "Bool", "description": "Trigger to evaluate signal signal (rising edges)"}, {"name": "monitorTime", "type": "Time", "description": "Time to monitor fand count edges on `trigger` input"}, {"name": "single", "type": "Bool", "description": "Single edge until monitoring time expires"}, {"name": "double", "type": "Bool", "description": "Two edges in between the monitoring time"}, {"name": "long", "type": "Bool", "description": "Just a single edge in the monitoring time, the `trigger` input stays\nTRUE after the edge appears"}, {"name": "severalEdges", "type": "Bool", "description": "Numeros Edges occure within the monitoring time, see `noOfEdges`\nto get the number of edges"}, {"name": "noOfEdges", "type": "USInt", "description": "Number of edges in between the monitoring time frame"}], "input": [{"name": "trigger", "type": "Bool", "description": "Trigger to evaluate signal signal (rising edges)"}, {"name": "monitorTime", "type": "Time", "description": "Time to monitor fand count edges on `trigger` input"}], "output": [{"name": "single", "type": "Bool", "description": "Single edge until monitoring time expires"}, {"name": "double", "type": "Bool", "description": "Two edges in between the monitoring time"}, {"name": "long", "type": "Bool", "description": "Just a single edge in the monitoring time, the `trigger` input stays\nTRUE after the edge appears"}, {"name": "severalEdges", "type": "Bool", "description": "Numeros Edges occure within the monitoring time, see `noOfEdges`\nto get the number of edges"}, {"name": "noOfEdges", "type": "USInt", "description": "Number of edges in between the monitoring time frame"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_CountBooleanEdges\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Simatic_Systems_Support\nFAMILY : LGF\nNAME : LGF_CountBooleanEdges\n   VAR_INPUT \n      trigger : Bool;\n      monitorTime : Time := T#1s;\n   END_VAR\n\n   VAR_OUTPUT \n      single { ExternalWritable := 'False'} : Bool;\n      double { ExternalWritable := 'False'} : Bool;\n      long { ExternalWritable := 'False'} : Bool;\n      severalEdges { ExternalWritable := 'False'} : Bool;\n      noOfEdges { ExternalWritable := 'False'} : USInt;\n   END_VAR\n\n   VAR \n      instTimer {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;\n      statTriggerPrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statTimeElapsedFlag { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statTriggerCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;\n   END_VAR\n\n   VAR_TEMP \n      tempTriggerEdge : Bool;\n      tempSingle : Bool;\n      tempDouble : Bool;\n      tempLong : Bool;\n      tempSeveralEdges : Bool;\n      tempNoOfEdges : USInt;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS / (c)Copyright (2021)\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CountBooleanEdges\n\t  // Comment/Function: This function evaluates a input signal for diffrent states in a certain amount of time.\n\t  //                   The states are:\n\t  //                   * One edge and input present over thw whole monitoring time\n\t  //                   * Single edge\n\t  //                   * Double edge\n\t  //                   * N-Edges in between the monitoring time\n\t  //                   The Output signal is present for at least on cycle after the monitoring time hase expired, or as long as the input `trigger` remains `TRUE`\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Simatic Systems Support\n\t  // Tested with:      1516F FW2.8 / S7-PLCSIM Advanced V3.0\n\t  // Engineering:      TIA Portal V16 Update 4\n\t  // Restrictions:     ENO not in use, set to true, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  //----------|------------|-------------------------|------------------------------\n\t  // 01.00.00 | 19.01.2021 | Simatic Systems Support | First released version\n\t  //===============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t(/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION  \n\t  // Initialize functionality\n\t  // Edge detection\n\t  #tempTriggerEdge := #trigger AND NOT #statTriggerPrevious;\n\t  #statTriggerPrevious := #trigger;\n\tEND_REGION INITIALISATION  \n\t\n\tREGION PROGRAM LOGIC\n\t  // Trigger edge dedected\n\t  // Start the monitoring time and/or just increment edge counter\n\t  IF #tempTriggerEdge THEN\n\t    // Call timer\n\t    #instTimer.TP(IN := TRUE,\n\t                  PT := #monitorTime);\n\t    \n\t    // Each edge increments the counter\n\t    #statTriggerCounter += 1;\n\t  END_IF;\n\t  \n\t  // Monitoring time ist elapsed / over and we dedected at least on edge\n\t  IF NOT #instTimer.Q THEN\n\t    // Reset contition if trigger is reseted\n\t    //And time elapsed flag is true\n\t    IF NOT #trigger AND #statTimeElapsedFlag THEN\n\t      // If no action is required, reset Outputs\n\t      #tempLong :=\n\t      #tempSingle :=\n\t      #tempDouble :=\n\t      #tempSeveralEdges := FALSE;\n\t      // Reset edge counters\n\t      #tempNoOfEdges :=\n\t      #statTriggerCounter := 0;\n\t      #statTimeElapsedFlag := FALSE;\n\t      // Reset timer\n\t      #instTimer.TP(IN := FALSE,\n\t                    PT := #monitorTime);\n\t      \n\t    ELSIF (#statTriggerCounter <> 0) THEN\n\t      IF #trigger AND #statTriggerCounter = 1 THEN\n\t        #tempLong := TRUE;\n\t      ELSIF #statTriggerCounter = 1 THEN\n\t        #tempSingle := TRUE;\n\t      ELSIF #statTriggerCounter = 2 THEN\n\t        #tempDouble := TRUE;\n\t      ELSE\n\t        #tempSeveralEdges := TRUE;\n\t      END_IF;\n\t      #tempNoOfEdges := #statTriggerCounter;\n\t      #statTimeElapsedFlag := TRUE;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION PROGRAM LOGIC\n\t\n\tREGION OUTPUTS\n\t  // Write application specific temp values to outputs\n\t  #single := #tempSingle;\n\t  #double := #tempDouble;\n\t  #long := #tempLong;\n\t  #severalEdges := #tempSeveralEdges;\n\t  #noOfEdges := #tempNoOfEdges;\n\t  \n\t  // ENO is not used, forced to TRUE\n\t  ENO := TRUE;\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "GetBitStates", "description": "This function checks a DWord for falling as well as rising edges. It returns the number of edges, a DWord with the edge bits, and a boolean value if edge(s) are present.", "type": "FUNCTION_BLOCK", "name": "LGF_GetBitStates", "vars": [{"name": "value", "type": "DWord", "description": "Check input value for changes and edges"}, {"name": "hasChanged", "type": "Bool", "description": "Input value has changed (compared to the previous cycle)"}, {"name": "hasRisingEdges", "type": "Bool", "description": "Input value has rising edges"}, {"name": "risingBits", "type": "DWord", "description": "Bitstream with the rising edges"}, {"name": "noOfRisingBits", "type": "USInt", "description": "Number of rising edges in the input value"}, {"name": "hasFallingEdges", "type": "Bool", "description": "Input value has falling edges"}, {"name": "fallingBits", "type": "DWord", "description": "Bitstream with the falling edges"}, {"name": "noOfFallingBits", "type": "USInt", "description": "Number of falling edges in the input value"}], "input": [{"name": "value", "type": "DWord", "description": "Check input value for changes and edges"}], "output": [{"name": "hasChanged", "type": "Bool", "description": "Input value has changed (compared to the previous cycle)"}, {"name": "hasRisingEdges", "type": "Bool", "description": "Input value has rising edges"}, {"name": "risingBits", "type": "DWord", "description": "Bitstream with the rising edges"}, {"name": "noOfRisingBits", "type": "USInt", "description": "Number of rising edges in the input value"}, {"name": "hasFallingEdges", "type": "Bool", "description": "Input value has falling edges"}, {"name": "fallingBits", "type": "DWord", "description": "Bitstream with the falling edges"}, {"name": "noOfFallingBits", "type": "USInt", "description": "Number of falling edges in the input value"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_GetBitStates\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Simatic_Systems_Support\nFAMILY : LGF\nNAME : LGF_CountBitStates\n   VAR_INPUT \n      value : DWord;\n   END_VAR\n\n   VAR_OUTPUT \n      hasChanged { ExternalWritable := 'False'} : Bool;\n      hasRisingEdges { ExternalWritable := 'False'} : Bool;\n      risingBits { ExternalWritable := 'False'} : DWord;\n      noOfRisingBits { ExternalWritable := 'False'} : USInt;\n      hasFallingEdges { ExternalWritable := 'False'} : Bool;\n      fallingBits { ExternalWritable := 'False'} : DWord;\n      noOfFallingBits { ExternalWritable := 'False'} : USInt;\n   END_VAR\n\n   VAR \n      statPreviousValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;\n   END_VAR\n\n   VAR_TEMP \n      tempRisingResult : DWord;\n      tempNoRisingBits : DWord;\n      tempFallingResult : DWord;\n      tempNoFallingBits : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_EDGES : DWord;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_GetBitStates\n\t  // Comment/Function: Check DWord for edges, falling as well as rising.  \n\t  //                   Returns the number of edges, DWords with edge bits and a bool if edge(s) exists.\n\t  //                   https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Simatic Systems Support\n\t  // Tested with:      1516F FW2.8 / S7-PLCSIM Advanced V3.0\n\t  // Engineering:      TIA Portal V16 Update 4\n\t  // Restrictions:     ENO not in use, set to true, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  //----------|------------|-------------------------|------------------------------\n\t  // 01.00.00 | 2021.01.28 | Simatic Systems Support | First released version\n\t  //=============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t(/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION PROGRAM LOGIC\n\t  // Get edges from input DWord and DWord from previous cycle\n\t  #tempRisingResult := #value AND NOT #statPreviousValue;\n\t  #tempFallingResult := NOT #value AND #statPreviousValue;\n\t  \n\t  // Store value for next cycle\n\t  #statPreviousValue := #value;\n\t  \n\t  // Copy edge result into work variable for counting the number of rising edges\n\t  #tempNoRisingBits := #tempRisingResult;\n\t  // Count number of rising edges, algorythm descriped from: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n\t  #tempNoRisingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoRisingBits) - DWORD_TO_UDINT(SHR(IN := #tempNoRisingBits, N := 1) AND 16#55555555));\n\t  #tempNoRisingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoRisingBits & 16#33333333) + DWORD_TO_UDINT(SHR(IN := #tempNoRisingBits, N := 2) AND 16#33333333));\n\t  #tempNoRisingBits := SHR(IN := UDINT_TO_DWORD(DWORD_TO_UDINT(UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoRisingBits) + DWORD_TO_UDINT(SHR(IN := #tempNoRisingBits, N := 4))) AND 16#0F0F0F0F) * DWORD_TO_UDINT(16#01010101)), N := 24);\n\t  \n\t  // Copy edges result into work variable for counting the number of falling edges\n\t  #tempNoFallingBits := #tempFallingResult;\n\t  // Count number of falling edges, algorythm descriped from: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n\t  #tempNoFallingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoFallingBits) - DWORD_TO_UDINT(SHR(IN := #tempNoFallingBits, N := 1) AND 16#55555555));\n\t  #tempNoFallingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoFallingBits & 16#33333333) + DWORD_TO_UDINT(SHR(IN := #tempNoFallingBits, N := 2) AND 16#33333333));\n\t  #tempNoFallingBits := SHR(IN := UDINT_TO_DWORD(DWORD_TO_UDINT(UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoFallingBits) + DWORD_TO_UDINT(SHR(IN := #tempNoFallingBits, N := 4))) AND 16#0F0F0F0F) * DWORD_TO_UDINT(16#01010101)), N := 24);\n\tEND_REGION PROGRAM LOGIC\n\t\n\tREGION OUTPUTS\n\t  #hasChanged := (#tempRisingResult > #ZERO_EDGES) OR (#tempFallingResult > #ZERO_EDGES);\n\t  #hasRisingEdges := #tempRisingResult > #ZERO_EDGES;\n\t  #risingBits := #tempRisingResult;\n\t  #noOfRisingBits := DWORD_TO_USINT(#tempNoRisingBits);\n\t  \n\t  #hasFallingEdges := #tempFallingResult > #ZERO_EDGES;\n\t  #fallingBits := #tempFallingResult;\n\t  #noOfFallingBits := DWORD_TO_USINT(#tempNoFallingBits);\n\t  \n\t  // ENO not needed, no error evaluation needed\n\t  ENO := FALSE;\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "BinaryMaskCompare", "description": "This function compares two binary Values source and compare by a given mask. Both given values are masked (input AND mask), and the results is than compared and returned. Can be used for Word and Byte as well, by convert the passed parameter using for e.g. Byte_to_DWord(...).", "type": "FUNCTION", "name": "LGF_BinaryMaskCompare", "vars": [{"name": "source", "type": "DWord", "description": "Source value to compare"}, {"name": "compare", "type": "DWord", "description": "Value to compare against"}, {"name": "mask", "type": "DWord", "description": "Mask the data - bits will pass if TRUE or block if FALSE"}, {"name": "Ret_Val", "type": "Bool", "description": "Return TRUE if masked values are equal"}], "input": [{"name": "source", "type": "DWord", "description": "Source value to compare"}, {"name": "compare", "type": "DWord", "description": "Value to compare against"}, {"name": "mask", "type": "DWord", "description": "Mask the data - bits will pass if TRUE or block if FALSE"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_BinaryMaskCompare\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Simatic_Systems_Support\nFAMILY : LGF\nNAME : LGF_BinaryMaskCompare\n   VAR_INPUT \n      source : DWord;\n      compare : DWord;\n      mask { S7_PredefinedAssignment := '16#FFFFFFFF'; S7_HiddenAssignment := 'Show'; S7_ShowAssignmentIfParamsNotIdentical := 'false'} : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      ALL_BITS_ARE_FALSE : DWord := 16#00000000;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_BinaryMaskCompare\n\t  // Comment/Function: Comparing two binary Values `source` and `compare` by a given `mask`.  \n\t  //                   Both given values are masked, and the results is than compared and returned\n\t  //                   Can be used for Word and Byte as well, by convert the passed parameter using for e.g. Byte_to_DWord(...)\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Simatic Systems Support\n\t  // Tested with:      1516F FW2.8 / S7-PLCSIM Advanced V3.0\n\t  // Engineering:      TIA Portal V16 Update 4\n\t  // Restrictions:     ENO not in use, set to true, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  // 01.00.00 | 19.01.2021 | Simatic Systems Support | First released version\n\t  //===============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\t//Mask Compare Equal DWord\n\t#LGF_BinaryMaskCompare := (((#source AND #mask) XOR (#compare AND #mask)) = #ALL_BITS_ARE_FALSE);\n\t\n\t// ENO is not used, forced to TRUE\n\tENO := TRUE;\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "CompareLReal", "description": "This function checks floating point numbers for equality, by using an approximation formula and a fixed precision by constant 1.0E-12 (pico)", "type": "FUNCTION", "name": "LGF_CompareLReal", "vars": [{"name": "valueA", "type": "LReal", "description": "First LREAL number to be compared."}, {"name": "valueB", "type": "LReal", "description": "Second LREAL number to be compared."}, {"name": "Ret_Val", "type": "Bool", "description": "FALSE: not equalTRUE: approximately the same"}], "input": [{"name": "valueA", "type": "LReal", "description": "First LREAL number to be compared."}, {"name": "valueB", "type": "LReal", "description": "Second LREAL number to be compared."}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_CompareLReal\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_CompareLReal\n   VAR_INPUT \n      valueA : LReal;\n      valueB : LReal;\n   END_VAR\n\n   VAR CONSTANT \n      PRECISION : LReal := 1.0E-12;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CompareLReal\n\t  // Comment/Function: This function checks floating point numbers for equality\n\t  //                   Using fixed precision by constant 1.0E-12\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO is not used, forced to TRUE, no error handling needed\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  // 01.00.00 13.01.2017  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.03 03.06.2019  Simatic Systems Support\n\t  //                      Refactoring and performance improvment\n\t  //                      Delete Error and Status there is no need for,\n\t  //                      because of changed / adjusted algorithm\n\t  //                      add eno handling\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 19.01.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  // 03.00.02 21.12.2023  Simatic Systems Support\n\t  //                      Fix compare error if one value is exactly zero\n\t  //===============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Approximation\n\t  // the compare of fLoating point numbers is based on a precison 1.0E-12\n\t  // difference of the input values A and B has to be smaller than\n\t  // the precision multiplied with one of the two given inputs\n\t  #LGF_CompareLReal := FALSE\n\t  OR ((#valueA = 0.0) AND (ABS(#valueB) <= #PRECISION))\n\t  OR ((#valueB = 0.0) AND (ABS(#valueA) <= #PRECISION))\n\t  OR (ABS(#valueA - #valueB) <= (#PRECISION * ABS(#valueA)));\n\t  \n\t  // ENO is not used, forced to TRUE, no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "CompareLRealByPrecision", "description": "This function checks floating point numbers for equality, by using an approximation formula and a fixed precision by constant 1.0E-12 (pico)", "type": "FUNCTION", "name": "LGF_CompareLRealByPrecision", "vars": [{"name": "valueA", "type": "LReal", "description": "First LREAL number to be compared."}, {"name": "valueB", "type": "LReal", "description": "Second LREAL number to be compared."}, {"name": "precision", "type": "LReal", "description": "Accuracy with which the two values are compared."}, {"name": "Ret_Val", "type": "Bool", "description": "FALSE: not equalTRUE: approximately the same"}], "input": [{"name": "valueA", "type": "LReal", "description": "First LREAL number to be compared."}, {"name": "valueB", "type": "LReal", "description": "Second LREAL number to be compared."}, {"name": "precision", "type": "LReal", "description": "Accuracy with which the two values are compared."}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_CompareLRealByPrecision\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_CompareLRealByPrecision\n   VAR_INPUT \n      valueA : LReal;\n      valueB : LReal;\n      precision : LReal;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CompareLRealByPrecision\n\t  // Comment/Function: This function checks floating point numbers for equality\n\t  //                   Using a given precision by parameter\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO is not used, forced to TRUE, no error handling needed\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  // 01.00.00 03.06.2019  Simatic Systems Support\n\t  //                      First released version\n\t  //                      function besad on `LGF_CompareLReal`\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 19.01.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  // 03.00.02 21.12.2023  Simatic Systems Support\n\t  //                      Fix compare error if one value is exactly zero\n\t  //===============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Approximation\n\t  // the compare of fLoating point numbers is based on a given precison, for e.g. 1.0E-6\n\t  // difference of the input values A and B has to be smaller than\n\t  // the precision multiplied with one of the two given inputs\n\t  #LGF_CompareLRealByPrecision := FALSE\n\t  OR ((#valueA = 0.0) AND (ABS(#valueB) <= #precision))\n\t  OR ((#valueB = 0.0) AND (ABS(#valueA) <= #precision))\n\t  OR (ABS(#valueA - #valueB) <= (#precision * ABS(#valueA)));\n\t  \n\t  // ENO is not used, forced to TRUE, no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "CompareString", "description": "Compares two strings and returns a number which indicates the result of the comparison.", "type": "FUNCTION", "name": "LGF_CompareString", "vars": [{"name": "Ret_Val", "type": "SInt", "description": "Return values:left < right := -1;left > right := 1;left == right := 0;"}, {"name": "left", "type": "String", "description": "Left / first string to compare"}, {"name": "right", "type": "String", "description": "Right / second string to compare"}], "input": [], "output": [], "in/out": [{"name": "left", "type": "String", "description": "Left / first string to compare"}, {"name": "right", "type": "String", "description": "Right / second string to compare"}], "answer": "FUNCTION \"LGF_CompareString\" : SInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Industry Support'\nFAMILY : LGF\nNAME : LGF_CompareString\n   VAR_IN_OUT \n      left : String;\n      right : String;\n   END_VAR\n\n   VAR_TEMP \n      tempResult : SInt;\n   END_VAR\n\n   VAR CONSTANT \n      RETURN_STRINGS_ARE_EQUAL : SInt := 0;\n      RETURN_STRING_LEFT_LESS_THAN_RIGHT : SInt := -1;\n      RETURN_STRING_LEFT_GREATER_THAN_RIGHT : SInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS / (c)Copyright 2021\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CompareString\n\t  // Function:         Compares two strings and returns a number which indicates the result of the comparison.\n\t  // Library:          LGF(Library General Functions)\n\t  // Author:           Siemens Industry Support\n\t  // Tested with:      CPU 1516-3 PN/DP\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     --\n\t  // Requirements:     S7-1200/1500\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge         | Changes applied\n\t  //----------|------------|--------------------------|----------------------------\n\t  // 01.00.00 | 10-06-2022 | Siemens Industry Support | First released version\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Process\n\t  // Check left string less than the right string\n\t  IF #left < #right THEN\n\t    #tempResult := #RETURN_STRING_LEFT_LESS_THAN_RIGHT;\n\t    \n\t    // Check left string greater than the right string\n\t  ELSIF #left > #right THEN\n\t    #tempResult := #RETURN_STRING_LEFT_GREATER_THAN_RIGHT;\n\t    \n\t  ELSE // Strings are equal\n\t    #tempResult := #RETURN_STRINGS_ARE_EQUAL;\n\t  END_IF;\n\t  \n\t  // return the result\n\t  #LGF_CompareString := #tempResult;\n\t  ENO := FALSE;\n\tEND_REGION Process\n\t\nEND_FUNCTION", "return_value": [{"type": "SInt"}]}
{"title": "CompareVariant", "description": "The function compares two structured actual parameters (array, PLC data type) and outputs whether they are of the same type and have the same values. Compare arrays or plc datatypes and their values up to a max lengh of 200 Bytes of the connected variables. If at least one value of an element is not identical –> set function result = false Restrictions: The attached structure must not include Strings The attached structure can not exceed 200 bytes, because of the internal buffer size", "type": "FUNCTION", "name": "LGF_CompareVariant", "vars": [{"name": "Ret_Val", "type": "Bool", "description": "FALSE: Values of comparison variables or PLC data types aredifferent.TRUE: Values of the comparison variables are equal and PLC datatypes are identical."}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "variableA", "type": "Variant", "description": "First comparison variable with any data type"}, {"name": "variableB", "type": "Variant", "description": "Second comparison variable with any data type"}], "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "variableA", "type": "Variant", "description": "First comparison variable with any data type"}, {"name": "variableB", "type": "Variant", "description": "Second comparison variable with any data type"}], "answer": "FUNCTION \"LGF_CompareVariant\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_CompareVariant\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n      subFunctionStatus : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      variableA : Variant;\n      variableB : Variant;\n   END_VAR\n\n   VAR_TEMP \n      tempVariableASize : DInt;\n      tempVariableBSize : DInt;\n      tempindex : DInt;\n      tempVariableAToBytes : Array[0..#MAX_LENGTH] of Byte;\n      tempVariableBToBytes : Array[0..#MAX_LENGTH] of Byte;\n      tempSerializeRet : Word;\n   END_VAR\n\n   VAR CONSTANT \n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_INPUT_TYPES_MUST_MATCH : Word := 16#8201;\n      ERR_INPUT_TYPES_LENGTH_NOT_EQUAL : Word := 16#8202;\n      ERR_SERIALIZE_VARIABLE_A : Word := 16#8601;\n      ERR_SERIALIZE_VARIABLE_B : Word := 16#8602;\n      MAX_LENGTH : Int := 200;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CompareVariant\n\t  // Comment/Function: Compare arrays or plc datatypes and their values \n\t  //                   up to a max lengh of 200 Bytes of the connected variables.\n\t  //                   If at least one value of an element is not identical -->\n\t  //                   set function result = false\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     The attached structure must not include Strings\n\t  //                   The attached structure can not exceed 200 bytes,\n\t  //                   because of the internal buffer size\n\t  //                   --> extend: cut from type, adjust \"MAX_LENGHT\" constant\n\t  //                   ENO disabled - error handling done with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  // 01.00.00 03.09.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 11.02.2015  Siemens Industry Online Support\n\t  //                      Bug fix\n\t  // 01.00.02 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V14 Update 1\n\t  // 01.00.03 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.04 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.05 03.06.2019  Simatic Systems Support\n\t  //                      Refactoring and performance improvment\n\t  //                      Change error handling to status and subFctStatus\n\t  //                      update serialize instruction\n\t  //                      add eno handling\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 19.01.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //===============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialisation\n\t  // init temporary variables\n\t  #tempVariableASize := 0;\n\t  #tempVariableBSize := 0;\n\t  #tempindex := 0;\n\t  \n\t  // Set \"No current job\" #status\n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERROR;\n\t  #subFunctionStatus := #STATUS_NO_ERROR;\n\t  \n\t  // Initialisation of function result\n\t  #LGF_CompareVariant := FALSE;\n\tEND_REGION Initialisation\n\t\n\tREGION Processing\n\t  \n\t  REGION Check input types\n\t    // Check if the datatypes of the connected tags are identical\n\t    IF TypeOf(#variableA) <> TypeOf(#variableB) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_INPUT_TYPES_MUST_MATCH;\n\t      #subFunctionStatus := #STATUS_NO_ERROR;\n\t      // no error handling needed\n\t      ENO := TRUE;\n\t      RETURN; // Finish function if conversion fails\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION Serialize Input Variable A\n\t    // convert variableA Values to serialised binary array of byte\n\t    #tempSerializeRet := INT_TO_WORD(\n\t                                     Serialize(SRC_VARIABLE := #variableA,\n\t                                               DEST_ARRAY => #tempVariableAToBytes,\n\t                                               POS := #tempVariableASize)\n\t    );\n\t    \n\t    // Check return value of SERIALIZE\n\t    // if not zero - error happend, write error codes and end/leave function\n\t    IF #tempSerializeRet <> #STATUS_NO_ERROR THEN\n\t      #error := TRUE;\n\t      #status := #ERR_SERIALIZE_VARIABLE_A;\n\t      #subFunctionStatus := #tempSerializeRet;\n\t      // no error handling needed\n\t      ENO := TRUE;\n\t      RETURN; // Finish function if conversion fails\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION Serialize Input Variable A\n\t    // convert variableB Values to serialised binary array of byte\n\t    #tempSerializeRet := INT_TO_WORD(\n\t                                     Serialize(SRC_VARIABLE := #variableB,\n\t                                               DEST_ARRAY => #tempVariableBToBytes,\n\t                                               POS := #tempVariableBSize)\n\t    );\n\t    \n\t    // Check return value of SERIALIZE\n\t    // if not zero - error happend, write error codes and end/leave function\n\t    IF #tempSerializeRet <> #STATUS_NO_ERROR THEN\n\t      #error := TRUE;\n\t      #status := #ERR_SERIALIZE_VARIABLE_B;\n\t      #subFunctionStatus := #tempSerializeRet;\n\t      // no error handling needed\n\t      ENO := TRUE;\n\t      RETURN; // Finish function if conversion fails\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION Check if serialized sizes are equal\n\t    // Compare size of both variables\n\t    IF #tempVariableASize <> #tempVariableBSize THEN\n\t      #error := TRUE;\n\t      #status := #ERR_INPUT_TYPES_LENGTH_NOT_EQUAL;\n\t      #subFunctionStatus := DINT_TO_WORD(#tempVariableASize - #tempVariableBSize);\n\t      // no error handling needed\n\t      ENO := TRUE;\n\t      RETURN; // Finish function if conversion fails\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION Compare\n\t    // Compare values of temp. array elements of bytes\n\t    WHILE #tempindex < #tempVariableASize DO\n\t      \n\t      // Compare bytes till difference detected\n\t      IF #tempVariableAToBytes[#tempindex] = #tempVariableBToBytes[#tempindex] THEN\n\t        // if equal increment index\n\t        #tempindex += 1; // Or end of array reached\n\t      ELSE\n\t        // if values diffrent (content missmatch) --> exit loop\n\t        EXIT;\n\t      END_IF;\n\t    END_WHILE;\n\t    \n\t  END_REGION\n\tEND_REGION Processing\n\t\n\tREGION Output\n\t  // Assign function result - if index is equal to size = TRUE\n\t  #LGF_CompareVariant := (#tempindex = #tempVariableASize);\n\t  \n\t  // ENO is not used, forced to TRUE\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "CalcDistance", "description": "The function calculates the distance between two points in the plane.", "type": "FUNCTION", "name": "LGF_CalcDistance_2D", "vars": [{"name": "x1", "type": "LReal", "description": "X coordinate point 1"}, {"name": "y1", "type": "LReal", "description": "Y coordinate point 1"}, {"name": "x2", "type": "LReal", "description": "X coordinate point 2"}, {"name": "y2", "type": "LReal", "description": "Y coordinate point 2"}, {"name": "Ret_Val", "type": "LReal", "description": "Calculated distance between the Points"}], "input": [{"name": "x1", "type": "LReal", "description": "X coordinate point 1"}, {"name": "y1", "type": "LReal", "description": "Y coordinate point 1"}, {"name": "x2", "type": "LReal", "description": "X coordinate point 2"}, {"name": "y2", "type": "LReal", "description": "Y coordinate point 2"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_CalcDistance_2D\" : LReal\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_CalcDistance_2D\n   VAR_INPUT \n      x1 : LReal;\n      y1 : LReal;\n      x2 : LReal;\n      y2 : LReal;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Siemens AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_CalcDistance_2D\n\t  // Comment/Function: Calculates the distance between two points in 2D space\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - ENO mechanism is not used\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 06.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.02.00 04.10.2019  Simatic Systems Support\n\t  //                      renamed from \"Distance\" to \"CalcDistance_2D\"\n\t  //                      Data type changed to LREAL\n\t  //                      Data type changed to LREAL\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Program\n\t  // Calculating the distance\n\t  #LGF_CalcDistance_2D := SQRT(SQR(#x2 - #x1) + SQR(#y2 - #y1));\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "LReal"}]}
{"title": "CalcDistance", "description": "The function calculates the distance between two points in 3D space.", "type": "FUNCTION", "name": "LGF_CalcDistance_3D", "vars": [{"name": "x1", "type": "LReal", "description": "X coordinate point 1"}, {"name": "y1", "type": "LReal", "description": "Y coordinate point 1"}, {"name": "z1", "type": "LReal", "description": "Z coordinate point 1"}, {"name": "x2", "type": "LReal", "description": "X coordinate point 2"}, {"name": "y2", "type": "LReal", "description": "Y coordinate point 2"}, {"name": "z2", "type": "LReal", "description": "Z coordinate point 2"}, {"name": "Ret_Val", "type": "LReal", "description": "Calculated distance between the Points"}], "input": [{"name": "x1", "type": "LReal", "description": "X coordinate point 1"}, {"name": "y1", "type": "LReal", "description": "Y coordinate point 1"}, {"name": "z1", "type": "LReal", "description": "Z coordinate point 1"}, {"name": "x2", "type": "LReal", "description": "X coordinate point 2"}, {"name": "y2", "type": "LReal", "description": "Y coordinate point 2"}, {"name": "z2", "type": "LReal", "description": "Z coordinate point 2"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_CalcDistance_3D\" : LReal\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_CalcDistance_3D\n   VAR_INPUT \n      x1 : LReal;\n      y1 : LReal;\n      z1 : LReal;\n      x2 : LReal;\n      y2 : LReal;\n      z2 : LReal;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Siemens AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_CalcDistance_3D\n\t  // Comment/Function: Calculates the distance between two points in 3D space\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - ENO mechanism is not used\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 04.10.2019  Siemens Industry Presales Support\n\t  //                      First released version\n\t  //                      derivate from \"CalcDistance_2D\" and extended to 3D\n\t  // 03.00.00 23.04.2020  Siemens Industry Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Program\n\t  // Calculating the distance\n\t  #LGF_CalcDistance_3D := SQRT(SQR(#x2 - #x1) + SQR(#y2 - #y1) + SQR(#z2 - #z1));\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "LReal"}]}
{"title": "GetFactorial", "description": "The function calculates the faculty of a natural number (ℕ!) and returns the result. The permissible value range of the input parameter naturalNumber is between 0 and 12, as 12 is the maximum factorial result fitting into a DInt type", "type": "FUNCTION", "name": "LGF_GetFactorial", "vars": [{"name": "naturalNumber", "type": "Int", "description": "Natural number (0..12)"}, {"name": "Ret_Val", "type": "DInt", "description": "Calculated factorial"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "naturalNumber", "type": "Int", "description": "Natural number (0..12)"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_GetFactorial\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_GetFactorial\n   VAR_INPUT \n      naturalNumber : Int;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempFactorial : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      FACTORIAL_OF_ZERO : Int := 1;\n      FACTORIAL_OF_ONE : Int := 1;\n      FACTORIAL_OF_TWO : Int := 2;\n      FACTORIAL_OF_THREE : Int := 6;\n      FACTORIAL_OF_FOUR : Int := 24;\n      FACTORIAL_OF_FIVE : Int := 120;\n      FACTORIAL_OF_SIX : Int := 720;\n      FACTORIAL_OF_SEVEN : Int := 5040;\n      FACTORIAL_OF_EIGHT : DInt := 40320;\n      FACTORIAL_OF_NINE : DInt := 362880;\n      FACTORIAL_OF_TEN : DInt := 3628800;\n      FACTORIAL_OF_ELEVEN : DInt := 39916800;\n      FACTORIAL_OF_TWELVE : DInt := 479001600;\n      DEFAULT_ZERO : DInt;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_WRONG_VALUE_RANGE : Word := 16#8101;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Siemens AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_GetFactorial\n\t  // Comment/Function: Outputs the value equal to the factorial N! of a natural number between 0 and 12\n\t  //                   Factorial of 12 is the maximum value fits into a DInt type\n\t  //                   MAGIC numbers are okay as they stay for the number/case itself\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  //                   Case of, MAGIC numbers are okay as they stay for the number/case itself\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //----------------------------------------------------------------------------- \n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|----------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.01.00 23.09.2019  Siemens Industry Online Support\n\t  //                      Renamed from \"Factorial\" to \"GetFactorial\"\n\t  //                      Code refactoring, regions and more comments added\n\t  //                      Reworked to case of, MAGIC numbers are okay as they stay for the number/case itself\n\t  // 03.00.00 23.04.2020  Siemens Industry Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Caluclation of factorial\n\t  //Validation check. Function is working with natural number between 0 and 12.\n\t  // N! = 1*2*3*....*N;\n\t  CASE #naturalNumber OF\n\t    0:\n\t      #tempFactorial := #FACTORIAL_OF_ZERO;\n\t    1:\n\t      #tempFactorial := #FACTORIAL_OF_ONE;\n\t    2:\n\t      #tempFactorial := #FACTORIAL_OF_TWO;\n\t    3:\n\t      #tempFactorial := #FACTORIAL_OF_THREE;\n\t    4:\n\t      #tempFactorial := #FACTORIAL_OF_FOUR;\n\t    5:\n\t      #tempFactorial := #FACTORIAL_OF_FIVE;\n\t    6:\n\t      #tempFactorial := #FACTORIAL_OF_SIX;\n\t    7:\n\t      #tempFactorial := #FACTORIAL_OF_SEVEN;\n\t    8:\n\t      #tempFactorial := #FACTORIAL_OF_EIGHT;\n\t    9:\n\t      #tempFactorial := #FACTORIAL_OF_NINE;\n\t    10:\n\t      #tempFactorial := #FACTORIAL_OF_TEN;\n\t    11:\n\t      #tempFactorial := #FACTORIAL_OF_ELEVEN;\n\t    12:\n\t      #tempFactorial := #FACTORIAL_OF_TWELVE;\n\t    ELSE\n\t      //Assigning error message when input is outside of working range\n\t      #LGF_GetFactorial := #DEFAULT_ZERO;\n\t      #error := TRUE;\n\t      #status := #ERR_WRONG_VALUE_RANGE;\n\t      RETURN;\n\t  END_CASE;\n\tEND_REGION\n\t\n\tREGION Writing output  \n\t  #LGF_GetFactorial := #tempFactorial;\n\t  \n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DInt"}]}
{"title": "IsNumber", "description": "This function proves a LReal datatype for a valid number and numeric range.", "type": "FUNCTION", "name": "LGF_IsNumber", "vars": [{"name": "number", "type": "LReal", "description": "Number to validate"}, {"name": "validRangeMin", "type": "LReal", "description": "Minimum real number for valid range"}, {"name": "validRangeMax", "type": "LReal", "description": "Maximum real number for valid range"}, {"name": "Ret_Val", "type": "Bool", "description": "TRUE: Is real numberFALSE: Out of range / NAN"}], "input": [{"name": "number", "type": "LReal", "description": "Number to validate"}, {"name": "validRangeMin", "type": "LReal", "description": "Minimum real number for valid range"}, {"name": "validRangeMax", "type": "LReal", "description": "Maximum real number for valid range"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_IsNumber\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_IsNumber\n   VAR_INPUT \n      number : LReal;\n      validRangeMin { S7_HiddenAssignment := 'Hide'; S7_PredefinedAssignment := '-2.2250738585072014E-308'; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : LReal;\n      validRangeMax { S7_HiddenAssignment := 'Hide'; S7_PredefinedAssignment := '+1.7976931348623157e+308'; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : LReal;\n   END_VAR\n\n   VAR CONSTANT \n      LREAL_ZERO : LReal := 0.0;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_IsNumber\n\t  // Comment/Function: This function proves an LReal for a valid numeric range \n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V5.0\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO mechanism is not used, Error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-----------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge                | Changes applied\n\t  // \n\t  // 01.00.00 | 29.07.2025 | Siemens SIMATIC Systems Support | First release version\n\t  //=============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Calculation\n\t  #LGF_IsNumber := TRUE\n\t  AND (#number = #number)\n\t  AND (FALSE\n\t  // Proof if number is inbetween the limits\n\t  OR ((#number <> #LREAL_ZERO) AND (#number >= #validRangeMin) AND (#number <= #validRangeMax))\n\t  // If number is a real 0.0 and the limits spann over / includes the zero\n\t  OR ((#number = #LREAL_ZERO) AND (#validRangeMin <= #LREAL_ZERO) AND (#LREAL_ZERO <= #validRangeMax))\n\t  );\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "IsValueInLimits", "description": "The function checks whether a value is within a defined value range. The value range is defined with a lower and an upper limit.", "type": "FUNCTION", "name": "LGF_IsValueInLimits", "vars": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined\nvalue range"}, {"name": "lowLimit", "type": "LReal", "description": "Low limit where the value is checked against to be greater"}, {"name": "highLimit", "type": "LReal", "description": "High limit where the value is checked against to to be less"}, {"name": "Ret_Val", "type": "Bool", "description": "Return: TRUE if the “value” is in the value range (range of the setpoint)"}, {"name": "overHighLimit", "type": "Bool", "description": "TRUE if the “value” is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the “value” is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined\nvalue range"}, {"name": "lowLimit", "type": "LReal", "description": "Low limit where the value is checked against to be greater"}, {"name": "highLimit", "type": "LReal", "description": "High limit where the value is checked against to to be less"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the “value” is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the “value” is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_IsValueInLimits\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_IsValueInLimits\n   VAR_INPUT \n      value : LReal;\n      lowLimit : LReal;\n      highLimit : LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      overHighLimit : Bool;\n      belowLowLimit : Bool;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempValueOverHighLimit : Bool;\n      tempValueUnderLowLimit : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_RANGE_HIGH_BELOW_LOW_LIMIT : Word := 16#8401;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_IsValueInLimits\n\t  // Comment/Function: Checks if a given value is within specified limits\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 10.12.2019  Siemens Industry Support\n\t  //                      First released version\n\t  //                      Copied from \"IsValueInRange\"\n\t  // 03.00.00 23.04.2020  Siemens Industry Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and limits check\n\t  // check if high limit is less then low limit\n\t  IF #highLimit < #lowLimit THEN\n\t    #error := true;\n\t    #status := #ERR_RANGE_HIGH_BELOW_LOW_LIMIT;\n\t    #overHighLimit := false;\n\t    #belowLowLimit := false;\n\t    #LGF_IsValueInLimits := false;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Limits evaluation\n\t  // Check if the value is higher then the high limit\n\t  #tempValueOverHighLimit := #value > #highLimit;\n\t  \n\t  // Check if the value is lower then the low limit\n\t  #tempValueUnderLowLimit := #value < #lowLimit;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t  // Check if the value is in range and write outputs\n\t  #LGF_IsValueInLimits := NOT (#tempValueOverHighLimit OR #tempValueUnderLowLimit);\n\t  #overHighLimit := #tempValueOverHighLimit;\n\t  #belowLowLimit := #tempValueUnderLowLimit;\n\t  \n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "IsValueInRange", "description": "The function checks whether a value is within a defined value range. The value range is defined with a set point and a range around this set point. The function calculates the low limit and high limit of the value range.", "type": "FUNCTION", "name": "LGF_IsValueInRange", "vars": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined\nvalue range"}, {"name": "setpoint", "type": "LReal", "description": "Set point"}, {"name": "range", "type": "LReal", "description": "Area where the setpoint is in range"}, {"name": "Ret_Val", "type": "Bool", "description": "Return: TRUE if the “value” is in the value range (range of the setpoint)"}, {"name": "overHighLimit", "type": "Bool", "description": "TRUE if the “value” is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the “value” is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined\nvalue range"}, {"name": "setpoint", "type": "LReal", "description": "Set point"}, {"name": "range", "type": "LReal", "description": "Area where the setpoint is in range"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the “value” is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the “value” is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_IsValueInRange\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_IsValueInRange\n   VAR_INPUT \n      value : LReal;\n      setpoint : LReal;\n      range : LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      overHighLimit : Bool;\n      belowLowLimit : Bool;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempHighLimit : LReal;\n      tempLowLimit : LReal;\n      tempValueOverHighLimit : Bool;\n      tempValueUnderLowLimit : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      HALF : LReal := 0.5;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_RANGE_LIMIT_VALUES : Word := 16#8401;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_IsValueInRange\n\t  // Comment/Function: Checks if a given value is within a specified range of a given setpoint\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 30.01.2017  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.01.00 13.11.2019  Simatic Systems Support\n\t  //                      renamed from \"LGF_HighLowLimit\" to \"LGF_IsValueInRange\"\n\t  //                      Code refactoring\n\t  //                      error values changed, regions, comments and constant’s are added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and limits check\n\t  // Calculation of limits \n\t  // High limit\n\t  #tempHighLimit := #setpoint + (#HALF * ABS(#range));\n\t  // Low limit\n\t  #tempLowLimit := #setpoint - (#HALF * ABS(#range));\n\t  // Outside of data range\n\t  IF ENO = false THEN\n\t    #error := true;\n\t    #status := #ERR_RANGE_LIMIT_VALUES;\n\t    #overHighLimit := false;\n\t    #belowLowLimit := false;\n\t    #LGF_IsValueInRange := false;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Limits evaluation\n\t  // Check if the value is higher then the high limit\n\t  #tempValueOverHighLimit := #value > #tempHighLimit;\n\t  \n\t  // Check if the value is lower then the low limit\n\t  #tempValueUnderLowLimit := #value < #tempLowLimit;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t  // Check if the value is in range and write outputs\n\t  #LGF_IsValueInRange := NOT (#tempValueOverHighLimit OR #tempValueUnderLowLimit);\n\t  #overHighLimit := #tempValueOverHighLimit;\n\t  #belowLowLimit := #tempValueUnderLowLimit;\n\t  \n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "IsValueInTolerance", "description": "The function checks whether a value is within a defined value range. The value range is defined with a set point, as well as a tolerance range, around the set point in percent (%). The function calculates the low limit and high limit of the value range.", "type": "FUNCTION", "name": "LGF_IsValueInTolerance", "vars": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined\nvalue range"}, {"name": "setpoint", "type": "LReal", "description": "Set point"}, {"name": "tolerance", "type": "LReal", "description": "Tolerance range around the set point in percent (%)"}, {"name": "Ret_Val", "type": "Bool", "description": "Return: TRUE if the “value” is in the value range (range of the setpoint)"}, {"name": "overHighLimit", "type": "Bool", "description": "TRUE if the “value” is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the “value” is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined\nvalue range"}, {"name": "setpoint", "type": "LReal", "description": "Set point"}, {"name": "tolerance", "type": "LReal", "description": "Tolerance range around the set point in percent (%)"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the “value” is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the “value” is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_IsValueInTolerance\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_IsValueInTolerance\n   VAR_INPUT \n      value : LReal;\n      setpoint : LReal;\n      tolerance : LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      overHighLimit : Bool;\n      belowLowLimit : Bool;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempHighLimit : LReal;\n      tempLowLimit : LReal;\n      tempValueOverHighLimit : Bool;\n      tempValueUnderLowLimit : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      ONE : LReal := 1.0;\n      ONEHUNDRET_PROCENT : LReal := 100.0;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_RANGE_LIMIT_VALUES : Word := 16#8401;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_IsValueInTolerance\n\t  // Comment/Function: Checks if a given value is within a specified tolerance in procent of a given setpoint\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 10.12.2019  Siemens Industry Support\n\t  //                      First released version\n\t  //                      Copied from \"IsValueInRange\"\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.02 12.11.2020  Simatic Systems Support\n\t  //                      Bug fix - negative setpoint verification\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and limits check\n\t  // Calculation of limits\n\t  IF #setpoint > 0.0 THEN\n\t    #tempHighLimit := #setpoint * (#ONE + (ABS(#tolerance) / #ONEHUNDRET_PROCENT));\n\t    #tempLowLimit := #setpoint * (#ONE - (ABS(#tolerance) / #ONEHUNDRET_PROCENT));\n\t  ELSE\n\t    #tempHighLimit := #setpoint * (#ONE - (ABS(#tolerance) / #ONEHUNDRET_PROCENT));\n\t    #tempLowLimit := #setpoint * (#ONE + (ABS(#tolerance) / #ONEHUNDRET_PROCENT));\n\t  END_IF;\n\t  \n\t  //Outside of data tolerance\n\t  IF ENO = false THEN\n\t    #error := true;\n\t    #status := #ERR_RANGE_LIMIT_VALUES;\n\t    #overHighLimit := false;\n\t    #belowLowLimit := false;\n\t    #LGF_IsValueInTolerance := false;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Limits evaluation\n\t  // Check if the value is higher then the high limit\n\t  #tempValueOverHighLimit := #value > #tempHighLimit;\n\t  \n\t  // Check if the value is lower then the low limit\n\t  #tempValueUnderLowLimit := #value < #tempLowLimit;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t  // Check if the value is in range and write outputs\n\t  #LGF_IsValueInTolerance := NOT (#tempValueOverHighLimit OR #tempValueUnderLowLimit);\n\t  #overHighLimit := #tempValueOverHighLimit;\n\t  #belowLowLimit := #tempValueUnderLowLimit;\n\t  \n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "NthRoot", "description": "This function extracts the n-th root of a given value. The root is defined as follows: 1 𝑟𝑒𝑠𝑢𝑙𝑡= 𝑟𝑜𝑜√𝑡 𝑣𝑎𝑙𝑢𝑒=𝑣𝑎𝑙𝑢𝑒𝑟𝑜𝑜𝑡 STEP 7 (TIA Portal) results in the following formula: 𝑟𝑒𝑠𝑢𝑙𝑡=𝑣𝑎𝑙𝑢𝑒∗∗(1/𝑟𝑜𝑜𝑡)", "type": "FUNCTION", "name": "LGF_NthRoot", "vars": [{"name": "value", "type": "LReal", "description": "Value from which the root should be calculated."}, {"name": "root", "type": "LReal", "description": "Exponent\nof root"}, {"name": "Ret_Val", "type": "LReal", "description": "Returns the Nth root of a value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "value", "type": "LReal", "description": "Value from which the root should be calculated."}, {"name": "root", "type": "LReal", "description": "Exponent\nof root"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_NthRoot\" : LReal\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_NthRoot\n   VAR_INPUT \n      value : LReal;\n      root : LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : LReal := 0.0;\n      ONE : LReal := 1.0;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NEG_VAR : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_NthRoot\n\t  // Comment/Function: This function extracts the n-th root of a given value\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.02 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.03 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.04 17.01.2019  Simatic Systems Support\n\t  //                      Calculation changed\n\t  // 01.00.09 13.11.2019  Simatic Systems Support\n\t  //                      Renamed from \"LGF_XRoot\" to \"LGF_NthRoot\"\n\t  //                      Regions, comments and constants are added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION Validation\n\t  // Check if the variable value is negative \n\t  IF #value < #ZERO THEN\n\t    #error := true;\n\t    #status := #ERR_NEG_VAR;\n\t    #LGF_NthRoot := #ZERO;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of the n-th root\n\t  #LGF_NthRoot := #value ** (#ONE / #root);\n\t  \n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "LReal"}]}
{"title": "Random", "description": "This function generates a random value with each call. The random number has the data type DInt.", "type": "FUNCTION", "name": "LGF_Random_DInt", "vars": [{"name": "Ret_Val", "type": "DInt", "description": "Random number in the DInt range"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION \"LGF_Random_DInt\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_Random_DInt\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n      subfunctionStatus : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempNanoSecondInDWord : DWord;\n      tempTimeStatus : Word;\n      tempRandomValue : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : DInt;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_RD_SYS_T : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_Random_DInt\n\t  // Comment/Function: Generates a random number in the DInt Range\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 13.11.2019  Siemens Industry Presales Support\n\t  //                      First release\n\t  //                      copied from \"LGF_Random_Real\"\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 04.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Validation\n\t  // Read system time\n\t  #tempTimeStatus := INT_TO_WORD(RD_SYS_T(#tempTime));\n\t  \n\t  // Check return variable for error\n\t  IF (#tempTimeStatus <> #SUB_STATUS_NO_ERROR) THEN\n\t    #error := true;\n\t    #status := #ERR_RD_SYS_T;\n\t    #subfunctionStatus := #tempTimeStatus;\n\t    #LGF_Random_DInt := #ZERO;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating random number\n\t  // Converting to double word so individual bytes can be addressed\n\t  #tempNanoSecondInDWord := UDINT_TO_DWORD(#tempTime.NANOSECOND);\n\t  \n\t  // Calculate a random-start-value depending on the time\n\t  #tempRandomValue.%B3 := #tempNanoSecondInDWord.%B0;\n\t  #tempRandomValue.%B2 := #tempNanoSecondInDWord.%B1;\n\t  #tempRandomValue.%B1 := #tempNanoSecondInDWord.%B2;\n\t  #tempRandomValue.%B0 := #tempNanoSecondInDWord.%B3;\n\t  \n\t  #LGF_Random_DInt := DWORD_TO_DINT(#tempRandomValue);\n\t  \n\t  #error := false;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DInt"}]}
{"title": "Random", "description": "This function generates a random value with each call. The random number has the data type Real in the range from 0.0 to 1.0.", "type": "FUNCTION", "name": "LGF_Random_Real", "vars": [{"name": "Ret_Val", "type": "Real", "description": "Random Real number between 0.0 and 1.0"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION \"LGF_Random_Real\" : Real\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_Random_Real\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n      subfunctionStatus : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempNanoSecondInDWord : DWord;\n      tempTimeStatus : Word;\n      tempRandomValue : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : Real;\n      MAX_UDINT : UDInt := 4294967295 ;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_RD_SYS_T : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_Random_Real\n\t  // Comment/Function: Generates a random real number between 0.0 and 1.0\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 27.01.2017  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.01.00 13.11.2019  Simatic Systems Support\n\t  //                      Renamed from \"LGF_RandomBasic\" to \"LGF_Random_Real\"\n\t  //                      Regions, comments and constants are added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 04.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Validation\n\t  // Read system time\n\t  #tempTimeStatus := INT_TO_WORD(RD_SYS_T(#tempTime));\n\t  \n\t  // Check return variable for error\n\t  IF (#tempTimeStatus <> #SUB_STATUS_NO_ERROR) THEN\n\t    #error := true;\n\t    #status := #ERR_RD_SYS_T;\n\t    #subfunctionStatus := #tempTimeStatus;\n\t    #LGF_Random_Real := #ZERO;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating random number\n\t  // Converting to double word so individual bytes can be addressed\n\t  #tempNanoSecondInDWord := UDINT_TO_DWORD(#tempTime.NANOSECOND);\n\t  \n\t  // Calculate a random-start-value depending on the time\n\t  #tempRandomValue.%B3 := #tempNanoSecondInDWord.%B0;\n\t  #tempRandomValue.%B2 := #tempNanoSecondInDWord.%B1;\n\t  #tempRandomValue.%B1 := #tempNanoSecondInDWord.%B2;\n\t  #tempRandomValue.%B0 := #tempNanoSecondInDWord.%B3;\n\t  \n\t  // Norm the calculated random number: 0.0 <= Random_Real <= 1.0\n\t  #LGF_Random_Real := UDINT_TO_REAL(DWORD_TO_UDINT(#tempRandomValue)) / UDINT_TO_REAL(#MAX_UDINT);\n\t  \n\t  #error := false;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Real"}]}
{"title": "Random", "description": "This function generates a random value with each call. The random number has the data type UDInt.", "type": "FUNCTION", "name": "LGF_Random_UDInt", "vars": [{"name": "Ret_Val", "type": "UDInt", "description": "Random number in the UDInt range"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION \"LGF_Random_UDInt\" : UDInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_Random_UDInt\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n      subfunctionStatus : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempNanoSecondInDWord : DWord;\n      tempTimeStatus : Word;\n      tempRandomValue : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : UDInt := 0;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_RD_SYS_T : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_Random_UDInt\n\t  // Comment/Function: Generates a random number in the UDInt Range\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 11.12.2019  Simatic Systems Support\n\t  //                      First release\n\t  //                      copied from \"LGF_Random_Real\"\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 04.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Validation\n\t  // Read system time\n\t  #tempTimeStatus := INT_TO_WORD(RD_SYS_T(#tempTime));\n\t  \n\t  // Check return variable for error\n\t  IF (#tempTimeStatus <> #SUB_STATUS_NO_ERROR) THEN\n\t    #error := true;\n\t    #status := #ERR_RD_SYS_T;\n\t    #subfunctionStatus := #tempTimeStatus;\n\t    #LGF_Random_UDInt := #ZERO;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating random number\n\t  // Converting to double word so individual bytes can be addressed\n\t  #tempNanoSecondInDWord := UDINT_TO_DWORD(#tempTime.NANOSECOND);\n\t  \n\t  // Calculate a random-start-value depending on the time\n\t  #tempRandomValue.%B3 := #tempNanoSecondInDWord.%B0;\n\t  #tempRandomValue.%B2 := #tempNanoSecondInDWord.%B1;\n\t  #tempRandomValue.%B1 := #tempNanoSecondInDWord.%B2;\n\t  #tempRandomValue.%B0 := #tempNanoSecondInDWord.%B3;\n\t  \n\t  #LGF_Random_UDInt := DWORD_TO_UDINT(#tempRandomValue);\n\t  \n\t  #error := false;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "UDInt"}]}
{"title": "RandomRange", "description": "This function generates a random value in defined limits with each call. The random number has the data type DInt in the specified range.", "type": "FUNCTION", "name": "LGF_RandomRange_DInt", "vars": [{"name": "minValue", "type": "DInt", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "DInt", "description": "Maximum value of the range of the random number - upper border"}, {"name": "Ret_Val", "type": "DInt", "description": "Random Real number in the predefined range"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [{"name": "minValue", "type": "DInt", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "DInt", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION \"LGF_RandomRange_DInt\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_RandomRange_DInt\n   VAR_INPUT \n      minValue : DInt;\n      maxValue : DInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n      subfunctionStatus : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempNanoSecondInDWord : DWord;\n      tempTimeStatus : Word;\n      tempRandomValue : DWord;\n      tempNormReal : Real;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : DInt := 0;\n      MAX_UDINT : UDInt := 4294967295 ;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_MAX_LESS_MIN : Word := 16#8200;\n      ERR_RD_SYS_T : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_RandomRange_DInt\n\t  // Comment/Function: This function generates random numbers in defined limits (Datatype DInt)\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.02 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.03 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.01.00 09.10.2019  Simatic Systems Support\n\t  //                      Renamed from \"LGF_RandomInt\" to \"LGF_RandomRange_DInt\"\n\t  //                      change random datatype from Int to DInt\n\t  //                      Regions, comments and constants are added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 04.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Validation\n\t  // Check if the maximal Value is less than the minimal value\n\t  IF (#minValue > #maxValue) THEN\n\t    #error := true;\n\t    #status := #ERR_MAX_LESS_MIN;\n\t    #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t    #LGF_RandomRange_DInt := #ZERO;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Read system time\n\t  #tempTimeStatus := INT_TO_WORD(RD_SYS_T(#tempTime));\n\t  \n\t  // Check return variable for error\n\t  IF (#tempTimeStatus <> #SUB_STATUS_NO_ERROR) THEN\n\t    #error := true;\n\t    #status := #ERR_RD_SYS_T;\n\t    #subfunctionStatus := #tempTimeStatus;\n\t    #LGF_RandomRange_DInt := #ZERO;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating random number\n\t  // Converting to double word so individual bytes can be addressed\n\t  #tempNanoSecondInDWord := UDINT_TO_DWORD(#tempTime.NANOSECOND);\n\t  \n\t  // Callculate a random-start-value depending on the time\n\t  #tempRandomValue.%B3 := #tempNanoSecondInDWord.%B0;\n\t  #tempRandomValue.%B2 := #tempNanoSecondInDWord.%B1;\n\t  #tempRandomValue.%B1 := #tempNanoSecondInDWord.%B2;\n\t  #tempRandomValue.%B0 := #tempNanoSecondInDWord.%B3;\n\t  \n\t  // Norm the calculated random number: 0.0 <= #tempNormReal <= 1.0\n\t  #tempNormReal := UDINT_TO_REAL(DWORD_TO_UDINT(#tempRandomValue)) / UDINT_TO_REAL(#MAX_UDINT);\n\t  \n\t  // Scale the tempNormReal to be in the range of maxValue and minValue\n\t  #LGF_RandomRange_DInt := REAL_TO_DINT((#tempNormReal * DINT_TO_REAL(#maxValue - #minValue) + DINT_TO_REAL(#minValue)));\n\t  \n\t  #error := false;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DInt"}]}
{"title": "RandomRange", "description": "This function generates a random value in defined limits with each call. The random number has the data type Real in the specified range.", "type": "FUNCTION", "name": "LGF_RandomRange_Real", "vars": [{"name": "minValue", "type": "Real", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "Real", "description": "Maximum value of the range of the random number - upper border"}, {"name": "Ret_Val", "type": "Real", "description": "Random Real number in the predefined range"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [{"name": "minValue", "type": "Real", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "Real", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION \"LGF_RandomRange_Real\" : Real\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_RandomRange_Real\n   VAR_INPUT \n      minValue : Real;\n      maxValue : Real;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n      subfunctionStatus : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempNanoSecondInDWord : DWord;\n      tempTimeStatus : Word;\n      tempRandomValue : DWord;\n      tempNormReal : Real;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : Real := 0.0;\n      MAX_UDINT : UDInt := 4294967295;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_MAX_LESS_MIN : Word := 16#8200;\n      ERR_RD_SYS_T : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_RandomRange_Real\n\t  // Comment/Function: This function generates random numbers in defined limits (Datatype Real)\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.02 02.03.2017  Siemens Industry Online Support\n\t  //                      Bugfix: FC number\n\t  // 01.00.03 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.04 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.01.00 13.11.2019  Simatic Systems Support\n\t  //                      Renamed from \"LGF_RandomReal\" to \"LGF_RandomRange_Real\"\n\t  //                      Regions, comments and constants are added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 04.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Validation\n\t  // Check if the maximal Value is less than the minimal value\n\t  IF (#minValue > #maxValue) THEN\n\t    #error := true;\n\t    #status := #ERR_MAX_LESS_MIN;\n\t    #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t    #LGF_RandomRange_Real := #ZERO;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Read system time\n\t  #tempTimeStatus := INT_TO_WORD(RD_SYS_T(#tempTime));\n\t  \n\t  // Check return variable for error\n\t  IF (#tempTimeStatus <> #SUB_STATUS_NO_ERROR) THEN\n\t    #error := true;\n\t    #status := #ERR_RD_SYS_T;\n\t    #subfunctionStatus := #tempTimeStatus;\n\t    #LGF_RandomRange_Real := #ZERO;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating random number\n\t  // Converting to double word so individual bytes can be addressed\n\t  #tempNanoSecondInDWord := UDINT_TO_DWORD(#tempTime.NANOSECOND);\n\t  \n\t  // Calculate a random-start-value depending on the time\n\t  #tempRandomValue.%B3 := #tempNanoSecondInDWord.%B0;\n\t  #tempRandomValue.%B2 := #tempNanoSecondInDWord.%B1;\n\t  #tempRandomValue.%B1 := #tempNanoSecondInDWord.%B2;\n\t  #tempRandomValue.%B0 := #tempNanoSecondInDWord.%B3;\n\t  \n\t  // Norm the calculated random number: 0.0 <= #tempNormReal <= 1.0\n\t  #tempNormReal := UDINT_TO_REAL(DWORD_TO_UDINT(#tempRandomValue)) / UDINT_TO_REAL(#MAX_UDINT);\n\t  \n\t  // Scale the tempNormReal to be in the range of maxValue and minValue\n\t  #LGF_RandomRange_Real := ((#tempNormReal * (#maxValue - #minValue) + (#minValue)));\n\t  \n\t  #error := false;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Real"}]}
{"title": "RandomRange", "description": "This function generates a random value in defined limits with each call. The random number has the data type UDInt in the specified range.", "type": "FUNCTION", "name": "LGF_RandomRange_UDInt", "vars": [{"name": "minValue", "type": "UDInt", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "UDInt", "description": "Maximum value of the range of the random number - upper border"}, {"name": "Ret_Val", "type": "UDInt", "description": "Random UDInt number in the predefined range"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [{"name": "minValue", "type": "UDInt", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "UDInt", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION \"LGF_RandomRange_UDInt\" : UDInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_RandomRange_UDInt\n   VAR_INPUT \n      minValue : UDInt;\n      maxValue : UDInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n      subfunctionStatus : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempNanoSecondInDWord : DWord;\n      tempTimeStatus : Word;\n      tempRandomValue : DWord;\n      tempNormReal : Real;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : UDInt := 0;\n      MAX_UDINT : UDInt := 4294967295 ;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_MAX_LESS_MIN : Word := 16#8200;\n      ERR_RD_SYS_T : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_RandomRange_UDInt\n\t  // Comment/Function: This function generates random numbers in defined limits (Datatype UDInt)\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 11.12.2019  Simatic Systems Support\n\t  //                      First released version\n\t  //                      copied from \"LGF_RandomRange_DInt\"\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 04.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Validation\n\t  // Check if the maximal Value is less than the minimal value\n\t  IF (#minValue > #maxValue) THEN\n\t    #error := true;\n\t    #status := #ERR_MAX_LESS_MIN;\n\t    #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t    #LGF_RandomRange_UDInt := #ZERO;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Read system time\n\t  #tempTimeStatus := INT_TO_WORD(RD_SYS_T(#tempTime));\n\t  \n\t  // Check return variable for error\n\t  IF (#tempTimeStatus <> #SUB_STATUS_NO_ERROR) THEN\n\t    #error := true;\n\t    #status := #ERR_RD_SYS_T;\n\t    #subfunctionStatus := #tempTimeStatus;\n\t    #LGF_RandomRange_UDInt := #ZERO;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating random number\n\t  // Converting to double word so individual bytes can be addressed\n\t  #tempNanoSecondInDWord := UDINT_TO_DWORD(#tempTime.NANOSECOND);\n\t  \n\t  // Calculate a random-start-value depending on the time\n\t  #tempRandomValue.%B3 := #tempNanoSecondInDWord.%B0;\n\t  #tempRandomValue.%B2 := #tempNanoSecondInDWord.%B1;\n\t  #tempRandomValue.%B1 := #tempNanoSecondInDWord.%B2;\n\t  #tempRandomValue.%B0 := #tempNanoSecondInDWord.%B3;\n\t  \n\t  // Norm the calculated random number: 0.0 <= #tempNormReal <= 1.0\n\t  #tempNormReal := UDINT_TO_REAL(DWORD_TO_UDINT(#tempRandomValue)) / UDINT_TO_REAL(#MAX_UDINT);\n\t  \n\t  // Scale the tempNormReal to be in the range of maxValue and minValue\n\t  #LGF_RandomRange_UDInt := REAL_TO_UDINT((#tempNormReal * UDINT_TO_REAL(#maxValue - #minValue) + UDINT_TO_REAL(#minValue)));\n\t  \n\t  #error := false;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "UDInt"}]}
{"title": "RoundByPrecision", "description": "This function rounds a floating-point number (LReal) to a specified number of decimal places.", "type": "FUNCTION", "name": "LGF_RoundByPrecision", "vars": [{"name": "number", "type": "LReal", "description": "Value to be rounded"}, {"name": "precisionDecimal", "type": "UInt", "description": "Number of decimal places to round the number (1,2,3)"}, {"name": "Ret_Val", "type": "LReal", "description": "Number rounded with the number of decimal places selected"}], "input": [{"name": "number", "type": "LReal", "description": "Value to be rounded"}, {"name": "precisionDecimal", "type": "UInt", "description": "Number of decimal places to round the number (1,2,3)"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_RoundByPrecision\" : LReal\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_RoundByPrecision\n   VAR_INPUT \n      number : LReal;\n      precisionDecimal : UInt;\n   END_VAR\n\n   VAR_TEMP \n      tempFactor : LReal;\n      tempDintNumber : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      DECIMAL_BASE_VALUE : UInt := 10;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_RoundByPrecision\n\t  // Comment/Function: This function rounds a floating-point number (LReal) to a specified number of decimal places. \n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V5.0\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO mechanism is not used, Error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 30.07.2025 | Siemens Industry Online Support\n\t  //                         First released version\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION CALCULATION\n\t  //Calculation of the exponent depending on the number of decimal places\n\t  #tempFactor := #DECIMAL_BASE_VALUE ** #precisionDecimal;\n\t  \n\t  //Multiplication, rounding and scalation\n\t  #tempDintNumber := LREAL_TO_DINT(#number * #tempFactor);\n\t  #LGF_RoundByPrecision := #tempDintNumber / #tempFactor;\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "LReal"}]}
{"title": "ScaleLinear", "description": "This function scales an input variable (LReal) via a linear straight-line equation.", "type": "FUNCTION", "name": "LGF_ScaleLinear", "vars": [{"name": "x", "type": "LReal", "description": "Input value `x` to be scaled."}, {"name": "x1", "type": "LReal", "description": "Point 1 (P1) -`x` coordinate of the linear function."}, {"name": "y1", "type": "LReal", "description": "Point 1 (P1) -`y` coordinate of the linear function."}, {"name": "x2", "type": "LReal", "description": "Point 2 (P2) -`x` coordinate of the linear function."}, {"name": "y2", "type": "LReal", "description": "Point 2 (P2) -`y` coordinate of the linear function."}, {"name": "yMin", "type": "LReal", "description": "Lower limit value of the output."}, {"name": "yMax", "type": "LReal", "description": "High limit value of the output."}, {"name": "Ret_Val", "type": "LReal", "description": "Scaled output value `y`"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "x", "type": "LReal", "description": "Input value `x` to be scaled."}, {"name": "x1", "type": "LReal", "description": "Point 1 (P1) -`x` coordinate of the linear function."}, {"name": "y1", "type": "LReal", "description": "Point 1 (P1) -`y` coordinate of the linear function."}, {"name": "x2", "type": "LReal", "description": "Point 2 (P2) -`x` coordinate of the linear function."}, {"name": "y2", "type": "LReal", "description": "Point 2 (P2) -`y` coordinate of the linear function."}, {"name": "yMin", "type": "LReal", "description": "Lower limit value of the output."}, {"name": "yMax", "type": "LReal", "description": "High limit value of the output."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_ScaleLinear\" : LReal\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry_Support\nFAMILY : LGF\nNAME : LGF_ScaleLinear\n   VAR_INPUT \n      x : LReal;\n      x1 : LReal;\n      y1 : LReal;\n      x2 : LReal;\n      y2 : LReal;\n      yMin : LReal;\n      yMax : LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempY : LReal;\n      tempStatus : Word;\n   END_VAR\n\n   VAR CONSTANT \n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_LOW_LIM_OVER_UP_LIM : Word := 16#8200;\n      WARN_Y_LIMITED_TO_YMIN : Word := 16#6001;\n      WARN_Y_LIMITED_TO_YMAX : Word := 16#6002;\n      PRECISION : LReal := 1.0E-06;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ScaleLinear\n\t  // Comment/Function: This function scales an input variable (`LReal`) via a linear straight-line equation.\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 Upd 1\n\t  // Restrictions:     ENO mechanism is not used, Error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 27.01.2017 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 17.08.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15 Update 2\n\t  // 01.00.02 | 23.11.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15.1\n\t  // 02.00.00 | 25.01.2019 | Simatic Systems Support\n\t  //                         Data type changed from Variant to LReal\n\t  // 02.00.01 | 25.06.2019 | Simatic Systems Support\n\t  //                         Standard header and block parameters update, status parameter added\n\t  //                         LReal value comparison added\n\t  //                         Result parameter changed to return value of FC for use in SCL\n\t  //                         Warning number changed to range of 16#6xxx\n\t  //                         refactor variable handling and extract returns in between the code\n\t  //                         add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 12.11.2020 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //                         Move to folder \"Math operations\"\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION\n\t  #tempY := 0.0;\n\t  #tempStatus := #STATUS_FINISHED_NO_ERROR;\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t  // check if limits in a plausible range\n\t  // --> higher limit has to be greater than lower limit\n\t  IF (#yMin > #yMax) THEN\n\t    #tempY := 0.0;\n\t    #tempStatus := #ERR_LOW_LIM_OVER_UP_LIM;\n\t    \n\t  ELSE// no error, process scaling\n\t    // Scale algorithm\n\t    IF (ABS(#x1 - #x2) <= (#PRECISION * ABS(#x1))) THEN\n\t      //The slope is approximately ZERO.\n\t      //Special CASE, use a different equation, NOT \"y = m*x+t\", instead you use \"x = y1\"\n\t      #tempY := #y1;\n\t    ELSE\n\t      // resolved equation --> F(x) = y = m*x+t, where m = slope/gradient, t = intercept\n\t      #tempY := (#y2 - #y1) / (#x2 - #x1) * (#x - #x1) + #y1;\n\t    END_IF;\n\t    \n\t    // Check if upper or lower limit is exceeded\n\t    IF (#tempY < #yMin) THEN\n\t      #tempY := #yMin;\n\t      #tempStatus := #WARN_Y_LIMITED_TO_YMIN;  // set warning indicator\n\t    ELSIF (#tempY > #yMax) THEN\n\t      #tempY := #yMax;\n\t      #tempStatus := #WARN_Y_LIMITED_TO_YMAX;  // set warning indicator\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION OUTPUTS  \n\t  // set status and error output\n\t  #status := #tempStatus;\n\t  #error := #tempStatus.%X15;\n\t  // set return value\n\t  #LGF_ScaleLinear := #tempY;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\nEND_FUNCTION", "return_value": [{"type": "LReal"}]}
{"title": "SearchMinMax", "description": "This function searches, in an array of the data type DInt, for the maximum and minimum value and the respective index in the array. The following data types of the array elements are supported: Int, DInt, UInt, UDInt, USInt, SInt, and Real.", "type": "FUNCTION", "name": "LGF_SearchMinMax", "vars": [{"name": "variableArray", "type": "Variant", "description": "Array in whose fields the maximum and minimum are searched"}, {"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "minValue", "type": "Variant", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array.\nThe start index of the array plus `minValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "maxValue", "type": "Variant", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array.\nThe start index of the array plus `maxValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [{"name": "variableArray", "type": "Variant", "description": "Array in whose fields the maximum and minimum are searched"}], "output": [{"name": "minValue", "type": "Variant", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array.\nThe start index of the array plus `minValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "maxValue", "type": "Variant", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array.\nThe start index of the array plus `maxValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION \"LGF_SearchMinMax\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_SearchMinMax\n   VAR_INPUT \n      variableArray : Variant;\n   END_VAR\n\n   VAR_OUTPUT \n      minValue : Variant;\n      minValueIndex : DInt;\n      maxValue : Variant;\n      maxValueIndex : DInt;\n      error : Bool;\n      status : Word;\n      subfunctionStatus : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempArrayEndIndex : DInt;\n      tempCounter : DInt;\n      tempSubfunctionErr : Int;\n      tempArrayIndexMax : DInt;\n      tempArrayIndexMin : DInt;\n      tempActValueInt : Int;\n      tempMinInt : Int;\n      tempMaxInt : Int;\n      tempActValueUInt : UInt;\n      tempMinUInt : UInt;\n      tempMaxUInt : UInt;\n      tempActValueDInt : DInt;\n      tempMinDInt : DInt;\n      tempMaxDInt : DInt;\n      tempActValueUDInt : UDInt;\n      tempMinUDInt : UDInt;\n      tempMaxUDInt : UDInt;\n      tempActValueUSInt : USInt;\n      tempMinUSInt : USInt;\n      tempMaxUSInt : USInt;\n      tempActValueSInt : SInt;\n      tempMinSInt : SInt;\n      tempMaxSInt : SInt;\n      tempActValueReal : Real;\n      tempMinReal : Real;\n      tempMaxReal : Real;\n      tempActValueLReal : LReal;\n      tempMinLReal : LReal;\n      tempMaxLReal : LReal;\n   END_VAR\n\n   VAR CONSTANT \n      DECREMNT_BY_ONE : DInt := 1;\n      START_FROM_SECOND_ELEMENT : Int := 1;\n      SUBFUNCTION_NO_ERROR : Int := 0;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_WRONG_TYPE : Word := 16#8201;\n      ERR_NOT_EQUAL_TYPES : Word := 16#8202;\n      ERR_MOVE_BLK_VARIANT : Word := 16#8203;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Siemens AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_SearchMinMax\n\t  // Comment/Function: Searches an array for the minimum and maximum number and\n\t  //                   outputs the position and values of those numbers\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - Error handling with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.02 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.03 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.01.00 08.11.2019  Siemens Industry Presales Support\n\t  //                      Code refactoring, regions and more comments added\n\t  // 03.00.00 23.04.2020  Siemens Industry Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 09.02.2021  Simatic Systems Support\n\t  //                      Rework constants and comments\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization\n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  #subfunctionStatus := INT_TO_WORD(#SUBFUNCTION_NO_ERROR);\n\t  #tempSubfunctionErr := #SUBFUNCTION_NO_ERROR;\n\tEND_REGION\n\t\n\tREGION Validation of inputs and outputs \n\t  // Check if the variant-variable is an array if yes cout the elements of the array\n\t  IF NOT (IS_ARRAY(#variableArray)) THEN\n\t    #error := true;\n\t    #status := #ERR_NO_ARRAY;\n\t    RETURN;\n\t    // Check if the elements of the array and the variables min and max have the same datatype.\n\t  ELSIF TypeOfElements(#variableArray) <> TypeOf(#minValue) OR TypeOf(#minValue) <> TypeOf(#maxValue) THEN\n\t    #error := true;\n\t    #status := #ERR_NOT_EQUAL_TYPES;\n\t    RETURN;\n\t  ELSE\n\t    #tempArrayEndIndex := (UDINT_TO_DINT(CountOfElements(#variableArray)) - #DECREMNT_BY_ONE);\n\t  END_IF;\n\t  //No need for validation for array max length. It cannot exceed DInt\n\tEND_REGION\n\t\n\tREGION Searching the array based on data type\n\t  CASE TypeOfElements(#variableArray) OF\n\t    Int:\n\t      REGION Search Array of Integers\n\t        //assign first value as min/max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMaxInt);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMinInt := #tempMaxInt;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          //Read the next element of the array\n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueInt);\n\t          // check for min\n\t          IF #tempActValueInt < #tempMinInt THEN\n\t            #tempMinInt := #tempActValueInt;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueInt > #tempMaxInt THEN\n\t            #tempMaxInt := #tempActValueInt;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    UInt:\n\t      REGION Search Array of Usigned Integers\n\t        //Assign first value as min / max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMaxUInt);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMinUInt := #tempMaxUInt;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          //Read the next element of the array\n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueUInt);\n\t          // check for min\n\t          IF #tempActValueUInt < #tempMinUInt THEN\n\t            #tempMinUInt := #tempActValueUInt;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueUInt > #tempMaxUInt THEN\n\t            #tempMaxUInt := #tempActValueUInt;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    DInt:\n\t      REGION Search Array of Double Integers\n\t        //Assign first value as min / max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMaxDInt);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMinDInt := #tempMaxDInt;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          //Read the next element of the array\n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueDInt);\n\t          // check for min\n\t          IF #tempActValueDInt < #tempMinDInt THEN\n\t            #tempMinDInt := #tempActValueDInt;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueDInt > #tempMaxDInt THEN\n\t            #tempMaxDInt := #tempActValueDInt;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    UDInt:\n\t      REGION Search Array of Unsigned Double Integers\n\t        //Assign first value as min / max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMaxUDInt);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMinUDInt := #tempMaxUDInt;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          //Read the next element of the array\n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueUDInt);\n\t          // check for min\n\t          IF #tempActValueUDInt < #tempMinUDInt THEN\n\t            #tempMinUDInt := #tempActValueUDInt;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueUDInt > #tempMaxUDInt THEN\n\t            #tempMaxUDInt := #tempActValueUDInt;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    USInt:\n\t      REGION Search Array of Unsigned Short Integers\n\t        //Assign first value as min/max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMaxUSInt);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMinUSInt := #tempMaxUSInt;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          //Read the next element of the array\n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueUSInt);\n\t          // check for min\n\t          IF #tempActValueUSInt < #tempMinUSInt THEN\n\t            #tempMinUSInt := #tempActValueUSInt;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueUSInt > #tempMaxUSInt THEN\n\t            #tempMaxUSInt := #tempActValueUSInt;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    SInt:\n\t      REGION Search Array of Signed Integers\n\t        //Assign first value as min / max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMaxSInt);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMinSInt := #tempMaxSInt;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          //Read the next element of the array\n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueSInt);\n\t          // check for min\n\t          IF #tempActValueSInt < #tempMinSInt THEN\n\t            #tempMinSInt := #tempActValueSInt;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueSInt > #tempMaxSInt THEN\n\t            #tempMaxSInt := #tempActValueSInt;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    Real:\n\t      REGION Search Array of Real\n\t        //Assign first value as min / max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMinReal);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMaxReal := #tempMinReal;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          \n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueReal);\n\t          // check for min\n\t          IF #tempActValueReal < #tempMinReal THEN\n\t            #tempMinReal := #tempActValueReal;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueReal > #tempMaxReal THEN\n\t            #tempMaxReal := #tempActValueReal;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    LReal:\n\t      REGION Search Array of LReal\n\t        //Assign first value as min / max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMinLReal);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMaxLReal := #tempMinLReal;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          \n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueLReal);\n\t          // check for min\n\t          IF #tempActValueLReal < #tempMinLReal THEN\n\t            #tempMinLReal := #tempActValueLReal;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueLReal > #tempMaxLReal THEN\n\t            #tempMaxLReal := #tempActValueLReal;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    ELSE\n\t      #error := true;\n\t      #subfunctionStatus := INT_TO_WORD(#SUBFUNCTION_NO_ERROR);\n\t      #status := #ERR_WRONG_TYPE;\n\t      RETURN;\n\t  END_CASE;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t  //Copy found values to outputs\n\t  //Copy Minimum value\n\t  #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                          COUNT := 1,\n\t                                          SRC_INDEX := #tempArrayIndexMin,\n\t                                          DEST_INDEX := 0,\n\t                                          DEST => #minValue);\n\t  //Copy Maximum value\n\t  #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                          COUNT := 1,\n\t                                          SRC_INDEX := #tempArrayIndexMax,\n\t                                          DEST_INDEX := 0,\n\t                                          DEST => #maxValue);\n\t  \n\t  //Checking return value of subfunction\n\t  IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t    #error := true;\n\t    #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t    #status := #ERR_MOVE_BLK_VARIANT;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  //Write found indexes to outputs\n\t  #minValueIndex := #tempArrayIndexMin;\n\t  #maxValueIndex := #tempArrayIndexMax;\n\t  \n\t  //ENO mechanism is not used, nerror handling via error & status\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "SearchMinMax", "description": "This function searches, in an array of the data type DInt, for the maximum and minimum value and the respective index in the array.", "type": "FUNCTION", "name": "LGF_SearchMinMax_DInt", "vars": [{"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "minValue", "type": "DInt", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array.\nThe start index of the array plus `minValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "maxValue", "type": "DInt", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array.\nThe start index of the array plus `maxValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "values", "type": "Array[*] of DInt", "description": "Array in whose fields the maximum and minimum are searched"}], "input": [], "output": [{"name": "minValue", "type": "DInt", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array.\nThe start index of the array plus `minValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "maxValue", "type": "DInt", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array.\nThe start index of the array plus `maxValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "Array in whose fields the maximum and minimum are searched"}], "answer": "FUNCTION \"LGF_SearchMinMax_DInt\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_SearchMinMax_DInt\n   VAR_OUTPUT \n      minValue : DInt;\n      minValueIndex : DInt;\n      maxValue : DInt;\n      maxValueIndex : DInt;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempArrayLowerBound : DInt;\n      tempArrayUpperBound : DInt;\n      tempCounter : DInt;\n      tempArrayIndexMax : DInt;\n      tempArrayIndexMin : DInt;\n      tempActValue : DInt;\n      tempMinValue : DInt;\n      tempMaxValue : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      START_FROM_SECOND_ELEMENT : Int := 1;\n      DIMENSION_ONE : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Siemens AG / (c)Copyright 2019\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_SearchMinMax_DInt\n\t  // Comment/Function: Searches an array for the minimum and maximum number and\n\t  //                   outputs the position and values of those numbers for\n\t  //                   array of double integers\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - Error handling not needed, using whole array\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 11.11.2019  Simatic Systems Support\n\t  //                      First release\n\t  //                      copied from \"LGF_SearchMinMax\" and reworked to array[*]\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 09.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  // 03.00.02 14.11.2022  Simatic Systems Support\n\t  //                      Fix loop start index (start from lower Bound + 1)\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Validation of inputs and outputs \n\t  // Lower bound\n\t  #tempArrayLowerBound := LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t  // Upper bound \n\t  #tempArrayUpperBound := UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\tEND_REGION\n\t\n\tREGION Searching the array \n\t  // Assign first value as min / max\n\t  #tempMinValue := #tempMaxValue := #values[#tempArrayLowerBound];\n\t  \n\t  // Search the Array for min/max values\n\t  FOR #tempCounter := (#tempArrayLowerBound + #START_FROM_SECOND_ELEMENT) TO #tempArrayUpperBound DO\n\t    \n\t    #tempActValue := #values[#tempCounter];\n\t    \n\t    // check for min\n\t    IF #tempActValue < #tempMinValue THEN\n\t      #tempMinValue := #tempActValue;\n\t      #tempArrayIndexMin := #tempCounter;\n\t      // check for max\n\t    ELSIF #tempActValue > #tempMaxValue THEN\n\t      #tempMaxValue := #tempActValue;\n\t      #tempArrayIndexMax := #tempCounter;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  // Copy found values to outputs\n\t  // Copy Minimum value\n\t  #minValue := #values[#tempArrayIndexMin];\n\t  // Copy Maximum value\n\t  #maxValue := #values[#tempArrayIndexMax];\n\t  \n\t  // Write found indexes to outputs\n\t  #minValueIndex := #tempArrayIndexMin;\n\t  #maxValueIndex := #tempArrayIndexMax;\n\t  \n\t  // ENO mechanism is not used, no error possible\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "SearchMinMax", "description": "This function searches, in an array of the data type LReal, for the maximum and minimum value and the respective index in the array.", "type": "FUNCTION", "name": "LGF_SearchMinMax_LReal", "vars": [{"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "minValue", "type": "LReal", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array.\nThe start index of the array plus `minValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "maxValue", "type": "LReal", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array.\nThe start index of the array plus `maxValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "values", "type": "Array[*] of LReal", "description": "Array in whose fields the maximum and minimum are searched"}], "input": [], "output": [{"name": "minValue", "type": "LReal", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array.\nThe start index of the array plus `minValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "maxValue", "type": "LReal", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array.\nThe start index of the array plus `maxValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Array in whose fields the maximum and minimum are searched"}], "answer": "FUNCTION \"LGF_SearchMinMax_LReal\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_SearchMinMax_LReal\n   VAR_OUTPUT \n      minValue : LReal;\n      minValueIndex : DInt;\n      maxValue : LReal;\n      maxValueIndex : DInt;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempArrayLowerBound : DInt;\n      tempArrayUpperBound : DInt;\n      tempCounter : DInt;\n      tempArrayIndexMax : DInt;\n      tempArrayIndexMin : DInt;\n      tempActValue : LReal;\n      tempMinValue : LReal;\n      tempMaxValue : LReal;\n   END_VAR\n\n   VAR CONSTANT \n      START_FROM_SECOND_ELEMENT : Int := 1;\n      DIMENSION_ONE : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Siemens AG / (c)Copyright 2019\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_SearchMinMax_LReal\n\t  // Comment/Function: Searches an array for the minimum and maximum number and\n\t  //                   outputs the position and values of those numbers for\n\t  //                   array of long real\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - Error handling not needed, using whole array\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 11.11.2019  Simatic Systems Support\n\t  //                      First release\n\t  //                      copied from \"LGF_SearchMinMax\" and reworked to array[*]\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 09.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  // 03.00.02 14.11.2022  Simatic Systems Support\n\t  //                      Fix loop start index (start from lower Bound + 1)\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Validation of inputs and outputs \n\t  // Lower bound\n\t  #tempArrayLowerBound := LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t  // Upper bound \n\t  #tempArrayUpperBound := UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\tEND_REGION\n\t\n\tREGION Searching the array \n\t  //Assign first value as min / max\n\t  #tempMaxValue := #values[#tempArrayLowerBound];\n\t  #tempMinValue := #tempMaxValue;\n\t  \n\t  //Search the Array for min/max values\n\t  FOR #tempCounter := (#tempArrayLowerBound + #START_FROM_SECOND_ELEMENT) TO #tempArrayUpperBound DO\n\t    \n\t    #tempActValue := #values[#tempCounter];\n\t    \n\t    // check for min\n\t    IF #tempActValue < #tempMinValue THEN\n\t      #tempMinValue := #tempActValue;\n\t      #tempArrayIndexMin := #tempCounter;\n\t      // check for max\n\t    ELSIF #tempActValue > #tempMaxValue THEN\n\t      #tempMaxValue := #tempActValue;\n\t      #tempArrayIndexMax := #tempCounter;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  //Copy found values to outputs\n\t  //Copy Minimum value\n\t  #minValue := #values[#tempArrayIndexMin];\n\t  //Copy Maximum value\n\t  #maxValue := #values[#tempArrayIndexMax];\n\t  \n\t  //Write found indexes to outputs\n\t  #minValueIndex := #tempArrayIndexMin;\n\t  #maxValueIndex := #tempArrayIndexMax;\n\t  \n\t  //ENO mechanism is not used, no error possible\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "SearchMinMax", "description": "This function searches, in an array of the data type UDInt, for the maximum and minimum value and the respective index in the array.", "type": "FUNCTION", "name": "LGF_SearchMinMax_UDInt", "vars": [{"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "minValue", "type": "UDInt", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array.\nThe start index of the array plus `minValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "maxValue", "type": "UDInt", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array.\nThe start index of the array plus `maxValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "values", "type": "Array[*] of UDInt", "description": "Array in whose fields the maximum and minimum are searched"}], "input": [], "output": [{"name": "minValue", "type": "UDInt", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array.\nThe start index of the array plus `minValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "maxValue", "type": "UDInt", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array.\nThe start index of the array plus `maxValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "Array in whose fields the maximum and minimum are searched"}], "answer": "FUNCTION \"LGF_SearchMinMax_UDInt\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_SearchMinMax_DInt\n   VAR_OUTPUT \n      minValue : UDInt;\n      minValueIndex : DInt;\n      maxValue : UDInt;\n      maxValueIndex : DInt;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of UDInt;\n   END_VAR\n\n   VAR_TEMP \n      tempArrayLowerBound : DInt;\n      tempArrayUpperBound : DInt;\n      tempCounter : DInt;\n      tempArrayIndexMax : DInt;\n      tempArrayIndexMin : DInt;\n      tempActValue : UDInt;\n      tempMinValue : UDInt;\n      tempMaxValue : UDInt;\n   END_VAR\n\n   VAR CONSTANT \n      START_FROM_SECOND_ELEMENT : Int := 1;\n      DIMENSION_ONE : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Siemens AG / (c)Copyright 2019\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_SearchMinMax_DInt\n\t  // Comment/Function: Searches an array for the minimum and maximum number and\n\t  //                   outputs the position and values of those numbers for\n\t  //                   array of unsigned double integers\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - Error handling not needed, using whole array\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 11.11.2019  Simatic Systems Support\n\t  //                      First release\n\t  //                      copied from \"LGF_SearchMinMax\" and reworked to array[*]\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 09.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Validation of inputs and outputs \n\t  // Lower bound\n\t  #tempArrayLowerBound := LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t  // Upper bound \n\t  #tempArrayUpperBound := UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\tEND_REGION\n\t\n\tREGION Searching the array \n\t  //Assign first value as min / max\n\t  #tempMaxValue := #values[#tempArrayLowerBound];\n\t  #tempMinValue := #tempMaxValue;\n\t  \n\t  //Search the Array for min/max values\n\t  FOR #tempCounter := (#tempArrayLowerBound + #START_FROM_SECOND_ELEMENT) TO #tempArrayUpperBound DO\n\t    \n\t    #tempActValue := #values[#tempCounter];\n\t    \n\t    // check for min\n\t    IF #tempActValue < #tempMinValue THEN\n\t      #tempMinValue := #tempActValue;\n\t      #tempArrayIndexMin := #tempCounter;\n\t      // check for max\n\t    ELSIF #tempActValue > #tempMaxValue THEN\n\t      #tempMaxValue := #tempActValue;\n\t      #tempArrayIndexMax := #tempCounter;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  //Copy found values to outputs\n\t  //Copy Minimum value\n\t  #minValue := #values[#tempArrayIndexMin];\n\t  //Copy Maximum value\n\t  #maxValue := #values[#tempArrayIndexMax];\n\t  \n\t  //Write found indexes to outputs\n\t  #minValueIndex := #tempArrayIndexMin;\n\t  #maxValueIndex := #tempArrayIndexMax;\n\t  \n\t  //ENO mechanism is not used, no error possible\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "Integration", "description": "The function approximately calculates the area under a function curve (the integral). The function curve is transferred as an analog value (LReal) which varies over time. The integral value is output on integral. The implementation is based on the trapezoidal rule and uses second [s] as time base, e.g. speed [m/s].", "type": "FUNCTION_BLOCK", "name": "LGF_Integration", "vars": [{"name": "enable", "type": "Bool", "description": "Enables integral calculation\nIf this input is set to the value `FALSE`, the integral\ncalculation is stopped and the `integral` output shows\nthe last calculated value."}, {"name": "value", "type": "LReal", "description": "Analog value of the continuous function curve, based\non [s], (e.g. [volume flow/s])"}, {"name": "reset", "type": "Bool", "description": "Sets the output “integral” to “0.0”."}, {"name": "integral", "type": "LReal", "description": "Integral value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [{"name": "enable", "type": "Bool", "description": "Enables integral calculation\nIf this input is set to the value `FALSE`, the integral\ncalculation is stopped and the `integral` output shows\nthe last calculated value."}, {"name": "value", "type": "LReal", "description": "Analog value of the continuous function curve, based\non [s], (e.g. [volume flow/s])"}, {"name": "reset", "type": "Bool", "description": "Sets the output “integral” to “0.0”."}], "output": [{"name": "integral", "type": "LReal", "description": "Integral value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_Integration\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_Integration\n   VAR_INPUT \n      enable : Bool;\n      value : LReal;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      integral { ExternalWritable := 'False'} : LReal;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      subfunctionStatus { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR \n      statLastTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;\n      statTimeDiffrence { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statInputOldValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statIntegral { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statEnablePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR_TEMP \n      tempSysTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempCalculation : LReal;\n      tempRetval : Word;\n   END_VAR\n\n   VAR CONSTANT \n      CLEAR_TIME {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      MILLISECOND_PER_SECOND : LReal := 1000.0;\n      NANOSEC_PER_SEC : LReal := 1000000000.0;\n      DIVIDE_BY_TWO : LReal := 2.0;\n      ZERO : LReal := 0.0;\n      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      ERR_READ_SYS_TIME : Word := 16#8600;\n      ONE_SECOND : LReal := 1.0;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_Integration\n\t  // Comment/Function: Integrates the input value\n\t  //                   integration by trapezoidal rule\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V4.0 / S7-1215\n\t  // Engineering:      TIA Portal V17 \n\t  // Restrictions:     ENO disabled - no error handling by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //----------|------------|------------------------|----------------------------\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|----------------------------\n\t  // 01.00.00 17.02.2017  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.01.00 12.11.2019  Simatic Systems Support\n\t  //                      Regions, comments and constants are added, code refactored\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 09.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  // 03.00.02 07.06.2021  Simatic Systems Support\n\t  //                      Fix bug - incompatibility with S7-1200 and LTIME\n\t  // 03.01.00 11.07.2025  Simatic Systems Support\n\t  //                      Fix bug - Time measurement and calculation for nanoseconds fixed\n\t  //                      Fix Wording/Bug - Time measurement scaling [ms] / [s] - timing for calculatiuon is bnased on seconds \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\t//Reset region must be before the enable region so that even if the function disabled, the user can reset the values.\n\tREGION Reset the function\n\t  IF #reset THEN\n\t    #statInputOldValue := #ZERO;\n\t    #statIntegral := #ZERO;\n\t    \n\t    // Clear LastTime value.\n\t    // Initial condition - first Delta time will be 0.\n\t    #statLastTime := #CLEAR_TIME;\n\t    \n\t    #integral := #ZERO;\n\t    #error := false;\n\t    #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t    #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t    ENO := TRUE; //ENO mechanism is not used because of error and status\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION Reset the function\n\t\n\tREGION Enable/Disable integral calculation\n\t  IF NOT #enable THEN\n\t    #statInputOldValue := #ZERO;\n\t    #statEnablePrevious := #enable;\n\t    \n\t    // Clear LastTime value.\n\t    // If it is not cleared when the function is enabled again,\n\t    // the first value will be multiplied with the time difference of the whole disable time\n\t    // Initial condition - first Delta time will be 0.\n\t    #statLastTime := #CLEAR_TIME;\n\t    \n\t    #integral := #statIntegral;\n\t    #error := false;\n\t    #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t    #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t    ENO := TRUE; //ENO mechanism is not used because of error and status\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION Enable/Disable integral calculation\n\t\n\tREGION Get system time\n\t  // Read system time\n\t  #tempRetval := INT_TO_WORD(RD_SYS_T(OUT => #tempSysTime));\n\t  \n\t  // in case of rising edge, reset old time to actual time\n\t  // This results in the first calcualtion step adding ZERO to the integral value,\n\t  // as we do not have to diffrent points for calculation at this time...\n\t  IF #enable AND NOT #statEnablePrevious THEN\n\t    #statLastTime := #tempSysTime;\n\t  END_IF;\n\t  \n\t  // Error Handling read system time\n\t  IF (#tempRetval > #SUB_STATUS_NO_ERROR) THEN\n\t    #integral := #statIntegral;\n\t    #error := TRUE;\n\t    #status := #ERR_READ_SYS_TIME;\n\t    #subfunctionStatus := #tempRetval;\n\t    ENO := TRUE; //ENO mechanism is not used because of error and status\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating the integral\n\t  // Calculate time difference between last and actual time\n\t  // coverting from DTL via time and DInt to Real\n\t  // scale from millisecond to second\n\t  #statTimeDiffrence := DINT_TO_LREAL(UDINT_TO_DINT(#tempSysTime.NANOSECOND) - UDINT_TO_DINT(#statLastTime.NANOSECOND)) / #NANOSEC_PER_SEC;\n\t  \n\t  // just in case the new nanoseconds counter is less than the old one we need to add one second\n\t  IF #statTimeDiffrence < #ZERO THEN\n\t    #statTimeDiffrence += #ONE_SECOND;\n\t  END_IF;\n\t  \n\t  // integration by trapezoidal rule\n\t  // add LastScalIn to ScalIn\n\t  // divide by two --> avarage of both - old and actual value\n\t  // multiply with time delta --> area unterneath the both borders\n\t  #tempCalculation := (#value + #statInputOldValue) * #statTimeDiffrence / #DIVIDE_BY_TWO;\n\t  \n\t  // Calculate new integral by adding the new/actual value to the old value\n\t  #statIntegral += #tempCalculation;\n\t  \n\t  // Write actual to last time\n\t  #statLastTime := #tempSysTime;\n\t  // Save last input value for next iteration\n\t  #statInputOldValue := #value;\n\t  // Save previous value of enable\n\t  #statEnablePrevious := #enable;\n\tEND_REGION Calculating the integral\n\t\n\tREGION Write outputs\n\t  #integral := #statIntegral;\n\t  #error := false;\n\t  #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t  #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  ENO := TRUE; //ENO mechanism is not used because of error and status\n\tEND_REGION Write outputs\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "IsValueInToleranceByTime", "description": "Checks if a given value is within a specified tolerance in percent of a given set point. The block has a configurable timing for set point change hiding, lower limit and as well for upper limit violation hiding.", "type": "FUNCTION_BLOCK", "name": "LGF_IsValueInToleranceByTime", "vars": [{"name": "value", "type": "Real", "description": "Value to check if in range of setpoint"}, {"name": "setpoint", "type": "Real", "description": "Setpoint"}, {"name": "lowerMinimum", "type": "Real", "description": "[% or ABS] Lower limit/tolerance of the setpoint in\npercent or absolut"}, {"name": "upperMaximum", "type": "Real", "description": "[% or ABS] Upper limit/tolerance of the setpoint in\npercent or absolut"}, {"name": "reset", "type": "Bool", "description": "Reset Block"}, {"name": "configuration", "type": "LGF_typeIsValueI\nn\nToleranceByTime\nConfiguration", "description": "Module related configuration parameters"}, {"name": "overHighLimit", "type": "Bool", "description": "TRUE: if value is above high limit"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE: if value is below low limit"}, {"name": "inLimits", "type": "Bool", "description": "TRUE: if value is in between the limits"}, {"name": "setpointChange", "type": "Bool", "description": "TRUE: when a setpoint change has been detected"}, {"name": "error", "type": "Bool", "description": "Error occured"}, {"name": "status", "type": "Word", "description": "Status of the function"}, {"name": "disableLimits", "type": "Bool", "description": "TRUE: Disable the monitoring timer. Leaving the\ntolerance triggers immediately"}, {"name": "limitsAsAbsolut\nValues", "type": "Bool", "description": "TRUE: Limit given as absolut value / FALSE: Limits\ngiven as tolerance from setpoint - absolut or perecent\nvalue"}, {"name": "toleranzAs\nAbsoluteValues", "type": "Bool", "description": "TRUE: Toleranze given as absolut value / FALSE:\nToleranze in percent from Setpoint"}, {"name": "upperLimit\nMonitoringTime", "type": "Time", "description": "Monitoring time for the upper limit violation"}, {"name": "lowerLimit\nMonitoringTime", "type": "Time", "description": "Monitoring time for the lower limit violation"}, {"name": "setpointChange\nMonitingTime", "type": "Time", "description": "Monitoring time for setpoint changes"}], "input": [{"name": "value", "type": "Real", "description": "Value to check if in range of setpoint"}, {"name": "setpoint", "type": "Real", "description": "Setpoint"}, {"name": "lowerMinimum", "type": "Real", "description": "[% or ABS] Lower limit/tolerance of the setpoint in\npercent or absolut"}, {"name": "upperMaximum", "type": "Real", "description": "[% or ABS] Upper limit/tolerance of the setpoint in\npercent or absolut"}, {"name": "reset", "type": "Bool", "description": "Reset Block"}, {"name": "configuration", "type": "LGF_typeIsValueI\nn\nToleranceByTime\nConfiguration", "description": "Module related configuration parameters"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE: if value is above high limit"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE: if value is below low limit"}, {"name": "inLimits", "type": "Bool", "description": "TRUE: if value is in between the limits"}, {"name": "setpointChange", "type": "Bool", "description": "TRUE: when a setpoint change has been detected"}, {"name": "error", "type": "Bool", "description": "Error occured"}, {"name": "status", "type": "Word", "description": "Status of the function"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_IsValueInToleranceByTime\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_IsValueInToleranceByTime\n   VAR_INPUT \n      value : Real;\n      setpoint : Real;\n      lowerMinimum : Real;\n      upperMaximum : Real;\n      reset : Bool;\n      configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : \"LGF_typeIsValueInToleranceByTimeConfiguration\";\n   END_VAR\n\n   VAR_OUTPUT \n      overHighLimit { ExternalWritable := 'False'} : Bool;\n      belowLowLimit { ExternalWritable := 'False'} : Bool;\n      inLimits { ExternalWritable := 'False'} : Bool;\n      setpointChange { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR \n      instMonitorUpper {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;\n      instMonitorLower {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;\n      instMonitorChange {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;\n      statSetpointPrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;\n      statResetPrev { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statSetpointChange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statWasWithinTolerance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR_TEMP \n      tempValueOverHighLimit : Bool;\n      tempValueUnderLowLimit : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      ONE : Real := 1.0;\n      ONEHUNDRED_PERCENT : Real := 100.0;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_RANGE_LIMIT_VALUE_CALC : Word := 16#8401;\n      ERR_SETPOINT_ABOVE_HIGH_LIMIT : Word := 16#8402;\n      ERR_SETPOINT_BELOW_LOW_LIMIT : Word := 16#8403;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_IsValueInTolerance\n\t  // Comment/Function: Checks if a given value is within a specified tolerance in percent of a given set point.\n\t  //                   The block has a configurable timing FOR set point change hiding,\n\t  //                   lower limit AND as well FOR upper limit violation hiding.\n\t  // Library/Family:   LGF(Library of general Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V5.0\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 21.12.2023 | Siemens Industry Support\n\t  //                         First released version\n\t  //                         Copied snd extended from \"IsValueInRange\"\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and limits check\n\t  // Calculation of limits\n\t  IF #configuration.limitsAsAbsolutValues THEN\n\t    #tempValueOverHighLimit := #value > #upperMaximum;\n\t    #tempValueUnderLowLimit := #value < #lowerMinimum;\n\t  ELSE\n\t    IF #configuration.toleranzAsAbsoluteValues THEN\n\t      #tempValueOverHighLimit := #value > #setpoint + #upperMaximum;\n\t      #tempValueUnderLowLimit := #value < #setpoint - #lowerMinimum;\n\t    ELSE\n\t      #tempValueOverHighLimit := #value > (#setpoint * (#ONE + (ABS(#upperMaximum) / #ONEHUNDRED_PERCENT)));\n\t      #tempValueUnderLowLimit := #value < (#setpoint * (#ONE - (ABS(#lowerMinimum) / #ONEHUNDRED_PERCENT)));\n\t    END_IF;\n\t  END_IF;\n\t  \n\t  \n\t  // Detecting a change in the setpoint, thus resetting the was in tolerance flag\n\t  IF (#statSetpointPrevious <> #setpoint) THEN\n\t    #statWasWithinTolerance := FALSE;\n\t    #statSetpointChange := TRUE;\n\t  END_IF;\n\t  #statSetpointPrevious := #setpoint;\n\t  \n\t  IF FALSE\n\t    OR #configuration.disableLimits\n\t    OR (#reset AND NOT #statResetPrev)\n\t  THEN\n\t    #statWasWithinTolerance := FALSE;\n\t    #statSetpointChange := FALSE;\n\t  END_IF;\n\t  #statResetPrev := #reset;\n\t  \n\t  IF TRUE\n\t    AND NOT (#tempValueUnderLowLimit OR #tempValueOverHighLimit)\n\t    AND NOT #statWasWithinTolerance\n\t  THEN\n\t    #statWasWithinTolerance := TRUE;\n\t  END_IF;\n\t  \n\t  //Outside of data tolerance\n\t  IF ENO = false THEN\n\t    #error := true;\n\t    #status := #ERR_RANGE_LIMIT_VALUE_CALC;\n\t    #overHighLimit := false;\n\t    #belowLowLimit := false;\n\t    #inLimits := false;\n\t    RETURN;\n\t  ELSIF TRUE\n\t    AND #configuration.limitsAsAbsolutValues\n\t    AND #setpoint > #upperMaximum\n\t  THEN\n\t    #error := true;\n\t    #status := #ERR_SETPOINT_ABOVE_HIGH_LIMIT;\n\t    #overHighLimit := false;\n\t    #belowLowLimit := false;\n\t    #inLimits := false;\n\t    RETURN;\n\t  ELSIF TRUE\n\t    AND #configuration.limitsAsAbsolutValues\n\t    AND #setpoint < #lowerMinimum\n\t  THEN\n\t    #error := true;\n\t    #status := #ERR_SETPOINT_BELOW_LOW_LIMIT;\n\t    #overHighLimit := false;\n\t    #belowLowLimit := false;\n\t    #inLimits := false;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Limits evaluation\n\t  // Check if the value is above the high limit\n\t  // In here the upper limit monitor timer will be started once the upper limit is exceeded.\n\t  // The signal is triggered once the timer expired and the process value is still not within the limit.\n\t  // This requires that the process value was at least once within the limits\n\t  #instMonitorUpper.TON(IN := TRUE\n\t                        AND #tempValueOverHighLimit\n\t                        AND (#statWasWithinTolerance OR #instMonitorChange.Q)\n\t                        AND NOT #configuration.disableLimits\n\t                        ,\n\t                        PT := #configuration.upperLimitMonitoringTime);\n\t  \n\t  // Check if the value is below the low limit\n\t  // As above the signal is triggered, when the lower limit is not reached within a certain time\n\t  #instMonitorLower.TON(IN := TRUE\n\t                        AND #tempValueUnderLowLimit\n\t                        AND (#statWasWithinTolerance OR #instMonitorChange.Q)\n\t                        AND NOT #configuration.disableLimits\n\t                        ,\n\t                        PT := #configuration.lowerLimitMonitoringTime);\n\t  \n\t  #instMonitorChange.TON(IN := TRUE\n\t                         AND #statSetpointChange\n\t                         AND NOT #statWasWithinTolerance\n\t                         AND NOT #configuration.disableLimits\n\t                         ,\n\t                         PT := #configuration.setpointChangeMonitingTime);\n\t  \n\t  IF TRUE\n\t    //AND #instMonitorChange.Q\n\t    AND #statSetpointChange\n\t    AND #statWasWithinTolerance\n\t  THEN\n\t    #statSetpointChange := FALSE;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t  // Check if the value is in range and write outputs\n\t  #inLimits := TRUE\n\t  AND NOT (#instMonitorLower.Q OR #instMonitorUpper.Q)\n\t  AND NOT (#statSetpointChange AND NOT #instMonitorChange.Q)\n\t  AND #statWasWithinTolerance;\n\t  \n\t  #overHighLimit := #instMonitorUpper.Q;\n\t  #belowLowLimit := #instMonitorLower.Q;\n\t  #setpointChange := #statSetpointChange AND NOT #statWasWithinTolerance;\n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "SimpleAveraging", "description": "This function calculates a moving arithmetic mean from LReal values. The method can be used to smooth data series; the values can be read in cyclically or triggered.", "type": "FUNCTION_BLOCK", "name": "LGF_SimpleAveraging", "vars": [{"name": "cyclicExecution", "type": "Bool", "description": "TRUE: cyclic operation, trigger not in use"}, {"name": "trigger", "type": "Bool", "description": "Rising edge: Read in `value` with every pulse at input\n`trigger`"}, {"name": "reset", "type": "Bool", "description": "TRUE: The block is reset and the calculation starts\nagain."}, {"name": "value", "type": "LReal", "description": "Value/s from which the moving average is to be\ndetermined."}, {"name": "windowSize", "type": "USInt", "description": "Window length for averaging in the range from 1..255"}, {"name": "average", "type": "LReal", "description": "Moving / Floating average"}, {"name": "overflow", "type": "Bool", "description": "TRUE: Overflow detected in the calculation"}], "input": [{"name": "cyclicExecution", "type": "Bool", "description": "TRUE: cyclic operation, trigger not in use"}, {"name": "trigger", "type": "Bool", "description": "Rising edge: Read in `value` with every pulse at input\n`trigger`"}, {"name": "reset", "type": "Bool", "description": "TRUE: The block is reset and the calculation starts\nagain."}, {"name": "value", "type": "LReal", "description": "Value/s from which the moving average is to be\ndetermined."}, {"name": "windowSize", "type": "USInt", "description": "Window length for averaging in the range from 1..255"}], "output": [{"name": "average", "type": "LReal", "description": "Moving / Floating average"}, {"name": "overflow", "type": "Bool", "description": "TRUE: Overflow detected in the calculation"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_SimpleAveraging\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_FloatingAverage\n   VAR_INPUT \n      cyclicExecution : Bool;\n      trigger : Bool;\n      reset : Bool;\n      value : LReal;\n      windowSize : USInt := 5;\n   END_VAR\n\n   VAR_OUTPUT \n      average { ExternalWritable := 'False'} : LReal;\n      overflow { ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR \n      statValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statAverage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 0.0;\n      statWindowSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;\n      statOverflow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statTriggerOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_LREAL : LReal := 0.0;\n      LGF_LREAL_MAX_NORM : LReal := 16#7FEF_FFFF_FFFF_FFFF;\n      LGF_LREAL_MIN_NORM : LReal := 16#0010_0000_0000_0000;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_SimpleAveraging\n\t  // Comment/Function: This function calculates a moving arithmetic mean value from LReal values.\n\t  //                   The method can be used to smooth data series, values can be read in cyclically or triggered.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled, forced to true - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 18.07.2024 | Simatic Systems Support\n\t  //                       | First Release\n\t  //===============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Floating average calculation\n\t  // Copy commonly used data to temp variables\n\t  #statValue := #value;\n\t  \n\t  // Reset OR window size changes the calculation\n\t  IF #reset THEN\n\t    #statAverage := #ZERO_LREAL;\n\t    \n\t    // Triggered calculation OR cyclicly operation\n\t    // Positive edge detection for triggering of calculation\n\t  ELSIF FALSE\n\t    OR #cyclicExecution\n\t    OR #trigger AND NOT #statTriggerOld\n\t  THEN\n\t    IF #statWindowSize > 1 THEN\n\t      // Actual NEW = (previous * (averageNumber - 1) + actual) / averageNumber;\n\t      #statAverage := (#statAverage * (#statWindowSize - 1) + #statValue) / #statWindowSize;\n\t      #statOverflow := (ABS(#statValue) <> #ZERO_LREAL) AND (FALSE\n\t      OR ((#LGF_LREAL_MIN_NORM * #statWindowSize) > ABS(#statValue))\n\t      OR ((#LGF_LREAL_MAX_NORM / #statWindowSize) < ABS(#statValue))\n\t      );\n\t    ELSE\n\t      #statAverage := #statValue;\n\t      #statOverflow := FALSE;\n\t    END_IF;\n\t  END_IF;\n\t  #statTriggerOld := #trigger;\n\t  #statWindowSize := #windowSize;\n\tEND_REGION\n\t\n\tREGION Outputs\n\t  #average := #statAverage;\n\t  #overflow := #statOverflow;\n\t  \n\t  // ENO mechanism is not used - forced to true\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "StoreMinMax", "description": "This function reads-in a value of a variable at each call and outputs the maximum and minimum value that has been read in since the first call. The evaluation can be reset if necessary. The block supports the data type LReal.", "type": "FUNCTION_BLOCK", "name": "LGF_StoreMinMax", "vars": [{"name": "value", "type": "LReal", "description": "Value to be compared with min/max"}, {"name": "reset", "type": "Bool", "description": "TRUE: The min/max history is reset and the evaluation\nstarts over again."}, {"name": "minValue", "type": "LReal", "description": "Minimum value since first call or `reset`."}, {"name": "maxValue", "type": "LReal", "description": "Maximum values since first call or `reset`."}], "input": [{"name": "value", "type": "LReal", "description": "Value to be compared with min/max"}, {"name": "reset", "type": "Bool", "description": "TRUE: The min/max history is reset and the evaluation\nstarts over again."}], "output": [{"name": "minValue", "type": "LReal", "description": "Minimum value since first call or `reset`."}, {"name": "maxValue", "type": "LReal", "description": "Maximum values since first call or `reset`."}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_StoreMinMax\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_MinMaxHistory\n   VAR_INPUT \n      value : LReal := 0.0;\n      reset : Bool := false;\n   END_VAR\n\n   VAR_OUTPUT \n      minValue { ExternalWritable := 'False'} : LReal := 0.0;\n      maxValue { ExternalWritable := 'False'} : LReal := 0.0;\n   END_VAR\n\n   VAR \n      statStoreMinValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := #LREAL_MAX;\n      statStoreMaxValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := #LREAL_MIN;\n   END_VAR\n\n   VAR CONSTANT \n      LREAL_MAX : LReal := 1.7976931348623157e+308;\n      LREAL_MIN : LReal := -1.7976931348623157e+308;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_MinMaxHistory\n\t  // Comment/Function: This function block saves the minimum and maximum value,\n\t  //                   since the start of the block.\n\t  //                   ENO disabled - no error handling, no failure possible\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     -\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  //                      Code optimization\n\t  // 01.00.02 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.03 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.04 09.10.2019  Simatic Systems Support\n\t  //                      Regions, comments and constants are added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 04.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION Compare values\n\t  // Save min value\n\t  IF (#value < #statStoreMinValue) THEN\n\t    #statStoreMinValue := #value;\n\t  END_IF;\n\t  \n\t  // Save max value\n\t  IF (#value > #statStoreMaxValue) THEN\n\t    #statStoreMaxValue := #value;\n\t  END_IF;\n\t  \n\t  // If reset is TRUE, min and max value are set to #LREAL_MAX and #LREAL_MIN respectively\n\t  IF #reset THEN\n\t    #statStoreMinValue := #LREAL_MAX;\n\t    #statStoreMaxValue := #LREAL_MIN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  #minValue := #statStoreMinValue;\n\t  #maxValue := #statStoreMaxValue;\n\t  \n\t  //ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "MatrixAddition", "description": "This block adds two matrices of equal size of the data type ARRAY[*,*] of LREAL. The individual fields of the two incoming matrices are read, added and then output in the matrix matrixResult. 𝑎 11 ⋯ 𝑎 1𝑛 𝑏 11 ⋯ 𝑏 1𝑛 𝑎 11 +𝑏 11 ⋯ 𝑎 1𝑛 +𝑏 1𝑛 𝑟𝑒𝑠𝑢𝑙𝑡=[ ⋮ ⋱ ⋮ ]+[ ⋮ ⋱ ⋮ ]=[ ⋮ ⋱ ⋮ ] 𝑎 𝑚1 ⋯ 𝑎 𝑚𝑛 𝑏 𝑚1 ⋯ 𝑏 𝑚𝑛 𝑎 𝑚1 +𝑏 𝑚1 ⋯ 𝑎 𝑚𝑛 +𝑏 𝑚𝑛 Note Note that all input and output matrices must have the same low and high limits and therefore the same number of columns and rows.", "type": "FUNCTION", "name": "LGF_MatrixAddition", "vars": [{"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "matrix1", "type": "Array[*, *] of L\nReal", "description": "First summand (matrix)"}, {"name": "matrix2", "type": "Array[*, *] of L\nReal", "description": "Second summand (matrix)"}, {"name": "matrixResult", "type": "Array[*, *] of L\nReal", "description": "Sum of the matrices"}], "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of L\nReal", "description": "First summand (matrix)"}, {"name": "matrix2", "type": "Array[*, *] of L\nReal", "description": "Second summand (matrix)"}, {"name": "matrixResult", "type": "Array[*, *] of L\nReal", "description": "Sum of the matrices"}], "answer": "FUNCTION \"LGF_MatrixAddition\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_MatrixAddition\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      matrix1 : Array[*, *] of LReal;\n      matrix2 : Array[*, *] of LReal;\n      matrixResult : Array[*, *] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempMatrix1LowerBoundRows : DInt;\n      tempMatrix1LowerBoundColumns : DInt;\n      tempMatrix1UpperBoundRows : DInt;\n      tempMatrix1UpperBoundColumns : DInt;\n      tempMatrix2LowerBoundRows : DInt;\n      tempMatrix2LowerBoundColumns : DInt;\n      tempMatrix2UpperBoundRows : DInt;\n      tempMatrix2UpperBoundColumns : DInt;\n      tempResultMatrixLowerBoundRows : DInt;\n      tempResultMatrixLowerBoundColumns : DInt;\n      tempResultMatrixUpperBoundRows : DInt;\n      tempResultMatrixUpperBoundColumns : DInt;\n      tempCounterRows : DInt;\n      tempCounterColumns : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ROWS : UInt := 1;\n      COLUMNS : UInt := 2;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS : Word := 16#8200;\n      ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS : Word := 16#8201;\n      ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS : Word := 16#8202;\n      ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS : Word := 16#8203;\n      ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS : Word := 16#8204;\n      ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS : Word := 16#8205;\n      ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS : Word := 16#8206;\n      ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS : Word := 16#8207;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_MatrixAddition\n\t  // Comment/Function: Caluclates the sum of two matrices\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 02.00.00 06.02.2017  Siemens Industry Online Support\n\t  //                      Functionality using Array[*,*]\n\t  // 02.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 02.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 02.00.08 13.11.2019  Simatic Systems Support\n\t  //                      Regions, comments and constants are added\n\t  //                      Moved matrices to IO field.\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 02.02.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Getting matrices size\n\t  //Determine the size of the matrices\n\t  // Lower bound rows\n\t  #tempMatrix1LowerBoundRows := LOWER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2LowerBoundRows := LOWER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  #tempResultMatrixLowerBoundRows := LOWER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Lower bound columns\n\t  #tempMatrix1LowerBoundColumns := LOWER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2LowerBoundColumns := LOWER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\t  #tempResultMatrixLowerBoundColumns := LOWER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\t  \n\t  // Upper bound rows\n\t  #tempMatrix1UpperBoundRows := UPPER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2UpperBoundRows := UPPER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  #tempResultMatrixUpperBoundRows := UPPER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Upper bound columns\n\t  #tempMatrix1UpperBoundColumns := UPPER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2UpperBoundColumns := UPPER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\t  #tempResultMatrixUpperBoundColumns := UPPER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\tEND_REGION\n\t\n\tREGION Error evaluation of matrixes dimentions\n\t  //Check the lower bound of all matrices\n\t  IF (#tempMatrix1LowerBoundRows <> #tempMatrix2LowerBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundRows <> #tempResultMatrixLowerBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundColumns <> #tempMatrix2LowerBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundColumns <> #tempResultMatrixLowerBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS;\n\t    RETURN;\n\t  END_IF;\n\t  //Check the upper bound of all matrices\n\t  IF (#tempMatrix1UpperBoundRows <> #tempMatrix2UpperBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundRows <> #tempResultMatrixUpperBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundColumns <> #tempMatrix2UpperBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundColumns <> #tempResultMatrixUpperBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Addition of the matrices and writting to output\n\t  FOR #tempCounterRows := #tempMatrix1LowerBoundRows TO #tempMatrix1UpperBoundRows DO\n\t    FOR #tempCounterColumns := #tempMatrix1LowerBoundColumns TO #tempMatrix1UpperBoundColumns DO\n\t      #matrixResult[#tempCounterRows, #tempCounterColumns] := #matrix1[#tempCounterRows, #tempCounterColumns] + #matrix2[#tempCounterRows, #tempCounterColumns];\n\t    END_FOR;\n\t  END_FOR;\n\t  \n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "MatrixCompare", "description": "This function compares two matrices of the data type ARRAY[*,*] of LREAL of equal size. If both matrices are identical, the return value of the function is set to TRUE. Note Note that all input matrices must have the same lower and upper limit, and, therefore, the same number of columns and rows.", "type": "FUNCTION", "name": "LGF_MatrixCompare", "vars": [{"name": "Ret_Val", "type": "Bool", "description": "TRUE: Both matrices are identical."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "matrix1", "type": "Array[*, *] of L\nReal", "description": "First Matrix"}, {"name": "matrix2", "type": "Array[*, *] of L\nReal", "description": "Second Matrix"}], "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of L\nReal", "description": "First Matrix"}, {"name": "matrix2", "type": "Array[*, *] of L\nReal", "description": "Second Matrix"}], "answer": "FUNCTION \"LGF_MatrixCompare\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_MatrixCompare\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      matrix1 : Array[*, *] of LReal;\n      matrix2 : Array[*, *] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempMatrix1LowerBoundRows : DInt;\n      tempMatrix1LowerBoundColumns : DInt;\n      tempMatrix1UpperBoundRows : DInt;\n      tempMatrix1UpperBoundColumns : DInt;\n      tempMatrix2LowerBoundRows : DInt;\n      tempMatrix2LowerBoundColumns : DInt;\n      tempMatrix2UpperBoundRows : DInt;\n      tempMatrix2UpperBoundColumns : DInt;\n      tempCounterRows : DInt;\n      tempCounterColumns : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ROWS : UInt := 1;\n      COLUMNS : UInt := 2;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS : Word := 16#8200;\n      ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS : Word := 16#8201;\n      ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS : Word := 16#8202;\n      ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS : Word := 16#8203;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_MatrixCompare\n\t  // Comment/Function: Compares two matrices\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 13.11.2019  Simatic Systems Support\n\t  //                      First release\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 02.02.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Getting matrices size\n\t  //Determine the size of the matrices\n\t  // Lower bound rows\n\t  #tempMatrix1LowerBoundRows := LOWER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2LowerBoundRows := LOWER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  // Lower bound columns\n\t  #tempMatrix1LowerBoundColumns := LOWER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2LowerBoundColumns := LOWER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\t  \n\t  // Upper bound rows\n\t  #tempMatrix1UpperBoundRows := UPPER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2UpperBoundRows := UPPER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  // Upper bound columns\n\t  #tempMatrix1UpperBoundColumns := UPPER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2UpperBoundColumns := UPPER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\tEND_REGION\n\t\n\tREGION Error evaluation of matrixes dimentions\n\t  //Check the lower bound of the matrices\n\t  IF (#tempMatrix1LowerBoundRows <> #tempMatrix2LowerBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS;\n\t    #LGF_MatrixCompare := false;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundColumns <> #tempMatrix2LowerBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS;\n\t    #LGF_MatrixCompare := false;\n\t    RETURN;\n\t  END_IF;\n\t  //Check the upper bound of the matrices\n\t  IF (#tempMatrix1UpperBoundRows <> #tempMatrix2UpperBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS;\n\t    #LGF_MatrixCompare := false;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundColumns <> #tempMatrix2UpperBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS;\n\t    #LGF_MatrixCompare := false;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Comparison of the matices\n\t  FOR #tempCounterRows := #tempMatrix1LowerBoundRows TO #tempMatrix1UpperBoundRows DO\n\t    FOR #tempCounterColumns := #tempMatrix1LowerBoundColumns TO #tempMatrix1UpperBoundColumns DO\n\t      //Each element must be equal to the corresponding element from the other matrix\n\t      IF #matrix1[#tempCounterRows, #tempCounterColumns] <> #matrix2[#tempCounterRows, #tempCounterColumns] THEN\n\t        // elelmts do not match, return false \n\t        #LGF_MatrixCompare := false;\n\t        #error := false;\n\t        #status := #STATUS_NO_ERROR;\n\t        RETURN;\n\t      END_IF;\n\t    END_FOR;\n\t  END_FOR;\n\t  \n\t  // loop runs trough all array places, all are identical\n\t  #LGF_MatrixCompare := true;\n\t  \n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "MatrixInverse", "description": "This function inverts a square matrix of the data type ARRAY[*,*] of LREAL. The square matrix of any size will be inverted according to the Shipley-Coleman method. 𝑚𝑎𝑡𝑟𝑖𝑥𝑅𝑒𝑠𝑢𝑙𝑡=𝑚𝑎𝑡𝑟𝑖𝑥−1 Note Note that the input matrix must be square. This means that the number of rows must be equal to the number of columns. The output matrix must be the same size and have the same array boundaries as the input matrix.", "type": "FUNCTION", "name": "LGF_MatrixInverse", "vars": [{"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "matrix", "type": "Array[*, *] of L\nReal", "description": "Square input matrix that will be inversed (Array[0..x, 0..x] of REAL)"}, {"name": "matrixResult", "type": "Array[*, *] of L\nReal", "description": "Inverted matrix"}], "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "matrix", "type": "Array[*, *] of L\nReal", "description": "Square input matrix that will be inversed (Array[0..x, 0..x] of REAL)"}, {"name": "matrixResult", "type": "Array[*, *] of L\nReal", "description": "Inverted matrix"}], "answer": "FUNCTION \"LGF_MatrixInverse\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_MatrixInverse\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      matrix : Array[*, *] of LReal;\n      matrixResult : Array[*, *] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempMatrix1LowerBoundRows : DInt;\n      tempMatrix1LowerBoundColumns : DInt;\n      tempMatrix1UpperBoundRows : DInt;\n      tempMatrix1UpperBoundColumns : DInt;\n      tempResultMatrixLowerBoundRows : DInt;\n      tempResultMatrixLowerBoundColumns : DInt;\n      tempResultMatrixUpperBoundRows : DInt;\n      tempResultMatrixUpperBoundColumns : DInt;\n      tempCounterRows : DInt;\n      tempCounterColumns : DInt;\n      tempColumns : DInt;\n      tempRows : DInt;\n      tempK : DInt;\n      tempI : DInt;\n      tempJ : DInt;\n      tempMatrixElement : LReal;\n   END_VAR\n\n   VAR CONSTANT \n      PRECISION : LReal := 1.0E-10;\n      NEGATIVE_NUMERATOR : LReal := -1.0;\n      ZERO : UInt := 0;\n      ONE : UInt := 1;\n      ROWS : UInt := 1;\n      COLUMNS : UInt := 2;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NOT_SQUARE_MATRIX : Word := 16#8200;\n      ERR_ALGORITHM_NOT_POSSIBLE : Word := 16#8201;\n      ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS : Word := 16#8202;\n      ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS : Word := 16#8203;\n      ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS : Word := 16#8204;\n      ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS : Word := 16#8205;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_MatrixInverse\n\t  // Comment/Function: Caluclates an inverted version of a matrix\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 02.00.00 06.02.2017  Siemens Industry Online Support\n\t  //                      Functionality using Array[*,*]\n\t  // 02.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 02.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 02.00.05 13.11.2019  Simatic Systems Support\n\t  //                      Regions, comments and constants are added\n\t  //                      Moved matrices to IO field.\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 02.02.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=================================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Determine the size of the matrices\n\t  // Lower bound rows\n\t  #tempMatrix1LowerBoundRows := LOWER_BOUND(ARR := #matrix, DIM := #ROWS);\n\t  #tempResultMatrixLowerBoundRows := LOWER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Lower bound columns\n\t  #tempMatrix1LowerBoundColumns := LOWER_BOUND(ARR := #matrix, DIM := #COLUMNS);\n\t  #tempResultMatrixLowerBoundColumns := LOWER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\t  // Upper bound rows\n\t  #tempMatrix1UpperBoundRows := UPPER_BOUND(ARR := #matrix, DIM := #ROWS);\n\t  #tempResultMatrixUpperBoundRows := UPPER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Upper bound columns\n\t  #tempMatrix1UpperBoundColumns := UPPER_BOUND(ARR := #matrix, DIM := #COLUMNS);\n\t  #tempResultMatrixUpperBoundColumns := UPPER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\tEND_REGION\n\t\n\tREGION Count the columns and rows of input matrix\n\t  // Count the columns\n\t  IF #tempMatrix1LowerBoundColumns = #ZERO THEN\n\t    #tempColumns := #tempMatrix1UpperBoundColumns + #ONE;\n\t  ELSE\n\t    #tempColumns := (#tempMatrix1UpperBoundColumns - #tempMatrix1LowerBoundColumns) + #ONE;\n\t  END_IF;\n\t  // Count the rows\n\t  IF #tempMatrix1LowerBoundRows = #ZERO THEN\n\t    #tempRows := #tempMatrix1UpperBoundRows + #ONE;\n\t  ELSE\n\t    #tempRows := (#tempMatrix1UpperBoundRows - #tempMatrix1LowerBoundRows) + #ONE;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Error validation\n\t  // Check whether input matrix is a square matrix\n\t  IF #tempRows <> #tempColumns THEN\n\t    #error := TRUE;\n\t    #status := #ERR_NOT_SQUARE_MATRIX;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Output matrix must have same lower bounds as the input matrix. (Same array size)\n\t  IF (#tempMatrix1LowerBoundRows <> #tempResultMatrixLowerBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundColumns <> #tempResultMatrixLowerBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS;\n\t    RETURN;\n\t  END_IF;\n\t  // Output matrix must have same upper bounds as the input matrix. (Same array size)\n\t  IF (#tempMatrix1UpperBoundRows <> #tempResultMatrixUpperBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundColumns <> #tempResultMatrixUpperBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of the inversed matrix\n\t  #matrixResult[#tempMatrix1LowerBoundRows, #tempMatrix1LowerBoundColumns] := #ZERO;\n\t  // Negate the input matrix and copy to output matrix.\n\t  FOR #tempCounterRows := #tempMatrix1LowerBoundRows TO #tempMatrix1UpperBoundRows DO\n\t    FOR #tempCounterColumns := #tempMatrix1LowerBoundColumns TO #tempMatrix1UpperBoundColumns DO\n\t      #matrixResult[#tempCounterRows, #tempCounterColumns] := - #matrix[#tempCounterRows, #tempCounterColumns];\n\t    END_FOR;\n\t  END_FOR;\n\t  \n\t  //Outside loop - relegation of \"Main\" diagonal\n\t  FOR #tempK := #tempMatrix1LowerBoundColumns TO #tempMatrix1UpperBoundColumns DO\n\t    // Avoid a division by zero --> Error: Algorithm does not work for the input matrix.\n\t    \n\t    #tempMatrixElement := #matrixResult[#tempK, #tempK];\n\t    IF ABS(#tempMatrixElement - #ZERO) <= (#PRECISION * ABS(#tempMatrixElement)) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_ALGORITHM_NOT_POSSIBLE;\n\t      RETURN;\n\t    END_IF;\n\t    \n\t    //Calculation of Pivot-element\n\t    #tempMatrixElement := (#NEGATIVE_NUMERATOR / #tempMatrixElement);\n\t    #matrixResult[#tempK, #tempK] := #tempMatrixElement;\n\t    \n\t    //Calculation of elemente in the Pivot-column.\n\t    FOR #tempI := #tempMatrix1LowerBoundColumns TO #tempMatrix1UpperBoundColumns DO\n\t      IF #tempI <> #tempK THEN\n\t        #matrixResult[#tempI, #tempK] :=\n\t        #matrixResult[#tempI, #tempK] * #matrixResult[#tempK, #tempK];\n\t      END_IF;\n\t    END_FOR;\n\t    \n\t    // Convert-calculation of elements, which are NOT in the Pivot-rolumn AND NOT in the Pivot-row.\n\t    FOR #tempI := #tempMatrix1LowerBoundRows TO #tempMatrix1UpperBoundRows DO\n\t      IF #tempI <> #tempK THEN\n\t        FOR #tempJ := #tempMatrix1LowerBoundColumns TO #tempMatrix1UpperBoundColumns DO\n\t          IF #tempJ <> #tempK THEN\n\t            #matrixResult[#tempI, #tempJ] :=\n\t            #matrixResult[#tempI, #tempJ] + #matrixResult[#tempI, #tempK] * #matrixResult[#tempK, #tempJ];\n\t          END_IF;\n\t        END_FOR;\n\t      END_IF;\n\t    END_FOR;\n\t    \n\t    //Calculation of elements in the Pivot-row.\n\t    FOR #tempJ := #tempMatrix1LowerBoundColumns TO #tempMatrix1UpperBoundColumns DO\n\t      IF #tempJ <> #tempK THEN\n\t        #matrixResult[#tempK, #tempJ] :=\n\t        #matrixResult[#tempK, #tempJ] * #matrixResult[#tempK, #tempK];\n\t      END_IF;\n\t    END_FOR;\n\t  END_FOR;\n\t  \n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "MatrixMultiplication", "description": "This function multiplies two matrices of the data type ARRAY[*,*] of LREAL.", "type": "FUNCTION", "name": "LGF_MatrixMultiplication", "vars": [{"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "matrix1", "type": "Array[*, *] of L\nReal", "description": "First factor: Matrix to multiply"}, {"name": "matrix2", "type": "Array[*, *] of L\nReal", "description": "Second factor: Matrix to multiply"}, {"name": "matrixResult", "type": "Array[*, *] of L\nReal", "description": "Product: The resulting matrix"}], "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of L\nReal", "description": "First factor: Matrix to multiply"}, {"name": "matrix2", "type": "Array[*, *] of L\nReal", "description": "Second factor: Matrix to multiply"}, {"name": "matrixResult", "type": "Array[*, *] of L\nReal", "description": "Product: The resulting matrix"}], "answer": "FUNCTION \"LGF_MatrixMultiplication\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_MatrixMultiplication\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      matrix1 : Array[*, *] of LReal;\n      matrix2 : Array[*, *] of LReal;\n      matrixResult : Array[*, *] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempMatrix1LowerBoundRows : DInt;\n      tempMatrix1LowerBoundColumns : DInt;\n      tempMatrix1UpperBoundRows : DInt;\n      tempMatrix1UpperBoundColumns : DInt;\n      tempMatrix2LowerBoundRows : DInt;\n      tempMatrix2LowerBoundColumns : DInt;\n      tempMatrix2UpperBoundRows : DInt;\n      tempMatrix2UpperBoundColumns : DInt;\n      tempResultMatrixLowerBoundRows : DInt;\n      tempResultMatrixLowerBoundColumns : DInt;\n      tempResultMatrixUpperBoundRows : DInt;\n      tempResultMatrixUpperBoundColumns : DInt;\n      tempJ : DInt;\n      tempK : DInt;\n      tempL : DInt;\n      tempResult : LReal;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : Real := 0.0;\n      ROWS : UInt := 1;\n      COLUMNS : UInt := 2;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_ROWS : Word := 16#8200;\n      ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_ROWS : Word := 16#8201;\n      ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS : Word := 16#8202;\n      ERR_MATR2_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS : Word := 16#8203;\n      ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS : Word := 16#8204;\n      ERR_MATR2_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS : Word := 16#8205;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_MatrixMultiplication\n\t  // Comment/Function: Caluclates the multiplication of two matrices\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 02.00.00 06.02.2017  Siemens Industry Online Support\n\t  //                      Functionality using Array[*,*]\n\t  // 02.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 02.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 02.00.06 13.11.2019  Simatic Systems Support\n\t  //                      Regions, comments and constants are added\n\t  //                      Moved matrices to IO field.\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 02.02.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=================================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Getting matrices size\n\t  //Determine the size of the matrices\n\t  // Lower bound rows\n\t  #tempMatrix1LowerBoundRows := LOWER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2LowerBoundRows := LOWER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  #tempResultMatrixLowerBoundRows := LOWER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Lower bound columns\n\t  #tempMatrix1LowerBoundColumns := LOWER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2LowerBoundColumns := LOWER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\t  #tempResultMatrixLowerBoundColumns := LOWER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\t  \n\t  // Upper bound rows\n\t  #tempMatrix1UpperBoundRows := UPPER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2UpperBoundRows := UPPER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  #tempResultMatrixUpperBoundRows := UPPER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Upper bound columns\n\t  #tempMatrix1UpperBoundColumns := UPPER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2UpperBoundColumns := UPPER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\t  #tempResultMatrixUpperBoundColumns := UPPER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\tEND_REGION\n\t\n\tREGION Error evaluation of matrices dimentions\n\t  // Matrix one must have the same count of rows as matrix two has columns. Else the multiplication is not possible.\n\t  IF #tempMatrix1LowerBoundColumns <> #tempMatrix2LowerBoundRows THEN\n\t    #error := true;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF #tempMatrix1UpperBoundColumns <> #tempMatrix2UpperBoundRows THEN\n\t    #error := true;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_ROWS;\n\t    RETURN;\n\t  END_IF;\n\t  // Result matrix must have the same number of rows as matrix 1 and the same number of columns as the matrix 2.\n\t  IF (#tempMatrix1LowerBoundRows <> #tempResultMatrixLowerBoundRows) THEN\n\t    #error := true;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundRows <> #tempResultMatrixUpperBoundRows) THEN\n\t    #error := true;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix2LowerBoundColumns <> #tempResultMatrixLowerBoundColumns) THEN\n\t    #error := true;\n\t    #status := #ERR_MATR2_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix2UpperBoundColumns <> #tempResultMatrixUpperBoundColumns) THEN\n\t    #error := true;\n\t    #status := #ERR_MATR2_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Multiplication\n\t  //Multiplies each row with each column\n\t  FOR #tempJ := #tempMatrix1LowerBoundRows TO #tempMatrix1UpperBoundRows DO\n\t    FOR #tempK := #tempMatrix2LowerBoundColumns TO #tempMatrix2UpperBoundColumns DO\n\t      #tempResult := #ZERO;\n\t      FOR #tempL := #tempMatrix1LowerBoundColumns TO #tempMatrix1UpperBoundColumns DO\n\t        #tempResult := #tempResult + #matrix1[#tempJ, #tempL] * #matrix2[#tempL, #tempK];\n\t      END_FOR;\n\t      #matrixResult[#tempJ, #tempK] := #tempResult;\n\t    END_FOR;\n\t  END_FOR;\n\t  \n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "MatrixScalarMultiplication", "description": "This function block multiplies a matrix of the data type ARRAY[*,*] of LREAL with a scalar.", "type": "FUNCTION", "name": "LGF_MatrixScalarMultiplication", "vars": [{"name": "scalar", "type": "LReal", "description": "Scalar value where the matrix is multiplied"}, {"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "matrixInput", "type": "Array[*, *] of L\nReal", "description": "Matrix to multiply"}, {"name": "matrixResult", "type": "Array[*, *] of L\nReal", "description": "The result matrix of the multiplication"}], "input": [{"name": "scalar", "type": "LReal", "description": "Scalar value where the matrix is multiplied"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "matrixInput", "type": "Array[*, *] of L\nReal", "description": "Matrix to multiply"}, {"name": "matrixResult", "type": "Array[*, *] of L\nReal", "description": "The result matrix of the multiplication"}], "answer": "FUNCTION \"LGF_MatrixScalarMultiplication\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_MatrixScalarMultiplication\n   VAR_INPUT \n      scalar : LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      matrixInput : Array[*, *] of LReal;\n      matrixResult : Array[*, *] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempMatrixInLowerBoundRows : DInt;\n      tempMatrixInLowerBoundColumns : DInt;\n      tempMatrixInUpperBoundRows : DInt;\n      tempMatrixInUpperBoundColumns : DInt;\n      tempResultMatrixLowerBoundRows : DInt;\n      tempResultMatrixLowerBoundColumns : DInt;\n      tempResultMatrixUpperBoundRows : DInt;\n      tempResultMatrixUpperBoundColumns : DInt;\n      tempRowIndex : DInt;\n      tempColumIndex : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ROWS : UInt := 1;\n      COLUMNS : UInt := 2;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_MATRICES_LOWER_BOUND_ROWS_DONT_MATCH : Word := 16#8201;\n      ERR_MATRICES_UPPER_BOUND_ROWS_DONT_MATCH : Word := 16#8202;\n      ERR_MATRICES_LOWER_BOUND_COLUMNS_DONT_MATCH : Word := 16#8203;\n      ERR_MATRICES_UPPER_BOUND_COLUMNS_DONT_MATCH : Word := 16#8204;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_MatrixScalarMultiplication\n\t  // Comment/Function: Caluclates the multiplication of one matrix and a scalar value\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 11.12.2019  Simatic Systems Support\n\t  //                      First released version\n\t  //                      based on \"LGF_MatrixMultiplication\"\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 02.02.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  // 03.00.02 18.07.2020  Simatic Systems Support\n\t  //                      Fix bug regarding wrong calculation\n\t  //=================================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Getting matrices size\n\t  //Determine the size of the matrices\n\t  // Lower bound rows\n\t  #tempMatrixInLowerBoundRows := LOWER_BOUND(ARR := #matrixInput, DIM := #ROWS);\n\t  #tempResultMatrixLowerBoundRows := LOWER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Lower bound columns\n\t  #tempMatrixInLowerBoundColumns := LOWER_BOUND(ARR := #matrixInput, DIM := #COLUMNS);\n\t  #tempResultMatrixLowerBoundColumns := LOWER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\t  \n\t  // Upper bound rows\n\t  #tempMatrixInUpperBoundRows := UPPER_BOUND(ARR := #matrixInput, DIM := #ROWS);\n\t  #tempResultMatrixUpperBoundRows := UPPER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Upper bound columns\n\t  #tempMatrixInUpperBoundColumns := UPPER_BOUND(ARR := #matrixInput, DIM := #COLUMNS);\n\t  #tempResultMatrixUpperBoundColumns := UPPER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\tEND_REGION\n\t\n\tREGION Error evaluation of matrices dimentions\n\t  // Result matrix must have the same number of rows as matrix 1 and the same number of columns as the matrix 2.\n\t  IF (#tempMatrixInLowerBoundRows <> #tempResultMatrixLowerBoundRows) THEN\n\t    #error := true;\n\t    #status := #ERR_MATRICES_LOWER_BOUND_ROWS_DONT_MATCH;\n\t    RETURN;\n\t  ELSIF (#tempMatrixInUpperBoundRows <> #tempResultMatrixUpperBoundRows) THEN\n\t    #error := true;\n\t    #status := #ERR_MATRICES_UPPER_BOUND_ROWS_DONT_MATCH;\n\t    RETURN;\n\t  ELSIF (#tempMatrixInLowerBoundColumns <> #tempResultMatrixLowerBoundColumns) THEN\n\t    #error := true;\n\t    #status := #ERR_MATRICES_LOWER_BOUND_COLUMNS_DONT_MATCH;\n\t    RETURN;\n\t  ELSIF (#tempMatrixInUpperBoundColumns <> #tempResultMatrixUpperBoundColumns) THEN\n\t    #error := true;\n\t    #status := #ERR_MATRICES_UPPER_BOUND_COLUMNS_DONT_MATCH;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Multiplication\n\t  //Multiplies each row with each column\n\t  FOR #tempRowIndex := #tempMatrixInLowerBoundRows TO #tempMatrixInUpperBoundRows DO\n\t    FOR #tempColumIndex := #tempMatrixInLowerBoundColumns TO #tempMatrixInUpperBoundColumns DO\n\t      // result is input matrix element multiplied with the scalar\n\t      #matrixResult[#tempRowIndex, #tempColumIndex] := #matrixInput[#tempRowIndex, #tempColumIndex] * #scalar;\n\t    END_FOR;\n\t  END_FOR;\n\t  \n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "MatrixSubtraction", "description": "This function subtracts a matrix of the data type ARRAY[*,*] of LREAL from another one. The individual fields of the two matrices are read, subtracted and then output in the matrix matrixResult. 𝑎 11 ⋯ 𝑎 1𝑛 𝑏 11 ⋯ 𝑏 1𝑛 𝑎 11 −𝑏 11 ⋯ 𝑎 1𝑛 −𝑏 1𝑛 𝑟𝑒𝑠𝑢𝑙𝑡=[ ⋮ ⋱ ⋮ ]−[ ⋮ ⋱ ⋮ ]=[ ⋮ ⋱ ⋮ ] 𝑎 𝑚1 ⋯ 𝑎 𝑚𝑛 𝑏 𝑚1 ⋯ 𝑏 𝑚𝑛 𝑎 𝑚1 −𝑏 𝑚1 ⋯ 𝑎 𝑚𝑛 −𝑏 𝑚𝑛 Note Note that all input and output matrices must have the same number of columns and rows.", "type": "FUNCTION", "name": "LGF_MatrixSubtraction", "vars": [{"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "matrix1", "type": "Array[*, *] of L\nReal", "description": "First matrix - minuend"}, {"name": "matrix2", "type": "Array[*, *] of L\nReal", "description": "Second matrix - subtrahend"}, {"name": "matrixResult", "type": "Array[*, *] of L\nReal", "description": "Sum of the matrices"}], "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of L\nReal", "description": "First matrix - minuend"}, {"name": "matrix2", "type": "Array[*, *] of L\nReal", "description": "Second matrix - subtrahend"}, {"name": "matrixResult", "type": "Array[*, *] of L\nReal", "description": "Sum of the matrices"}], "answer": "FUNCTION \"LGF_MatrixSubtraction\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_MatrixSubtraction\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      matrix1 : Array[*, *] of LReal;\n      matrix2 : Array[*, *] of LReal;\n      matrixResult : Array[*, *] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempMatrix1LowerBoundRows : DInt;\n      tempMatrix1LowerBoundColumns : DInt;\n      tempMatrix1UpperBoundRows : DInt;\n      tempMatrix1UpperBoundColumns : DInt;\n      tempMatrix2LowerBoundRows : DInt;\n      tempMatrix2LowerBoundColumns : DInt;\n      tempMatrix2UpperBoundRows : DInt;\n      tempMatrix2UpperBoundColumns : DInt;\n      tempResultMatrixLowerBoundRows : DInt;\n      tempResultMatrixLowerBoundColumns : DInt;\n      tempResultMatrixUpperBoundRows : DInt;\n      tempResultMatrixUpperBoundColumns : DInt;\n      tempCounterRows : DInt;\n      tempCounterColumns : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ROWS : UInt := 1;\n      COLUMNS : UInt := 2;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS : Word := 16#8200;\n      ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS : Word := 16#8201;\n      ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS : Word := 16#8202;\n      ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS : Word := 16#8203;\n      ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS : Word := 16#8204;\n      ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS : Word := 16#8205;\n      ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS : Word := 16#8206;\n      ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS : Word := 16#8207;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_MatrixSubtraction\n\t  // Comment/Function: Caluclates the difference of two matrices with same boundries\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 02.00.00 06.02.2017  Siemens Industry Online Support\n\t  //                      Functionality using Array[*,*]\n\t  // 02.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 02.00.06 07.10.2019  Simatic Systems Support\n\t  //                      Regions, comments and constants are added\n\t  //                      Moved matrices to IO field.\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 02.02.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Getting matrices size\n\t  //Determine the size of the matrices\n\t  // Lower bound rows\n\t  #tempMatrix1LowerBoundRows := LOWER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2LowerBoundRows := LOWER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  #tempResultMatrixLowerBoundRows := LOWER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Lower bound columns\n\t  #tempMatrix1LowerBoundColumns := LOWER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2LowerBoundColumns := LOWER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\t  #tempResultMatrixLowerBoundColumns := LOWER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\t  \n\t  // Upper bound rows\n\t  #tempMatrix1UpperBoundRows := UPPER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2UpperBoundRows := UPPER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  #tempResultMatrixUpperBoundRows := UPPER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Upper bound columns\n\t  #tempMatrix1UpperBoundColumns := UPPER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2UpperBoundColumns := UPPER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\t  #tempResultMatrixUpperBoundColumns := UPPER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\tEND_REGION\n\t\n\tREGION Error evaluation of matrixes dimentions\n\t  // Check the lower bound of all matrices\n\t  IF #tempMatrix1LowerBoundRows <> #tempMatrix2LowerBoundRows THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF #tempMatrix1LowerBoundRows <> #tempResultMatrixLowerBoundRows THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF #tempMatrix1LowerBoundColumns <> #tempMatrix2LowerBoundColumns THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS;\n\t    RETURN;\n\t  ELSIF #tempMatrix1LowerBoundColumns <> #tempResultMatrixLowerBoundColumns THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Check the upper bound of all matrices\n\t  IF (#tempMatrix1UpperBoundRows <> #tempMatrix2UpperBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundRows <> #tempResultMatrixUpperBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundColumns <> #tempMatrix2UpperBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundColumns <> #tempResultMatrixUpperBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Subtraction of the matrices and writting to output\n\t  FOR #tempCounterRows := #tempMatrix1LowerBoundRows TO #tempMatrix1UpperBoundRows DO\n\t    FOR #tempCounterColumns := #tempMatrix1LowerBoundColumns TO #tempMatrix1UpperBoundColumns DO\n\t      #matrixResult[#tempCounterRows, #tempCounterColumns] := #matrix1[#tempCounterRows, #tempCounterColumns] - #matrix2[#tempCounterRows, #tempCounterColumns];\n\t    END_FOR;\n\t  END_FOR;\n\t  \n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "MatrixTranspose", "description": "This function transposes a matrix of the data type ARRAY[*,*] of LREAL. Condition: Input matrix (m x n) = output matrix (n x m). A matrix is transposed by making columns out of the rows. 𝑎 ⋯ 𝑎 𝑎 ⋯ 𝑎 11 1𝑛 11 𝑚1 𝐴=[ ⋮ ⋱ ⋮ ];𝐴𝑇 =[ ⋮ ⋱ ⋮ ] 𝑎 ⋯ 𝑎 𝑎 ⋯ 𝑎 𝑚1 𝑚𝑛 1𝑛 𝑚𝑛 Note Note that the number of rows of the input matrix must be equal to the number of columns of the output matrix. Also, the number of columns of the input matrix must be equal to the number of rows of the output matrix.", "type": "FUNCTION", "name": "LGF_MatrixTranspose", "vars": [{"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "matrix", "type": "Array[*, *] of L\nReal", "description": "Matrix to be transposed"}, {"name": "matrixTranspose", "type": "Array[*, *] of L\nReal", "description": "Transposed matrix"}], "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "matrix", "type": "Array[*, *] of L\nReal", "description": "Matrix to be transposed"}, {"name": "matrixTranspose", "type": "Array[*, *] of L\nReal", "description": "Transposed matrix"}], "answer": "FUNCTION \"LGF_MatrixTranspose\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_MatrixTranspose\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      matrix : Array[*, *] of LReal;\n      matrixTranspose : Array[*, *] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempMatrix1LowerBoundRows : DInt;\n      tempMatrix1LowerBoundColumns : DInt;\n      tempMatrix1UpperBoundRows : DInt;\n      tempMatrix1UpperBoundColumns : DInt;\n      tempResultMatrixLowerBoundRows : DInt;\n      tempResultMatrixLowerBoundColumns : DInt;\n      tempResultMatrixUpperBoundRows : DInt;\n      tempResultMatrixUpperBoundColumns : DInt;\n      tempCounterRow : DInt;\n      tempCounterColumn : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ROWS : UInt := 1;\n      COLUMNS : UInt := 2;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_COLUMNS : Word := 16#8200;\n      ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_ROWS : Word := 16#8201;\n      ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_COLUMNS : Word := 16#8202;\n      ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_ROWS : Word := 16#8203;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_MatrixTranspose\n\t  // Comment/Function: Caluclates the transposed matrix of the input matrix\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 02.00.00 06.02.2017  Siemens Industry Online Support\n\t  //                      Functionality using Array[*,*]\n\t  // 02.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 02.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 02.00.07 13.11.2019  Simatic Systems Support\n\t  //                      Regions, comments and constants are added\n\t  //                      Moved matrices to IO field.\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 02.02.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=================================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Determine the size of the matrices\n\t  // Lower bound rows\n\t  #tempMatrix1LowerBoundRows := LOWER_BOUND(ARR := #matrix, DIM := #ROWS);\n\t  #tempResultMatrixLowerBoundRows := LOWER_BOUND(ARR := #matrixTranspose, DIM := #ROWS);\n\t  // Lower bound columns\n\t  #tempMatrix1LowerBoundColumns := LOWER_BOUND(ARR := #matrix, DIM := #COLUMNS);\n\t  #tempResultMatrixLowerBoundColumns := LOWER_BOUND(ARR := #matrixTranspose, DIM := #COLUMNS);\n\t  // Upper bound rows\n\t  #tempMatrix1UpperBoundRows := UPPER_BOUND(ARR := #matrix, DIM := #ROWS);\n\t  #tempResultMatrixUpperBoundRows := UPPER_BOUND(ARR := #matrixTranspose, DIM := #ROWS);\n\t  // Upper bound columns\n\t  #tempMatrix1UpperBoundColumns := UPPER_BOUND(ARR := #matrix, DIM := #COLUMNS);\n\t  #tempResultMatrixUpperBoundColumns := UPPER_BOUND(ARR := #matrixTranspose, DIM := #COLUMNS);\n\tEND_REGION\n\t\n\tREGION Error validation\n\t  // Input matrix lower bound rows must be equal to output matrix lower bound columns.\n\t  IF (#tempMatrix1LowerBoundRows <> #tempResultMatrixLowerBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_COLUMNS;\n\t    RETURN;\n\t    // Input matrix lower bound columns must be equal to output matrix lower bound rows. \n\t  ELSIF (#tempMatrix1LowerBoundColumns <> #tempResultMatrixLowerBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_ROWS;\n\t    RETURN;\n\t    // Input matrix upper bound rows must be equal to output matrix upper bound columns\n\t  ELSIF (#tempMatrix1UpperBoundRows <> #tempResultMatrixUpperBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_COLUMNS;\n\t    RETURN;\n\t    // Input matrix upper bound columns must be equal to output matrix upper bound rows.\n\t  ELSIF (#tempMatrix1UpperBoundColumns <> #tempResultMatrixUpperBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_ROWS;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of the transposed matrix\n\t  FOR #tempCounterRow := #tempMatrix1LowerBoundRows TO #tempMatrix1UpperBoundRows DO\n\t    FOR #tempCounterColumn := #tempMatrix1LowerBoundColumns TO #tempMatrix1UpperBoundColumns DO\n\t      #matrixTranspose[#tempCounterColumn, #tempCounterRow] := #matrix[#tempCounterRow, #tempCounterColumn];\n\t    END_FOR;\n\t  END_FOR;\n\t  \n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  //Set ENO to true\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "CalcCRC16", "description": "The CRC calculation is used for error detection at data transmission. The result of a calculation returns a CRC value via the data sent. The receiver detects a faulty transmission due to the unequal CRC value. The function LGF_CalcCRC16 uses 16 bits as the generator polynomial (mask).", "type": "FUNCTION", "name": "LGF_CalcCRC16", "vars": [{"name": "initValue", "type": "Word", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "Word", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation\n0 = all elements / the whole array"}, {"name": "Ret_Val", "type": "Word", "description": "Calculated CRC value (return value of the function)."}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated."}], "input": [{"name": "initValue", "type": "Word", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "Word", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation\n0 = all elements / the whole array"}], "output": [{"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated."}], "answer": "FUNCTION \"LGF_CalcCRC16\" : Word\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_CRC16\n   VAR_INPUT \n      initValue { S7_PredefinedAssignment := '16#00'} : Word;\n      mask { S7_PredefinedAssignment := '16#00'} : Word;\n      noOfElements { S7_PredefinedAssignment := '0'} : UInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of Byte;\n   END_VAR\n\n   VAR_TEMP \n      tempCRC : Word;\n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempIndexArray : DInt;\n      tempIndexCRC : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      SHIFT_ONE_BIT : UInt := 1;\n      SHIFT_ONE_BYTE : UInt := 8;\n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      CRC_LOOP_LOWER_LIMIT : DInt := 0;\n      CRC_LOOP_UPPER_LIMIT : DInt := 7;\n      ERR_NO_OF_ELEMENTS : Word := 16#8400;\n      STATUS_NO_ERROR : Word := 16#0000;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CRC16\n\t  // Comment/Function: This function makes a CRC calculation according\n\t  //                   to the CRC-16 algorithm\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.03 09.10.2019  Simatic Systems Support\n\t  //                      Code refactoring, comments added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //                      Assign default start values to optional inputs - `initValue`, `mask`\n\t  // 03.01.00 14.04.2023  Simatic Systems Support\n\t  //                      Add input `noOfElements` to assign length to be converted different from array size \n\t  //                      Add outputs `error` and `status` display a wrong assignment to `noOfElements`\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and input data processing\n\t  // Defining initial value for algorithm\n\t  #tempCRC := #initValue;\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // check paramter `noOfELements`, if gretaer than zero check if fits to array size\n\t  IF #noOfElements > 0 THEN\n\t    IF #noOfElements > (#tempUpperLimit - #tempLowerLimit + 1) THEN\n\t      #status := #ERR_NO_OF_ELEMENTS;\n\t      #error := TRUE;\n\t      ENO := FALSE;\n\t      #LGF_CalcCRC16 := #tempCRC;\n\t      RETURN;\n\t    ELSE\n\t      #tempUpperLimit := #tempLowerLimit + #noOfElements - 1;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION CRC calculation\n\t  FOR #tempIndexArray := #tempLowerLimit TO #tempUpperLimit DO\n\t    // Perform division using XOR function for appropriate word in array (with shift byte into MSB of 16bit CRC)\n\t    #tempCRC := #tempCRC XOR SHL(IN := BYTE_TO_WORD(#array[#tempIndexArray]), N := #SHIFT_ONE_BYTE);\n\t    \n\t    FOR #tempIndexCRC := #CRC_LOOP_LOWER_LIMIT TO #CRC_LOOP_UPPER_LIMIT DO\n\t      // Check if MSB is set\n\t      IF #tempCRC.%X15 THEN\n\t        // Shift left and perform division by mask polynomial using XOR function\n\t        #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT) XOR #mask;\n\t      ELSE\n\t        // Shift left without division\n\t        #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT);\n\t      END_IF;\n\t    END_FOR;\n\t    \n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Outputs assignment\n\t  #LGF_CalcCRC16 := #tempCRC;\n\t  \n\t  #status := #STATUS_NO_ERROR;\n\t  #error := FALSE;\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Word"}]}
{"title": "CalcCRC16Advanced", "description": "The CRC calculation is used for error detection at data transmission. The result of a calculation returns a CRC value via the data sent. The receiver detects a faulty transmission due to the unequal CRC value. The function LGF_CalcCRC16Advanced uses 16 bits as the generator polynomial (mask) and the parameters finalXorValue, reflectInput, and reflectResult.", "type": "FUNCTION", "name": "LGF_CalcCRC16Advanced", "vars": [{"name": "initValue", "type": "Word", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "Word", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "finalXorValue", "type": "Word", "description": "Value with which another XOR operation is performed at the end"}, {"name": "reflectInput", "type": "Bool", "description": "TRUE: the sequence of the bits within the input byte is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "reflectResult", "type": "Bool", "description": "TRUE: the order of the bits within the result is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation\n0 = all elements / the whole array"}, {"name": "Ret_Val", "type": "Word", "description": "Calculated CRC value (return value of the function)."}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated."}], "input": [{"name": "initValue", "type": "Word", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "Word", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "finalXorValue", "type": "Word", "description": "Value with which another XOR operation is performed at the end"}, {"name": "reflectInput", "type": "Bool", "description": "TRUE: the sequence of the bits within the input byte is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "reflectResult", "type": "Bool", "description": "TRUE: the order of the bits within the result is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation\n0 = all elements / the whole array"}], "output": [{"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated."}], "answer": "FUNCTION \"LGF_CalcCRC16Advanced\" : Word\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_CRC16Advanced\n   VAR_INPUT \n      initValue { S7_PredefinedAssignment := '16#00'} : Word;\n      mask { S7_PredefinedAssignment := '16#00'} : Word;\n      finalXorValue { S7_PredefinedAssignment := '16#00'} : Word;\n      reflectInput { S7_PredefinedAssignment := 'FALSE'} : Bool;\n      reflectResult { S7_PredefinedAssignment := 'FALSE'} : Bool;\n      noOfElements { S7_PredefinedAssignment := '0'} : UInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of Byte;\n   END_VAR\n\n   VAR_TEMP \n      tempInput : Byte;\n      tempCRC : Word;\n      tempInvCRC : Word;\n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempIndexArray : DInt;\n      tempIndexCRC : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      SHIFT_ONE_BIT : UInt := 1;\n      SHIFT_ONE_BYTE : UInt := 8;\n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      CRC_LOOP_LOWER_LIMIT : DInt := 0;\n      CRC_LOOP_UPPER_LIMIT : DInt := 7;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_OF_ELEMENTS : Word := 16#8400;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CRC16Advanced\n\t  // Comment/Function: This function makes a CRC calculation according\n\t  //                   to the CRC-16 advanced algorithm\n\t  //                   advanced because of reflect In/Out and final XOR combination\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 16.12.2019  Simatic Systems Support\n\t  //                      first release, copied from \"LGF_CalcCRC32Advanced\"\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //                      Assign default start values to optional inputs - `initValue`, `mask`, `finalXorValue`, `reflectInput`, `reflectResult`\n\t  // 03.01.00 14.04.2023  Simatic Systems Support\n\t  //                      Add input `noOfElements` to assign length to be converted different from array size \n\t  //                      Add outputs `error` and `status` display a wrong assignment to `noOfElements`\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and input data processing\n\t  // Defining initial value for algorithm\n\t  #tempCRC := #initValue;\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // check paramter `noOfELements`, if gretaer than zero check if fits to array size\n\t  IF #noOfElements > 0 THEN\n\t    IF #noOfElements > (#tempUpperLimit - #tempLowerLimit + 1) THEN\n\t      #status := #ERR_NO_OF_ELEMENTS;\n\t      #error := TRUE;\n\t      ENO := FALSE;\n\t      #LGF_CalcCRC16Advanced := #tempCRC;\n\t      RETURN;\n\t    ELSE\n\t      #tempUpperLimit := #tempLowerLimit + #noOfElements - 1;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION CRC calculation\n\t  FOR #tempIndexArray := #tempLowerLimit TO #tempUpperLimit DO\n\t    \n\t    IF #reflectInput THEN\n\t      // Reverse bit order in input byte\n\t      #tempInput.%X7 := #array[#tempIndexArray].%X0;\n\t      #tempInput.%X6 := #array[#tempIndexArray].%X1;\n\t      #tempInput.%X5 := #array[#tempIndexArray].%X2;\n\t      #tempInput.%X4 := #array[#tempIndexArray].%X3;\n\t      #tempInput.%X3 := #array[#tempIndexArray].%X4;\n\t      #tempInput.%X2 := #array[#tempIndexArray].%X5;\n\t      #tempInput.%X1 := #array[#tempIndexArray].%X6;\n\t      #tempInput.%X0 := #array[#tempIndexArray].%X7;\n\t    ELSE\n\t      #tempInput := #array[#tempIndexArray];\n\t    END_IF;\n\t    \n\t    // Perform division using XOR function for appropriate Word in array (with shift byte into MSB of 16bit CRC)\n\t    #tempCRC := #tempCRC XOR SHL(IN := BYTE_TO_WORD(#tempInput), N := #SHIFT_ONE_BYTE);\n\t    \n\t    FOR #tempIndexCRC := #CRC_LOOP_LOWER_LIMIT TO #CRC_LOOP_UPPER_LIMIT DO\n\t      // Check if MSB is set\n\t      IF #tempCRC.%X15 THEN\n\t        // Shift left and perform division by mask polynomial using XOR function\n\t        #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT) XOR #mask;\n\t      ELSE\n\t        // Shift left without division\n\t        #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT);\n\t      END_IF;\n\t    END_FOR;\n\t    \n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Outputs assignment\n\t  IF #reflectResult THEN\n\t    // Reverse bit order in CRC checksum\n\t    #tempInvCRC.%X15 := #tempCRC.%X0;\n\t    #tempInvCRC.%X14 := #tempCRC.%X1;\n\t    #tempInvCRC.%X13 := #tempCRC.%X2;\n\t    #tempInvCRC.%X12 := #tempCRC.%X3;\n\t    #tempInvCRC.%X11 := #tempCRC.%X4;\n\t    #tempInvCRC.%X10 := #tempCRC.%X5;\n\t    #tempInvCRC.%X9 := #tempCRC.%X6;\n\t    #tempInvCRC.%X8 := #tempCRC.%X7;\n\t    #tempInvCRC.%X7 := #tempCRC.%X8;\n\t    #tempInvCRC.%X6 := #tempCRC.%X9;\n\t    #tempInvCRC.%X5 := #tempCRC.%X10;\n\t    #tempInvCRC.%X4 := #tempCRC.%X11;\n\t    #tempInvCRC.%X3 := #tempCRC.%X12;\n\t    #tempInvCRC.%X2 := #tempCRC.%X13;\n\t    #tempInvCRC.%X1 := #tempCRC.%X14;\n\t    #tempInvCRC.%X0 := #tempCRC.%X15;\n\t    \n\t    #LGF_CalcCRC16Advanced := #tempInvCRC XOR #finalXorValue;\n\t  ELSE\n\t    #LGF_CalcCRC16Advanced := #tempCRC XOR #finalXorValue;\n\t  END_IF;\n\t  \n\t  #status := #STATUS_NO_ERROR;\n\t  #error := FALSE;\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Word"}]}
{"title": "CalcCRC32", "description": "The CRC calculation is used for error detection at data transmission. The result of a calculation returns a CRC value via the data sent. The receiver detects a faulty transmission due to the unequal CRC value. The function LGF_CalcCRC32 uses 32 bits as the generator polynomial (mask).", "type": "FUNCTION", "name": "LGF_CalcCRC32", "vars": [{"name": "initValue", "type": "DWord", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "DWord", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation\n0 = all elements / the whole array"}, {"name": "Ret_Val", "type": "DWord", "description": "Calculated CRC value (return value of the function)."}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated."}], "input": [{"name": "initValue", "type": "DWord", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "DWord", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation\n0 = all elements / the whole array"}], "output": [{"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated."}], "answer": "FUNCTION \"LGF_CalcCRC32\" : DWord\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_CRC32\n   VAR_INPUT \n      initValue { S7_PredefinedAssignment := '16#00'} : DWord;\n      mask { S7_PredefinedAssignment := '16#00'} : DWord;\n      noOfElements { S7_PredefinedAssignment := '0'} : UInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of Byte;\n   END_VAR\n\n   VAR_TEMP \n      tempCRC : DWord;\n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempIndexArray : DInt;\n      tempIndexCRC : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      SHIFT_ONE_BIT : UInt := 1;\n      SHIFT_THREE_BYTES : UInt := 24;\n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      CRC_LOOP_LOWER_LIMIT : DInt := 0;\n      CRC_LOOP_UPPER_LIMIT : DInt := 7;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_OF_ELEMENTS : Word := 16#8400;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CRC32\n\t  // Comment/Function: This function makes a CRC calculation according\n\t  //                   to the CRC-32 algorithm\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.03 09.10.2019  Simatic Systems Support\n\t  //                      Code refactoring, comments added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //                      Assign default start values to optional inputs - `initValue`, `mask`\n\t  // 03.01.00 14.04.2023  Simatic Systems Support\n\t  //                      Add input `noOfElements` to assign length to be converted different from array size \n\t  //                      Add outputs `error` and `status` display a wrong assignment to `noOfElements`\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and input data processing\n\t  // Defining initial value for algorithm\n\t  #tempCRC := #initValue;\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // check paramter `noOfELements`, if gretaer than zero check if fits to array size\n\t  IF #noOfElements > 0 THEN\n\t    IF #noOfElements > (#tempUpperLimit - #tempLowerLimit + 1) THEN\n\t      #status := #ERR_NO_OF_ELEMENTS;\n\t      #error := TRUE;\n\t      ENO := FALSE;\n\t      #LGF_CalcCRC32 := #tempCRC;\n\t      RETURN;\n\t    ELSE\n\t      #tempUpperLimit := #tempLowerLimit + #noOfElements - 1;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION CRC calculation\n\t  FOR #tempIndexArray := #tempLowerLimit TO #tempUpperLimit DO\n\t    // Perform division using XOR function for appropriate word in array (with shift byte into MSB of 32bit CRC)\n\t    #tempCRC := #tempCRC XOR SHL(IN := BYTE_TO_DWORD(#array[#tempIndexArray]), N := #SHIFT_THREE_BYTES);\n\t    \n\t    FOR #tempIndexCRC := #CRC_LOOP_LOWER_LIMIT TO #CRC_LOOP_UPPER_LIMIT DO\n\t      // Check if MSB is set\n\t      IF #tempCRC.%X31 THEN\n\t        // Shift left and perform division by mask polynomial using XOR function\n\t        #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT) XOR #mask;\n\t      ELSE\n\t        // Shift left without division\n\t        #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT);\n\t      END_IF;\n\t    END_FOR;\n\t    \n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Outputs assignment\n\t  #LGF_CalcCRC32 := #tempCRC;\n\t  \n\t  #status := #STATUS_NO_ERROR;\n\t  #error := FALSE;\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DWord"}]}
{"title": "CalcCRC32Advanced", "description": "The CRC calculation is used for error detection at data transmission. The result of a calculation returns a CRC value via the data sent. The receiver detects a faulty transmission due to the unequal CRC value. The function LGF_CalcCRC32Advanced uses 32 bits as the generator polynomial (mask) and the parameters finalXorValue, reflectInput, and reflectResult.", "type": "FUNCTION", "name": "LGF_CalcCRC32Advanced", "vars": [{"name": "initValue", "type": "DWord", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "DWord", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "finalXorValue", "type": "DWord", "description": "Value with which another XOR operation is performed at the end"}, {"name": "reflectInput", "type": "Bool", "description": "TRUE: the sequence of the bits within the input byte is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "reflectResult", "type": "Bool", "description": "TRUE: the order of the bits within the result is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation\n0 = all elements / the whole array"}, {"name": "Ret_Val", "type": "DWord", "description": "Calculated CRC value (return value of the function)."}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated."}], "input": [{"name": "initValue", "type": "DWord", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "DWord", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "finalXorValue", "type": "DWord", "description": "Value with which another XOR operation is performed at the end"}, {"name": "reflectInput", "type": "Bool", "description": "TRUE: the sequence of the bits within the input byte is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "reflectResult", "type": "Bool", "description": "TRUE: the order of the bits within the result is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation\n0 = all elements / the whole array"}], "output": [{"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated."}], "answer": "FUNCTION \"LGF_CalcCRC32Advanced\" : DWord\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_CRC32Advanced\n   VAR_INPUT \n      initValue { S7_PredefinedAssignment := '16#00'} : DWord;\n      mask { S7_PredefinedAssignment := '16#00'} : DWord;\n      finalXorValue { S7_PredefinedAssignment := '16#00'} : DWord;\n      reflectInput { S7_PredefinedAssignment := 'FALSE'} : Bool;\n      reflectResult { S7_PredefinedAssignment := 'FALSE'} : Bool;\n      noOfElements { S7_PredefinedAssignment := '0'} : UInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of Byte;\n   END_VAR\n\n   VAR_TEMP \n      tempInput : Byte;\n      tempCRC : DWord;\n      tempInvCRC : DWord;\n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempIndexArray : DInt;\n      tempIndexCRC : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      SHIFT_ONE_BIT : UInt := 1;\n      SHIFT_THREE_BYTE : UInt := 24;\n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      CRC_LOOP_LOWER_LIMIT : DInt := 0;\n      CRC_LOOP_UPPER_LIMIT : DInt := 7;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_OF_ELEMENTS : Word := 16#8400;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CRC32Advanced\n\t  // Comment/Function: This function makes a CRC calculation according\n\t  //                   to the CRC-32 algorithm\n\t  //                   advanced because of reflect In/Out and final XOR combination\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.03 09.10.2019  Simatic Systems Support\n\t  //                      Code refactoring, comments added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //                      Assign default start values to optional inputs - `initValue`, `mask`, `finalXorValue`, `reflectInput`, `reflectResult`\n\t  // 03.01.00 14.04.2023  Simatic Systems Support\n\t  //                      Add input `noOfElements` to assign length to be converted different from array size \n\t  //                      Add outputs `error` and `status` display a wrong assignment to `noOfElements`\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and input data processing\n\t  // Defining initial value for algorithm\n\t  #tempCRC := #initValue;\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // check paramter `noOfELements`, if gretaer than zero check if fits to array size\n\t  IF #noOfElements > 0 THEN\n\t    IF #noOfElements > (#tempUpperLimit - #tempLowerLimit + 1) THEN\n\t      #status := #ERR_NO_OF_ELEMENTS;\n\t      #error := TRUE;\n\t      ENO := FALSE;\n\t      #LGF_CalcCRC32Advanced := #tempCRC;\n\t      RETURN;\n\t    ELSE\n\t      #tempUpperLimit := #tempLowerLimit + #noOfElements - 1;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION CRC calculation\n\t  FOR #tempIndexArray := #tempLowerLimit TO #tempUpperLimit DO\n\t    \n\t    IF #reflectInput THEN\n\t      // Reverse bit order in input byte\n\t      #tempInput.%X7 := #array[#tempIndexArray].%X0;\n\t      #tempInput.%X6 := #array[#tempIndexArray].%X1;\n\t      #tempInput.%X5 := #array[#tempIndexArray].%X2;\n\t      #tempInput.%X4 := #array[#tempIndexArray].%X3;\n\t      #tempInput.%X3 := #array[#tempIndexArray].%X4;\n\t      #tempInput.%X2 := #array[#tempIndexArray].%X5;\n\t      #tempInput.%X1 := #array[#tempIndexArray].%X6;\n\t      #tempInput.%X0 := #array[#tempIndexArray].%X7;\n\t    ELSE\n\t      #tempInput := #array[#tempIndexArray];\n\t    END_IF;\n\t    \n\t    // Perform division using XOR function for appropriate DWord in array (with shift byte into MSB of 32bit CRC)\n\t    #tempCRC := #tempCRC XOR SHL(IN := BYTE_TO_DWORD(#tempInput), N := #SHIFT_THREE_BYTE);\n\t    \n\t    FOR #tempIndexCRC := #CRC_LOOP_LOWER_LIMIT TO #CRC_LOOP_UPPER_LIMIT DO\n\t      // Check if MSB is set\n\t      IF #tempCRC.%X31 THEN\n\t        // Shift left and perform division by mask polynomial using XOR function\n\t        #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT) XOR #mask;\n\t      ELSE\n\t        // Shift left without division\n\t        #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT);\n\t      END_IF;\n\t    END_FOR;\n\t    \n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Outputs assignment\n\t  IF #reflectResult THEN\n\t    // Reverse bit order in CRC checksum\n\t    #tempInvCRC.%X31 := #tempCRC.%X0;\n\t    #tempInvCRC.%X30 := #tempCRC.%X1;\n\t    #tempInvCRC.%X29 := #tempCRC.%X2;\n\t    #tempInvCRC.%X28 := #tempCRC.%X3;\n\t    #tempInvCRC.%X27 := #tempCRC.%X4;\n\t    #tempInvCRC.%X26 := #tempCRC.%X5;\n\t    #tempInvCRC.%X25 := #tempCRC.%X6;\n\t    #tempInvCRC.%X24 := #tempCRC.%X7;\n\t    #tempInvCRC.%X23 := #tempCRC.%X8;\n\t    #tempInvCRC.%X22 := #tempCRC.%X9;\n\t    #tempInvCRC.%X21 := #tempCRC.%X10;\n\t    #tempInvCRC.%X20 := #tempCRC.%X11;\n\t    #tempInvCRC.%X19 := #tempCRC.%X12;\n\t    #tempInvCRC.%X18 := #tempCRC.%X13;\n\t    #tempInvCRC.%X17 := #tempCRC.%X14;\n\t    #tempInvCRC.%X16 := #tempCRC.%X15;\n\t    #tempInvCRC.%X15 := #tempCRC.%X16;\n\t    #tempInvCRC.%X14 := #tempCRC.%X17;\n\t    #tempInvCRC.%X13 := #tempCRC.%X18;\n\t    #tempInvCRC.%X12 := #tempCRC.%X19;\n\t    #tempInvCRC.%X11 := #tempCRC.%X20;\n\t    #tempInvCRC.%X10 := #tempCRC.%X21;\n\t    #tempInvCRC.%X9 := #tempCRC.%X22;\n\t    #tempInvCRC.%X8 := #tempCRC.%X23;\n\t    #tempInvCRC.%X7 := #tempCRC.%X24;\n\t    #tempInvCRC.%X6 := #tempCRC.%X25;\n\t    #tempInvCRC.%X5 := #tempCRC.%X26;\n\t    #tempInvCRC.%X4 := #tempCRC.%X27;\n\t    #tempInvCRC.%X3 := #tempCRC.%X28;\n\t    #tempInvCRC.%X2 := #tempCRC.%X29;\n\t    #tempInvCRC.%X1 := #tempCRC.%X30;\n\t    #tempInvCRC.%X0 := #tempCRC.%X31;\n\t    \n\t    #LGF_CalcCRC32Advanced := #tempInvCRC XOR #finalXorValue;\n\t  ELSE\n\t    #LGF_CalcCRC32Advanced := #tempCRC XOR #finalXorValue;\n\t  END_IF;\n\t  \n\t  #status := #STATUS_NO_ERROR;\n\t  #error := FALSE;\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DWord"}]}
{"title": "CalcCRC8", "description": "The CRC calculation is used for error detection at data transmission. The result of a calculation returns a CRC value via the data sent. The receiver detects a faulty transmission due to the unequal CRC value. The function LGF_CalcCRC8 uses 8 bits as the generator polynomial (mask).", "type": "FUNCTION", "name": "LGF_CalcCRC8", "vars": [{"name": "initValue", "type": "Byte", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation\n0 = all elements / the whole array"}, {"name": "Ret_Val", "type": "Byte", "description": "Calculated CRC value (return value of the function)."}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated."}], "input": [{"name": "initValue", "type": "Byte", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation\n0 = all elements / the whole array"}], "output": [{"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated."}], "answer": "FUNCTION \"LGF_CalcCRC8\" : Byte\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_CRC8\n   VAR_INPUT \n      initValue { S7_PredefinedAssignment := '16#00'} : Byte;\n      mask { S7_PredefinedAssignment := '16#00'} : Byte;\n      noOfElements { S7_PredefinedAssignment := '0'} : UInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of Byte;\n   END_VAR\n\n   VAR_TEMP \n      tempCRC : Byte;\n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempIndexArray : DInt;\n      tempIndexCRC : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      SHIFT_ONE_BIT : UInt := 1;\n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      CRC_LOOP_LOWER_LIMIT : DInt := 0;\n      CRC_LOOP_UPPER_LIMIT : DInt := 7;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_OF_ELEMENTS : Word := 16#8400;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CRC8\n\t  // Comment/Function: This function makes a CRC calculation according\n\t  //                   to the CRC-8 algorithm\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.03 09.10.2019  Simatic Systems Support\n\t  //                      Code refactoring, comments added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //                      Assign default start values to optional inputs - `initValue`, `mask`\n\t  // 03.01.00 14.04.2023  Simatic Systems Support\n\t  //                      Add input `noOfElements` to assign length to be converted different from array size \n\t  //                      Add outputs `error` and `status` display a wrong assignment to `noOfElements`\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and input data processing\n\t  // Defining initial value for algorithm\n\t  #tempCRC := #initValue;\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // check paramter `noOfELements`, if gretaer than zero check if fits to array size\n\t  IF #noOfElements > 0 THEN\n\t    IF #noOfElements > (#tempUpperLimit - #tempLowerLimit + 1) THEN\n\t      #status := #ERR_NO_OF_ELEMENTS;\n\t      #error := TRUE;\n\t      ENO := FALSE;\n\t      #LGF_CalcCRC8 := #tempCRC;\n\t      RETURN;\n\t    ELSE\n\t      #tempUpperLimit := #tempLowerLimit + #noOfElements - 1;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION CRC calculation\n\t  FOR #tempIndexArray := #tempLowerLimit TO #tempUpperLimit DO\n\t    // Perform division using XOR function for appropriate byte in array\n\t    #tempCRC := #tempCRC XOR #array[#tempIndexArray];\n\t    \n\t    FOR #tempIndexCRC := #CRC_LOOP_LOWER_LIMIT TO #CRC_LOOP_UPPER_LIMIT DO\n\t      // Check if MSB is set\n\t      IF #tempCRC.%X7 THEN\n\t        // Shift left and perform division by mask polynomial using XOR function\n\t        #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT) XOR #mask;\n\t      ELSE\n\t        // Shift left without division\n\t        #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT);\n\t      END_IF;\n\t    END_FOR;\n\t    \n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Outputs assignment\n\t  #LGF_CalcCRC8 := #tempCRC;\n\t  \n\t  #status := #STATUS_NO_ERROR;\n\t  #error := FALSE;\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Byte"}]}
{"title": "CalcCRC8Advanced", "description": "The CRC calculation is used for error detection at data transmission. The result of a calculation returns a CRC value via the data sent. The receiver detects a faulty transmission due to the unequal CRC value. The function LGF_CalcCRC8Advanced uses 8 bits as the generator polynomial (mask) and the parameters finalXorValue, reflectInput, and reflectResult.", "type": "FUNCTION", "name": "LGF_CalcCRC8Advanced", "vars": [{"name": "initValue", "type": "Byte", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "finalXorValue", "type": "Byte", "description": "Value with which another XOR operation is performed at the end"}, {"name": "reflectInput", "type": "Bool", "description": "TRUE: the sequence of the bits within the input byte is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "reflectResult", "type": "Bool", "description": "TRUE: the order of the bits within the result is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation\n0 = all elements / the whole array"}, {"name": "Ret_Val", "type": "Byte", "description": "Calculated CRC value (return value of the function)."}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated."}], "input": [{"name": "initValue", "type": "Byte", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "finalXorValue", "type": "Byte", "description": "Value with which another XOR operation is performed at the end"}, {"name": "reflectInput", "type": "Bool", "description": "TRUE: the sequence of the bits within the input byte is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "reflectResult", "type": "Bool", "description": "TRUE: the order of the bits within the result is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation\n0 = all elements / the whole array"}], "output": [{"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated."}], "answer": "FUNCTION \"LGF_CalcCRC8Advanced\" : Byte\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_CRC8Advanced\n   VAR_INPUT \n      initValue { S7_PredefinedAssignment := '16#00'} : Byte;\n      mask { S7_PredefinedAssignment := '16#00'} : Byte;\n      finalXorValue { S7_PredefinedAssignment := '16#00'} : Byte;\n      reflectInput { S7_PredefinedAssignment := 'FALSE'} : Bool;\n      reflectResult { S7_PredefinedAssignment := 'FALSE'} : Bool;\n      noOfElements { S7_PredefinedAssignment := '0'} : UInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of Byte;\n   END_VAR\n\n   VAR_TEMP \n      tempInput : Byte;\n      tempCRC : Byte;\n      tempInvCRC : Byte;\n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempIndexArray : DInt;\n      tempIndexCRC : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      SHIFT_ONE_BIT : UInt := 1;\n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      CRC_LOOP_LOWER_LIMIT : DInt := 0;\n      CRC_LOOP_UPPER_LIMIT : DInt := 7;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_OF_ELEMENTS : Word := 16#8400;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CRC8Advanced\n\t  // Comment/Function: This function makes a CRC calculation according\n\t  //                   to the CRC-8 advanced algorithm\n\t  //                   advanced because of reflect In/Out and final XOR combination\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 16.12.2019  Simatic Systems Support\n\t  //                      first release, copied from \"LGF_CalcCRC32Advanced\"\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //                      Assign default start values to optional inputs - `initValue`, `mask`, `finalXorValue`, `reflectInput`, `reflectResult`\n\t  // 03.01.00 14.04.2023  Simatic Systems Support\n\t  //                      Add input `noOfElements` to assign length to be converted different from array size \n\t  //                      Add outputs `error` and `status` display a wrong assignment to `noOfElements`\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and input data processing\n\t  // Defining initial value for algorithm\n\t  #tempCRC := #initValue;\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // check paramter `noOfELements`, if gretaer than zero check if fits to array size\n\t  IF #noOfElements > 0 THEN\n\t    IF #noOfElements > (#tempUpperLimit - #tempLowerLimit + 1) THEN\n\t      #status := #ERR_NO_OF_ELEMENTS;\n\t      #error := TRUE;\n\t      ENO := FALSE;\n\t      #LGF_CalcCRC8Advanced := #tempCRC;\n\t      RETURN;\n\t    ELSE\n\t      #tempUpperLimit := #tempLowerLimit + #noOfElements - 1;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION CRC calculation\n\t  FOR #tempIndexArray := #tempLowerLimit TO #tempUpperLimit DO\n\t    \n\t    IF #reflectInput THEN\n\t      // Reverse bit order in input byte\n\t      #tempInput.%X7 := #array[#tempIndexArray].%X0;\n\t      #tempInput.%X6 := #array[#tempIndexArray].%X1;\n\t      #tempInput.%X5 := #array[#tempIndexArray].%X2;\n\t      #tempInput.%X4 := #array[#tempIndexArray].%X3;\n\t      #tempInput.%X3 := #array[#tempIndexArray].%X4;\n\t      #tempInput.%X2 := #array[#tempIndexArray].%X5;\n\t      #tempInput.%X1 := #array[#tempIndexArray].%X6;\n\t      #tempInput.%X0 := #array[#tempIndexArray].%X7;\n\t    ELSE\n\t      #tempInput := #array[#tempIndexArray];\n\t    END_IF;\n\t    \n\t    // Perform division using XOR function for appropriate byte in the array\n\t    #tempCRC := #tempCRC XOR #tempInput;\n\t    \n\t    FOR #tempIndexCRC := #CRC_LOOP_LOWER_LIMIT TO #CRC_LOOP_UPPER_LIMIT DO\n\t      // Check if MSB is set\n\t      IF #tempCRC.%X7 THEN\n\t        // Shift left and perform division by mask polynomial using XOR function\n\t        #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT) XOR #mask;\n\t      ELSE\n\t        // Shift left without division\n\t        #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT);\n\t      END_IF;\n\t    END_FOR;\n\t    \n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Outputs assignment\n\t  IF #reflectResult THEN\n\t    // Reverse bit order in CRC checksum\n\t    #tempInvCRC.%X7 := #tempCRC.%X0;\n\t    #tempInvCRC.%X6 := #tempCRC.%X1;\n\t    #tempInvCRC.%X5 := #tempCRC.%X2;\n\t    #tempInvCRC.%X4 := #tempCRC.%X3;\n\t    #tempInvCRC.%X3 := #tempCRC.%X4;\n\t    #tempInvCRC.%X2 := #tempCRC.%X5;\n\t    #tempInvCRC.%X1 := #tempCRC.%X6;\n\t    #tempInvCRC.%X0 := #tempCRC.%X7;\n\t    \n\t    #LGF_CalcCRC8Advanced := #tempInvCRC XOR #finalXorValue;\n\t  ELSE\n\t    #LGF_CalcCRC8Advanced := #tempCRC XOR #finalXorValue;\n\t  END_IF;\n\t  \n\t  #status := #STATUS_NO_ERROR;\n\t  #error := FALSE;\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Byte"}]}
{"title": "CalcCRC8For1Byte", "description": "The CRC calculation is used for error detection at data transmission. The result of a calculation returns a CRC value via the data sent (Byte). The receiver detects a faulty transmission due to the unequal CRC value. The function LGF_CalcCRC8For1Byte uses 8 bits as the generator polynomial (mask).", "type": "FUNCTION", "name": "LGF_CalcCRC8For1Byte", "vars": [{"name": "initValue", "type": "Byte", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "value", "type": "Byte", "description": "Data byte for which the CRC value will be calculated."}, {"name": "Ret_Val", "type": "Byte", "description": "Calculated CRC value (return value of the function)."}], "input": [{"name": "initValue", "type": "Byte", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "value", "type": "Byte", "description": "Data byte for which the CRC value will be calculated."}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_CalcCRC8For1Byte\" : Byte\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_CRC8For1Byte\n   VAR_INPUT \n      initValue { S7_PredefinedAssignment := '16#00'} : Byte;\n      mask { S7_PredefinedAssignment := '16#00'} : Byte;\n      value : Byte;\n   END_VAR\n\n   VAR_TEMP \n      tempCRC : Byte;\n      tempIndexCRC : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      SHIFT_ONE_BIT : UInt := 1;\n      CRC_LOOP_LOWER_LIMIT : DInt := 0;\n      CRC_LOOP_UPPER_LIMIT : DInt := 7;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CRC8For1Byte\n\t  // Comment/Function: This function makes a CRC calculation according\n\t  //                   to the CRC-8 algorithm for 1 byte\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.03 09.10.2019  Simatic Systems Support\n\t  //                      Code refactoring, comments added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //                      Assign default start values to optional inputs - `initValue`, `mask`\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and input data processing\n\t  // Defining initial value for algorithm\n\t  #tempCRC := #initValue XOR #value;\n\tEND_REGION\n\t\n\tREGION CRC calculation\n\t  FOR #tempIndexCRC := #CRC_LOOP_LOWER_LIMIT TO #CRC_LOOP_UPPER_LIMIT DO\n\t    // Check if MSB is set\n\t    IF #tempCRC.%X7 THEN\n\t      // Shift left and perform division by mask polynomial using XOR function\n\t      #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT) XOR #mask;\n\t    ELSE\n\t      // Shift left without division\n\t      #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT);\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Outputs assignment\n\t  #LGF_CalcCRC8For1Byte := #tempCRC;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Byte"}]}
{"title": "IsParityEven", "description": "The function checks whether the parity of the input variable of type DWord is even. If the number of bits that are assigned TRUE in the sequence is even, the return value is set to TRUE.", "type": "FUNCTION", "name": "LGF_IsParityEven", "vars": [{"name": "doubleWord", "type": "DWord", "description": "Variable for which the parity is to be determined."}, {"name": "Ret_Val", "type": "Bool", "description": "TRUE: When the number of bits that are assigned `TRUE` is even"}], "input": [{"name": "doubleWord", "type": "DWord", "description": "Variable for which the parity is to be determined."}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_IsParityEven\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_SIMATIC_Systems_Support\nFAMILY : LGF\nNAME : LGF_IsParityEven\n   VAR_INPUT \n      doubleWord : DWord;\n   END_VAR\n\n   VAR_TEMP \n      tempDword : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      SHIFT_ONE_BIT : USInt := 1;\n      SHIFT_TWO_BIT : USInt := 2;\n      SHIFT_TO_RESULT : USInt := 28;\n      MASK_FOR_RESULT : DWord := 16#11111111;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_IsParityEven\n\t  // Comment/Function: check if parity in input tag is even\n\t  //                   if number of bits is even, return TRUE\n\t  //                   https://graphics.stanford.edu/~seander/bithacks.html#ParityMultiply\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO not needed, no error possible\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 2019.11.28 | Simatic Systems Support\n\t  //                         First released version\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 12.11.2020 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Logic\n\t  #tempDword := #doubleWord; // 32-bit word\n\t  #tempDword := #tempDword XOR SHR(IN := #tempDword, N := #SHIFT_ONE_BIT);\n\t  #tempDword := #tempDword XOR SHR(IN := #tempDword, N := #SHIFT_TWO_BIT);\n\t  #tempDword := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempDword AND #MASK_FOR_RESULT) * DWORD_TO_UDINT(#MASK_FOR_RESULT));\n\t  \n\t  #tempDword := SHR(IN := #tempDword, N := #SHIFT_TO_RESULT);\n\t  \n\t  // result is stored in LSB\n\t  #LGF_IsParityEven := NOT #tempDword.%X0;\n\t  \n\t  // ENO not needed, no error possible\n\t  ENO := FALSE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "IsParityOdd", "description": "The function checks whether the parity of the input variable of type DWord is odd. The return value is set to TRUE if the number of bits that are assigned TRUE in the sequence is odd.", "type": "FUNCTION", "name": "LGF_IsParityOdd", "vars": [{"name": "doubleWord", "type": "DWord", "description": "Variable for which the parity is to be determined."}, {"name": "Ret_Val", "type": "Bool", "description": "TRUE: When the number of bits that are assigned `TRUE` is odd"}], "input": [{"name": "doubleWord", "type": "DWord", "description": "Variable for which the parity is to be determined."}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_IsParityOdd\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_SIMATIC_Systems_Support\nFAMILY : LGF\nNAME : LGF_IsParityOdd\n   VAR_INPUT \n      doubleWord : DWord;\n   END_VAR\n\n   VAR_TEMP \n      tempDword : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      SHIFT_ONE_BIT : USInt := 1;\n      SHIFT_TWO_BIT : USInt := 2;\n      SHIFT_TO_RESULT : USInt := 28;\n      MASK_FOR_RESULT : DWord := 16#11111111;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_IsParityOdd\n\t  // Comment/Function: check if parity in input tag is odd\n\t  //                   if number of bits is odd, return TRUE\n\t  //                   https://graphics.stanford.edu/~seander/bithacks.html#ParityMultiply\n\t  //                   ENO not needed, no error possible\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO not needed, no error possible\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 2019.11.28 | Simatic Systems Support\n\t  //                         First released version\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 12.11.2020 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Logic\n\t  #tempDword := #doubleWord; // 32-bit word\n\t  #tempDword := #tempDword XOR SHR(IN := #tempDword, N := #SHIFT_ONE_BIT);\n\t  #tempDword := #tempDword XOR SHR(IN := #tempDword, N := #SHIFT_TWO_BIT);\n\t  \n\t  #tempDword := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempDword AND #MASK_FOR_RESULT) * DWORD_TO_UDINT(#MASK_FOR_RESULT));\n\t  \n\t  #tempDword := SHR(IN := #tempDword, N := #SHIFT_TO_RESULT);\n\t  \n\t  // result is stored in LSB\n\t  #LGF_IsParityOdd := #tempDword.%X0;\n\t  \n\t  // eno not needed, no error possible\n\t  ENO := FALSE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "DataLogC", "description": "LGF_DataLogC (C -> Compact) function integrates all the datalog system functions and can be used as standalone data logger.", "type": "FUNCTION_BLOCK", "name": "LGF_DataLogC", "vars": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "name", "type": "String", "description": "Name of datalog, also used as file name"}, {"name": "triggerLogEntry", "type": "Bool", "description": "Rising edge trigger one entry in data log (only if\n`parameter.isLoggingByInterval` := FALSE)"}, {"name": "clearLog", "type": "Bool", "description": "Rising edge triggering clearing of datalog file"}, {"name": "deleteLog", "type": "Bool", "description": "Rising edge triggering deletion of datalog file if exist"}, {"name": "parameter", "type": "LGF_typeDataLog\nParameter", "description": "This UDT belongs to the Module `LGF_DataLogC` and\nlists all possible parameter to configure its behaviour."}, {"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "writeEntryDone", "type": "Bool", "description": "TRUE: DataLog write done successfully"}, {"name": "clearLogDone", "type": "Bool", "description": "TRUE: DataLog clear done successfully"}, {"name": "deleteLogDone", "type": "Bool", "description": "TRUE: DataLog delete done successfully"}, {"name": "lastEntryReached", "type": "Bool", "description": "TRUE: Last entry of datalog reached, if `enableRingBuffer` is set,\nstart from beginning, otherwise block ends here"}, {"name": "noOfEntries", "type": "UDInt", "description": "Number of entries in datalog"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}, {"name": "data", "type": "Variant", "description": "Data structure to log in datalog file"}, {"name": "statNoOfEntries", "type": "UDInt", "description": "Number of entries in datalog"}, {"name": "statLlastEntry\nReached", "type": "Bool", "description": "TRUE: Last entry of datalog reached, if `enableRingBuffer` is\nset, start from beginning, otherwise block ends here"}, {"name": "header", "type": "String", "description": "Headline of datalog, string of all data fields, separated\nby a comma: \"field1,field2,field3,...\""}, {"name": "maxNumberOf\nEntries", "type": "UDInt", "description": "Maximum number of entries in datalog"}, {"name": "timestampFormat", "type": "USInt", "description": "Timestamp format - see manual in \"DataLogCreate\" for\nused PLC Type (S7-1200 or S7-1500)"}, {"name": "clearOnOpen", "type": "Bool", "description": "Clear datalog during opening datalog while enabling\nblock"}, {"name": "deleteFile", "type": "Bool", "description": "Delete as well datalog file during datalog delete"}, {"name": "enableRingBuffer", "type": "Bool", "description": "TRUE: Overwrite old values and start from the\nbeginning if datalog reaches its maximum entries\nFALSE: Stop logging if `maxNumberOfEntries` entries\nreached"}, {"name": "loggingBy\nInterval", "type": "Bool", "description": "TRUE: Log on interval time parameter\nFALSE: log on \"triggerEntry\""}, {"name": "loggingInterval", "type": "Time", "description": "Time for automatic logging interval"}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "name", "type": "String", "description": "Name of datalog, also used as file name"}, {"name": "triggerLogEntry", "type": "Bool", "description": "Rising edge trigger one entry in data log (only if\n`parameter.isLoggingByInterval` := FALSE)"}, {"name": "clearLog", "type": "Bool", "description": "Rising edge triggering clearing of datalog file"}, {"name": "deleteLog", "type": "Bool", "description": "Rising edge triggering deletion of datalog file if exist"}, {"name": "parameter", "type": "LGF_typeDataLog\nParameter", "description": "This UDT belongs to the Module `LGF_DataLogC` and\nlists all possible parameter to configure its behaviour."}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "writeEntryDone", "type": "Bool", "description": "TRUE: DataLog write done successfully"}, {"name": "clearLogDone", "type": "Bool", "description": "TRUE: DataLog clear done successfully"}, {"name": "deleteLogDone", "type": "Bool", "description": "TRUE: DataLog delete done successfully"}, {"name": "lastEntryReached", "type": "Bool", "description": "TRUE: Last entry of datalog reached, if `enableRingBuffer` is set,\nstart from beginning, otherwise block ends here"}, {"name": "noOfEntries", "type": "UDInt", "description": "Number of entries in datalog"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}], "in/out": [{"name": "data", "type": "Variant", "description": "Data structure to log in datalog file"}], "answer": "FUNCTION_BLOCK \"LGF_DataLogC\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_DataLogC\n   VAR_INPUT \n      enable : Bool;\n      \"name\" : String := 'DefaultDataLog';\n      triggerLogEntry : Bool;\n      clearLog : Bool;\n      deleteLog : Bool;\n      parameter { S7_HiddenAssignment := 'Hide'} : \"LGF_typeDataLogParameter\";\n   END_VAR\n\n   VAR_OUTPUT \n      valid { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      writeEntryDone { ExternalWritable := 'False'} : Bool;\n      clearLogDone { ExternalWritable := 'False'} : Bool;\n      deleteLogDone { ExternalWritable := 'False'} : Bool;\n      lastEntryReached { ExternalWritable := 'False'} : Bool;\n      noOfEntries { ExternalWritable := 'False'} : UDInt;\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR_IN_OUT \n      data : Variant;\n   END_VAR\n\n   VAR \n      statDataLogCommands { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         \"name\" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;\n         header { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;\n         id { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;\n         noOfRecords { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         timestampFormat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;\n         loggingInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;\n         clearOnOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;\n         enableRingBuffer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         isLoggingByInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         edgeOnTriggerLogEntry { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         clearLogPrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         deleteLogPrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      END_STRUCT;\n      instIntervalTimer {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;\n      instDataLogCreate {InstructionName := 'DataLogCreate'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : DataLogCreate;\n      instDataLogOpen {InstructionName := 'DataLogOpen'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : DataLogOpen;\n      instDataLogClose {InstructionName := 'DataLogClose'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : DataLogClose;\n      instDataLogWrite {InstructionName := 'DataLogWrite'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : DataLogWrite;\n      instDataLogClear {InstructionName := 'DataLogClear'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : DataLogClear;\n      instDataLogDelete {InstructionName := 'DataLogDelete'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : DataLogDelete;\n      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         enablePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         valid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorUserCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorAutoCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         disablingCompleted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\";\n      END_STRUCT;\n      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;\n   END_VAR\n   VAR RETAIN\n      statNoOfEntries { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt := 0;\n      statLlastEntryReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n   END_VAR\n   VAR \n      statWriteEntryDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR_TEMP \n      tempEnable : Bool;\n      tempExitStateLoop : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      FB_STATE_NO_PROCESSING : DInt := 0;\n      FB_STATE_DL_OPEN : DInt := 20;\n      FB_STATE_DL_CREATE : DInt := 21;\n      FB_STATE_DL_NEW : DInt := 22;\n      FB_STATE_DL_WAIT_FOR_TRIGGER : DInt := 30;\n      FB_STATE_DL_WAIT_FOR_WRITE_CYCLE : DInt := 31;\n      FB_STATE_DL_WRITE : DInt := 40;\n      FB_STATE_DL_CLEAR : DInt := 51;\n      FB_STATE_DL_CLEAR_DONE : DInt := 52;\n      FB_STATE_DL_DELETE : DInt := 53;\n      FB_STATE_DL_DELETE_DONE : DInt := 54;\n      FB_STATE_DISABLING : DInt := 90;\n      FB_STATE_DISABLING_COMPLETED : DInt := 91;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      STATUS_MAX_ENTRIES_REACHED : Word := 16#7010;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n      ERR_WRONG_COMMAND_CALL_ORDER : Word := 16#8401;\n      ERR_DATALOG_OPEN : Word := 16#8601;\n      ERR_DATALOG_CREATE : Word := 16#8602;\n      ERR_DATALOG_CLOSE : Word := 16#8603;\n      ERR_DATALOG_WRITE : Word := 16#8604;\n      ERR_DATALOG_CLEAR : Word := 16#8605;\n      ERR_DATALOG_DELETE : Word := 16#8605;\n      \"//- internal Error codes from sub functions\" : Word;\n      SUB_ERR_DATALOG_DOSE_NOT_EXIST : Word := 16#8092;\n      \"//- internal constants\" : Word;\n      DATALOG_DEFAULT_ID : Word := 16#0000;\n      DATALOG_NO_TIMESTAMP_FORMAT : USInt := 0;\n      DATALOG_LAST_ENTRY_WRITTEN : Word := 16#0001;\n      DATALOG_DELETE_OLD_ENTRIES : UInt := 1;\n      DATALOG_KEEP_OLD_ENTRIES : UInt := 0;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Siemens / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_DataLogC\n\t  // Comment/Function: LGF_DataLogC function integrates all the datalog system functions and can be used as standalone data logger (C -> Compact). \n\t  // Library/Family:   LGF - library of general functions\n\t  // Author:           Simatic Systems Support\n\t  // Tested with:      S7-1200 V4.3 / S7-1500 V2.8\n\t  // Engineering:      TIA Portal (V16)\n\t  // Restrictions:     Just one datalog is possible, after the log is full, a new one has to be created\n\t  //                   or using the log as ringbuffer and overwrite the oldest entries\n\t  //                   ENO not active because of Error and Status output\n\t  // Requirements:     -\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  //----------|------------|-------------------------|------------------------------\n\t  // 01.00.00 | 19.02.2022 | Simatic Systems Support | First released version\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION ENABLING/DISABLING\n\t  #tempEnable := #enable; // Work with temporary value / create process image\n\t  IF TRUE // wrong command call order during enabled\n\t    AND #tempEnable\n\t    AND (#statInternal.diagnostics.status = #STATUS_NO_CALL)\n\t    AND (#deleteLog OR #clearLog)\n\t  THEN\n\t    // set error in case of wrong command call order....\n\t    #statInternal.diagnostics.status := #ERR_WRONG_COMMAND_CALL_ORDER;\n\t    #statInternal.diagnostics.subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t    #statInternal.diagnostics.stateNumber := #statMainState;\n\t    #statInternal.errorAutoCleared := TRUE;\n\t    #statInternal.disablingCompleted := FALSE;\n\t    \n\t  ELSIF #tempEnable AND NOT #statInternal.enablePrevious AND (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Enable FB\n\t    // First call; initialize FB\n\t    #statInternal.valid := TRUE;\n\t    #statInternal.busy := TRUE;\n\t    #statInternal.error := FALSE;\n\t    #statInternal.errorUserCleared := FALSE;\n\t    #statInternal.errorAutoCleared := FALSE;\n\t    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;\n\t    #statInternal.diagnostics.subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t    #statInternal.diagnostics.stateNumber := 0;\n\t    #diagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.disablingCompleted := FALSE;\n\t    // State machine - start functionality\n\t    #statMainState := #FB_STATE_DL_OPEN;\n\t    \n\t    REGION Init block parameter\n\t      // Initialize functionality: reset of variables, diagnostics, etc.\n\t      // check all parameter if valid or not\n\t      #statWriteEntryDone := FALSE;\n\t      #statDataLogCommands.name := #name;\n\t      #statDataLogCommands.header := #parameter.header;\n\t      #statDataLogCommands.noOfRecords := #parameter.maxNumberOfEntries;\n\t      #statDataLogCommands.loggingInterval := #parameter.loggingInterval;\n\t      #statDataLogCommands.isLoggingByInterval := #parameter.loggingByInterval;\n\t      \n\t      // reset internal parameter\n\t      #statDataLogCommands.id := #DATALOG_DEFAULT_ID;\n\t      \n\t      #statDataLogCommands.timestampFormat := #parameter.timestampFormat;\n\t      //#statDataLogCommands.timestampFormat := #DATALOG_NO_TIMESTAMP_FORMAT;\n\t      \n\t      // check if datalog entries should be deleted on open file\n\t      IF #parameter.clearOnOpen THEN\n\t        #statDataLogCommands.clearOnOpen := #DATALOG_DELETE_OLD_ENTRIES;\n\t        // if Datalog has to be cleared, DataLogFull has to be reset as well\n\t        #statLlastEntryReached := FALSE;\n\t        #statNoOfEntries := 0;\n\t      ELSE\n\t        #statDataLogCommands.clearOnOpen := #DATALOG_KEEP_OLD_ENTRIES;\n\t      END_IF;\n\t      \n\t      #statDataLogCommands.enableRingBuffer := #parameter.enableRingBuffer;\n\t      // check if ringbuffer is deactivated and buffer is full\n\t      // if that is the case, do not overwrite and leave function here...\n\t      IF NOT #parameter.enableRingBuffer AND #statLlastEntryReached THEN\n\t        // set flag\n\t        #statInternal.diagnostics.status := #STATUS_MAX_ENTRIES_REACHED;\n\t        #statMainState := #FB_STATE_NO_PROCESSING;\n\t      END_IF;\n\t    END_REGION Init block parameter\n\t    \n\t    REGION Init subFunction calls\n\t      // just if previous parameter-check was successful\n\t      IF (#statMainState <> #FB_STATE_NO_PROCESSING) THEN\n\t        #instDataLogCreate(REQ := FALSE);\n\t        #instDataLogOpen(REQ := FALSE);\n\t        #instDataLogClose(REQ := FALSE);\n\t        #instDataLogWrite(REQ := FALSE);\n\t        #instDataLogClear(REQ := FALSE);\n\t        #instDataLogDelete(REQ := FALSE);\n\t      END_IF;\n\t    END_REGION Init subFunction calls\n\t    \n\t  ELSIF (#tempEnable = FALSE) AND (#statInternal.enablePrevious = TRUE) THEN // Disable FB \n\t    #statMainState := #FB_STATE_DISABLING;\n\t    \n\t  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN // Set status identifier of subsequent call\n\t    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t  END_IF;\n\t  \n\t  // Edge detection 'enable' input\n\t  #statInternal.enablePrevious := #tempEnable;\n\tEND_REGION ENABLING/DISABLING\n\t\n\tIF (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION Command evaluation\n\t  IF FALSE\n\t    OR #statMainState = #FB_STATE_NO_PROCESSING\n\t    OR (TRUE\n\t    AND #statMainState > #FB_STATE_DL_CREATE\n\t    AND #statMainState < #FB_STATE_DL_DELETE\n\t    )\n\t  THEN\n\t    // clear datalog requested\n\t    IF #clearLog AND NOT #statDataLogCommands.clearLogPrevious THEN\n\t      #statMainState := #FB_STATE_DL_CLEAR;\n\t      #statInternal.errorUserCleared := FALSE;\n\t      // delete datalog requested\n\t    ELSIF #deleteLog AND NOT #statDataLogCommands.deleteLogPrevious THEN\n\t      #statMainState := #FB_STATE_DL_DELETE;\n\t      #statInternal.errorAutoCleared := FALSE;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION STATE_MACHINE\n\t  \n\t  // if one ore more runs in the same cycle are necessary, set #tempStateChangeActive := TRUE;\n\t  REPEAT\n\t    // reset #tempExitStateLoop := TRUE; as its defined state to prevent endless loop\n\t    #tempExitStateLoop := TRUE;\n\t    \n\t    CASE #statMainState OF // State machine of FB\n\t      #FB_STATE_NO_PROCESSING:\n\t        REGION NO Processing\n\t          ; // No processing active (Note: this state must always be present and left empty)\n\t        END_REGION NO Processing\n\t        \n\t      #FB_STATE_DL_OPEN:\n\t        REGION DataLog open\n\t          #instDataLogOpen(REQ  := TRUE,\n\t                           MODE := #statDataLogCommands.clearOnOpen,\n\t                           NAME := #statDataLogCommands.name,\n\t                           ID   := #statDataLogCommands.id);\n\t          \n\t          // check if open DL is done successfully - goto write\n\t          IF #instDataLogOpen.DONE THEN\n\t            IF #statDataLogCommands.isLoggingByInterval THEN\n\t              #statMainState := #FB_STATE_DL_WRITE;\n\t            ELSE // is logging by trigger\n\t              #statMainState := #FB_STATE_DL_WAIT_FOR_TRIGGER;\n\t            END_IF;\n\t            // reset instance\n\t            #instDataLogOpen(REQ := FALSE);\n\t            \n\t            // check if error occurred\n\t          ELSIF #instDataLogOpen.ERROR THEN\n\t            // datalog do not exist --> Create\n\t            IF (#instDataLogOpen.STATUS = #SUB_ERR_DATALOG_DOSE_NOT_EXIST) THEN\n\t              #statMainState := #FB_STATE_DL_CREATE;\n\t              \n\t            ELSE // error not known, user have to act - leave block\n\t              #statInternal.diagnostics.status := #ERR_DATALOG_OPEN;\n\t              #statInternal.diagnostics.subfunctionStatus := #instDataLogOpen.STATUS;\n\t              #statInternal.diagnostics.stateNumber := #FB_STATE_DL_OPEN;\n\t              #statInternal.errorUserCleared := TRUE;\n\t            END_IF;\n\t            // reset instance\n\t            #instDataLogOpen(REQ := FALSE);\n\t          END_IF;\n\t        END_REGION DataLog open\n\t        \n\t      #FB_STATE_DL_CREATE:\n\t        REGION DataLog create\n\t          #instDataLogCreate(REQ       := TRUE,\n\t                             RECORDS   := #statDataLogCommands.noOfRecords,\n\t                             TIMESTAMP := #statDataLogCommands.timestampFormat,\n\t                             NAME      := #statDataLogCommands.name,\n\t                             ID        := #statDataLogCommands.id,\n\t                             HEADER    := #statDataLogCommands.header,\n\t                             DATA      := #data);\n\t          \n\t          // check if creating and opening DL is done successfully - goto write\n\t          IF #instDataLogCreate.DONE THEN\n\t            IF (#statDataLogCommands.isLoggingByInterval = TRUE) THEN\n\t              #statMainState := #FB_STATE_DL_WRITE;\n\t            ELSE // is logging by trigger\n\t              #statMainState := #FB_STATE_DL_WAIT_FOR_TRIGGER;\n\t            END_IF;\n\t            // reset instance\n\t            #instDataLogCreate(REQ := FALSE);\n\t            \n\t            // check if error occurred\n\t          ELSIF #instDataLogCreate.ERROR THEN\n\t            // error not known, user have to act\n\t            #statInternal.diagnostics.status := #ERR_DATALOG_CREATE;\n\t            #statInternal.diagnostics.subfunctionStatus := #instDataLogCreate.STATUS;\n\t            #statInternal.diagnostics.stateNumber := #FB_STATE_DL_OPEN;\n\t            #statInternal.errorUserCleared := TRUE;\n\t            // reset instance\n\t            #instDataLogCreate(REQ := FALSE);\n\t          END_IF;\n\t        END_REGION DataLog create\n\t        \n\t      #FB_STATE_DL_WAIT_FOR_TRIGGER,\n\t      #FB_STATE_DL_WAIT_FOR_WRITE_CYCLE:\n\t        REGION Wait for trigger\n\t          // reset flags\n\t          #statLlastEntryReached := FALSE;\n\t          #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t          \n\t          IF TRUE // if trigger has a rising edge\n\t            AND (#triggerLogEntry AND NOT #statDataLogCommands.edgeOnTriggerLogEntry)\n\t            AND (#statMainState = #FB_STATE_DL_WAIT_FOR_TRIGGER)\n\t          THEN\n\t            #statMainState := #FB_STATE_DL_WRITE;\n\t            \n\t          ELSIF TRUE // if interval is over\n\t            AND #instIntervalTimer.Q\n\t            AND (#statMainState = #FB_STATE_DL_WAIT_FOR_WRITE_CYCLE)\n\t          THEN\n\t            #statMainState := #FB_STATE_DL_WRITE;\n\t          END_IF;\n\t        END_REGION Wait for trigger \n\t        \n\t      #FB_STATE_DL_WRITE:\n\t        REGION DataLog write\n\t          #instDataLogWrite(REQ := TRUE,\n\t                            ID  := #statDataLogCommands.id);\n\t          \n\t          // check if datalog is at its last entry\n\t          IF (#instDataLogWrite.STATUS = #DATALOG_LAST_ENTRY_WRITTEN) THEN\n\t            // set flag\n\t            #statLlastEntryReached := TRUE;\n\t            #statInternal.diagnostics.status := #STATUS_MAX_ENTRIES_REACHED;\n\t            // increment counter\n\t            #statNoOfEntries += 1;\n\t            #statWriteEntryDone := TRUE;\n\t            \n\t            // check if datalog should be overwritten or not\n\t            IF #statDataLogCommands.enableRingBuffer THEN\n\t              // is logging by interval\n\t              IF #statDataLogCommands.isLoggingByInterval THEN\n\t                #statMainState := #FB_STATE_DL_WAIT_FOR_WRITE_CYCLE;\n\t                \n\t              ELSE // is logging by trigger\n\t                #statMainState := #FB_STATE_DL_WAIT_FOR_TRIGGER;\n\t              END_IF;\n\t              \n\t            ELSE // do not overwrite - disable and leave block\n\t              #statMainState := #FB_STATE_NO_PROCESSING;\n\t            END_IF;\n\t            // reset instance\n\t            #instDataLogWrite(REQ := FALSE);\n\t            #tempExitStateLoop := FALSE;\n\t            \n\t            // check if open DL is done successfully - goto write\n\t          ELSIF #instDataLogWrite.DONE THEN\n\t            // increment counter\n\t            #statNoOfEntries += 1;\n\t            #statWriteEntryDone := TRUE;\n\t            \n\t            IF #statDataLogCommands.isLoggingByInterval = TRUE THEN\n\t              #statMainState := #FB_STATE_DL_WAIT_FOR_WRITE_CYCLE;\n\t            ELSE // is logging by trigger\n\t              #statMainState := #FB_STATE_DL_WAIT_FOR_TRIGGER;\n\t            END_IF;\n\t            // reset instance\n\t            #instDataLogWrite(REQ := FALSE);\n\t            #tempExitStateLoop := FALSE;\n\t            \n\t            // check if error occurred\n\t          ELSIF #instDataLogWrite.ERROR THEN\n\t            // error not known, user have to act\n\t            #statInternal.diagnostics.status := #ERR_DATALOG_WRITE;\n\t            #statInternal.diagnostics.subfunctionStatus := #instDataLogWrite.STATUS;\n\t            #statInternal.diagnostics.stateNumber := #FB_STATE_DL_WRITE;\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statMainState := #FB_STATE_NO_PROCESSING;\n\t            // reset instance\n\t            #instDataLogWrite(REQ := FALSE);\n\t          END_IF;\n\t        END_REGION DataLog write\n\t        \n\t      #FB_STATE_DL_CLEAR:\n\t        REGION DataLog clear\n\t          #instDataLogClear(REQ := TRUE,\n\t                            ID  := #statDataLogCommands.id);\n\t          \n\t          // check if open DL is done successfully - goto write\n\t          IF #instDataLogClear.DONE THEN\n\t            #statMainState := #FB_STATE_DL_CLEAR_DONE;\n\t            // reset flag\n\t            #statLlastEntryReached := FALSE;\n\t            #statNoOfEntries := 0;\n\t            // reset instance\n\t            #instDataLogClear(REQ := FALSE);\n\t            \n\t            // check if error occurred\n\t          ELSIF #instDataLogClear.ERROR THEN\n\t            // error not known, user have to act\n\t            #statInternal.diagnostics.status := #ERR_DATALOG_CLEAR;\n\t            #statInternal.diagnostics.subfunctionStatus := #instDataLogClear.STATUS;\n\t            #statInternal.diagnostics.stateNumber := #FB_STATE_DL_CLEAR;\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statMainState := #FB_STATE_NO_PROCESSING;\n\t            // reset instance\n\t            #instDataLogWrite(REQ := FALSE);\n\t          END_IF;\n\t        END_REGION DataLog clear\n\t        \n\t      #FB_STATE_DL_CLEAR_DONE:\n\t        REGION DataLog clear done\n\t          IF NOT #clearLog THEN\n\t            IF #statDataLogCommands.isLoggingByInterval THEN\n\t              #statMainState := #FB_STATE_DL_WRITE;\n\t            ELSE\n\t              #statMainState := #FB_STATE_DL_WAIT_FOR_TRIGGER;\n\t            END_IF;\n\t          END_IF;\n\t        END_REGION DataLog clear\n\t        \n\t      #FB_STATE_DL_DELETE:\n\t        REGION DataLog delete\n\t          #instDataLogDelete(REQ     := TRUE,\n\t                             NAME    := #statDataLogCommands.name,\n\t                             DelFile := #parameter.deleteFile,\n\t                             ID      := #statDataLogCommands.id);\n\t          \n\t          // check if delete DL is done successfully - goto disable completed\n\t          IF #instDataLogDelete.DONE THEN\n\t            #statMainState := #FB_STATE_DL_DELETE_DONE;\n\t            // reset flag\n\t            #statLlastEntryReached := FALSE;\n\t            #statNoOfEntries := 0;\n\t            // reset instance\n\t            #instDataLogDelete(REQ := FALSE);\n\t            \n\t            // check if error occurred\n\t          ELSIF #instDataLogDelete.ERROR THEN\n\t            // error not known, user have to act\n\t            #statInternal.diagnostics.status := #ERR_DATALOG_DELETE;\n\t            #statInternal.diagnostics.subfunctionStatus := #instDataLogDelete.STATUS;\n\t            #statInternal.diagnostics.stateNumber := #FB_STATE_DL_DELETE;\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statMainState := #FB_STATE_NO_PROCESSING;\n\t            // reset instance\n\t            #instDataLogDelete(REQ := FALSE);\n\t          END_IF;\n\t        END_REGION DataLog delete\n\t        \n\t      #FB_STATE_DL_DELETE_DONE:\n\t        REGION DataLog delete done\n\t          IF NOT #deleteLog THEN\n\t            #statMainState := #FB_STATE_DISABLING_COMPLETED;\n\t          END_IF;\n\t        END_REGION DataLog delete\n\t        \n\t      #FB_STATE_DISABLING: // Disabling active\n\t        REGION Disabling\n\t          // closing DataLog\n\t          #instDataLogClose(REQ := TRUE,\n\t                            ID  := #statDataLogCommands.id);\n\t          \n\t          // check if datalog is closed\n\t          IF FALSE\n\t            OR #instDataLogClose.DONE\n\t            OR #instDataLogClose.STATUS = #SUB_ERR_DATALOG_DOSE_NOT_EXIST\n\t          THEN\n\t            #statMainState := #FB_STATE_DISABLING_COMPLETED;\n\t            #statInternal.diagnostics.status := #STATUS_FINISHED_NO_ERROR;\n\t            \n\t            // if closing ends with error - report this as well\n\t          ELSIF #instDataLogClose.ERROR THEN\n\t            // error occurred - copy to outputs\n\t            #statInternal.diagnostics.status := #ERR_DATALOG_CLOSE;\n\t            #statInternal.diagnostics.subfunctionStatus := #instDataLogClose.STATUS;\n\t            #statInternal.diagnostics.stateNumber := #FB_STATE_DISABLING;\n\t            #statInternal.errorAutoCleared := TRUE;// next state\n\t            #statMainState := #FB_STATE_DISABLING_COMPLETED;\n\t          END_IF;\n\t        END_REGION Disabling\n\t        \n\t      #FB_STATE_DISABLING_COMPLETED:\n\t        REGION Disabling completed\n\t          // reset instance\n\t          #instDataLogClose(REQ := FALSE);\n\t          // When disabling is complete the bit #statDisablingCompleted must be set\n\t          #statInternal.disablingCompleted := TRUE;\n\t        END_REGION Disabling completed\n\t        \n\t      ELSE // Undefined state in state machine reached\n\t        REGION Undefined state        \n\t          #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;\n\t          #statInternal.diagnostics.subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t          #statInternal.diagnostics.stateNumber := #statMainState;\n\t          #statInternal.errorUserCleared := TRUE;\n\t        END_REGION Undefined state\n\t    END_CASE;\n\t    \n\t    // call interval timer\n\t    #instIntervalTimer.TON(IN := (#statMainState = #FB_STATE_DL_WAIT_FOR_WRITE_CYCLE),\n\t                           PT := #statDataLogCommands.loggingInterval);    // if one ore more runs in the same cycle are necessary, set #tempExitStateLoop := FALSE;\n\t    // check state, if condition = TRUE --> #tempExitStateLoop = TRUE --> LEAVE LOOP\n\t  UNTIL (TRUE = #tempExitStateLoop)\n\t  END_REPEAT;\n\tEND_REGION STATE_MACHINE\n\t\n\tREGION Edge memory\n\t  // store/ reset edge memory\n\t  #statDataLogCommands.edgeOnTriggerLogEntry := #triggerLogEntry;\n\t  #statDataLogCommands.clearLogPrevious := #clearLog;\n\t  #statDataLogCommands.deleteLogPrevious := #deleteLog;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  IF (#statInternal.disablingCompleted = TRUE) THEN\n\t    REGION disabling\n\t      // Reset outputs if disabling completed\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := FALSE;\n\t      #statInternal.errorUserCleared := FALSE;\n\t      #statInternal.errorAutoCleared := FALSE;\n\t      #statInternal.diagnostics.status := #STATUS_NO_CALL;\n\t      // Reset application specific outputs\n\t      #statWriteEntryDone := FALSE;\n\t    END_REGION disabling\n\t    \n\t  ELSIF (#statInternal.errorUserCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION error user cleared\n\t      // Error can only be cleared by user; rising edge at enable input is needed to continue \n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // Reset application specific outputs\n\t      #statWriteEntryDone := FALSE;\n\t      // execution aborted --> set state no processing\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION error user cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION error auto cleared\n\t      // Error can be reset by FB automatically\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // Reset application specific outputs\n\t      #statWriteEntryDone := FALSE;\n\t    END_REGION error auto cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = FALSE) AND (#statInternal.errorUserCleared = FALSE) AND (#statInternal.error = TRUE) THEN\n\t    REGION after user/auto cleared\n\t      // If autocleared error is acknowledged\n\t      #statInternal.valid := TRUE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := FALSE;\n\t      // remove this line if more detailed status information is used instead of \"#STATUS_SUBSEQUENT_CALL\"\n\t      #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t    END_REGION after user/auto cleared\n\t  END_IF;\n\t  \n\t  REGION Write static values to outputs\n\t    #valid := #statInternal.valid;\n\t    #busy := #statInternal.busy;\n\t    #error := #statInternal.error;\n\t    #status := #statInternal.diagnostics.status;\n\t    // if ENO mechanism is not used / not wanted replace the following line by --> ENO := TRUE;\n\t    ENO := NOT #statInternal.error;\n\t    // Write application specific static values to outputs\n\t    #lastEntryReached := #statLlastEntryReached;\n\t    #noOfEntries := #statNoOfEntries;\n\t    \n\t    #writeEntryDone := #statWriteEntryDone;\n\t    #statWriteEntryDone := FALSE;\n\t    \n\t    #clearLogDone := #statMainState = #FB_STATE_DL_CLEAR_DONE;\n\t    #deleteLogDone := #statMainState = #FB_STATE_DL_DELETE_DONE;\n\t  END_REGION Write static values to outputs\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "FIFO", "description": "FIFO (First-In First-Out / Queue / ring buffer memory) The function stores incoming data and outputs the oldest unprocessed data.", "type": "FUNCTION_BLOCK", "name": "LGF_FIFO", "vars": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "enqueue", "type": "Bool", "description": "Enqueue item to the buffer"}, {"name": "dequeue", "type": "Bool", "description": "Dequeue item from the buffer and return it on `item`"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value\n`initialItem` (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized\n(usually: `0` / default value)"}, {"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "TRUE: Buffer is empty"}, {"name": "isFull", "type": "Bool", "description": "TRUE: Buffer is full"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}, {"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the\nbuffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer. (Array of…)"}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "enqueue", "type": "Bool", "description": "Enqueue item to the buffer"}, {"name": "dequeue", "type": "Bool", "description": "Dequeue item from the buffer and return it on `item`"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value\n`initialItem` (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized\n(usually: `0` / default value)"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "TRUE: Buffer is empty"}, {"name": "isFull", "type": "Bool", "description": "TRUE: Buffer is full"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}], "in/out": [{"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the\nbuffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer. (Array of…)"}], "answer": "FUNCTION_BLOCK \"LGF_FIFO\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_FIFO\n   VAR_INPUT \n      enable : Bool;\n      enqueue : Bool := false;\n      dequeue : Bool := false;\n      reset : Bool;\n      clear : Bool;\n      initialItem : Variant;\n   END_VAR\n\n   VAR_OUTPUT \n      valid { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      elementCount { ExternalWritable := 'False'} : DInt := 0;\n      isEmpty { ExternalWritable := 'False'} : Bool := false;\n      isFull { ExternalWritable := 'False'} : Bool;\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR_IN_OUT \n      item : Variant;\n      buffer : Variant;\n   END_VAR\n\n   VAR \n      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         enablePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         valid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorUserCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorAutoCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         disablingCompleted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\";\n         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\";\n      END_STRUCT;\n      statEdgesMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         enqueue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         dequeue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         clear { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      END_STRUCT;\n      statBufferSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n      statFirstItemIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := -1;\n      statNextEmptyItemIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;\n      statElementCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;\n   END_VAR\n\n   VAR_TEMP \n      tempEnable : Bool;\n      tempEdges : Struct\n         enqueue : Bool;\n         dequeue : Bool;\n         reset : Bool;\n         clear : Bool;\n      END_STRUCT;\n      tempInternalError : Int;\n      tempNewFirstItemIndex : Int;\n      tempNewNextEmptyItemIndex : Int;\n      tempCounter : DInt;\n      tempRepeatStateMaschine : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      BUFFER_IS_EMPTY : Int := -1;\n      NO_INTERNAL_ERROR : Int := 0;\n      BUFFER_INITIALIZED : Int := -1;\n      EMPTY_INITIALIZED : Int := 0;\n      INDEX_BEGINNING : Int := 0;\n      COUNT_ELEMENTS : UDInt := 1;\n      INCREMENT : Int := 1;\n      BUFFER_SIZE_CORRECTION : UDInt := 1;\n      COUNTER_LOWER_LIMIT : DInt := 0;\n      ZERO_ELEMENTS : DInt := 0;\n      FB_STATE_NO_PROCESSING : DInt := 0;\n      FB_STATE_ENABLING : DInt := 1;\n      FB_STATE_IDLE : DInt := 10;\n      FB_STATE_RESET : DInt := 11;\n      FB_STATE_CLEAR : DInt := 12;\n      FB_STATE_ENQUEUE : DInt := 20;\n      FB_STATE_DEQUEUE : DInt := 30;\n      FB_STATE_DISABLING : DInt := 90;\n      STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_NO_CURRENT_JOBS : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      ERR_BUFFER_EMPTY : Word := 16#8001;\n      ERR_BUFFER_FULL : Word := 16#8002;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_WRONG_TYPE_ITEM : Word := 16#8201;\n      ERR_WRONG_TYPE_INITIAL_ITEM : Word := 16#8202;\n      ERR_BOOL_NOT_SUPPORTED : Word := 16#8203;\n      ERR_MULTIPLE_COMMANDS_DEDECTED : Word := 16#8204;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n      ERR_INDEX_IN_ARRAY_LIMITS_1 : Word := 16#8601;\n      ERR_INDEX_IN_ARRAY_LIMITS_2 : Word := 16#8602;\n      ERR_CLEAR_BUFFER : Word := 16#8610;\n      ERR_RETURN_FIRST_ENTRY : Word := 16#8611;\n      ERR_REPLACE_ITEM_BY_INIT_VALUE : Word := 16#8612;\n      ERR_WRITE_ENTRY : Word := 16#8613;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_FIFO\n\t  // Comment/Function: FIFO (First-In First-Out / Queue / ring buffer memory)  \n\t  //                   The function stores incoming data AND outputs the oldest unprocessed data.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  //                   Bool array is not supported by `MOVE_BLK_VARIANT`\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 16.11.2015  Siemens Industry Online Support\n\t  //                      Bug fix resetBuffer\n\t  // 01.00.02 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.03 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.04 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 02.00.00 29.01.2019  Siemens Industry Online Support\n\t  //                      Output \"done\" removed (not necessary, because block works synchronous)\n\t  // 03.00.00 22.10.2019  Simatic Systems Support\n\t  //                      Code refactoring, comments added\n\t  //                      Interface change (enqueue, dequeue etc.)\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  // 04.00.00 04.09.2024  Simatic Systems Support\n\t  //                      Rework to PLC Open `Enable` behavior\n\t  //                      Add `isFull` outputs\n\t  //                      Fix Bug while filling after left shift operation\n\t  //                      Rework to diagnostic output datatype\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION ENABLING/DISABLING\n\t  #tempEnable := #enable; // Work with temporary value / create process image\n\t  IF (#tempEnable = TRUE) AND (#statInternal.diagnostics.status = #STATUS_NO_CURRENT_JOBS) THEN // Enable FB\n\t    // First call; initialize FB\n\t    #statInternal.valid := TRUE;\n\t    #statInternal.busy := TRUE;\n\t    #statInternal.error := FALSE;\n\t    #statInternal.errorUserCleared := FALSE;\n\t    #statInternal.errorAutoCleared := FALSE;\n\t    #statInternal.disablingCompleted := FALSE;\n\t    #statInternal.diagnostics := #statInternal.emptyDiagnostics;\n\t    #diagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;\n\t    // State machine - start processing\n\t    #statMainState := #FB_STATE_ENABLING;\n\t    \n\t  ELSIF (#tempEnable = FALSE) AND (#statInternal.enablePrevious = TRUE) THEN // Disable FB \n\t    #statMainState := #FB_STATE_DISABLING;\n\t    \n\t  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN // Set status identifier of subsequent call\n\t    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t  END_IF;\n\t  \n\t  // Edge detection 'enable' input\n\t  #statInternal.enablePrevious := #tempEnable;\n\tEND_REGION ENABLING/DISABLING\n\t\n\tIF (#statInternal.diagnostics.status = #STATUS_NO_CURRENT_JOBS) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION STATE MACHINE\n\t  REPEAT\n\t    #tempRepeatStateMaschine := FALSE;\n\t    \n\t    CASE #statMainState OF // State machine of FB\n\t      #FB_STATE_NO_PROCESSING:\n\t        REGION No Processing\n\t          ; // No processing active (Note: this state must always be present and left empty)\n\t        END_REGION No Processing\n\t        \n\t      #FB_STATE_ENABLING: // Enabling active\n\t        REGION Enabling\n\t          // check whether the item type is BOOL\n\t          // Bool is not supported by Systemfunction MOVE BLOCK VARIANT\n\t          IF FALSE\n\t            OR TypeOf(#item) = Bool\n\t            OR TypeOf(#initialItem) = Bool\n\t            OR TypeOfElements(#buffer) = Bool\n\t          THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_BOOL_NOT_SUPPORTED;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          // check whether the ring #buffer is an ARRAY.\n\t          // IF so, the number OF the ARRAY elements is read out.\n\t          // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t          IF IS_ARRAY(#buffer) THEN\n\t            #statBufferSize := CountOfElements(#buffer);\n\t          ELSE\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_NO_ARRAY;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // check whether the data type OF the ARRAY elements matches\n\t          // the data type OF the entry (#item). IF the data types DO NOT match,\n\t          // the program execution is terminated at this point\n\t          IF (TypeOf(#item) <> TypeOfElements(#buffer)) THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_WRONG_TYPE_ITEM;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // check whether the initial value OF the ring #buffer\n\t          // matches the entry (tag #item). IF the data types DO NOT match,\n\t          // the program execution is terminated at this point\n\t          IF (TypeOf(#item) <> TypeOf(#initialItem)) THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_WRONG_TYPE_INITIAL_ITEM;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // Store values for edge detection\n\t          #statEdgesMem.enqueue := #enqueue;\n\t          #statEdgesMem.dequeue := #dequeue;\n\t          #statEdgesMem.reset := #reset;\n\t          #statEdgesMem.clear := #clear;\n\t          \n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION Enabling\n\t        \n\t      #FB_STATE_IDLE:\n\t        REGION IDLE\n\t          // Collect edges\n\t          #tempEdges.enqueue := #enqueue AND NOT #statEdgesMem.enqueue;\n\t          #tempEdges.dequeue := #dequeue AND NOT #statEdgesMem.dequeue;\n\t          #tempEdges.reset := #reset AND NOT #statEdgesMem.reset;\n\t          #tempEdges.clear := #clear AND NOT #statEdgesMem.clear;\n\t          // Store values for edge detection\n\t          #statEdgesMem.enqueue := #enqueue;\n\t          #statEdgesMem.dequeue := #dequeue;\n\t          #statEdgesMem.reset := #reset;\n\t          #statEdgesMem.clear := #clear;\n\t          \n\t          // Reset is allways possible\n\t          IF #tempEdges.reset THEN\n\t            #statMainState := #FB_STATE_RESET;\n\t            #tempRepeatStateMaschine := TRUE;\n\t            \n\t            // If error Pending - do nothing until error was reseted\n\t          ELSIF #statInternal.diagnostics.status.%X15 THEN\n\t            ;// Stay here and no further operation possible\n\t            \n\t            // Check whether the variable indices are within the ARRAY limits.\n\t            // IF they are NOT, the program execution is terminated at this point\n\t          ELSIF (#statNextEmptyItemIndex >= #statBufferSize) THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_INDEX_IN_ARRAY_LIMITS_1;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t          ELSIF (#statFirstItemIndex >= #statBufferSize) THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_INDEX_IN_ARRAY_LIMITS_2;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // multiple commands dedected\n\t          ELSIF (BOOL_TO_INT(#tempEdges.clear) + BOOL_TO_INT(#tempEdges.dequeue) + BOOL_TO_INT(#tempEdges.enqueue)) > 1 THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_MULTIPLE_COMMANDS_DEDECTED;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // Commands\n\t          ELSIF #tempEdges.clear THEN\n\t            #statMainState := #FB_STATE_CLEAR;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSIF #tempEdges.dequeue THEN\n\t            #statMainState := #FB_STATE_DEQUEUE;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSIF #tempEdges.enqueue THEN\n\t            #statMainState := #FB_STATE_ENQUEUE;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSE\n\t            #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t          END_IF;\n\t        END_REGION IDLE\n\t        \n\t      #FB_STATE_CLEAR:\n\t        REGION CLEARING\n\t          // Reset status\n\t          #statInternal.errorAutoCleared := FALSE;\n\t          \n\t          FOR #tempCounter := #COUNTER_LOWER_LIMIT TO UDINT_TO_DINT(#statBufferSize - #BUFFER_SIZE_CORRECTION) DO\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #tempCounter,\n\t                                                   DEST => #buffer);\n\t            \n\t            // Checks whether a local error has occurred.\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t              #statInternal.errorAutoCleared := TRUE;\n\t              #statInternal.diagnostics.status := #ERR_CLEAR_BUFFER;\n\t              #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t              EXIT;\n\t            END_IF;\n\t          END_FOR;\n\t          IF #statInternal.errorAutoCleared THEN\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // Reset counters\n\t          #statFirstItemIndex := #BUFFER_INITIALIZED;\n\t          #statNextEmptyItemIndex := #EMPTY_INITIALIZED;\n\t          #statElementCount := #EMPTY_INITIALIZED;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_RESET:\n\t        REGION RESET\n\t          // Reset Error Auto Cleared\n\t          #statInternal.errorAutoCleared := FALSE;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_DEQUEUE:\n\t        REGION DEQUEUE\n\t          // Check whether the ring #buffer is empty\n\t          // IF this is the CASE, program execution is terminated at this point\n\t          IF (#statFirstItemIndex = #BUFFER_IS_EMPTY) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_BUFFER_EMPTY;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // Return the first entry of the ring buffer\n\t          #tempInternalError := MOVE_BLK_VARIANT(SRC := #buffer,\n\t                                                 COUNT := #COUNT_ELEMENTS,\n\t                                                 SRC_INDEX := #statFirstItemIndex,\n\t                                                 DEST_INDEX := #INDEX_BEGINNING,\n\t                                                 DEST => #item);\n\t          \n\t          // Check whether a local error has occurred\n\t          IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_RETURN_FIRST_ENTRY;\n\t            #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // Check whether the ring #buffer contains ARRAY elements\n\t          // IF it does, the first entry is passed further on and the index is incremented BY 1\n\t          #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                 COUNT := #COUNT_ELEMENTS,\n\t                                                 SRC_INDEX := #INDEX_BEGINNING,\n\t                                                 DEST_INDEX := #statFirstItemIndex,\n\t                                                 DEST => #buffer);\n\t          \n\t          // Check whether a local error has occurred\n\t          IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_REPLACE_ITEM_BY_INIT_VALUE;\n\t            #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // Calculate the new index of the first entry\n\t          #tempNewFirstItemIndex := #statFirstItemIndex + #INCREMENT;\n\t          #tempNewFirstItemIndex := #tempNewFirstItemIndex MOD UDINT_TO_INT(#statBufferSize);\n\t          \n\t          // Check whether the ring buffer is empty\n\t          IF (#statNextEmptyItemIndex = #tempNewFirstItemIndex) THEN\n\t            // If the ring buffer is empty, the index is set to 0\n\t            #statFirstItemIndex := #BUFFER_INITIALIZED;\n\t            #statNextEmptyItemIndex := #EMPTY_INITIALIZED;\n\t          ELSE\n\t            // The index of the first entry is changed\n\t            #statFirstItemIndex := #tempNewFirstItemIndex;\n\t          END_IF;\n\t          \n\t          // Evaluation of the number of elements in the stack\n\t          #statElementCount -= #INCREMENT;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_ENQUEUE:\n\t        REGION ENQUEUE\n\t          // check whether the ring #buffer is full\n\t          // IF this is the CASE, program execution is terminated at this point\n\t          IF (#statNextEmptyItemIndex = #statFirstItemIndex) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_BUFFER_FULL;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // write the entry to the ring buffer\n\t          #tempInternalError := MOVE_BLK_VARIANT(SRC := #item,\n\t                                                 COUNT := #COUNT_ELEMENTS,\n\t                                                 SRC_INDEX := #INDEX_BEGINNING,\n\t                                                 DEST_INDEX := #statNextEmptyItemIndex,\n\t                                                 DEST => #buffer);\n\t          \n\t          // check whether a local error has occurred\n\t          IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_WRITE_ENTRY;\n\t            #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // increment the index by 1 and calculates the new empty entry index\n\t          #tempNewNextEmptyItemIndex := (#statNextEmptyItemIndex + #INCREMENT) MOD UDINT_TO_INT(#statBufferSize);\n\t          #statNextEmptyItemIndex := #tempNewNextEmptyItemIndex;\n\t          \n\t          // check which index the \"#firstItemIndex\" tag has\n\t          // IF the number = -1, the ring buffer is initialized\n\t          // AND the entry is written TO the ring #buffer\n\t          // Therefore, \"0\" must be assigned TO the tag\n\t          IF (#statFirstItemIndex = #BUFFER_INITIALIZED) THEN\n\t            #statFirstItemIndex := #INDEX_BEGINNING;\n\t          END_IF;\n\t          \n\t          // Evaluation of the number of elements in the stack\n\t          #statElementCount += #INCREMENT;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_DISABLING: // Disabling active\n\t        REGION Disabling\n\t          // Disabling is complete the bit #statDisablingCompleted must be set\n\t          #statInternal.disablingCompleted := TRUE;\n\t        END_REGION Disabling\n\t        \n\t      ELSE // Undefined state in state machine reached\n\t        REGION Undefined state\n\t          #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;\n\t          #statInternal.diagnostics.subfunctionStatus := 16#00;\n\t          #statInternal.diagnostics.stateNumber := #statMainState;\n\t          #statInternal.errorUserCleared := TRUE;\n\t        END_REGION Undefined state\n\t    END_CASE;\n\t  UNTIL #tempRepeatStateMaschine = false END_REPEAT;\n\tEND_REGION STATE MACHINE\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  IF (#statInternal.disablingCompleted = TRUE) THEN\n\t    REGION Disabling\n\t      // Reset outputs if disabling completed\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := FALSE;\n\t      #statInternal.errorUserCleared := FALSE;\n\t      #statInternal.errorAutoCleared := FALSE;\n\t      #statInternal.diagnostics.status := #STATUS_NO_CURRENT_JOBS;\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION Disabling\n\t    \n\t  ELSIF (#statInternal.errorUserCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION Error user cleared\n\t      // Error can only be cleared by user; rising edge at enable input is needed to continue \n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // Execution aborted --> set state no processing\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION Error user cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION Error auto cleared\n\t      // Error can be reset by FB automatically\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // Handling of autocleared error\n\t      #statMainState := #FB_STATE_IDLE;\n\t      #tempRepeatStateMaschine := TRUE;\n\t    END_REGION Error auto cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = FALSE) AND (#statInternal.errorUserCleared = FALSE) AND (#statInternal.error = TRUE) THEN\n\t    REGION After user/auto cleared or command aborted\n\t      // If autocleared error is acknowledged\n\t      #statInternal.valid := TRUE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := FALSE;\n\t      #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t    END_REGION After user/auto cleared or command aborted\n\t  END_IF;\n\t  \n\t  REGION Write static values to outputs\n\t    #valid := #statInternal.valid;\n\t    #busy := #statInternal.busy;\n\t    #error := #statInternal.error;\n\t    #status := #statInternal.diagnostics.status;\n\t    // if ENO mechanism is not used / error /& Status output present\n\t    ENO := TRUE;\n\t    // Write application specific static values to outputs\n\t    #elementCount := #statElementCount;\n\t    #isEmpty := #statElementCount <= #ZERO_ELEMENTS;\n\t    #isFull := #statElementCount >= #statBufferSize;\n\t  END_REGION Write static values to outputs\n\tEND_REGION OUTPUTS\n\t\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "FileDelete", "description": "This function block deletes a file that is stored on the memory card of the PLC (SMC) in the UserFiles folder.", "type": "FUNCTION_BLOCK", "name": "LGF_FileDelete", "vars": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file delete"}, {"name": "fileName", "type": "String", "description": "Name of file including path: `UserFiles/test.dat`"}, {"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished; new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the functionality"}, {"name": "fileDoesNotExist", "type": "Bool", "description": "True: The file or the path present at `fileName` does not exist"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file delete"}, {"name": "fileName", "type": "String", "description": "Name of file including path: `UserFiles/test.dat`"}], "output": [{"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished; new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the functionality"}, {"name": "fileDoesNotExist", "type": "Bool", "description": "True: The file or the path present at `fileName` does not exist"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_FileDelete\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Simatic Systems Support'\nFAMILY : LGF\nNAME : LGF_FileDelete\n   VAR_INPUT \n      execute : Bool;\n      fileName : String;\n   END_VAR\n\n   VAR_OUTPUT \n      done { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      fileDoesNotExist { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR \n      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         executePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n      END_STRUCT;\n      instFileDelete {InstructionName := 'FileDelete'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : FileDelete;\n      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;\n   END_VAR\n\n   VAR_TEMP \n      tempExecute : Bool;\n      tempExitStateLoop : Bool;\n      tempResult : Word;\n      tempBufferPosition : DInt;\n      tempPathPrefix : String;\n   END_VAR\n\n   VAR CONSTANT \n      PATH_PREFIX : String := 'UserFiles/';\n      FILE_DELETE_PATH_NAME_NOT_EXIST : Word := 16#8091;\n      FILE_DELETE_FILE_NOT_EXIST : Word := 16#8092;\n      FB_STATE_NO_PROCESSING : DInt := 0;\n      FB_STATE_INIT : DInt := 1;\n      FB_STATE_FILE_DELETE : DInt := 2;\n      STATUS_EXECUTION_FINISHED : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n      \"- - - Application Error codes\" : Word;\n      ERR_FILE_PATH : Word := 16#8401;\n      ERR_FILE_DELETE_INIT : Word := 16#8604;\n      ERR_FILE_DELETE : Word := 16#8605;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //================================================================================\n\t  // (C)Copyright Siemens 2025\n\t  //--------------------------------------------------------------------------------\n\t  // Library:       LGF (Library General Functions) \n\t  // Tested with:   S7-1510SP-F\n\t  // Engineering:   TIA Portal V15\n\t  // Restrictions:  ---\n\t  // Requirements:  S7-1500/S7-1500T FW 2.5\n\t  // Functionality: This function block offers deleting a file stored on the PLC's memory card (SMC) in the folder `UserFiles`.\n\t  //--------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  //----------|------------|-------------------------|------------------------------\n\t  // 01.00.00 | 29.04.2025 | Simatic Systems Support | First released version\n\t  //================================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION TRIGGERING\n\t  #tempExecute := #execute; // Work with temporary value / create process image\n\t  IF (#tempExecute = TRUE) AND (#statInternal.executePrevious = FALSE) // Check if FB is triggered\n\t    // FB shall finish current job before new job can be started with rising edge of execute\n\t    AND (#statInternal.diagnostics.status = #STATUS_NO_CALL)\n\t  THEN // First call; initialize FB\n\t    #statInternal.done := FALSE;\n\t    #statInternal.busy := TRUE;\n\t    #statInternal.error := FALSE;\n\t    \n\t    #statMainState := #FB_STATE_INIT; // State machine - start processing\n\t    // Initialize functionality: reset of variables, diagnostics, etc.\n\t    #statInternal.diagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;\n\t    #diagnostics := #statInternal.emptyDiagnostics;\n\t    \n\t    // Initialize functionality: call subsidiary FBs with FALSE\n\t    #instFileDelete(REQ := FALSE);\n\t    \n\t  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN\n\t    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t  END_IF;\n\t  \n\t  // Edge detection 'execute' input\n\t  #statInternal.executePrevious := #tempExecute;\n\tEND_REGION TRIGGERING\n\t\n\tIF (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION STATE_MACHINE\n\t  // if one ore more runs in the same cycle are necessary, set #tempStateChangeActive := TRUE;\n\t  REPEAT\n\t    // reset #tempExitStateLoop := TRUE; as its defined state to prevent endless loop\n\t    #tempExitStateLoop := TRUE;\n\t    \n\t    // State machine of FB\n\t    CASE #statMainState OF\n\t      #FB_STATE_NO_PROCESSING: // No processing active (Note: this state must always be present and left empty)\n\t        ;\n\t        \n\t      #FB_STATE_INIT:\n\t        REGION Init\n\t          REGION Verify File Path\n\t            #tempPathPrefix := #PATH_PREFIX;\n\t            \n\t            FOR #tempBufferPosition := 1 TO DINT_TO_INT(LEN(#tempPathPrefix)) DO\n\t              IF #fileName[#tempBufferPosition] <> #tempPathPrefix[#tempBufferPosition] THEN\n\t                // Characters arenÄt identiacal\n\t                #statInternal.diagnostics.status := #ERR_FILE_PATH;\n\t                #statInternal.diagnostics.subfunctionStatus := DINT_TO_WORD(#tempBufferPosition);\n\t                // stop execution and leave block\n\t                EXIT;\n\t              END_IF;\n\t            END_FOR;\n\t            \n\t            IF #statInternal.diagnostics.status.%X15 THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          // next state\n\t          #statMainState := #FB_STATE_FILE_DELETE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_FILE_DELETE:\n\t        REGION File handling\n\t          // set file handler request to true\n\t          #instFileDelete(REQ  := TRUE,\n\t                          Name := #fileName);\n\t          \n\t          IF #instFileDelete.Error THEN\n\t            #statInternal.diagnostics.status := #ERR_FILE_DELETE;\n\t            #statInternal.diagnostics.subfunctionStatus := #instFileDelete.Status;\n\t            // stop execution and leave block\n\t            EXIT;\n\t            \n\t          ELSIF #instFileDelete.Done THEN\n\t            // next state switched by status\n\t            #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED;\n\t            #statInternal.diagnostics.subfunctionStatus := 16#0000;\n\t            \n\t          ELSE\n\t            ; // nothing to do, just proceed\n\t          END_IF;\n\t        END_REGION\n\t        \n\t      ELSE // Undefined state in state machine reached\n\t        #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;\n\t    END_CASE;\n\t    // if one ore more runs in the same cycle are necessary, set #tempExitStateLoop := FALSE;\n\t    // check state, if condition = TRUE --> #tempExitStateLoop = TRUE --> LEAVE LOOP\n\t  UNTIL (TRUE = #tempExitStateLoop)\n\t  END_REPEAT;\n\tEND_REGION STATE_MACHINE\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  IF (#statInternal.diagnostics.status = #STATUS_EXECUTION_FINISHED) AND (#statInternal.done = FALSE) THEN // Execution finished without errors\n\t    #statInternal.done := TRUE;\n\t    #statInternal.busy := FALSE;\n\t    #statInternal.error := FALSE;\n\t    #statMainState := #FB_STATE_NO_PROCESSING; // Switch state machine to \"no processing\"\n\t    \n\t  ELSIF (#statInternal.diagnostics.status.%X15 = TRUE) AND (#statInternal.error = FALSE) THEN // Error occurred (#statStatus is 16#8000 to 16#FFFF)\n\t    #statInternal.done := FALSE;\n\t    #statInternal.busy := FALSE;\n\t    #statInternal.error := TRUE;\n\t    // Write diagnostics\n\t    #statInternal.diagnostics.stateNumber := #statMainState;\n\t    #diagnostics := #statInternal.diagnostics;\n\t    #statMainState := #FB_STATE_NO_PROCESSING; // Switch state machine to \"no processing\"\n\t    \n\t  ELSIF (#tempExecute = FALSE) AND ((#statInternal.done = TRUE) OR (#statInternal.error = TRUE)) THEN // Reset outputs\n\t    #statInternal.done := FALSE;\n\t    #statInternal.busy := FALSE;\n\t    #statInternal.error := FALSE;\n\t    #statInternal.diagnostics.status := #STATUS_NO_CALL;\n\t  END_IF;\n\t  \n\t  // Write static values to outputs\n\t  #done := #statInternal.done;\n\t  #busy := #statInternal.busy;\n\t  #error := #statInternal.error;\n\t  #status := #statInternal.diagnostics.status;\n\t  \n\t  #fileDoesNotExist := TRUE\n\t  AND #statInternal.diagnostics.status = #ERR_FILE_DELETE\n\t  AND (FALSE\n\t  OR #statInternal.diagnostics.subfunctionStatus = #FILE_DELETE_PATH_NAME_NOT_EXIST\n\t  OR #statInternal.diagnostics.subfunctionStatus = #FILE_DELETE_FILE_NOT_EXIST\n\t  )\n\t  ;\n\t  \n\t  ENO := #statInternal.error;\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "FileRead", "description": "This function block offers reading data as binary / serialized data stream from files stored on the PLC's memory card in the folder UserFiles.", "type": "FUNCTION_BLOCK", "name": "LGF_FileRead", "vars": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file read once"}, {"name": "dataLengthMustMatch", "type": "Bool", "description": "TRUE: The length of the file data set and the dataset in\nthe PLC must match."}, {"name": "fileName", "type": "String", "description": "Name of file including path: `UserFiles/test.dat`"}, {"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished; new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the functionality"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "dataLength", "type": "DInt", "description": "Data length read from file (serialized length of `data`)"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}, {"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set read from file"}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file read once"}, {"name": "dataLengthMustMatch", "type": "Bool", "description": "TRUE: The length of the file data set and the dataset in\nthe PLC must match."}, {"name": "fileName", "type": "String", "description": "Name of file including path: `UserFiles/test.dat`"}], "output": [{"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished; new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the functionality"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "dataLength", "type": "DInt", "description": "Data length read from file (serialized length of `data`)"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}], "in/out": [{"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set read from file"}], "answer": "FUNCTION_BLOCK \"LGF_FileRead\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Simatic Systems Support'\nFAMILY : LGF\nNAME : LGF_FileRead\n   VAR_INPUT \n      execute : Bool;\n      dataLengthMustMatch : Bool;\n      fileName : String;\n   END_VAR\n\n   VAR_OUTPUT \n      done { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      dataLength { ExternalWritable := 'False'} : DInt;\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR_IN_OUT \n      bufferByteArray : Array[*] of Byte;\n      data : Variant;\n   END_VAR\n\n   VAR \n      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         executePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n      END_STRUCT;\n      instFileRead {InstructionName := 'FileReadC'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : FileReadC;\n      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;\n      statParameterDataIsByteArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statAsynchronusMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statBufferSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statLengthData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statLengthFile { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 0;\n   END_VAR\n\n   VAR_TEMP \n      tempExecute : Bool;\n      tempExitStateLoop : Bool;\n      tempResult : Word;\n      tempBufferPosition : DInt;\n      tempPathPrefix : String;\n   END_VAR\n\n   VAR CONSTANT \n      PATH_PREFIX : String := 'UserFiles/';\n      FB_STATE_NO_PROCESSING : DInt := 0;\n      FB_STATE_INIT : DInt := 1;\n      FB_STATE_FILE_READ : DInt := 2;\n      FB_STATE_PARAMETER_TO_INTERFACE : DInt := 3;\n      STATUS_EXECUTION_FINISHED : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n      \"- - - Application Error codes\" : Word;\n      ERR_BUFFER_LOWERBOUND : Word := 16#8201;\n      ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY : Word := 16#8202;\n      ERR_FILE_PATH : Word := 16#8401;\n      ERR_FILE_SIZE_GRATER_THEN_DATA_SIZE : Word := 16#8411;\n      ERR_FILE_SIZE_LESS_THEN_DATA_SIZE : Word := 16#8412;\n      ERR_MOVE_BLK_VARIANT : Word := 16#8601;\n      ERR_DATA_SERIALIZE : Word := 16#8602;\n      ERR_DATA_DESERIALIZE : Word := 16#8603;\n      ERR_FILE_READ_INIT : Word := 16#8604;\n      ERR_FILE_READ : Word := 16#8605;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //================================================================================\n\t  // SIEMENS AG\n\t  // (c)Copyright 2017 All Rights Reserved\n\t  //--------------------------------------------------------------------------------\n\t  // Library:       LGF (Library General Functions) \n\t  // Tested with:   S7-1510SP-F\n\t  // Engineering:   TIA Portal V15\n\t  // Restrictions:  ---\n\t  // Requirements:  S7-1500/S7-1500T FW 2.5\n\t  // Functionality: This function block offers reading data as binary / serialized data stream\n\t  //                from files stored on the PLC's memory card in the folder `UserFiles`.\n\t  //--------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  //----------|------------|-------------------------|------------------------------\n\t  // 01.00.00 | 19.02.2023 | Simatic Systems Support | First released version\n\t  // 01.00.01 | 29.04.2025 | Simatic Systems Support | Add missing text in constant area\n\t  //================================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION TRIGGERING\n\t  #tempExecute := #execute; // Work with temporary value / create process image\n\t  IF (#tempExecute = TRUE) AND (#statInternal.executePrevious = FALSE) // Check if FB is triggered\n\t    // FB shall finish current job before new job can be started with rising edge of execute\n\t    AND (#statInternal.diagnostics.status = #STATUS_NO_CALL)\n\t  THEN // First call; initialize FB\n\t    #statInternal.done := FALSE;\n\t    #statInternal.busy := TRUE;\n\t    #statInternal.error := FALSE;\n\t    \n\t    #statMainState := #FB_STATE_INIT; // State machine - start processing\n\t    // Initialize functionality: reset of variables, diagnostics, etc.\n\t    #statInternal.diagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;\n\t    #diagnostics := #statInternal.emptyDiagnostics;\n\t    \n\t    // Initialize functionality: call subsidiary FBs with FALSE\n\t    #instFileRead(REQ := FALSE);\n\t    \n\t  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN\n\t    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t  END_IF;\n\t  \n\t  // Edge detection 'execute' input\n\t  #statInternal.executePrevious := #tempExecute;\n\tEND_REGION TRIGGERING\n\t\n\tIF (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION STATE_MACHINE\n\t  // if one ore more runs in the same cycle are necessary, set #tempStateChangeActive := TRUE;\n\t  REPEAT\n\t    // reset #tempExitStateLoop := TRUE; as its defined state to prevent endless loop\n\t    #tempExitStateLoop := TRUE;\n\t    \n\t    // State machine of FB\n\t    CASE #statMainState OF\n\t      #FB_STATE_NO_PROCESSING: // No processing active (Note: this state must always be present and left empty)\n\t        ;\n\t        \n\t      #FB_STATE_INIT:\n\t        REGION Init\n\t          REGION Verify File Path\n\t            #tempPathPrefix := #PATH_PREFIX;\n\t            \n\t            FOR #tempBufferPosition := 1 TO DINT_TO_INT(LEN(#tempPathPrefix)) DO\n\t              IF #fileName[#tempBufferPosition] <> #tempPathPrefix[#tempBufferPosition] THEN\n\t                // Characters arenÄt identiacal\n\t                #statInternal.diagnostics.status := #ERR_FILE_PATH;\n\t                #statInternal.diagnostics.subfunctionStatus := DINT_TO_WORD(#tempBufferPosition);\n\t                // stop execution and leave block\n\t                EXIT;\n\t              END_IF;\n\t            END_FOR;\n\t            \n\t            IF #statInternal.diagnostics.status.%X15 THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          REGION Verify buffer boundary\n\t            // check buffer size\n\t            // check lower boundary\n\t            #tempResult := DINT_TO_WORD(LOWER_BOUND(ARR := #bufferByteArray, DIM := 1));\n\t            \n\t            IF 0 <> #tempResult THEN\n\t              // ERROR: buffer lowerbound has to be 0\n\t              #statInternal.diagnostics.status := #ERR_BUFFER_LOWERBOUND;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              // stop execution and leave block\n\t              EXIT;\n\t            ELSE\n\t              ; // nothing to do, just proceed\n\t            END_IF;\n\t            \n\t            // get upper boundary and calc size of buffer\n\t            #statBufferSize := UPPER_BOUND(ARR := #bufferByteArray, DIM := 1) + 1;\n\t          END_REGION\n\t          \n\t          // verify parameter data types\n\t          REGION Verify parameter data types\n\t            // check type of Parameter attached to IN/OUT\n\t            // if Array proceed here, Array limits checked by move block variant\n\t            IF IS_ARRAY(#data) AND TypeOfElements(#data) = Byte THEN\n\t              // data type match - nothing to do\n\t              #statParameterDataIsByteArray := TRUE;\n\t              // get array size\n\t              #statLengthData := UDINT_TO_DINT(CountOfElements(#data));\n\t              \n\t              // verify if buffer is big enough to store data\n\t              IF #statBufferSize < #statLengthData THEN\n\t                // ERROR: buffer array is to small for data array\n\t                #statInternal.diagnostics.status := #ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY;\n\t                #statInternal.diagnostics.subfunctionStatus := 16#0000;\n\t                // stop execution and leave block\n\t                EXIT;\n\t              ELSE\n\t                ; // nothing to do, just proceed\n\t              END_IF;\n\t              \n\t            ELSE\n\t              #statParameterDataIsByteArray := FALSE;\n\t              #statLengthData := 0;\n\t              #tempResult := INT_TO_WORD(\n\t                                         Serialize(SRC_VARIABLE := #data,\n\t                                                   DEST_ARRAY => #bufferByteArray,\n\t                                                   POS := #statLengthData));\n\t              \n\t              // check if serialize parameter structure was successful, otherwise set ERROR\n\t              IF 16#0000 <> #tempResult THEN\n\t                #statInternal.diagnostics.status := #ERR_DATA_SERIALIZE;\n\t                #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t                // stop execution and leave block\n\t                EXIT;\n\t              ELSE\n\t                ; // nothing to do, just proceed\n\t              END_IF;\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          REGION File handler init\n\t            // Set length for FileRead call\n\t            IF #dataLengthMustMatch THEN\n\t              #instFileRead.Length := 0;\n\t            ELSE\n\t              #instFileRead.Length := DINT_TO_UDINT(#statLengthData);\n\t            END_IF;\n\t            \n\t            // init file read with false\n\t            #instFileRead(REQ := FALSE);\n\t            \n\t            IF #instFileRead.Error THEN\n\t              #statInternal.diagnostics.status := #ERR_FILE_READ_INIT;\n\t              #statInternal.diagnostics.subfunctionStatus := #instFileRead.Status;\n\t              // stop execution and leave block\n\t              EXIT;\n\t            ELSE //IF TRUE = #instFileReadC.Done THEN\n\t              // next state\n\t              #statMainState := #FB_STATE_FILE_READ;\n\t              // ASYNCRONUS - set to true:\n\t              #tempExitStateLoop := #statAsynchronusMode;\n\t            END_IF;\n\t          END_REGION\n\t        END_REGION\n\t        \n\t      #FB_STATE_FILE_READ:\n\t        REGION File handling\n\t          // set file handler request to true\n\t          #instFileRead(REQ    := TRUE,\n\t                        Name   := #fileName,\n\t                        Offset := UDINT#0,\n\t                        Data   := #bufferByteArray);\n\t          \n\t          IF #instFileRead.Error THEN\n\t            #statLengthFile := UDINT_TO_DINT(#instFileRead.ResultLength);\n\t            #statInternal.diagnostics.status := #ERR_FILE_READ;\n\t            #statInternal.diagnostics.subfunctionStatus := #instFileRead.Status;\n\t            // stop execution and leave block\n\t            EXIT;\n\t            \n\t          ELSIF #instFileRead.Done THEN\n\t            #statLengthFile := UDINT_TO_DINT(#instFileRead.ResultLength);\n\t            // Check file length parameter\n\t            IF TRUE\n\t              AND #dataLengthMustMatch\n\t              AND (#statLengthFile > #statLengthData)\n\t            THEN\n\t              #statInternal.diagnostics.status := #ERR_FILE_SIZE_GRATER_THEN_DATA_SIZE;\n\t              #statInternal.diagnostics.subfunctionStatus := DINT_TO_WORD(#statLengthData);\n\t              // stop execution and leave block\n\t              EXIT;\n\t              \n\t            ELSIF TRUE\n\t              AND #dataLengthMustMatch\n\t              AND (#statLengthFile < #statLengthData)\n\t            THEN\n\t              #statInternal.diagnostics.status := #ERR_FILE_SIZE_LESS_THEN_DATA_SIZE;\n\t              #statInternal.diagnostics.subfunctionStatus := DINT_TO_WORD(#statLengthData);\n\t              // stop execution and leave block\n\t              EXIT;\n\t              \n\t            ELSE\n\t              // next state\n\t              #statMainState := #FB_STATE_PARAMETER_TO_INTERFACE;\n\t              // ASYNCRONUS - set to true:\n\t              #tempExitStateLoop := #statAsynchronusMode;\n\t            END_IF;\n\t            \n\t          ELSE\n\t            ; // nothing to do, just proceed\n\t          END_IF;\n\t        END_REGION\n\t        \n\t      #FB_STATE_PARAMETER_TO_INTERFACE:\n\t        REGION Parameter handling \n\t          // if paramter is byte array - just copy\n\t          IF #statParameterDataIsByteArray THEN\n\t            // copy buffer array into paramter array\n\t            #tempResult := INT_TO_WORD(\n\t                                       MOVE_BLK_VARIANT(SRC := #bufferByteArray,\n\t                                                        COUNT := DINT_TO_UDINT(#statLengthData),\n\t                                                        SRC_INDEX := DINT#0,\n\t                                                        DEST_INDEX := DINT#0,\n\t                                                        DEST => #data)\n\t            );\n\t            \n\t            // check if move parameter structure was successful, otherwise set ERROR\n\t            IF 16#0000 <> #tempResult THEN\n\t              #statInternal.diagnostics.status := #ERR_MOVE_BLK_VARIANT;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              // stop execution and leave block\n\t              EXIT;\n\t            ELSE\n\t              // next state switched by status\n\t              #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED;\n\t              #statInternal.diagnostics.subfunctionStatus := 16#0000;\n\t            END_IF;\n\t            \n\t          ELSE\n\t            // elsif paramter is NOT byte array - DESERIALZE\n\t            // init buffer size/position pointer\n\t            #tempBufferPosition := 0;\n\t            // deserialize data from buffer\n\t            #tempResult := INT_TO_WORD(\n\t                                       Deserialize(\n\t                                                   SRC_ARRAY := #bufferByteArray,\n\t                                                   DEST_VARIABLE => #data,\n\t                                                   POS := #tempBufferPosition)\n\t            );\n\t            \n\t            // check if serialize parameter structure was successful, otherwise set ERROR\n\t            IF 16#0000 <> #tempResult THEN\n\t              #statInternal.diagnostics.status := #ERR_DATA_DESERIALIZE;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              // stop execution and leave block\n\t              EXIT;\n\t            ELSE\n\t              // next state switched by status\n\t              #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED;\n\t              #statInternal.diagnostics.subfunctionStatus := 16#0000;\n\t            END_IF;\n\t          END_IF;\n\t        END_REGION\n\t        \n\t      ELSE // Undefined state in state machine reached\n\t        #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;\n\t    END_CASE;\n\t    // if one ore more runs in the same cycle are necessary, set #tempExitStateLoop := FALSE;\n\t    // check state, if condition = TRUE --> #tempExitStateLoop = TRUE --> LEAVE LOOP\n\t  UNTIL (TRUE = #tempExitStateLoop)\n\t  END_REPEAT;\n\tEND_REGION STATE_MACHINE\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  IF (#statInternal.diagnostics.status = #STATUS_EXECUTION_FINISHED) AND (#statInternal.done = FALSE) THEN // Execution finished without errors\n\t    #statInternal.done := TRUE;\n\t    #statInternal.busy := FALSE;\n\t    #statInternal.error := FALSE;\n\t    #statMainState := #FB_STATE_NO_PROCESSING; // Switch state machine to \"no processing\"\n\t    \n\t  ELSIF (#statInternal.diagnostics.status.%X15 = TRUE) AND (#statInternal.error = FALSE) THEN // Error occurred (#statStatus is 16#8000 to 16#FFFF)\n\t    #statInternal.done := FALSE;\n\t    #statInternal.busy := FALSE;\n\t    #statInternal.error := TRUE;\n\t    // Write diagnostics\n\t    #statInternal.diagnostics.stateNumber := #statMainState;\n\t    #diagnostics := #statInternal.diagnostics;\n\t    #statMainState := #FB_STATE_NO_PROCESSING; // Switch state machine to \"no processing\"\n\t    \n\t  ELSIF (#tempExecute = FALSE) AND ((#statInternal.done = TRUE) OR (#statInternal.error = TRUE)) THEN // Reset outputs\n\t    #statInternal.done := FALSE;\n\t    #statInternal.busy := FALSE;\n\t    #statInternal.error := FALSE;\n\t    #statInternal.diagnostics.status := #STATUS_NO_CALL;\n\t    #statLengthData := 0;\n\t    #statLengthFile := 0;\n\t  END_IF;\n\t  \n\t  // Write static values to outputs\n\t  #done := #statInternal.done;\n\t  #busy := #statInternal.busy;\n\t  #error := #statInternal.error;\n\t  #status := #statInternal.diagnostics.status;\n\t  \n\t  #dataLength := #statLengthData;\n\t  ENO := #statInternal.error;\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "FileReadWriteDelete", "description": "The function LGF_FileReadWriteDelete can be used to read, write or delete a file to/from the SIMATIC Memory Card (SMC). To read or write the data, it is necessary to deserialize/serialize it, which the function already does for the user. For this purpose, an external buffer in the form of a byte array must be connected, which can hold the amount of data; if the buffer is too small, an error is output. The file name must always be specified in full together with the folder name and the file extension in the following format: UserFiles/Test.dat.", "type": "FUNCTION_BLOCK", "name": "LGF_FileReadWriteDelete", "vars": [{"name": "executeRead", "type": "Bool", "description": "Rising edge starts file read once"}, {"name": "executeWrite", "type": "Bool", "description": "Rising edge starts file write once"}, {"name": "executeDelete", "type": "Bool", "description": "Rising edge starts file delete once"}, {"name": "fileName", "type": "String", "description": "Name of file including path: `UserFiles/test.dat`"}, {"name": "parameter", "type": "LGF_typeFileRead\nWriteDelete\nParameter", "description": "This UDT belongs to the Module\n`LGF_FileReadWriteDelete` and lists all possible\nparameters to configure its behavior."}, {"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished; new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the functionality"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "dataLength", "type": "DInt", "description": "Data length read from file (serialized length of `data`)"}, {"name": "fileDoesNotExist", "type": "Bool", "description": "True: The file or the path present at `fileName` does not exist"}, {"name": "timestamps", "type": "LGF_typeFileRead\nWriteDelete\nTimestamps", "description": "Timestamps for commands and file"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}, {"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set read from file / to write to file"}, {"name": "dataLengthMust\nMatch", "type": "Bool", "description": "TRUE: The length of the file data set and the dataset in\nthe PLC must match (File read)"}, {"name": "clearBuffer\nBefore", "type": "Bool", "description": "TRUE: Buffer would be cleared with 16#00 Byte before\nwriting the data (File write)"}, {"name": "includeTimestamp", "type": "Bool", "description": "TRUE: A Timestamp (DTL) is included in front of the\nData.\n`executeWrite` adds the actual time (system- or local\ntime)\n`executeRead` reads back the timestamp"}, {"name": "timeStampIsLocal", "type": "Bool", "description": "TRUE: The timestamp is used in local time.\nFALSE: The timestamp is used in system time / UTC.\nOnly used if `includeTimestamp` is set."}, {"name": "file", "type": "LGF_typeFileRea\nd\nWriteDelete\nTimestamp", "description": "Time stamp of file"}, {"name": "lastCommand", "type": "LGF_typeFileRea\nd\nWriteDelete\nTimestamp", "description": "Time stamp of last command"}, {"name": "executeRead", "type": "LGF_typeFileRea\nd\nWriteDelete\nTimestamp", "description": "Time stamp of command `executeRead`"}, {"name": "executeWrite", "type": "LGF_typeFileRea\nd\nWriteDelete\nTimestamp", "description": "Time stamp of command `executeWrite`"}, {"name": "executeDelete", "type": "LGF_typeFileRea\nd\nWriteDelete\nTimestamp", "description": "Time stamp of command `executeDelete`"}, {"name": "lastError", "type": "LGF_typeFileRea\nd\nWriteDelete\nTimestamp", "description": "Time stamp of the last error that occurred"}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [{"name": "executeRead", "type": "Bool", "description": "Rising edge starts file read once"}, {"name": "executeWrite", "type": "Bool", "description": "Rising edge starts file write once"}, {"name": "executeDelete", "type": "Bool", "description": "Rising edge starts file delete once"}, {"name": "fileName", "type": "String", "description": "Name of file including path: `UserFiles/test.dat`"}, {"name": "parameter", "type": "LGF_typeFileRead\nWriteDelete\nParameter", "description": "This UDT belongs to the Module\n`LGF_FileReadWriteDelete` and lists all possible\nparameters to configure its behavior."}], "output": [{"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished; new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the functionality"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "dataLength", "type": "DInt", "description": "Data length read from file (serialized length of `data`)"}, {"name": "fileDoesNotExist", "type": "Bool", "description": "True: The file or the path present at `fileName` does not exist"}, {"name": "timestamps", "type": "LGF_typeFileRead\nWriteDelete\nTimestamps", "description": "Timestamps for commands and file"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}], "in/out": [{"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set read from file / to write to file"}], "answer": "FUNCTION_BLOCK \"LGF_FileReadWriteDelete\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Simatic Systems Support'\nFAMILY : LGF\nNAME : LGF_FileReadWriteDelete\n   VAR_INPUT \n      executeRead : Bool;\n      executeWrite : Bool;\n      executeDelete : Bool;\n      fileName : String;\n      parameter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : \"LGF_typeFileReadWriteDeleteParameter\";\n   END_VAR\n\n   VAR_OUTPUT \n      done { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      dataLength { ExternalWritable := 'False'} : DInt;\n      fileDoesNotExist { ExternalWritable := 'False'} : Bool;\n      timestamps { ExternalWritable := 'False'} : \"LGF_typeFileReadWriteDeleteTimestamps\";\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR_IN_OUT \n      bufferByteArray : Array[*] of Byte;\n      data : Variant;\n   END_VAR\n\n   VAR \n      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         executePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n      END_STRUCT;\n      instFileRead {InstructionName := 'FileReadC'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : FileReadC;\n      instFileWrite {InstructionName := 'FileWriteC'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : FileWriteC;\n      instFileDelete {InstructionName := 'FileDelete'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : FileDelete;\n      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #STATE_NO_PROCESSING;\n      statParameterDataIsByteArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statAsynchronusMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statBufferSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statLengthData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statLengthFile { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 0;\n      statLengthTimeStamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 0;\n      statTimestamps { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeFileReadWriteDeleteTimestamps\";\n      statTimestampDefault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeFileReadWriteDeleteTimestamp\" := (#DEFAULT_DATE, FALSE);\n   END_VAR\n\n   VAR_TEMP \n      tempExecute : Bool;\n      tempExitStateLoop : Bool;\n      tempResult : Word;\n      tempBufferPosition : DInt;\n      tempPathPrefix : String;\n   END_VAR\n\n   VAR CONSTANT \n      DEFAULT_DATE {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1970-01-01-00:00:00;\n      PATH_PREFIX : String := 'UserFiles/';\n      EMPTY_BYTE : Byte := 16#00;\n      FILE_DELETE_PATH_NAME_NOT_EXIST : Word := 16#8091;\n      FILE_DELETE_FILE_NOT_EXIST : Word := 16#8092;\n      STATE_NO_PROCESSING : DInt := 0;\n      STATE_FILE_READ_INIT : DInt := 1;\n      STATE_FILE_WRITE_INIT : DInt := 2;\n      STATE_FILE_DELETE_INIT : DInt := 3;\n      STATE_FILE_READ : DInt := 10;\n      STATE_FILE_READ_PARAMETER_TO_INTERFACE : DInt := 11;\n      STATE_FILE_WRITE_PARAMETER : DInt := 20;\n      STATE_FILE_WRITE : DInt := 21;\n      STATE_FILE_DELETE : DInt := 30;\n      STATUS_EXECUTION_FINISHED : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n      \"- - - Application Error codes\" : Word;\n      ERR_BUFFER_LOWERBOUND : Word := 16#8201;\n      ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY : Word := 16#8202;\n      ERR_MULTIPLE_COMMANDS : Word := 16#8400;\n      ERR_FILE_PATH : Word := 16#8401;\n      ERR_READ_TIME_LOCAL : Word := 16#8402;\n      ERR_READ_TIME_SYSTEM : Word := 16#8403;\n      ERR_FILE_SIZE_GRATER_THEN_DATA_SIZE : Word := 16#8411;\n      ERR_FILE_SIZE_LESS_THEN_DATA_SIZE : Word := 16#8412;\n      ERR_MOVE_BLK_VARIANT : Word := 16#8601;\n      ERR_SERIALIZE_DATA : Word := 16#8602;\n      ERR_DESERIALIZE_DATA : Word := 16#8603;\n      ERR_SERIALIZE_DATE_TIMESTAMP : Word := 16#8604;\n      ERR_DESERIALIZE_DATE_TIMESTAMP : Word := 16#8605;\n      ERR_FILE_READ_INIT : Word := 16#8610;\n      ERR_FILE_READ : Word := 16#8611;\n      ERR_FILE_WRITE_INIT : Word := 16#8620;\n      ERR_FILE_WRITE : Word := 16#8621;\n      ERR_FILE_DELETE_INIT : Word := 16#8630;\n      ERR_FILE_DELETE : Word := 16#8631;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //================================================================================\n\t  //SIEMENS AG\n\t  //(c)Copyright 2017 All Rights Reserved\n\t  //--------------------------------------------------------------------------------\n\t  //Library:       LGF (Library General Functions) \n\t  //Tested with:   S7-1510SP-F\n\t  //Engineering:   TIA Portal V15\n\t  //Restrictions:  ---\n\t  //Requirements:  S7-1500/S7-1500T FW 2.5\n\t  //Functionality: The function `LGF_FileReadWriteDelete` can be used to read, write or delete a file to/from the SIMATIC Memory Card (SMC).\n\t  //To read or write the data, it is necessary to deserialize/serialize it, which the function already does for the user.\n\t  //For this purpose, an external buffer in the form of a Byte array must be connected, which can hold the amount of data;\n\t  //if the buffer is too small, an error is output.\n\t  //The file name must always be specified in full together with the folder name AND the file extension in the following format: `UserFiles/Test.dat`.\n\t  //--------------------------------------------------------------------------------\n\t  //Change log table:\n\t  //Version  | Date       | Expert in charge        | Changes applied\n\t  //---------|------------|-------------------------|------------------------------\n\t  //01.00.00 | 10.07.2025 | Simatic Systems Support | First released version\n\t  //================================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\t  \n\t  (/**/)\n\t  \n\t  (/**/)\n\t  \n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION TRIGGERING\n\t  #tempExecute := #executeRead OR #executeWrite OR #executeDelete; // Work with temporary value / create process image\n\t  IF (#tempExecute = TRUE) AND (#statInternal.executePrevious = FALSE) // Check if FB is triggered\n\t    // FB shall finish current job before new job can be started with rising edge of execute\n\t    AND (#statInternal.diagnostics.status = #STATUS_NO_CALL)\n\t  THEN // First call; initialize FB\n\t    #statInternal.done := FALSE;\n\t    #statInternal.busy := TRUE;\n\t    #statInternal.error := FALSE;\n\t    \n\t    // Initialize functionality: reset of variables, diagnostics, etc.\n\t    #statInternal.diagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;\n\t    #diagnostics := #statInternal.emptyDiagnostics;\n\t    \n\t    // Initialize functionality: call subsidiary FBs with FALSE\n\t    #instFileRead(REQ := FALSE);\n\t    #instFileWrite(REQ := FALSE);\n\t    #instFileDelete(REQ := FALSE);\n\t    \n\t    REGION Generate Timestamp of command\n\t      IF #parameter.timeStampIsLocal THEN\n\t        #tempResult := INT_TO_WORD(RD_LOC_T(#statTimestamps.lastCommand.dateAndTime));\n\t      ELSE\n\t        #tempResult := INT_TO_WORD(RD_SYS_T(#statTimestamps.lastCommand.dateAndTime));\n\t      END_IF;\n\t      #statTimestamps.lastCommand.timestampIsLocal := #parameter.timeStampIsLocal;\n\t    END_REGION\n\t    \n\t    IF FALSE // Multiple Commands set?\n\t      OR (#executeRead AND #executeWrite)\n\t      OR (#executeRead AND #executeDelete)\n\t      OR (#executeWrite AND #executeDelete)\n\t    THEN\n\t      #statInternal.diagnostics.status := #ERR_MULTIPLE_COMMANDS;\n\t      #statInternal.diagnostics.stateNumber := #STATE_NO_PROCESSING;\n\t      #statMainState := #STATE_NO_PROCESSING;\n\t      \n\t    ELSIF #tempResult.%X15 THEN // Read time stamp throws an error?\n\t      IF #parameter.timeStampIsLocal THEN\n\t        #statInternal.diagnostics.status := #ERR_READ_TIME_LOCAL;\n\t      ELSE\n\t        #statInternal.diagnostics.status := #ERR_READ_TIME_SYSTEM;\n\t      END_IF;\n\t      \n\t      #statInternal.diagnostics.stateNumber := #STATE_NO_PROCESSING;\n\t      #statMainState := #STATE_NO_PROCESSING;\n\t      \n\t      // State machine - start processing\n\t    ELSIF #executeRead THEN\n\t      #statMainState := #STATE_FILE_READ_INIT;\n\t    ELSIF #executeWrite THEN\n\t      #statMainState := #STATE_FILE_WRITE_INIT;\n\t    ELSIF #executeDelete THEN\n\t      #statMainState := #STATE_FILE_DELETE_INIT;\n\t    END_IF;\n\t    \n\t  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN\n\t    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t  END_IF;\n\t  \n\t  // Edge detection 'execute' input\n\t  #statInternal.executePrevious := #tempExecute;\n\tEND_REGION TRIGGERING\n\t\n\tIF (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION STATE_MACHINE\n\t  // If one ore more runs in the same cycle are necessary, set #tempStateChangeActive := TRUE;\n\t  REPEAT\n\t    // Reset #tempExitStateLoop := TRUE; as its defined state to prevent endless loop\n\t    #tempExitStateLoop := TRUE;\n\t    \n\t    // State machine of FB\n\t    CASE #statMainState OF\n\t      #STATE_NO_PROCESSING: // No processing active (Note: this state must always be present and left empty)\n\t        ;\n\t        \n\t      #STATE_FILE_READ_INIT,\n\t      #STATE_FILE_WRITE_INIT,\n\t      #STATE_FILE_DELETE_INIT:\n\t        REGION Init\n\t          REGION Verify File Path\n\t            #tempPathPrefix := #PATH_PREFIX;\n\t            \n\t            FOR #tempBufferPosition := 1 TO DINT_TO_INT(LEN(#tempPathPrefix)) DO\n\t              IF #fileName[#tempBufferPosition] <> #tempPathPrefix[#tempBufferPosition] THEN\n\t                // Characters arenÄt identiacal\n\t                #statInternal.diagnostics.status := #ERR_FILE_PATH;\n\t                #statInternal.diagnostics.subfunctionStatus := DINT_TO_WORD(#tempBufferPosition);\n\t                EXIT; // Stop execution and leave block\n\t              END_IF;\n\t            END_FOR;\n\t            \n\t            // Leaving the outer loop as well in case of error\n\t            IF #statInternal.diagnostics.status.%X15 THEN\n\t              EXIT; // Stop execution and leave block\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          REGION Proof if delete is called to jump to the next step\n\t            // If delet is called - move on to next state\n\t            // jump over the others by jump over loop iterator with continue\n\t            IF #statMainState = #STATE_FILE_DELETE_INIT THEN\n\t              REGION Delete File handler init\n\t                // Init file read with false\n\t                #instFileDelete(REQ := FALSE);\n\t                \n\t                IF #instFileDelete.Error THEN\n\t                  #statInternal.diagnostics.status := #ERR_FILE_DELETE_INIT;\n\t                  #statInternal.diagnostics.subfunctionStatus := #instFileDelete.Status;\n\t                  EXIT; // Stop execution and leave block\n\t                END_IF;\n\t                \n\t                // Next state\n\t                #statMainState := #STATE_FILE_DELETE;\n\t                // ASYNCRONUS - set to true:\n\t                #tempExitStateLoop := #statAsynchronusMode;\n\t                CONTINUE;\n\t              END_REGION\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          REGION Verify buffer boundary\n\t            // Check buffer size\n\t            // Check lower boundary\n\t            #tempResult := DINT_TO_WORD(LOWER_BOUND(ARR := #bufferByteArray, DIM := 1));\n\t            \n\t            IF 0 <> #tempResult THEN // ERROR: buffer lowerbound has to be 0\n\t              #statInternal.diagnostics.status := #ERR_BUFFER_LOWERBOUND;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              EXIT; // Stop execution and leave block\n\t            END_IF;\n\t            \n\t            // Get upper boundary and calc size of buffer\n\t            #statBufferSize := UPPER_BOUND(ARR := #bufferByteArray, DIM := 1) + 1;\n\t          END_REGION\n\t          \n\t          // Verify parameter data types\n\t          REGION Set TimeStamp length\n\t            IF #parameter.includeTimestamp THEN\n\t              #statLengthTimeStamp := 14;\n\t            ELSE\n\t              #statLengthTimeStamp := 0;\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          REGION Verify parameter data types\n\t            // Check type of Parameter attached to IN/OUT\n\t            // If Array proceed here, Array limits checked by move block variant\n\t            IF IS_ARRAY(#data) AND TypeOfElements(#data) = Byte THEN\n\t              #statParameterDataIsByteArray := TRUE;\n\t              // Get array size\n\t              #statLengthData := UDINT_TO_DINT(CountOfElements(#data));\n\t              \n\t              // Verify if buffer is big enough to store data\n\t              IF #statBufferSize < (#statLengthData + #statLengthTimeStamp) THEN\n\t                // ERROR: buffer array is to small for data array\n\t                #statInternal.diagnostics.status := #ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY;\n\t                #statInternal.diagnostics.subfunctionStatus := 16#0000;\n\t                EXIT; // Stop execution and leave block\n\t              END_IF;\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          REGION Proof if read is called to jump to the next step\n\t            IF #statMainState = #STATE_FILE_READ_INIT THEN\n\t              REGION Check array to see if the length is sufficient to store the read data\n\t                #statParameterDataIsByteArray := FALSE;\n\t                #statLengthData := 0;\n\t                \n\t                #tempResult := INT_TO_WORD(\n\t                                           Serialize(SRC_VARIABLE := #data,\n\t                                                     DEST_ARRAY => #bufferByteArray,\n\t                                                     POS := #statLengthData));\n\t                \n\t                // Check if serialize parameter structure was successful, otherwise set ERROR\n\t                IF #STATUS_EXECUTION_FINISHED <> #tempResult THEN\n\t                  #statInternal.diagnostics.status := #ERR_SERIALIZE_DATA;\n\t                  #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t                  EXIT; // Stop execution and leave block\n\t                END_IF;\n\t              END_REGION\n\t              \n\t              REGION Read File handler init\n\t                // Set length for FileRead call\n\t                IF #parameter.dataLengthMustMatch THEN\n\t                  #instFileRead.Length := 0;\n\t                ELSE\n\t                  #instFileRead.Length := DINT_TO_UDINT(#statLengthData + #statLengthTimeStamp);\n\t                END_IF;\n\t                \n\t                // Init file read with false\n\t                #instFileRead(REQ := FALSE);\n\t                \n\t                IF #instFileRead.Error THEN\n\t                  #statInternal.diagnostics.status := #ERR_FILE_READ_INIT;\n\t                  #statInternal.diagnostics.subfunctionStatus := #instFileRead.Status;\n\t                  EXIT; // Stop execution and leave block\n\t                END_IF;\n\t                \n\t                // Next state\n\t                #statMainState := #STATE_FILE_READ;\n\t                // ASYNCRONUS - set to true:\n\t                #tempExitStateLoop := #statAsynchronusMode;\n\t                CONTINUE;\n\t              END_REGION\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          REGION Proof if write is called to jump to the next step\n\t            IF #statMainState = #STATE_FILE_WRITE_INIT THEN\n\t              REGION File handler init\n\t                // Init file write with false\n\t                #instFileWrite(REQ := FALSE);\n\t                \n\t                IF #instFileWrite.Error THEN\n\t                  #statInternal.diagnostics.status := #ERR_FILE_WRITE_INIT;\n\t                  #statInternal.diagnostics.subfunctionStatus := #instFileWrite.Status;\n\t                  EXIT; // Stop execution and leave block\n\t                END_IF;\n\t                \n\t                // Next state\n\t                #statMainState := #STATE_FILE_WRITE_PARAMETER;\n\t                // ASYNCRONUS - set to true:\n\t                #tempExitStateLoop := #statAsynchronusMode;\n\t                CONTINUE;\n\t              END_REGION\n\t            END_IF;\n\t          END_REGION\n\t        END_REGION\n\t        \n\t      #STATE_FILE_READ:\n\t        REGION File read - File handling\n\t          // Set file handler request to true\n\t          #instFileRead(REQ    := TRUE,\n\t                        Name   := #fileName,\n\t                        Offset := UDINT#0,\n\t                        Data   := #bufferByteArray);\n\t          \n\t          IF #instFileRead.Error THEN\n\t            #statLengthFile := UDINT_TO_DINT(#instFileRead.ResultLength);\n\t            #statInternal.diagnostics.status := #ERR_FILE_READ;\n\t            #statInternal.diagnostics.subfunctionStatus := #instFileRead.Status;\n\t            EXIT; // Stop execution and leave block\n\t            \n\t          ELSIF #instFileRead.Done THEN\n\t            #statLengthFile := UDINT_TO_DINT(#instFileRead.ResultLength);\n\t            // Check file length parameter\n\t            IF TRUE\n\t              AND #parameter.dataLengthMustMatch\n\t              AND (#statLengthFile > (#statLengthData + #statLengthTimeStamp))\n\t            THEN\n\t              #statTimestamps.file := #statTimestampDefault;\n\t              #statInternal.diagnostics.status := #ERR_FILE_SIZE_GRATER_THEN_DATA_SIZE;\n\t              #statInternal.diagnostics.subfunctionStatus := DINT_TO_WORD((#statLengthData + #statLengthTimeStamp));\n\t              EXIT; // Stop execution and leave block\n\t              \n\t            ELSIF TRUE\n\t              AND #parameter.dataLengthMustMatch\n\t              AND (#statLengthFile < (#statLengthData + #statLengthTimeStamp))\n\t            THEN\n\t              #statTimestamps.file := #statTimestampDefault;\n\t              #statInternal.diagnostics.status := #ERR_FILE_SIZE_LESS_THEN_DATA_SIZE;\n\t              #statInternal.diagnostics.subfunctionStatus := DINT_TO_WORD((#statLengthData + #statLengthTimeStamp));\n\t              EXIT; // Stop execution and leave block\n\t              \n\t            ELSE\n\t              // Next state\n\t              #statMainState := #STATE_FILE_READ_PARAMETER_TO_INTERFACE;\n\t              // ASYNCRONUS - set to true:\n\t              #tempExitStateLoop := #statAsynchronusMode;\n\t            END_IF;\n\t          END_IF;\n\t        END_REGION\n\t        \n\t      #STATE_FILE_READ_PARAMETER_TO_INTERFACE:\n\t        REGION File read - Parameter handling\n\t          // Init buffer size/position pointer\n\t          #tempBufferPosition := 0;\n\t          \n\t          REGION Include time stamp\n\t            IF #parameter.includeTimestamp THEN\n\t              // Deserialize Time Stamp into buffer\n\t              // Length of timestamp is 14 byte\n\t              #tempResult := INT_TO_WORD(\n\t                                         Deserialize(SRC_ARRAY := #bufferByteArray,\n\t                                                     DEST_VARIABLE => #statTimestamps.file,\n\t                                                     POS := #tempBufferPosition)\n\t              );\n\t              \n\t              \n\t              // Check if move parameter structure was successful, otherwise set ERROR\n\t              IF #STATUS_EXECUTION_FINISHED <> #tempResult THEN\n\t                #statTimestamps.file := #statTimestampDefault;\n\t                #statInternal.diagnostics.status := #ERR_DESERIALIZE_DATE_TIMESTAMP;\n\t                #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t                EXIT; // Stop execution and leave block\n\t              END_IF;\n\t              \n\t            ELSE\n\t              #statTimestamps.file := #statTimestampDefault;\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          // If parameter is byte array - just copy\n\t          IF #statParameterDataIsByteArray THEN\n\t            // Copy buffer array into parameter array\n\t            #tempResult := INT_TO_WORD(\n\t                                       MOVE_BLK_VARIANT(SRC := #bufferByteArray,\n\t                                                        COUNT := DINT_TO_UDINT(#statLengthData),\n\t                                                        SRC_INDEX := #tempBufferPosition,\n\t                                                        DEST_INDEX := DINT#0,\n\t                                                        DEST => #data)\n\t            );\n\t            \n\t            // Check if move parameter structure was successful, otherwise set ERROR\n\t            IF #STATUS_EXECUTION_FINISHED <> #tempResult THEN\n\t              #statTimestamps.file := #statTimestampDefault;\n\t              #statInternal.diagnostics.status := #ERR_MOVE_BLK_VARIANT;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              EXIT; // Stop execution and leave block\n\t            END_IF;\n\t            \n\t            // Next state switched by status\n\t            #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_EXECUTION_FINISHED;\n\t            \n\t          ELSE // Parameter is NOT byte array - DESERIALZE\n\t            // Deserialize data from buffer\n\t            #tempResult := INT_TO_WORD(\n\t                                       Deserialize(SRC_ARRAY := #bufferByteArray,\n\t                                                   DEST_VARIABLE => #data,\n\t                                                   POS := #tempBufferPosition)\n\t            );\n\t            \n\t            // Check if serialize parameter structure was successful, otherwise set ERROR\n\t            IF #STATUS_EXECUTION_FINISHED <> #tempResult THEN\n\t              #statTimestamps.file := #statTimestampDefault;\n\t              #statInternal.diagnostics.status := #ERR_DESERIALIZE_DATA;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              EXIT; // Stop execution and leave block\n\t            END_IF;\n\t            \n\t            #statTimestamps.executeRead := #statTimestamps.lastCommand;\n\t            // Next state switched by status\n\t            #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_EXECUTION_FINISHED;\n\t          END_IF;\n\t        END_REGION\n\t        \n\t      #STATE_FILE_WRITE_PARAMETER:\n\t        REGION File write - Parameter handling\n\t          // Init buffer size/position pointer\n\t          #tempBufferPosition := 0;\n\t          \n\t          REGION Include time stamp\n\t            IF #parameter.includeTimestamp THEN\n\t              // Serialize Time Stamp into buffer\n\t              // Length of timestamp is 14 byte\n\t              #statTimestamps.file := #statTimestamps.lastCommand;\n\t              \n\t              #tempResult := INT_TO_WORD(\n\t                                         Serialize(SRC_VARIABLE := #statTimestamps.file,\n\t                                                   DEST_ARRAY => #bufferByteArray,\n\t                                                   POS := #tempBufferPosition)\n\t              );\n\t              \n\t              // Check if move parameter structure was successful, otherwise set ERROR\n\t              IF #STATUS_EXECUTION_FINISHED <> #tempResult THEN\n\t                #statTimestamps.file := #statTimestampDefault;\n\t                #statInternal.diagnostics.status := #ERR_SERIALIZE_DATE_TIMESTAMP;\n\t                #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t                EXIT; // Stop execution and leave block\n\t              END_IF;\n\t              \n\t            ELSE\n\t              #statTimestamps.file := #statTimestampDefault;\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          IF #statParameterDataIsByteArray THEN // Parameter is byte array - just copy\n\t            // Copy parameter array into buffer array\n\t            #tempResult := INT_TO_WORD(\n\t                                       MOVE_BLK_VARIANT(SRC := #data,\n\t                                                        COUNT := DINT_TO_UDINT(#statLengthData),\n\t                                                        SRC_INDEX := DINT#0,\n\t                                                        DEST_INDEX := #tempBufferPosition,\n\t                                                        DEST => #bufferByteArray)\n\t            );\n\t            // Set data length\n\t            #statLengthData += #tempBufferPosition;\n\t            \n\t            // Check if move parameter structure was successful, otherwise set ERROR\n\t            IF #STATUS_EXECUTION_FINISHED <> #tempResult THEN\n\t              #statTimestamps.file := #statTimestampDefault;\n\t              #statInternal.diagnostics.status := #ERR_MOVE_BLK_VARIANT;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              EXIT; // Stop execution and leave block\n\t            END_IF;\n\t            \n\t          ELSE // Parameter is NOT byte array - SERIALZE Data\n\t            // Clear buffer before writing the data into the file\n\t            // This avoids unintended content inside the binary file\n\t            IF #parameter.clearBufferBefore THEN\n\t              FILL_BLK(IN    := #EMPTY_BYTE,\n\t                       COUNT := DINT_TO_UDINT(#statBufferSize - #tempBufferPosition - 1),\n\t                       OUT   => #bufferByteArray[#tempBufferPosition]);\n\t            END_IF;\n\t            \n\t            // Serialize data into buffer\n\t            #tempResult := INT_TO_WORD(\n\t                                       Serialize(SRC_VARIABLE := #data,\n\t                                                 DEST_ARRAY => #bufferByteArray,\n\t                                                 POS := #tempBufferPosition)\n\t            );\n\t            \n\t            // After serialize, set array size pointer to numer of serialized elements\n\t            #statLengthData := #tempBufferPosition;\n\t            \n\t            // Check if serialize parameter structure was successful, otherwise set ERROR\n\t            IF #STATUS_EXECUTION_FINISHED <> #tempResult THEN\n\t              #statTimestamps.file := #statTimestampDefault;\n\t              #statInternal.diagnostics.status := #ERR_SERIALIZE_DATA;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              EXIT; // Stop execution and leave block\n\t            END_IF;\n\t          END_IF;\n\t          \n\t          // Next state\n\t          #statMainState := #STATE_FILE_WRITE;\n\t          // ASYNCRONUS - set to true:\n\t          #tempExitStateLoop := #statAsynchronusMode;\n\t        END_REGION\n\t        \n\t      #STATE_FILE_WRITE:\n\t        REGION File write - File handling\n\t          // Set file handler request to true\n\t          #instFileWrite(REQ    := TRUE,\n\t                         Name   := #fileName,\n\t                         Offset := UDINT#0,\n\t                         Length := DINT_TO_UDINT(#statLengthData),\n\t                         Data   := #bufferByteArray);\n\t          \n\t          IF #instFileWrite.Error THEN\n\t            #statTimestamps.file := #statTimestampDefault;\n\t            #statTimestamps.executeWrite := #statTimestampDefault;\n\t            #statLengthFile := UDINT_TO_DINT(#instFileWrite.ResultLength);\n\t            #statInternal.diagnostics.status := #ERR_FILE_WRITE;\n\t            #statInternal.diagnostics.subfunctionStatus := #instFileWrite.Status;\n\t            EXIT; // Stop execution and leave block\n\t            \n\t          ELSIF #instFileWrite.Done THEN\n\t            #statTimestamps.executeWrite := #statTimestamps.lastCommand;\n\t            \n\t            #statLengthFile := UDINT_TO_DINT(#instFileWrite.ResultLength);\n\t            // Next state switched by status\n\t            #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED;\n\t            #statInternal.diagnostics.subfunctionStatus := 16#0000;\n\t          END_IF;\n\t        END_REGION\n\t        \n\t      #STATE_FILE_DELETE:\n\t        REGION File delete\n\t          // Set file handler request to true\n\t          #instFileDelete(REQ  := TRUE,\n\t                          Name := #fileName);\n\t          \n\t          IF #instFileDelete.Error THEN\n\t            #statTimestamps.file := #statTimestampDefault;\n\t            #statTimestamps.executeDelete := #statTimestampDefault;\n\t            #statInternal.diagnostics.status := #ERR_FILE_DELETE;\n\t            #statInternal.diagnostics.subfunctionStatus := #instFileDelete.Status;\n\t            EXIT; // Stop execution and leave block\n\t            \n\t          ELSIF #instFileDelete.Done THEN\n\t            #statTimestamps.file := #statTimestampDefault;\n\t            #statTimestamps.executeDelete := #statTimestamps.lastCommand;\n\t            // Next state switched by status\n\t            #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED;\n\t            #statInternal.diagnostics.subfunctionStatus := 16#0000;\n\t          END_IF;\n\t        END_REGION\n\t        \n\t      ELSE // Undefined state in state machine reached\n\t        #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;\n\t    END_CASE;\n\t    // if one ore more runs in the same cycle are necessary, set #tempExitStateLoop := FALSE;\n\t    // Check state, if condition = TRUE --> #tempExitStateLoop = TRUE --> LEAVE LOOP\n\t  UNTIL (TRUE = #tempExitStateLoop)\n\t  END_REPEAT;\n\tEND_REGION STATE_MACHINE\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  IF (#statInternal.diagnostics.status = #STATUS_EXECUTION_FINISHED) AND (#statInternal.done = FALSE) THEN // Execution finished without errors\n\t    #statInternal.done := TRUE;\n\t    #statInternal.busy := FALSE;\n\t    #statInternal.error := FALSE;\n\t    #statMainState := #STATE_NO_PROCESSING; // Switch state machine to \"no processing\"\n\t    \n\t  ELSIF (#statInternal.diagnostics.status.%X15 = TRUE) AND (#statInternal.error = FALSE) THEN // Error occurred (#statStatus is 16#8000 to 16#FFFF)\n\t    #statInternal.done := FALSE;\n\t    #statInternal.busy := FALSE;\n\t    #statInternal.error := TRUE;\n\t    // Write diagnostics\n\t    #statTimestamps.lastError := #statTimestamps.lastCommand;\n\t    #statInternal.diagnostics.stateNumber := #statMainState;\n\t    #diagnostics := #statInternal.diagnostics;\n\t    #statMainState := #STATE_NO_PROCESSING; // Switch state machine to \"no processing\"\n\t    \n\t  ELSIF (#tempExecute = FALSE) AND ((#statInternal.done = TRUE) OR (#statInternal.error = TRUE)) THEN // Reset outputs\n\t    #statInternal.done := FALSE;\n\t    #statInternal.busy := FALSE;\n\t    #statInternal.error := FALSE;\n\t    #statInternal.diagnostics.status := #STATUS_NO_CALL;\n\t    #statLengthData := 0;\n\t    #statLengthFile := 0;\n\t  END_IF;\n\t  \n\t  // Write static values to outputs\n\t  #done := #statInternal.done;\n\t  #busy := #statInternal.busy;\n\t  #error := #statInternal.error;\n\t  #status := #statInternal.diagnostics.status;\n\t  \n\t  #dataLength := #statLengthData;\n\t  \n\t  #fileDoesNotExist := TRUE\n\t  AND (FALSE\n\t  OR #statInternal.diagnostics.status = #ERR_FILE_READ\n\t  OR #statInternal.diagnostics.status = #ERR_FILE_DELETE\n\t  ) AND (FALSE\n\t  OR #statInternal.diagnostics.subfunctionStatus = #FILE_DELETE_PATH_NAME_NOT_EXIST\n\t  OR #statInternal.diagnostics.subfunctionStatus = #FILE_DELETE_FILE_NOT_EXIST\n\t  );\n\t  \n\t  #timestamps := #statTimestamps;\n\t  \n\t  ENO := #statInternal.error;\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "FileWrite", "description": "This function block offers writing data as binary / serialized data stream to a file which is then stored on the PLC's memory card in the folder UserFiles.", "type": "FUNCTION_BLOCK", "name": "LGF_FileWrite", "vars": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file write once"}, {"name": "clearBufferBefore", "type": "Bool", "description": "TRUE: Buffer would be cleared with 16#00 Byte before\nwriting the data"}, {"name": "fileName", "type": "String", "description": "Name of file including path: `UserFiles/test.dat`"}, {"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished; new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the functionality"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "dataLength", "type": "DInt", "description": "Data length written to file (serialized length of `data`)"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}, {"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set to write into file"}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file write once"}, {"name": "clearBufferBefore", "type": "Bool", "description": "TRUE: Buffer would be cleared with 16#00 Byte before\nwriting the data"}, {"name": "fileName", "type": "String", "description": "Name of file including path: `UserFiles/test.dat`"}], "output": [{"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished; new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the functionality"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "dataLength", "type": "DInt", "description": "Data length written to file (serialized length of `data`)"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}], "in/out": [{"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set to write into file"}], "answer": "FUNCTION_BLOCK \"LGF_FileWrite\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens SIMATIC Systems Support'\nFAMILY : LGF\nNAME : LGF_FileWrite\n   VAR_INPUT \n      execute : Bool;\n      clearBufferBefore : Bool;\n      fileName : String;\n   END_VAR\n\n   VAR_OUTPUT \n      done { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      dataLength { ExternalWritable := 'False'} : DInt;\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR_IN_OUT \n      bufferByteArray : Array[*] of Byte;\n      data : Variant;\n   END_VAR\n\n   VAR \n      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         executePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n      END_STRUCT;\n      instFileWrite {InstructionName := 'FileWriteC'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : FileWriteC;\n      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;\n      statParameterDataIsByteArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statAsynchronusMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statBufferSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statLengthData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statLengthFile { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 0;\n   END_VAR\n\n   VAR_TEMP \n      tempExecute : Bool;\n      tempExitStateLoop : Bool;\n      tempResult : Word;\n      tempBufferPosition : DInt;\n      tempPathPrefix : String;\n   END_VAR\n\n   VAR CONSTANT \n      PATH_PREFIX : String := 'UserFiles/';\n      EMPTY_BYTE : Byte := 16#00;\n      FB_STATE_NO_PROCESSING : DInt := 0;\n      FB_STATE_INIT : DInt := 1;\n      FB_STATE_PARAMETER : DInt := 2;\n      FB_STATE_FILE_WRITE : DInt := 3;\n      STATUS_EXECUTION_FINISHED : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n      \"- - - Application Error codes\" : Word;\n      ERR_BUFFER_LOWERBOUND : Word := 16#8201;\n      ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY : Word := 16#8202;\n      ERR_FILE_PATH : Word := 16#8401;\n      ERR_MOVE_BLK_VARIANT : Word := 16#8601;\n      ERR_DATA_SERIALIZE : Word := 16#8603;\n      ERR_FILE_WRITE_INIT : Word := 16#8604;\n      ERR_FILE_WRITE : Word := 16#8605;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //================================================================================\n\t  // SIEMENS AG\n\t  // (c)Copyright 2017 All Rights Reserved\n\t  //--------------------------------------------------------------------------------\n\t  // Library:       LGF (Library General Functions)\n\t  // Tested with:   S7-1510SP-F\n\t  // Engineering:   TIA Portal V15\n\t  // Restrictions:  ---\n\t  // Requirements:  S7-1500/S7-1500T FW 2.5\n\t  // Functionality: This function block offers writing data as binary / serialized data stream\n\t  //                to a file which is then stored on the PLC's memory card in the folder `UserFiles`.\n\t  //--------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  //----------|------------|-------------------------|------------------------------\n\t  // 01.00.00 | 19.02.2023 | Simatic Systems Support | First released version\n\t  // 01.01.00 | 29.04.2025 | Simatic Systems Support | Insert parameter `clearBufferBefore` to clear buffer befor serializing the data\n\t  //================================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION TRIGGERING\n\t  #tempExecute := #execute; // Work with temporary value / create process image\n\t  IF (#tempExecute = TRUE) AND (#statInternal.executePrevious = FALSE) // Check if FB is triggered\n\t    // FB shall finish current job before new job can be started with rising edge OF #execute\n\t    AND (#statInternal.diagnostics.status = #STATUS_NO_CALL)\n\t  THEN // First call; initialize FB\n\t    #statInternal.done := FALSE;\n\t    #statInternal.busy := TRUE;\n\t    #statInternal.error := FALSE;\n\t    \n\t    #statMainState := #FB_STATE_INIT; // State machine - start processing\n\t    // Initialize functionality: reset of variables, diagnostics, etc.\n\t    #statInternal.diagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;\n\t    #diagnostics := #statInternal.emptyDiagnostics;\n\t    \n\t    // Initialize functionality: call subsidiary FBs with FALSE\n\t    #instFileWrite(REQ := FALSE);\n\t    \n\t  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN\n\t    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t  END_IF;\n\t  \n\t  // Edge detection 'execute' input\n\t  #statInternal.executePrevious := #tempExecute;\n\tEND_REGION TRIGGERING\n\t\n\tIF (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION STATE_MACHINE\n\t  // if one ore more runs in the same cycle are necessary, set #tempStateChangeActive := TRUE;\n\t  REPEAT\n\t    // reset #tempExitStateLoop := TRUE; as its defined state to prevent endless loop\n\t    #tempExitStateLoop := TRUE;\n\t    \n\t    // State machine of FB\n\t    CASE #statMainState OF\n\t      #FB_STATE_NO_PROCESSING: // No processing active (Note: this state must always be present and left empty)\n\t        ;\n\t        \n\t      #FB_STATE_INIT:\n\t        REGION Init\n\t          REGION Verify File Path\n\t            #tempPathPrefix := #PATH_PREFIX;\n\t            \n\t            FOR #tempBufferPosition := 1 TO DINT_TO_INT(LEN(#tempPathPrefix)) DO\n\t              IF #fileName[#tempBufferPosition] <> #tempPathPrefix[#tempBufferPosition] THEN\n\t                // Characters arenÄt identiacal\n\t                #statInternal.diagnostics.status := #ERR_FILE_PATH;\n\t                #statInternal.diagnostics.subfunctionStatus := DINT_TO_WORD(#tempBufferPosition);\n\t                // stop execution and leave block\n\t                EXIT;\n\t              END_IF;\n\t            END_FOR;\n\t            \n\t            IF #statInternal.diagnostics.status.%X15 THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          REGION Verify buffer boundary\n\t            // check buffer size\n\t            // check lower boundary\n\t            #tempResult := DINT_TO_WORD(LOWER_BOUND(ARR := #bufferByteArray, DIM := 1));\n\t            \n\t            IF 0 <> #tempResult THEN\n\t              // ERROR: buffer lowerbound has to be 0\n\t              #statInternal.diagnostics.status := #ERR_BUFFER_LOWERBOUND;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              // stop execution and leave block\n\t              EXIT;\n\t            ELSE\n\t              ; // nothing to do, just proceed\n\t            END_IF;\n\t            \n\t            // get upper boundary and calc size of buffer\n\t            #statBufferSize := UPPER_BOUND(ARR := #bufferByteArray, DIM := 1) + 1;\n\t          END_REGION\n\t          \n\t          // verify parameter data types\n\t          REGION Verify parameter data types\n\t            // check type of Parameter attached to IN/OUT\n\t            // if Array proceed here, Array limits checked by move block variant\n\t            IF IS_ARRAY(#data) AND TypeOfElements(#data) = Byte THEN\n\t              // data type match - nothing to do\n\t              #statParameterDataIsByteArray := TRUE;\n\t              // get array size\n\t              #statLengthData := UDINT_TO_DINT(CountOfElements(#data));\n\t              \n\t              // verify if buffer is big enough to store data\n\t              IF #statBufferSize < #statLengthData THEN\n\t                // ERROR: buffer array is to small for data array\n\t                #statInternal.diagnostics.status := #ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY;\n\t                #statInternal.diagnostics.subfunctionStatus := 16#0000;\n\t                // stop execution and leave block\n\t                EXIT;\n\t              ELSE\n\t                ; // nothing to do, just proceed\n\t              END_IF;\n\t              \n\t            ELSE\n\t              #statParameterDataIsByteArray := FALSE;\n\t              #statLengthData := 0;\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          REGION File handler init\n\t            // init file write with false\n\t            #instFileWrite(REQ := FALSE);\n\t            \n\t            IF #instFileWrite.Error THEN\n\t              #statInternal.diagnostics.status := #ERR_FILE_WRITE_INIT;\n\t              #statInternal.diagnostics.subfunctionStatus := #instFileWrite.Status;\n\t              // stop execution and leave block\n\t              EXIT;\n\t            ELSE //IF TRUE = #instFileWriteC.Done THEN\n\t              // next state\n\t              #statMainState := #FB_STATE_PARAMETER;\n\t              // ASYNCRONUS - set to true:\n\t              #tempExitStateLoop := #statAsynchronusMode;\n\t            END_IF;\n\t          END_REGION\n\t        END_REGION\n\t        \n\t      #FB_STATE_PARAMETER:\n\t        REGION Parameter handling\n\t          // if paramter is byte array - just copy\n\t          IF #statParameterDataIsByteArray THEN\n\t            // copy paramter array into buffer array\n\t            #tempResult := INT_TO_WORD(\n\t                                       MOVE_BLK_VARIANT(SRC := #data,\n\t                                                        COUNT := DINT_TO_UDINT(#statLengthData),\n\t                                                        SRC_INDEX := DINT#0,\n\t                                                        DEST_INDEX := DINT#0,\n\t                                                        DEST => #bufferByteArray)\n\t            );\n\t            \n\t            // check if move parameter structure was successful, otherwise set ERROR\n\t            IF 16#0000 <> #tempResult THEN\n\t              #statInternal.diagnostics.status := #ERR_MOVE_BLK_VARIANT;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              // stop execution and leave block\n\t              EXIT;\n\t              \n\t            ELSE\n\t              // next state\n\t              #statMainState := #FB_STATE_FILE_WRITE;\n\t              // ASYNCRONUS - set to true:\n\t              #tempExitStateLoop := #statAsynchronusMode;\n\t            END_IF;\n\t            \n\t            // else if parameter is NOT byte array - SERIALZE Data\n\t          ELSE\n\t            // Clear buffer before writing the data into the file\n\t            // This avoids unintended content inside the binary file\n\t            IF #clearBufferBefore THEN\n\t              FILL_BLK(IN    := #EMPTY_BYTE,\n\t                       COUNT := DINT_TO_UDINT(#statBufferSize),\n\t                       OUT   => #bufferByteArray[0]);\n\t            END_IF;\n\t            \n\t            // init buffer size/position pointer\n\t            #tempBufferPosition := 0;\n\t            // serialize data into buffer\n\t            #tempResult := INT_TO_WORD(\n\t                                       Serialize(SRC_VARIABLE := #data,\n\t                                                 DEST_ARRAY => #bufferByteArray,\n\t                                                 POS := #tempBufferPosition)\n\t            );\n\t            \n\t            // check if serialize parameter structure was successful, otherwise set ERROR\n\t            IF 16#0000 <> #tempResult THEN\n\t              #statInternal.diagnostics.status := #ERR_DATA_SERIALIZE;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              // stop execution and leave block\n\t              EXIT;\n\t            ELSE\n\t              // after serialize, set array size pointer to numer of serialized elements\n\t              #statLengthData := #tempBufferPosition;\n\t              // next state\n\t              #statMainState := #FB_STATE_FILE_WRITE;\n\t              // ASYNCRONUS - set to true:\n\t              #tempExitStateLoop := #statAsynchronusMode;\n\t            END_IF;\n\t          END_IF;\n\t        END_REGION\n\t        \n\t      #FB_STATE_FILE_WRITE:\n\t        REGION File handling\n\t          // set file handler request to true\n\t          #instFileWrite(REQ    := TRUE,\n\t                         Name   := #fileName,\n\t                         Offset := UDINT#0,\n\t                         Length := DINT_TO_UDINT(#statLengthData),\n\t                         Data   := #bufferByteArray);\n\t          \n\t          IF #instFileWrite.Error THEN\n\t            #statLengthFile := UDINT_TO_DINT(#instFileWrite.ResultLength);\n\t            #statInternal.diagnostics.status := #ERR_FILE_WRITE;\n\t            #statInternal.diagnostics.subfunctionStatus := #instFileWrite.Status;\n\t            // stop execution and leave block\n\t            EXIT;\n\t            \n\t          ELSIF #instFileWrite.Done THEN\n\t            #statLengthFile := UDINT_TO_DINT(#instFileWrite.ResultLength);\n\t            // next state switched by status\n\t            #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED;\n\t            #statInternal.diagnostics.subfunctionStatus := 16#0000;\n\t            \n\t          ELSE\n\t            ; // nothing to do, just proceed\n\t          END_IF;\n\t        END_REGION\n\t        \n\t      ELSE // Undefined state in state machine reached\n\t        #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;\n\t        #statInternal.diagnostics.subfunctionStatus := 16#0000;\n\t    END_CASE;\n\t    // if one ore more runs in the same cycle are necessary, set #tempExitStateLoop := FALSE;\n\t    // check state, if condition = TRUE --> #tempExitStateLoop = TRUE --> LEAVE LOOP\n\t  UNTIL (TRUE = #tempExitStateLoop)\n\t  END_REPEAT;\n\tEND_REGION STATE_MACHINE\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  IF (#statInternal.diagnostics.status = #STATUS_EXECUTION_FINISHED) AND (#statInternal.done = FALSE) THEN // Execution finished without errors\n\t    #statInternal.done := TRUE;\n\t    #statInternal.busy := FALSE;\n\t    #statInternal.error := FALSE;\n\t    #statMainState := #FB_STATE_NO_PROCESSING; // Switch state machine to \"no processing\"\n\t    \n\t  ELSIF (#statInternal.diagnostics.status.%X15 = TRUE) AND (#statInternal.error = FALSE) THEN // Error occurred (#statStatus is 16#8000 to 16#FFFF)\n\t    #statInternal.done := FALSE;\n\t    #statInternal.busy := FALSE;\n\t    #statInternal.error := TRUE;\n\t    // Write diagnostics\n\t    #statInternal.diagnostics.stateNumber := #statMainState;\n\t    #diagnostics := #statInternal.diagnostics;\n\t    #statMainState := #FB_STATE_NO_PROCESSING; // Switch state machine to \"no processing\"\n\t    \n\t  ELSIF (#tempExecute = FALSE) AND ((#statInternal.done = TRUE) OR (#statInternal.error = TRUE)) THEN // Reset outputs\n\t    #statInternal.done := FALSE;\n\t    #statInternal.busy := FALSE;\n\t    #statInternal.error := FALSE;\n\t    #statInternal.diagnostics.status := #STATUS_NO_CALL;\n\t    #statLengthData := 0;\n\t    #statLengthFile := 0;\n\t  END_IF;\n\t  \n\t  // Write static values to outputs\n\t  #done := #statInternal.done;\n\t  #busy := #statInternal.busy;\n\t  #error := #statInternal.error;\n\t  #status := #statInternal.diagnostics.status;\n\t  \n\t  #dataLength := #statLengthData;\n\t  ENO := #statInternal.error;\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "LIFO", "description": "LIFO (Last-In First-Out / Stack buffer memory) This function stores incoming data and outputs the latest/most recent not-yet-processed data.", "type": "FUNCTION_BLOCK", "name": "LGF_LIFO", "vars": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "push", "type": "Bool", "description": "Push item to the buffer"}, {"name": "pop", "type": "Bool", "description": "Pop item from the buffer"}, {"name": "peek", "type": "Bool", "description": "Peek item from the buffer (buffer not changed/modified)"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value\n`initialItem` (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized\n(usually: `0` / default value)"}, {"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "TRUE: Buffer is empty"}, {"name": "isFull", "type": "Bool", "description": "TRUE: Buffer is full"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}, {"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the\nbuffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer. (Array of…)"}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "push", "type": "Bool", "description": "Push item to the buffer"}, {"name": "pop", "type": "Bool", "description": "Pop item from the buffer"}, {"name": "peek", "type": "Bool", "description": "Peek item from the buffer (buffer not changed/modified)"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value\n`initialItem` (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized\n(usually: `0` / default value)"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "TRUE: Buffer is empty"}, {"name": "isFull", "type": "Bool", "description": "TRUE: Buffer is full"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}], "in/out": [{"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the\nbuffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer. (Array of…)"}], "answer": "FUNCTION_BLOCK \"LGF_LIFO\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_LIFO\n   VAR_INPUT \n      enable : Bool;\n      push : Bool := false;\n      pop : Bool := false;\n      peek : Bool := false;\n      reset : Bool;\n      clear : Bool;\n      initialItem : Variant;\n   END_VAR\n\n   VAR_OUTPUT \n      valid { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      elementCount { ExternalWritable := 'False'} : DInt;\n      isEmpty { ExternalWritable := 'False'} : Bool;\n      isFull { ExternalWritable := 'False'} : Bool;\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR_IN_OUT \n      item : Variant;\n      buffer : Variant;\n   END_VAR\n\n   VAR \n      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         enablePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         valid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorUserCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorAutoCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         disablingCompleted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\";\n         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\";\n      END_STRUCT;\n      statEdgesMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         push { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         pop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         peek { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         clear { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      END_STRUCT;\n      statBufferSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n      statLastItemIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := -1;\n      statElementCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;\n   END_VAR\n\n   VAR_TEMP \n      tempEnable : Bool;\n      tempEdges : Struct\n         push : Bool;\n         pop : Bool;\n         peek : Bool;\n         clear : Bool;\n         reset : Bool;\n      END_STRUCT;\n      tempInternalError : Int;\n      tempNewFirstItemIndex : Int;\n      tempNewNextEmptyItemIndex : Int;\n      tempCounter : Int;\n      tempRepeatStateMaschine : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      BUFFER_IS_EMPTY : Int := -1;\n      NO_INTERNAL_ERROR : Int := 0;\n      BUFFER_INITIALIZED : Int := -1;\n      EMPTY_INITIALIZED : Int := 0;\n      INDEX_BEGINNING : Int := 0;\n      COUNT_ELEMENTS : UDInt := 1;\n      INCREMENT : Int := 1;\n      BUFFER_SIZE_CORRECTION : UDInt := 1;\n      COUNTER_LOWER_LIMIT : Int := 0;\n      ZERO_ELEMENTS : DInt := 0;\n      FB_STATE_NO_PROCESSING : DInt := 0;\n      FB_STATE_ENABLING : DInt := 1;\n      FB_STATE_IDLE : DInt := 10;\n      FB_STATE_RESET : DInt := 11;\n      FB_STATE_CLEAR : DInt := 12;\n      FB_STATE_PUSH : DInt := 20;\n      FB_STATE_PEEK : DInt := 30;\n      FB_STATE_POP : DInt := 31;\n      FB_STATE_DISABLING : DInt := 90;\n      STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_NO_CURRENT_JOBS : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      ERR_BUFFER_EMPTY : Word := 16#8001;\n      ERR_BUFFER_FULL : Word := 16#8002;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_WRONG_TYPE_ITEM : Word := 16#8201;\n      ERR_WRONG_TYPE_INITIAL_ITEM : Word := 16#8202;\n      ERR_BOOL_NOT_SUPPORTED : Word := 16#8203;\n      ERR_MULTIPLE_COMMANDS_DEDECTED : Word := 16#8204;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n      ERR_INDEX_IN_ARRAY_LIMITS_1 : Word := 16#8601;\n      ERR_INDEX_IN_ARRAY_LIMITS_2 : Word := 16#8602;\n      ERR_CLEAR_BUFFER : Word := 16#8610;\n      ERR_RETURN_LAST_ENTRY : Word := 16#8611;\n      ERR_POP_REPLACE_ITEM_BY_INIT_VALUE : Word := 16#8612;\n      ERR_WRITE_ENTRY : Word := 16#8613;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_LIFO\n\t  // Comment/Function: LIFO (Last-In First-Out / Stack buffer memory)  \n\t  //                   The function stores incoming data and outputs\n\t  //                   the latest/most recent NOT-yet-processed data.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  //                   Bool array is not supported by `MOVE_BLK_VARIANT`\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 10.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 02.00.00 29.01.2019  Siemens Industry Online Support\n\t  //                      Output \"done\" removed (not necessary, because block works synchronous)\n\t  // 03.00.00 22.10.2019  Simatic Systems Support\n\t  //                      Code refactoring, comments added\n\t  //                      Interface change (push, pop, peek etc.)\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  // 04.00.00 04.09.2024  Simatic Systems Support\n\t  //                      Rework to PLC Open `Enable` behavior\n\t  //                      Add `isFull` outputs\n\t  //                      Rework to diagnostic output datatype\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION ENABLING/DISABLING\n\t  #tempEnable := #enable; // Work with temporary value / create process image\n\t  IF (#tempEnable = TRUE) AND (#statInternal.diagnostics.status = #STATUS_NO_CURRENT_JOBS) THEN // Enable FB\n\t    // First call; initialize FB\n\t    #statInternal.valid := TRUE;\n\t    #statInternal.busy := TRUE;\n\t    #statInternal.error := FALSE;\n\t    #statInternal.errorUserCleared := FALSE;\n\t    #statInternal.errorAutoCleared := FALSE;\n\t    #statInternal.disablingCompleted := FALSE;\n\t    #statInternal.diagnostics := #statInternal.emptyDiagnostics;\n\t    #diagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;\n\t    // State machine - start processing\n\t    #statMainState := #FB_STATE_ENABLING;\n\t    \n\t  ELSIF (#tempEnable = FALSE) AND (#statInternal.enablePrevious = TRUE) THEN // Disable FB \n\t    #statMainState := #FB_STATE_DISABLING;\n\t    \n\t  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN // Set status identifier of subsequent call\n\t    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t  END_IF;\n\t  \n\t  // Edge detection 'enable' input\n\t  #statInternal.enablePrevious := #tempEnable;\n\tEND_REGION ENABLING/DISABLING\n\t\n\tIF (#statInternal.diagnostics.status = #STATUS_NO_CURRENT_JOBS) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION STATE MACHINE\n\t  REPEAT\n\t    #tempRepeatStateMaschine := FALSE;\n\t    \n\t    CASE #statMainState OF // State machine of FB\n\t      #FB_STATE_NO_PROCESSING:\n\t        REGION No Processing\n\t          ; // No processing active (Note: this state must always be present and left empty)\n\t        END_REGION No Processing\n\t        \n\t      #FB_STATE_ENABLING: // Enabling active\n\t        REGION Enabling\n\t          // check whether the item type is BOOL\n\t          // Bool is not supported by Systemfunction MOVE BLOCK VARIANT\n\t          IF FALSE\n\t            OR TypeOf(#item) = Bool\n\t            OR TypeOf(#initialItem) = Bool\n\t            OR TypeOfElements(#buffer) = Bool\n\t          THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_BOOL_NOT_SUPPORTED;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          // check whether the ring #buffer is an ARRAY.\n\t          // IF so, the number OF the ARRAY elements is read out.\n\t          // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t          IF IS_ARRAY(#buffer) THEN\n\t            #statBufferSize := CountOfElements(#buffer);\n\t          ELSE\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_NO_ARRAY;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // check whether the data type OF the ARRAY elements matches\n\t          // the data type OF the entry (#item). IF the data types DO NOT match,\n\t          // the program execution is terminated at this point\n\t          IF (TypeOf(#item) <> TypeOfElements(#buffer)) THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_WRONG_TYPE_ITEM;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // check whether the initial value OF the ring #buffer\n\t          // matches the entry (tag #item). IF the data types DO NOT match,\n\t          // the program execution is terminated at this point\n\t          IF (TypeOf(#item) <> TypeOf(#initialItem)) THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_WRONG_TYPE_INITIAL_ITEM;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // Store values for edge detection\n\t          #statEdgesMem.push := #push;\n\t          #statEdgesMem.pop := #pop;\n\t          #statEdgesMem.peek := #peek;\n\t          #statEdgesMem.reset := #reset;\n\t          #statEdgesMem.clear := #clear;\n\t          \n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION Enabling\n\t        \n\t      #FB_STATE_IDLE:\n\t        REGION IDLE\n\t          // Collect edges\n\t          #tempEdges.push := #push AND NOT #statEdgesMem.push;\n\t          #tempEdges.pop := #pop AND NOT #statEdgesMem.pop;\n\t          #tempEdges.peek := #peek AND NOT #statEdgesMem.peek;\n\t          #tempEdges.reset := #reset AND NOT #statEdgesMem.reset;\n\t          #tempEdges.clear := #clear AND NOT #statEdgesMem.clear;\n\t          // Store values for edge detection\n\t          #statEdgesMem.push := #push;\n\t          #statEdgesMem.pop := #pop;\n\t          #statEdgesMem.peek := #peek;\n\t          #statEdgesMem.reset := #reset;\n\t          #statEdgesMem.clear := #clear;\n\t          \n\t          // Reset is allways possible\n\t          IF #tempEdges.reset THEN\n\t            #statMainState := #FB_STATE_RESET;\n\t            #tempRepeatStateMaschine := TRUE;\n\t            \n\t            // If error Pending - do nothing until error was reseted\n\t          ELSIF #statInternal.diagnostics.status.%X15 THEN\n\t            ;// Stay here and no further operation possible\n\t            \n\t            // Check whether the variable indices are within the ARRAY limits.\n\t            // IF they are NOT, the program execution is terminated at this point\n\t          ELSIF (#statLastItemIndex >= #statBufferSize) THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_INDEX_IN_ARRAY_LIMITS_1;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t          ELSIF (#statElementCount > #statBufferSize) THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_INDEX_IN_ARRAY_LIMITS_2;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // Multiple commands dedected\n\t          ELSIF (BOOL_TO_INT(#tempEdges.clear) + BOOL_TO_INT(#tempEdges.pop) + BOOL_TO_INT(#tempEdges.push) + BOOL_TO_INT(#tempEdges.peek)) > 1 THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_MULTIPLE_COMMANDS_DEDECTED;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // Commands\n\t          ELSIF #tempEdges.clear THEN\n\t            #statMainState := #FB_STATE_CLEAR;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSIF #tempEdges.push THEN\n\t            #statMainState := #FB_STATE_PUSH;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSIF #tempEdges.peek THEN\n\t            #statMainState := #FB_STATE_PEEK;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSIF #tempEdges.pop THEN\n\t            #statMainState := #FB_STATE_POP;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSE\n\t            #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t          END_IF;\n\t        END_REGION IDLE\n\t        \n\t      #FB_STATE_CLEAR:\n\t        REGION CLEARING\n\t          // Reset status\n\t          #statInternal.errorAutoCleared := FALSE;\n\t          \n\t          FOR #tempCounter := #COUNTER_LOWER_LIMIT TO UDINT_TO_INT(#statBufferSize - #BUFFER_SIZE_CORRECTION) DO\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #tempCounter,\n\t                                                   DEST => #buffer);\n\t            \n\t            // Checks whether a local error has occurred.\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t              #statInternal.errorAutoCleared := TRUE;\n\t              #statInternal.diagnostics.status := #ERR_CLEAR_BUFFER;\n\t              #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t              EXIT;\n\t            END_IF;\n\t          END_FOR;\n\t          IF #statInternal.errorAutoCleared THEN\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // Reset counters\n\t          #statLastItemIndex := #BUFFER_INITIALIZED;\n\t          #statElementCount := #EMPTY_INITIALIZED;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_RESET:\n\t        REGION RESET\n\t          // Reset Error Auto Cleared\n\t          #statInternal.errorAutoCleared := FALSE;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_PUSH:\n\t        REGION Push\n\t          // this program code section checks whether the ring #buffer is full.\n\t          // IF this is the CASE, program execution is terminated at this point\n\t          IF ((#statLastItemIndex + #INCREMENT) >= #statBufferSize) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_BUFFER_FULL;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // This program code section writes the entry to the ring buffer.   \n\t          #tempInternalError := MOVE_BLK_VARIANT(SRC := #item,\n\t                                                 COUNT := #COUNT_ELEMENTS,\n\t                                                 SRC_INDEX := #INDEX_BEGINNING,\n\t                                                 DEST_INDEX := #statLastItemIndex + #INCREMENT,\n\t                                                 DEST => #buffer);\n\t          \n\t          // Check whether a local error has occurred\n\t          IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_WRITE_ENTRY;\n\t            #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // This program code section increments the index by 1 for reading and writing.        \n\t          #statLastItemIndex += #INCREMENT;\n\t          // Evaluation of the number of elements in the stack\n\t          #statElementCount += #INCREMENT;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_PEEK,\n\t      #FB_STATE_POP:\n\t        REGION PEEK_POP\n\t          // checks whether the ring #buffer is empty.\n\t          // IF this is the CASE, program execution is terminated at this point\n\t          IF (#statLastItemIndex <= #BUFFER_IS_EMPTY) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_BUFFER_EMPTY;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // returning the last entry of the ring buffer\n\t          #tempInternalError := MOVE_BLK_VARIANT(SRC := #buffer,\n\t                                                 COUNT := #COUNT_ELEMENTS,\n\t                                                 SRC_INDEX := #statLastItemIndex,\n\t                                                 DEST_INDEX := #INDEX_BEGINNING,\n\t                                                 DEST => #item);\n\t          \n\t          // check whether a local error has occurred\n\t          IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_RETURN_LAST_ENTRY;\n\t            #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          REGION Pop\n\t            // is POP - delete element in buffer\n\t            // The value is initialized just if the \"pop\" input is triggered\n\t            // If the \"peek\" input is triggered, stack is not changed\n\t            IF #statMainState = #FB_STATE_POP THEN\n\t              #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                     COUNT := #COUNT_ELEMENTS,\n\t                                                     SRC_INDEX := #INDEX_BEGINNING,\n\t                                                     DEST_INDEX := #statLastItemIndex,\n\t                                                     DEST => #buffer);\n\t              \n\t              // This program code section checks whether a local error has occurred.\n\t              IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                #statInternal.errorAutoCleared := TRUE;\n\t                #statInternal.diagnostics.status := #ERR_POP_REPLACE_ITEM_BY_INIT_VALUE;\n\t                #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t                EXIT;\n\t              END_IF;\n\t              \n\t              // This program code section decrements the index by 1 for reading and writing.\n\t              #statLastItemIndex -= #INCREMENT;\n\t              // Evaluation of the number of elements in the stack\n\t              #statElementCount -= #INCREMENT;\n\t            END_IF;\n\t          END_REGION Pop\n\t          \n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_DISABLING: // Disabling active\n\t        REGION Disabling\n\t          // Disabling is complete the bit #statDisablingCompleted must be set\n\t          #statInternal.disablingCompleted := TRUE;\n\t        END_REGION Disabling\n\t        \n\t      ELSE // Undefined state in state machine reached\n\t        REGION Undefined state\n\t          #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;\n\t          #statInternal.diagnostics.subfunctionStatus := 16#00;\n\t          #statInternal.diagnostics.stateNumber := #statMainState;\n\t          #statInternal.errorUserCleared := TRUE;\n\t        END_REGION Undefined state\n\t    END_CASE;\n\t  UNTIL #tempRepeatStateMaschine = false END_REPEAT;\n\tEND_REGION STATE MACHINE\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  IF (#statInternal.disablingCompleted = TRUE) THEN\n\t    REGION Disabling\n\t      // Reset outputs if disabling completed\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := FALSE;\n\t      #statInternal.errorUserCleared := FALSE;\n\t      #statInternal.errorAutoCleared := FALSE;\n\t      #statInternal.diagnostics.status := #STATUS_NO_CURRENT_JOBS;\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION Disabling\n\t    \n\t  ELSIF (#statInternal.errorUserCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION Error user cleared\n\t      // Error can only be cleared by user; rising edge at enable input is needed to continue \n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // Execution aborted --> set state no processing\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION Error user cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION Error auto cleared\n\t      // Error can be reset by FB automatically\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // Handling of autocleared error\n\t      #statMainState := #FB_STATE_IDLE;\n\t      #tempRepeatStateMaschine := TRUE;\n\t    END_REGION Error auto cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = FALSE) AND (#statInternal.errorUserCleared = FALSE) AND (#statInternal.error = TRUE) THEN\n\t    REGION After user/auto cleared or command aborted\n\t      // If autocleared error is acknowledged\n\t      #statInternal.valid := TRUE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := FALSE;\n\t      #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t    END_REGION After user/auto cleared or command aborted\n\t  END_IF;\n\t  \n\t  REGION Write static values to outputs\n\t    #valid := #statInternal.valid;\n\t    #busy := #statInternal.busy;\n\t    #error := #statInternal.error;\n\t    #status := #statInternal.diagnostics.status;\n\t    // if ENO mechanism is not used / error /& Status output present\n\t    ENO := TRUE;\n\t    // Write application specific static values to outputs\n\t    #elementCount := #statElementCount;\n\t    #isEmpty := #statElementCount <= #ZERO_ELEMENTS;\n\t    #isFull := #statElementCount >= #statBufferSize;\n\t  END_REGION Write static values to outputs\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "ShellSort", "description": "This block sorts an array of type DInt with any number of elements (max. 1000) in ascending or descending order and returns the sorted version of the array in the same variable.", "type": "FUNCTION_BLOCK", "name": "LGF_ShellSort_DInt", "vars": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "array", "type": "Array[*] of DInt", "description": "Array to be sorted"}], "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "array", "type": "Array[*] of DInt", "description": "Array to be sorted"}], "answer": "FUNCTION_BLOCK \"LGF_ShellSort_DInt\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_ShellSort_DInt\n   VAR_INPUT \n      sortDirection : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of DInt;\n   END_VAR\n\n   VAR \n      tempArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..#MAX_ARRAY_ELEMENTS] of DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempNoOfElements : DInt;\n      tempGap : DInt;\n      tempLoopIndex : DInt;\n      tempExchangeIndex : DInt;\n      tempExchangeVariable : DInt;\n      tempArrayOffset : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      ARRAY_START_INDEX : UInt := 1;\n      SINGLE_ARRAY_ELEMENT : DInt := 1;\n      GAP_INIT : Int := 1;\n      GAP_THRESHOLD : Int := 1;\n      GAP_RATIO : DInt := 3;\n      INCREMENT : Int := 1;\n      ELEMENTS_COUNT_CORRECTION : DInt := 1;\n      MAX_ARRAY_ELEMENTS : Int := 1000;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_TOO_MANY_ELEMENTS : Word := 16#8201;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ShellSort_DInt\n\t  // Comment/Function: This block sorts an array with any number of elements (max. 1000)\n\t  //                   in ascending or descending order and returns the sorted version of the array in the same variable.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.01.00 19.05.2016  Siemens Industry Online Support\n\t  //                      New function: reverse sort\n\t  // 01.01.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.01.02 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.01.03 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 02.00.00 29.01.2019  Siemens Industry Online Support\n\t  //                      Output \"done\" removed (not necessary, because only one cycle)\n\t  // 02.00.01 15.10.2019  Simatic Systems Support\n\t  //                      Code refactoring, comments added,\n\t  //                      change data type from Int to DInt\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Special description\n\t  // Space note: If you wish to reduce the space of this block, you may reduce the\n\t  // size OF the tempArray<Type> TO one just big enough FOR your specific purpose\n\t  // It is not recommended to increase the size significantly.\n\tEND_REGION\n\t\n\tREGION Initialization and input data processing\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // Array elements calculation\n\t  // (for example: 6 - 2 = 4; but real number of elements is 5)\n\t  #tempNoOfElements := #tempUpperLimit - #tempLowerLimit + #ELEMENTS_COUNT_CORRECTION;\n\t  \n\t  // Shift array index to range 1..MAX_ARRAY_ELEMENTS\n\t  #tempArrayOffset := - #tempLowerLimit + #ARRAY_START_INDEX;\n\t  \n\t  // Check whether the array contains less than the maximum possible amount of elements\n\t  IF #tempNoOfElements > #MAX_ARRAY_ELEMENTS THEN\n\t    #error := true;\n\t    #status := #ERR_TOO_MANY_ELEMENTS;\n\t    RETURN;\n\t  ELSIF #tempNoOfElements <= #SINGLE_ARRAY_ELEMENT THEN\n\t    // If there are 0 elements in the array, set status to \"Error: Parameter is an empty array\"\n\t    #error := true;\n\t    #status := #ERR_NO_ARRAY;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Sorting\n\t  // Read the elements of the incoming array and write into the local array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #tempArray[#tempLoopIndex + #tempArrayOffset] := #array[#tempLoopIndex];\n\t  END_FOR;\n\t  \n\t  REGION Shell sort algorithm\n\t    #tempGap := #GAP_INIT;\n\t    \n\t    // Evaluation of the maximal gap size\n\t    REPEAT\n\t      #tempGap := (#GAP_RATIO * #tempGap) + #INCREMENT;\n\t    UNTIL #tempGap > #tempNoOfElements END_REPEAT;\n\t    \n\t    REPEAT\n\t      #tempGap := #tempGap / #GAP_RATIO;\n\t      \n\t      FOR #tempLoopIndex := #tempGap + #INCREMENT TO #tempNoOfElements DO\n\t        #tempExchangeVariable := #tempArray[#tempLoopIndex];\n\t        #tempExchangeIndex := #tempLoopIndex;\n\t        \n\t        // sort descending \n\t        IF #sortDirection THEN\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] < #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t          \n\t          // sort ascending\n\t        ELSE\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] > #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t        END_IF;\n\t        \n\t        #tempArray[#tempExchangeIndex] := #tempExchangeVariable;\n\t      END_FOR;\n\t      \n\t    UNTIL #tempGap <= #GAP_THRESHOLD END_REPEAT;\n\t  END_REGION\n\t  \n\t  // Write the elements of the local array back to the inOut array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #array[#tempLoopIndex] := #tempArray[#tempLoopIndex + #tempArrayOffset];\n\t  END_FOR;\n\t  \n\t  // Set \"No error\" status\n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "ShellSort", "description": "This block sorts an array of type LReal with any number of elements (max. 1000) in ascending or descending order and returns the sorted version of the array in the same variable.", "type": "FUNCTION_BLOCK", "name": "LGF_ShellSort_LReal", "vars": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "array", "type": "Array[*] of LReal", "description": "Array to be sorted"}], "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "array", "type": "Array[*] of LReal", "description": "Array to be sorted"}], "answer": "FUNCTION_BLOCK \"LGF_ShellSort_LReal\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_ShellSort_LReal\n   VAR_INPUT \n      sortDirection : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of LReal;\n   END_VAR\n\n   VAR \n      tempArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..#MAX_ARRAY_ELEMENTS] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempNoOfElements : DInt;\n      tempGap : DInt;\n      tempLoopIndex : DInt;\n      tempExchangeIndex : DInt;\n      tempExchangeVariable : LReal;\n      tempArrayOffset : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      ARRAY_START_INDEX : UInt := 1;\n      SINGLE_ARRAY_ELEMENT : DInt := 1;\n      GAP_INIT : Int := 1;\n      GAP_THRESHOLD : Int := 1;\n      GAP_RATIO : DInt := 3;\n      INCREMENT : Int := 1;\n      ELEMENTS_COUNT_CORRECTION : DInt := 1;\n      MAX_ARRAY_ELEMENTS : Int := 1000;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_TOO_MANY_ELEMENTS : Word := 16#8201;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ShellSort_DInt\n\t  // Comment/Function: This block sorts an array with any number of elements (max. 1000)\n\t  //                   in ascending or descending order and returns the sorted version of the array in the same variable.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.01.00 19.05.2016  Siemens Industry Online Support\n\t  //                      New function: reverse sort\n\t  // 01.01.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.01.02 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.01.03 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 02.00.00 29.01.2019  Siemens Industry Online Support\n\t  //                      Output \"done\" removed (not necessary, because only one cycle)\n\t  // 02.00.01 15.10.2019  Simatic Systems Support\n\t  //                      Code refactoring, comments added,\n\t  //                      change data type from Real to LReal\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Special description\n\t  // Space note: If you wish to reduce the space of this block, you may reduce the\n\t  // size OF the tempArray<Type> TO one just big enough FOR your specific purpose\n\t  // It is not recommended to increase the size significantly.\n\tEND_REGION\n\t\n\tREGION Initialization and input data processing\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // Array elements calculation\n\t  // (for example: 6 - 2 = 4; but real number of elements is 5)\n\t  #tempNoOfElements := #tempUpperLimit - #tempLowerLimit + #ELEMENTS_COUNT_CORRECTION;\n\t  \n\t  // Shift array index to range 1..MAX_ARRAY_ELEMENTS\n\t  #tempArrayOffset := - #tempLowerLimit + #ARRAY_START_INDEX;\n\t  \n\t  // Check whether the array contains less than the maximum possible amount of elements\n\t  IF #tempNoOfElements > #MAX_ARRAY_ELEMENTS THEN\n\t    #error := true;\n\t    #status := #ERR_TOO_MANY_ELEMENTS;\n\t    RETURN;\n\t  ELSIF #tempNoOfElements <= #SINGLE_ARRAY_ELEMENT THEN\n\t    // If there are 0 elements in the array, set status to \"Error: Parameter is an empty array\"\n\t    #error := true;\n\t    #status := #ERR_NO_ARRAY;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Sorting\n\t  // Read the elements of the incoming array and write into the local array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #tempArray[#tempLoopIndex + #tempArrayOffset] := #array[#tempLoopIndex];\n\t  END_FOR;\n\t  \n\t  REGION Shell sort algorithm\n\t    #tempGap := #GAP_INIT;\n\t    \n\t    // Evaluation of the maximal gap size\n\t    REPEAT\n\t      #tempGap := (#GAP_RATIO * #tempGap) + #INCREMENT;\n\t    UNTIL #tempGap > #tempNoOfElements END_REPEAT;\n\t    \n\t    REPEAT\n\t      #tempGap := #tempGap / #GAP_RATIO;\n\t      \n\t      FOR #tempLoopIndex := #tempGap + #INCREMENT TO #tempNoOfElements DO\n\t        #tempExchangeVariable := #tempArray[#tempLoopIndex];\n\t        #tempExchangeIndex := #tempLoopIndex;\n\t        \n\t        // sort descending \n\t        IF #sortDirection THEN\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] < #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t          \n\t          // sort ascending\n\t        ELSE\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] > #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t        END_IF;\n\t        \n\t        #tempArray[#tempExchangeIndex] := #tempExchangeVariable;\n\t      END_FOR;\n\t      \n\t    UNTIL #tempGap <= #GAP_THRESHOLD END_REPEAT;\n\t  END_REGION\n\t  \n\t  // Write the elements of the local array back to the inOut array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #array[#tempLoopIndex] := #tempArray[#tempLoopIndex + #tempArrayOffset];\n\t  END_FOR;\n\t  \n\t  // Set \"No error\" status\n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "ShellSort", "description": "This block sorts an array of type UDInt with any number of elements (max. 1000) in ascending or descending order and returns the sorted version of the array in the same variable.", "type": "FUNCTION_BLOCK", "name": "LGF_ShellSort_UDInt", "vars": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "array", "type": "Array[*] of UDInt", "description": "Array to be sorted"}], "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "array", "type": "Array[*] of UDInt", "description": "Array to be sorted"}], "answer": "FUNCTION_BLOCK \"LGF_ShellSort_UDInt\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_ShellSort_UDInt\n   VAR_INPUT \n      sortDirection : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of UDInt;\n   END_VAR\n\n   VAR \n      tempArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..#MAX_ARRAY_ELEMENTS] of UDInt;\n   END_VAR\n\n   VAR_TEMP \n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempNoOfElements : DInt;\n      tempGap : DInt;\n      tempLoopIndex : DInt;\n      tempExchangeIndex : DInt;\n      tempExchangeVariable : UDInt;\n      tempArrayOffset : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      ARRAY_START_INDEX : UInt := 1;\n      SINGLE_ARRAY_ELEMENT : DInt := 1;\n      GAP_INIT : Int := 1;\n      GAP_THRESHOLD : Int := 1;\n      GAP_RATIO : DInt := 3;\n      INCREMENT : Int := 1;\n      ELEMENTS_COUNT_CORRECTION : DInt := 1;\n      MAX_ARRAY_ELEMENTS : Int := 1000;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_TOO_MANY_ELEMENTS : Word := 16#8201;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ShellSort_DInt\n\t  // Comment/Function: This block sorts an array with any number of elements (max. 1000)\n\t  //                   in ascending or descending order and returns the sorted version of the array in the same variable.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.01.00 19.05.2016  Siemens Industry Online Support\n\t  //                      New function: reverse sort\n\t  // 01.01.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.01.02 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.01.03 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 02.00.00 29.01.2019  Siemens Industry Online Support\n\t  //                      Output \"done\" removed (not necessary, because only one cycle)\n\t  // 02.00.01 15.10.2019  Simatic Systems Support\n\t  //                      Code refactoring, comments added,\n\t  //                      change data type from UInt to UDInt\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Special description\n\t  // Space note: If you wish to reduce the space of this block, you may reduce the\n\t  // size OF the tempArray<Type> TO one just big enough FOR your specific purpose\n\t  // It is not recommended to increase the size significantly.\n\tEND_REGION\n\t\n\tREGION Initialization and input data processing\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // Array elements calculation\n\t  // (for example: 6 - 2 = 4; but real number of elements is 5)\n\t  #tempNoOfElements := #tempUpperLimit - #tempLowerLimit + #ELEMENTS_COUNT_CORRECTION;\n\t  \n\t  // Shift array index to range 1..MAX_ARRAY_ELEMENTS\n\t  #tempArrayOffset := - #tempLowerLimit + #ARRAY_START_INDEX;\n\t  \n\t  // Check whether the array contains less than the maximum possible amount of elements\n\t  IF #tempNoOfElements > #MAX_ARRAY_ELEMENTS THEN\n\t    #error := true;\n\t    #status := #ERR_TOO_MANY_ELEMENTS;\n\t    RETURN;\n\t  ELSIF #tempNoOfElements <= #SINGLE_ARRAY_ELEMENT THEN\n\t    // If there are 0 elements in the array, set status to \"Error: Parameter is an empty array\"\n\t    #error := true;\n\t    #status := #ERR_NO_ARRAY;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Sorting\n\t  // Read the elements of the incoming array and write into the local array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #tempArray[#tempLoopIndex + #tempArrayOffset] := #array[#tempLoopIndex];\n\t  END_FOR;\n\t  \n\t  REGION Shell sort algorithm\n\t    #tempGap := #GAP_INIT;\n\t    \n\t    // Evaluation of the maximal gap size\n\t    REPEAT\n\t      #tempGap := (#GAP_RATIO * #tempGap) + #INCREMENT;\n\t    UNTIL #tempGap > #tempNoOfElements END_REPEAT;\n\t    \n\t    REPEAT\n\t      #tempGap := #tempGap / #GAP_RATIO;\n\t      \n\t      FOR #tempLoopIndex := #tempGap + #INCREMENT TO #tempNoOfElements DO\n\t        #tempExchangeVariable := #tempArray[#tempLoopIndex];\n\t        #tempExchangeIndex := #tempLoopIndex;\n\t        \n\t        // sort descending \n\t        IF #sortDirection THEN\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] < #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t          \n\t          // sort ascending\n\t        ELSE\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] > #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t        END_IF;\n\t        \n\t        #tempArray[#tempExchangeIndex] := #tempExchangeVariable;\n\t      END_FOR;\n\t      \n\t    UNTIL #tempGap <= #GAP_THRESHOLD END_REPEAT;\n\t  END_REGION\n\t  \n\t  // Write the elements of the local array back to the inOut array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #array[#tempLoopIndex] := #tempArray[#tempLoopIndex + #tempArrayOffset];\n\t  END_FOR;\n\t  \n\t  // Set \"No error\" status\n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "ShiftRegister", "description": "The Function represents a shift register for any kind of Datatype (using variant). It is possible to shift the elements in the array at bufferRegister to the left (index array[n]:=array[n+1]) or right (index array[n]:=array[n-1]). It could be used for material tracking trough a machine or a process, e.g. for a rotary indexing table. Note As this is a real shift operation, it may cause some runtime effects while using big array sizes to move at the input bufferRegister. Please consider that a FIFO or LIFO storage, based on indexes, could be used as well for most applications.", "type": "FUNCTION_BLOCK", "name": "LGF_ShiftRegister", "vars": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "shiftLeft", "type": "Bool", "description": "Rising edge: Elements in the array `bufferRegister`\nshifted left.\nElements moved from index `N` to `N - 1`.\nThe element at index `N = 0`is overwritten"}, {"name": "shiftRight", "type": "Bool", "description": "Rising edge: Elements in the array `bufferRegister`\nshifted right.\nElements moved from index `N` to `N + 1`.\nThe element at index `N = lastIndex` is overwritten"}, {"name": "shiftRange", "type": "UInt", "description": "Number of places to be shifted in the `bufferRegister`\ninput array"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clear buffer elements in `bufferRegister` with\n`initalItem`"}, {"name": "fill", "type": "Bool", "description": "Overwrite buffer elements after shift operation.\n* `shiftLeft` - the most right element/s\n* `shiftRight` - the most left element/s\noverwritten by `initalItem`."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized\n(usually: `0` / default value)"}, {"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "leftShiftCount", "type": "DInt", "description": "Number of left shift operations since clearing"}, {"name": "rightShiftCount", "type": "DInt", "description": "Number of right shift operations since clearing"}, {"name": "shiftOffsetCounter", "type": "DInt", "description": "Offset of shift operations.\n`rightShift` - `leftShift`"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}, {"name": "bufferRegister", "type": "Variant", "description": "Buffer / Register memory as ARRAY, which keeps the data.\nThe data in the register is shifted left or right depending on the\ncommand."}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "shiftLeft", "type": "Bool", "description": "Rising edge: Elements in the array `bufferRegister`\nshifted left.\nElements moved from index `N` to `N - 1`.\nThe element at index `N = 0`is overwritten"}, {"name": "shiftRight", "type": "Bool", "description": "Rising edge: Elements in the array `bufferRegister`\nshifted right.\nElements moved from index `N` to `N + 1`.\nThe element at index `N = lastIndex` is overwritten"}, {"name": "shiftRange", "type": "UInt", "description": "Number of places to be shifted in the `bufferRegister`\ninput array"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clear buffer elements in `bufferRegister` with\n`initalItem`"}, {"name": "fill", "type": "Bool", "description": "Overwrite buffer elements after shift operation.\n* `shiftLeft` - the most right element/s\n* `shiftRight` - the most left element/s\noverwritten by `initalItem`."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized\n(usually: `0` / default value)"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "leftShiftCount", "type": "DInt", "description": "Number of left shift operations since clearing"}, {"name": "rightShiftCount", "type": "DInt", "description": "Number of right shift operations since clearing"}, {"name": "shiftOffsetCounter", "type": "DInt", "description": "Offset of shift operations.\n`rightShift` - `leftShift`"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}], "in/out": [{"name": "bufferRegister", "type": "Variant", "description": "Buffer / Register memory as ARRAY, which keeps the data.\nThe data in the register is shifted left or right depending on the\ncommand."}], "answer": "FUNCTION_BLOCK \"LGF_ShiftRegister\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry_Support\nFAMILY : LGF\nNAME : LGF_ShiftRegister\n   VAR_INPUT \n      enable : Bool;\n      shiftLeft : Bool;\n      shiftRight : Bool;\n      shiftRange { S7_PredefinedAssignment := '1'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : UInt := 1;\n      reset : Bool;\n      clear : Bool;\n      fill : Bool;\n      initialItem { S7_PredefinedAssignment := 'NULL'} : Variant;\n   END_VAR\n\n   VAR_OUTPUT \n      valid { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      leftShiftCount { ExternalWritable := 'False'} : DInt;\n      rightShiftCount { ExternalWritable := 'False'} : DInt;\n      shiftOffsetCounter { ExternalWritable := 'False'} : DInt;\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR_IN_OUT \n      bufferRegister : Variant;\n   END_VAR\n\n   VAR \n      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         enablePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         valid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorUserCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorAutoCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         disablingCompleted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\";\n         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\";\n      END_STRUCT;\n      statEdgesMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         shiftRight { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         shiftLeft { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         clear { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      END_STRUCT;\n      statBufferSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n      statLeftShiftCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 0;\n      statRightShiftCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 0;\n      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;\n   END_VAR\n\n   VAR_TEMP \n      tempEnable : Bool;\n      tempEdges : Struct\n         shiftLeft : Bool;\n         shiftRight : Bool;\n         reset : Bool;\n         clear : Bool;\n      END_STRUCT;\n      tempInternalError : Int;\n      tempCounter : DInt;\n      tempRepeatStateMaschine : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      NO_INTERNAL_ERROR : Int := 16#0000;\n      EMPTY_INITIALIZED : Int := 0;\n      INDEX_BEGINNING : Int := 0;\n      COUNT_ELEMENTS : UDInt := 1;\n      INCREMENT : Int := 1;\n      BUFFER_SIZE_CORRECTION : UDInt := 1;\n      COUNTER_LOWER_LIMIT : DInt := 0;\n      ZERO_ELEMENTS : DInt := 0;\n      FB_STATE_NO_PROCESSING : DInt := 0;\n      FB_STATE_ENABLING : DInt := 1;\n      FB_STATE_IDLE : DInt := 10;\n      FB_STATE_RESET : DInt := 11;\n      FB_STATE_CLEAR : DInt := 12;\n      FB_STATE_SHIFT_LEFT : DInt := 20;\n      FB_STATE_SHIFT_RIGHT : DInt := 30;\n      FB_STATE_DISABLING : DInt := 90;\n      STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_NO_CURRENT_JOBS : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      ERR_BUFFER_FULL : Word := 16#8002;\n      ERR_BUFFER_EMPTY : Word := 16#8001;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_CLEARING_WITHOUT_INITIAL_ITEM : Word := 16#8201;\n      ERR_FILL_WITHOUT_INITIAL_ITEM : Word := 16#8202;\n      ERR_WRONG_TYPE_INITIAL_ITEM : Word := 16#8203;\n      ERR_BOOL_NOT_SUPPORTED : Word := 16#8204;\n      ERR_MULTIPLE_COMMANDS_DEDECTED : Word := 16#8401;\n      ERR_IN_SHIFT_RANGE : Word := 16#8402;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n      ERR_CLEAR_BUFFER : Word := 16#8610;\n      ERR_SHIFT_BUFFER_LEFT : Word := 16#8611;\n      ERR_SHIFT_BUFFER_LEFT_FILL : Word := 16#8612;\n      ERR_SHIFT_BUFFER_RIGHT : Word := 16#8621;\n      ERR_SHIFT_BUFFER_RIGHT_FILL : Word := 16#8622;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ShiftRegister\n\t  // Comment/Function: The Function represnts a shift register for any kind of Datatype (using `variant`) - it can be used as a kind of a ring buffer.\n\t  //                   It is possible to shift the register array left (index `array[n]:=array[n+1]`) or right (index a`array[n]:=array[n-1]`).\n\t  //                   As this is a real shift operation, it may causes some runtime effects while using big array sizes to move.\n\t  //                   It could be used for pusing the material traking UDT trouf the maschin, e.g. a rotary indexing table\n\t  //                   Please consider that a FIFO  or LIFO storage, based on indexes, could be used as well for most applications.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V16 Update 4\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  //                   Bool array is not supported by `MOVE_BLK_VARIANT`\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 03.00.00 09.04.2021  Simatic Systems Support\n\t  //                      Refactoring and alignment to Datatype Variant\n\t  //                      Insert documentation\n\t  // 04.00.00 04.09.2024  Simatic Systems Support\n\t  //                      Rework to PLC Open `Enable` behavior\n\t  //                      Add `reset` input / counter outputs\n\t  //                      Fix Bug while filling after left shift operation\n\t  //                      Rework to diagnostic output datatype\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\t\n\tREGION ENABLING/DISABLING\n\t  #tempEnable := #enable; // Work with temporary value / create process image\n\t  IF (#tempEnable = TRUE) AND (#statInternal.diagnostics.status = #STATUS_NO_CURRENT_JOBS) THEN // Enable FB\n\t    // First call; initialize FB\n\t    #statInternal.valid := TRUE;\n\t    #statInternal.busy := TRUE;\n\t    #statInternal.error := FALSE;\n\t    #statInternal.errorUserCleared := FALSE;\n\t    #statInternal.errorAutoCleared := FALSE;\n\t    #statInternal.disablingCompleted := FALSE;\n\t    #statInternal.diagnostics := #statInternal.emptyDiagnostics;\n\t    #diagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;\n\t    // State machine - start processing\n\t    #statMainState := #FB_STATE_ENABLING;\n\t    \n\t  ELSIF (#tempEnable = FALSE) AND (#statInternal.enablePrevious = TRUE) THEN // Disable FB \n\t    #statMainState := #FB_STATE_DISABLING;\n\t    \n\t  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN // Set status identifier of subsequent call\n\t    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t  END_IF;\n\t  \n\t  // Edge detection 'enable' input\n\t  #statInternal.enablePrevious := #tempEnable;\n\tEND_REGION ENABLING/DISABLING\n\t\n\tIF (#statInternal.diagnostics.status = #STATUS_NO_CURRENT_JOBS) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION STATE MACHINE\n\t  REPEAT\n\t    #tempRepeatStateMaschine := FALSE;\n\t    \n\t    CASE #statMainState OF // State machine of FB\n\t      #FB_STATE_NO_PROCESSING:\n\t        REGION No Processing\n\t          ; // No processing active (Note: this state must always be present and left empty)\n\t        END_REGION No Processing\n\t        \n\t      #FB_STATE_ENABLING: // Enabling active\n\t        REGION Enabling\n\t          // check whether the item type is BOOL\n\t          // Bool is not supported by Systemfunction MOVE BLOCK VARIANT\n\t          IF FALSE\n\t            OR TypeOf(#initialItem) = Bool\n\t            OR TypeOfElements(#bufferRegister) = Bool\n\t          THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_BOOL_NOT_SUPPORTED;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          // check whether the ring #buffer is an ARRAY.\n\t          // IF so, the number OF the ARRAY elements is read out.\n\t          // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t          IF IS_ARRAY(#bufferRegister) THEN\n\t            #statBufferSize := CountOfElements(#bufferRegister);\n\t          ELSE\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_NO_ARRAY;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // check whether the initial value OF the ring #buffer\n\t          // matches the entry (tag #item). IF the data types DO NOT match,\n\t          // the program execution is terminated at this point\n\t          IF TRUE\n\t            AND (#initialItem <> NULL)\n\t            AND (TypeOfElements(#bufferRegister) <> TypeOf(#initialItem))\n\t          THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_WRONG_TYPE_INITIAL_ITEM;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // Store values for edge detection\n\t          #statEdgesMem.shiftLeft := #shiftLeft;\n\t          #statEdgesMem.shiftRight := #shiftRight;\n\t          #statEdgesMem.reset := #reset;\n\t          #statEdgesMem.clear := #clear;\n\t          \n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION Enabling\n\t        \n\t      #FB_STATE_IDLE:\n\t        REGION IDLE\n\t          // Collect edges\n\t          #tempEdges.shiftRight := #shiftRight AND NOT #statEdgesMem.shiftRight;\n\t          #tempEdges.shiftLeft := #shiftLeft AND NOT #statEdgesMem.shiftLeft;\n\t          #tempEdges.reset := #reset AND NOT #statEdgesMem.reset;\n\t          #tempEdges.clear := #clear AND NOT #statEdgesMem.clear;\n\t          // Store values for edge detection\n\t          #statEdgesMem.shiftRight := #shiftRight;\n\t          #statEdgesMem.shiftLeft := #shiftLeft;\n\t          #statEdgesMem.reset := #reset;\n\t          #statEdgesMem.clear := #clear;\n\t          \n\t          // Reset is allways possible\n\t          IF #tempEdges.reset THEN\n\t            #statMainState := #FB_STATE_RESET;\n\t            #tempRepeatStateMaschine := TRUE;\n\t            \n\t            // If error Pending - do nothing until error was reseted\n\t          ELSIF #statInternal.diagnostics.status.%X15 THEN\n\t            ;// Stay here and no further operation possible\n\t            \n\t            // Check if number of movements is in a plausible and valid range\n\t            // -> Has to be lees than the buffer size\n\t          ELSIF #shiftRange >= #statBufferSize THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_IN_SHIFT_RANGE;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // If Fill is activated, an inital item has to be present\n\t          ELSIF (#fill AND #initialItem = NULL) THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_FILL_WITHOUT_INITIAL_ITEM;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // If clearBuffer has rising edge, the buffer is initialized by initial values\n\t            // Check whether the initial value OF the ring #buffer\n\t            // matches the entry (tag #item). IF the data types DO NOT match,\n\t            // the program execution is terminated at this point\n\t          ELSIF (#tempEdges.clear AND #initialItem = NULL) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_CLEARING_WITHOUT_INITIAL_ITEM;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // If Fill is activated, an inital item has to be present\n\t          ELSIF (#fill AND #initialItem = NULL) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_FILL_WITHOUT_INITIAL_ITEM;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // Multiple commands dedected\n\t          ELSIF (BOOL_TO_INT(#tempEdges.clear) + BOOL_TO_INT(#tempEdges.shiftRight) + BOOL_TO_INT(#tempEdges.shiftLeft)) > 1 THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_MULTIPLE_COMMANDS_DEDECTED;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // Commands\n\t          ELSIF #tempEdges.clear THEN\n\t            #statMainState := #FB_STATE_CLEAR;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSIF #tempEdges.shiftRight THEN\n\t            #statMainState := #FB_STATE_SHIFT_RIGHT;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSIF #tempEdges.shiftLeft THEN\n\t            #statMainState := #FB_STATE_SHIFT_LEFT;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSE\n\t            #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t          END_IF;\n\t        END_REGION IDLE\n\t        \n\t      #FB_STATE_CLEAR:\n\t        REGION CLEARING\n\t          // Reset status\n\t          #statInternal.errorAutoCleared := FALSE;\n\t          \n\t          FOR #tempCounter := #COUNTER_LOWER_LIMIT TO UDINT_TO_DINT(#statBufferSize - #BUFFER_SIZE_CORRECTION) DO\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #tempCounter,\n\t                                                   DEST => #bufferRegister);\n\t            \n\t            // Checks whether a local error has occurred.\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t              #statInternal.errorAutoCleared := TRUE;\n\t              #statInternal.diagnostics.status := #ERR_CLEAR_BUFFER;\n\t              #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t              EXIT;\n\t            END_IF;\n\t          END_FOR;\n\t          IF #statInternal.errorAutoCleared THEN\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // Reset counters\n\t          #statLeftShiftCount :=\n\t          #statRightShiftCount := #EMPTY_INITIALIZED;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_RESET:\n\t        REGION RESET\n\t          // Reset Error Auto Cleared\n\t          #statInternal.errorAutoCleared := FALSE;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_SHIFT_LEFT:\n\t        REGION SHIFT_LEFT\n\t          // Shift whole array elemnts from N --> N-1\n\t          #tempInternalError := MOVE_BLK_VARIANT(SRC := #bufferRegister,\n\t                                                 COUNT := #statBufferSize - #shiftRange,\n\t                                                 SRC_INDEX := #shiftRange,\n\t                                                 DEST_INDEX := 0,\n\t                                                 DEST => #bufferRegister);\n\t          \n\t          // Check whether a local error has occurred\n\t          IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_SHIFT_BUFFER_LEFT;\n\t            #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          REGION Fill after shift left\n\t            IF #fill THEN\n\t              // Run through buffer and overwrite all elements with its initial item element\n\t              FOR #tempCounter := UDINT_TO_DINT(#statBufferSize - #shiftRange) TO UDINT_TO_DINT(#statBufferSize - #BUFFER_SIZE_CORRECTION) DO\n\t                // Overwrite the \"old\" values after shift\n\t                #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                       COUNT := #COUNT_ELEMENTS,\n\t                                                       SRC_INDEX := #INDEX_BEGINNING,\n\t                                                       DEST_INDEX := #tempCounter,\n\t                                                       DEST => #bufferRegister);\n\t                \n\t                // Check whether a local error has occurred\n\t                IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                  #statInternal.errorAutoCleared := TRUE;\n\t                  #statInternal.diagnostics.status := #ERR_SHIFT_BUFFER_LEFT_FILL;\n\t                  #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t                  EXIT;\n\t                END_IF;\n\t              END_FOR;\n\t              IF #statInternal.errorAutoCleared THEN\n\t                EXIT;\n\t              END_IF;\n\t            END_IF;\n\t          END_REGION Fill after shift left\n\t          \n\t          // This program code section increments the index by 1 for shifting.    \n\t          #statLeftShiftCount += #INCREMENT;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_SHIFT_RIGHT:\n\t        REGION SHIFT_RIGHT\n\t          // Shift whole array elemnsts from N --> N+1\n\t          #tempInternalError := MOVE_BLK_VARIANT(SRC := #bufferRegister,\n\t                                                 COUNT := #statBufferSize - #shiftRange,\n\t                                                 SRC_INDEX := #INDEX_BEGINNING,\n\t                                                 DEST_INDEX := #shiftRange,\n\t                                                 DEST => #bufferRegister);\n\t          \n\t          // Check whether a local error has occurred\n\t          IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_SHIFT_BUFFER_RIGHT;\n\t            #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t            RETURN;\n\t          END_IF;\n\t          \n\t          REGION Fill after shift right\n\t            IF #fill THEN\n\t              // Run through buffer and overwrite all elements with its initial item element\n\t              FOR #tempCounter := #INDEX_BEGINNING TO UDINT_TO_DINT(#shiftRange - #BUFFER_SIZE_CORRECTION) DO\n\t                // Overwrite the \"old\" values after shift\n\t                #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                       COUNT := #COUNT_ELEMENTS,\n\t                                                       SRC_INDEX := #INDEX_BEGINNING,\n\t                                                       DEST_INDEX := #tempCounter,\n\t                                                       DEST => #bufferRegister);\n\t                \n\t                // Check whether a local error has occurred\n\t                IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                  #statInternal.errorAutoCleared := TRUE;\n\t                  #statInternal.diagnostics.status := #ERR_SHIFT_BUFFER_RIGHT_FILL;\n\t                  #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t                  EXIT;\n\t                END_IF;\n\t              END_FOR;\n\t              IF #statInternal.errorAutoCleared THEN\n\t                EXIT;\n\t              END_IF;\n\t            END_IF;\n\t          END_REGION Fill after shift right\n\t          \n\t          // This program code section increments the index by 1 for shifting.    \n\t          #statRightShiftCount += #INCREMENT;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_DISABLING: // Disabling active\n\t        REGION Disabling\n\t          // Disabling is complete the bit #statDisablingCompleted must be set\n\t          #statInternal.disablingCompleted := TRUE;\n\t        END_REGION Disabling\n\t        \n\t      ELSE // Undefined state in state machine reached\n\t        REGION Undefined state\n\t          #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;\n\t          #statInternal.diagnostics.subfunctionStatus := 16#00;\n\t          #statInternal.diagnostics.stateNumber := #statMainState;\n\t          #statInternal.errorUserCleared := TRUE;\n\t        END_REGION Undefined state\n\t    END_CASE;\n\t  UNTIL #tempRepeatStateMaschine = false END_REPEAT;\n\tEND_REGION STATE MACHINE\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  IF (#statInternal.disablingCompleted = TRUE) THEN\n\t    REGION Disabling\n\t      // Reset outputs if disabling completed\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := FALSE;\n\t      #statInternal.errorUserCleared := FALSE;\n\t      #statInternal.errorAutoCleared := FALSE;\n\t      #statInternal.diagnostics.status := #STATUS_NO_CURRENT_JOBS;\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION Disabling\n\t    \n\t  ELSIF (#statInternal.errorUserCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION Error user cleared\n\t      // Error can only be cleared by user; rising edge at enable input is needed to continue \n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // Execution aborted --> set state no processing\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION Error user cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION Error auto cleared\n\t      // Error can be reset by FB automatically\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // Handling of autocleared error\n\t      #statMainState := #FB_STATE_IDLE;\n\t      #tempRepeatStateMaschine := TRUE;\n\t    END_REGION Error auto cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = FALSE) AND (#statInternal.errorUserCleared = FALSE) AND (#statInternal.error = TRUE) THEN\n\t    REGION After user/auto cleared or command aborted\n\t      // If autocleared error is acknowledged\n\t      #statInternal.valid := TRUE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := FALSE;\n\t      #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t    END_REGION After user/auto cleared or command aborted\n\t  END_IF;\n\t  \n\t  REGION Write static values to outputs\n\t    #valid := #statInternal.valid;\n\t    #busy := #statInternal.busy;\n\t    #error := #statInternal.error;\n\t    #status := #statInternal.diagnostics.status;\n\t    // if ENO mechanism is not used / error /& Status output present\n\t    ENO := TRUE;\n\t    // Write application specific static values to outputs\n\t    #leftShiftCount := #statLeftShiftCount;\n\t    #rightShiftCount := #statRightShiftCount;\n\t    #shiftOffsetCounter := #rightShiftCount - #leftShiftCount;\n\t  END_REGION Write static values to outputs\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "StartValueReadWrite", "description": "Read or write start value(s) from variables or complete data blocks", "type": "FUNCTION_BLOCK", "name": "LGF_StartValueReadWrite", "vars": [{"name": "read", "type": "Bool", "description": "Rising edge: Read start value of data block / Variable\nof data block"}, {"name": "write", "type": "Bool", "description": "Rising edge: Write actual value(s) to start value of data\nblock / Variable of data block"}, {"name": "dataSource", "type": "Variant", "description": "Data (block / variable) source, if a separate source is\nneeded.\nMay also be `NULL` - then the target is also used as\nthe source"}, {"name": "dataDestination", "type": "Variant", "description": "Data (block / variable) destination"}, {"name": "readDone", "type": "Bool", "description": "TRUE: Read has been completed successfully"}, {"name": "writeDone", "type": "Bool", "description": "TRUE: Write has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "lastRead", "type": "DTL", "description": "Timestamp of last read access"}, {"name": "lastWrite", "type": "DTL", "description": "Timestamp of last write access"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic information"}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [{"name": "read", "type": "Bool", "description": "Rising edge: Read start value of data block / Variable\nof data block"}, {"name": "write", "type": "Bool", "description": "Rising edge: Write actual value(s) to start value of data\nblock / Variable of data block"}, {"name": "dataSource", "type": "Variant", "description": "Data (block / variable) source, if a separate source is\nneeded.\nMay also be `NULL` - then the target is also used as\nthe source"}, {"name": "dataDestination", "type": "Variant", "description": "Data (block / variable) destination"}], "output": [{"name": "readDone", "type": "Bool", "description": "TRUE: Read has been completed successfully"}, {"name": "writeDone", "type": "Bool", "description": "TRUE: Write has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "lastRead", "type": "DTL", "description": "Timestamp of last read access"}, {"name": "lastWrite", "type": "DTL", "description": "Timestamp of last write access"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic information"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_StartValueReadWrite\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Simatic Systems Support'\nFAMILY : LGF\nNAME : LGF_StartValueReadWrite\n   VAR_INPUT \n      read : Bool;\n      write : Bool;\n      dataSource { S7_PredefinedAssignment := 'NULL'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Variant;\n      dataDestination { S7_PredefinedAssignment := 'NULL'} : Variant;\n   END_VAR\n\n   VAR_OUTPUT \n      readDone { ExternalWritable := 'False'} : Bool;\n      writeDone { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      lastRead {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;\n      lastWrite {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR \n      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         readPrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         writePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         readTimestamp {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;\n         writeTimestamp {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;\n         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\";\n      END_STRUCT;\n      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #STATE_NO_PROCESSING;\n   END_VAR\n\n   VAR_TEMP \n      tempExecute : Bool;\n      tempBusy : Bool;\n      tempReturnValue : Word;\n   END_VAR\n\n   VAR CONSTANT \n      NO_ERROR_OCCURRED : Word := 16#0000;\n      STATE_NO_PROCESSING : DInt := 0;\n      STATE_READ : DInt := 1;\n      STATE_WRITE : DInt := 2;\n      STATE_READ_DONE : DInt := 11;\n      STATE_WRITE_DONE : DInt := 12;\n      STATE_ERROR : Int := 19;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_READ : Word := 16#7001;\n      STATUS_WRITE : Word := 16#7002;\n      STATUS_READ_DONE : Word := 16#0001;\n      STATUS_WRITE_DONE : Word := 16#0002;\n      ERR_MULTIPLE_COMMANDS : Word := 16#8400;\n      ERR_READ : Word := 16#8601;\n      ERR_WRITE : Word := 16#8602;\n      ERR_READ_TIME : Word := 16#8611;\n      ERR_WRITE_TIME : Word := 16#8612;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // (C)Copyright Siemens 2025\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_StartValueReadWrite\n\t  // Comment/Function: Read or write start value(s) from variables or complete datablocks\n\t  // Library/Family:   LGF (Library General Functions\n\t  // Author:           Simatic Systems Support\n\t  // Tested with:      S7-1516F FW 2.9\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ---\n\t  // Requirements:     ---\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  //----------|------------|-------------------------|-----------------------------\n\t  // 01.00.00 | 2025-05-05 | Simatic Systems Support | First released version\n\t  //===============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t(/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION TRIGGERING\n\t  #tempExecute := #read OR #write; // Work with temporary value / create process image\n\t  IF (#tempExecute = TRUE) AND (#statInternal.readPrevious = FALSE) // Check if FB is triggered\n\t    // TODO(optional): delete next line and comment line if FB shall finish current job before new job can be started with rising edge of execute\n\t    AND (#statInternal.diagnostics.status = #STATUS_NO_CALL)\n\t  THEN // First call; initialize FB\n\t    #statInternal.error := FALSE;\n\t    #diagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.diagnostics := #statInternal.emptyDiagnostics;\n\t    // State machine - start processing\n\t    IF #read AND #write THEN\n\t      #statInternal.diagnostics.status := #ERR_MULTIPLE_COMMANDS;\n\t      #statInternal.diagnostics.stateNumber := #STATE_NO_PROCESSING;\n\t      #statMainState := #STATE_ERROR;\n\t      \n\t    ELSIF #read THEN\n\t      #statMainState := #STATE_READ;\n\t      #tempReturnValue := INT_TO_WORD(\n\t                                      READ_DBL(REQ := FALSE,\n\t                                               SRCBLK := #dataDestination,\n\t                                               BUSY => #tempBusy,\n\t                                               DSTBLK => #dataDestination)\n\t      );\n\t    ELSIF #write THEN\n\t      #statMainState := #STATE_WRITE;\n\t      #tempReturnValue := INT_TO_WORD(\n\t                                      READ_DBL(REQ := FALSE,\n\t                                               SRCBLK := #dataDestination,\n\t                                               BUSY => #tempBusy,\n\t                                               DSTBLK => #dataDestination)\n\t      );\n\t    END_IF;\n\t  END_IF;\n\t  \n\t  // Edge detection 'execute' input\n\t  #statInternal.readPrevious := #tempExecute;\n\tEND_REGION TRIGGERING\n\t\n\tIF (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION STATE MACHINE\n\t  CASE #statMainState OF // State machine of FB\n\t    #STATE_NO_PROCESSING:\n\t      REGION No Processing\n\t        ; // No processing active (Note: this state must always be present and left empty)\n\t      END_REGION No Processing\n\t      \n\t    #STATE_READ:\n\t      REGION Read\n\t        IF #dataSource <> null THEN\n\t          #tempReturnValue := INT_TO_WORD(\n\t                                          READ_DBL(REQ := TRUE,\n\t                                                   SRCBLK := #dataSource,\n\t                                                   BUSY => #tempBusy,\n\t                                                   DSTBLK => #dataDestination)\n\t          );\n\t        ELSE\n\t          #tempReturnValue := INT_TO_WORD(\n\t                                          READ_DBL(REQ := TRUE,\n\t                                                   SRCBLK := #dataDestination,\n\t                                                   BUSY => #tempBusy,\n\t                                                   DSTBLK => #dataDestination)\n\t          );\n\t        END_IF;\n\t        \n\t        IF FALSE THEN\n\t          ;\n\t          \n\t        ELSIF TRUE\n\t          AND NOT #tempBusy\n\t          AND #tempReturnValue = #NO_ERROR_OCCURRED\n\t        THEN\n\t          IF #dataSource <> null THEN\n\t            #tempReturnValue := INT_TO_WORD(\n\t                                            READ_DBL(REQ := FALSE,\n\t                                                     SRCBLK := #dataSource,\n\t                                                     BUSY => #tempBusy,\n\t                                                     DSTBLK => #dataDestination)\n\t            );\n\t          ELSE\n\t            #tempReturnValue := INT_TO_WORD(\n\t                                            READ_DBL(REQ := FALSE,\n\t                                                     SRCBLK := #dataDestination,\n\t                                                     BUSY => #tempBusy,\n\t                                                     DSTBLK => #dataDestination)\n\t            );\n\t          END_IF;\n\t          \n\t          #tempReturnValue := INT_TO_WORD(RD_LOC_T(#statInternal.readTimestamp));\n\t          \n\t          IF NOT #tempReturnValue.%X15 THEN\n\t            #statInternal.diagnostics.status := #STATUS_READ_DONE;\n\t            #statMainState := #STATE_READ_DONE;\n\t          ELSE\n\t            #statInternal.diagnostics.status := #ERR_READ_TIME;\n\t            #statInternal.diagnostics.subfunctionStatus := #tempReturnValue;\n\t            #statInternal.diagnostics.stateNumber := #STATE_READ;\n\t            #statMainState := #STATE_ERROR;\n\t          END_IF;\n\t          \n\t        ELSIF #tempReturnValue.%X15 THEN\n\t          #statInternal.diagnostics.status := #ERR_READ;\n\t          #statInternal.diagnostics.subfunctionStatus := #tempReturnValue;\n\t          #statInternal.diagnostics.stateNumber := #STATE_READ;\n\t          #statMainState := #STATE_ERROR;\n\t          \n\t        ELSE\n\t          #statInternal.diagnostics.status := #STATUS_READ;\n\t        END_IF;\n\t      END_REGION Read\n\t      \n\t    #STATE_WRITE:\n\t      REGION Write\n\t        IF #dataSource <> null THEN\n\t          #tempReturnValue := INT_TO_WORD(\n\t                                          WRIT_DBL(REQ := TRUE,\n\t                                                   SRCBLK := #dataSource,\n\t                                                   BUSY => #tempBusy,\n\t                                                   DSTBLK => #dataDestination)\n\t          );\n\t        ELSE\n\t          #tempReturnValue := INT_TO_WORD(\n\t                                          WRIT_DBL(REQ := TRUE,\n\t                                                   SRCBLK := #dataDestination,\n\t                                                   BUSY => #tempBusy,\n\t                                                   DSTBLK => #dataDestination)\n\t          );\n\t        END_IF;\n\t        \n\t        IF FALSE THEN\n\t          ;\n\t        ELSIF TRUE\n\t          AND NOT #tempBusy\n\t          AND #tempReturnValue = #NO_ERROR_OCCURRED\n\t        THEN\n\t          #tempReturnValue := INT_TO_WORD(\n\t                                          WRIT_DBL(REQ := FALSE,\n\t                                                   SRCBLK := #dataDestination,\n\t                                                   BUSY => #tempBusy,\n\t                                                   DSTBLK => #dataDestination));\n\t          \n\t          #tempReturnValue := INT_TO_WORD(RD_LOC_T(#statInternal.writeTimestamp));\n\t          \n\t          IF NOT #tempReturnValue.%X15 THEN\n\t            #statInternal.diagnostics.status := #STATUS_WRITE_DONE;\n\t            #statMainState := #STATE_WRITE_DONE;\n\t          ELSE\n\t            #statInternal.diagnostics.status := #ERR_WRITE_TIME;\n\t            #statInternal.diagnostics.subfunctionStatus := #tempReturnValue;\n\t            #statInternal.diagnostics.stateNumber := #STATE_WRITE;\n\t            #statMainState := #STATE_ERROR;\n\t          END_IF;\n\t          \n\t        ELSIF #tempReturnValue.%X15 THEN\n\t          #statInternal.diagnostics.status := #ERR_WRITE;\n\t          #statInternal.diagnostics.subfunctionStatus := #tempReturnValue;\n\t          #statInternal.diagnostics.stateNumber := #STATE_WRITE;\n\t          #statMainState := #STATE_ERROR;\n\t          \n\t        ELSE\n\t          #statInternal.diagnostics.status := #STATUS_WRITE;\n\t        END_IF;\n\t      END_REGION Write\n\t      \n\t    #STATE_READ_DONE,\n\t    #STATE_WRITE_DONE,\n\t    #STATE_ERROR:\n\t      REGION Read or Write done / Error\n\t        // execution done --> set state no processing\n\t        IF NOT #tempExecute THEN\n\t          #statInternal.diagnostics.status := #STATUS_NO_CALL;\n\t          #statMainState := #STATE_NO_PROCESSING;\n\t        END_IF;\n\t      END_REGION Read or Write done / Error\n\t      \n\t    ELSE // Undefined state in state machine reached\n\t      REGION Undefined state\n\t        #statInternal.diagnostics.#status := #ERR_UNDEFINED_STATE;\n\t        #statMainState := #STATE_ERROR;\n\t      END_REGION Undefined state\n\t  END_CASE;\n\tEND_REGION STATE MACHINE\n\t\n\tREGION Write outputs\n\t  IF #statInternal.diagnostics.status.%X15 AND NOT #statInternal.error THEN // Error occurred (#statStatus is 16#8000 to 16#FFFF)\n\t    REGION Error occured\n\t      #statInternal.error := TRUE;\n\t      #diagnostics := #statInternal.diagnostics;\n\t    END_REGION Error occured\n\t    \n\t  ELSIF (#tempExecute = FALSE) AND (#statMainState > #STATE_READ_DONE) THEN // Reset outputs\n\t    REGION Execute reseted\n\t      #statInternal.diagnostics.status := #STATUS_NO_CALL;\n\t    END_REGION Execute reseted\n\t  END_IF;\n\t  \n\t  REGION Write static values to outputs\n\t    #readDone := #statMainState = #STATE_READ_DONE;\n\t    #lastRead := #statInternal.readTimestamp;\n\t    #writeDone := #statMainState = #STATE_WRITE_DONE;\n\t    #lastWrite := #statInternal.writeTimestamp;\n\t    #busy := #statMainState = #STATE_READ OR #statMainState = #STATE_WRITE;\n\t    #error := #statMainState = #STATE_ERROR;\n\t    #status := #statInternal.diagnostics.status;\n\t    // if ENO mechanism is not used / not wanted replace the following line by --> ENO := TRUE;\n\t    ENO := #statMainState <> #STATE_ERROR;\n\t  END_REGION Write static values to outputs\n\tEND_REGION Write outputs\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "BinaryToGray", "description": "This function converts a binary coded value into a Gray-coded value.", "type": "FUNCTION", "name": "LGF_BinaryToGray", "vars": [{"name": "variableBinary", "type": "DWord", "description": "Binary coded value to convert to Gray code"}, {"name": "Ret_Val", "type": "DWord", "description": "Gray-coded value"}], "input": [{"name": "variableBinary", "type": "DWord", "description": "Binary coded value to convert to Gray code"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_BinaryToGray\" : DWord\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_BinaryToGray\n   VAR_INPUT \n      variableBinary : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      BIT_SHIFT_1 : USInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_BinaryToGray\n\t  // Comment/Function: This function converts a binary value to a gray coded value\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V14 Update 1\n\t  // Restrictions:     ENO disabled - no error handling needed\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 19.08.2015 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 28.10.2015 | Siemens Industry Online Support\n\t  //                         Name changed\n\t  // 01.00.02 | 02.01.2017 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.03 | 17.08.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15 Update 2\n\t  // 01.00.04 | 23.11.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15.1\n\t  // 01.00.05 | 11.06.2019 | Simatic Systems Support\n\t  //                         Standard header and block parameters update\n\t  //                         Add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION OUTPUTS\n\t  #LGF_BinaryToGray := #variableBinary XOR SHR(IN := #variableBinary, N := #BIT_SHIFT_1);\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DWord"}]}
{"title": "DecodeUtf8", "description": "Decodes a UTF-8 encoded byte stream into a WString", "type": "FUNCTION", "name": "LGF_DecodeUtf8", "vars": [{"name": "byteStream", "type": "Array[*] of Byte", "description": "UTF-8 encoded byte stream"}, {"name": "startPos", "type": "DInt", "description": "Position in byte stream to start decoding from"}, {"name": "count", "type": "UInt", "description": "Number of character (not bytes) to decode; 0: byte stream is\ndecoded until end"}, {"name": "Ret_Val", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FC, 16#8000 - 16#FFFF: Erroridentification"}, {"name": "decodedString", "type": "WString", "description": "Decoded string"}], "input": [{"name": "byteStream", "type": "Array[*] of Byte", "description": "UTF-8 encoded byte stream"}, {"name": "startPos", "type": "DInt", "description": "Position in byte stream to start decoding from"}, {"name": "count", "type": "UInt", "description": "Number of character (not bytes) to decode; 0: byte stream is\ndecoded until end"}], "output": [], "in/out": [{"name": "decodedString", "type": "WString", "description": "Decoded string"}], "answer": "FUNCTION \"LGF_DecodeUtf8\" : Word\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Online Support'\nFAMILY : LGF\nNAME : LGF_DecodeUtf8\n   VAR_INPUT \n      byteStream : Array[*] of Byte;\n      startPos : DInt;\n      count : UInt;\n   END_VAR\n\n   VAR_IN_OUT \n      decodedString : WString;\n   END_VAR\n\n   VAR_TEMP \n      tempString : WString;\n      tempStatus : Word;\n      tempCodepoint : DWord;\n      tempPos : DInt;\n      tempLowerBound : DInt;\n      tempUpperBound : DInt;\n      tempMaxLen : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      FOLLOW_BYTE : Byte := 2#10000000;\n      START_BYTE_TWO : Byte := 2#11000000;\n      START_BYTE_THREE : Byte := 2#11100000;\n      START_BYTE_FOUR : Byte := 2#11110000;\n      NUM_NET_BITS : USInt := 6;\n      REPLACEMENT_CHAR : Word := 16#003F;\n      MAX_CODEPOINT : Word := 16#D7FF;\n      STATUS_NO_ERROR : Word := 16#0000;\n      WARN_UNSUPPORTED_CHAR : Word := 16#7FFD;\n      WARN_STREAM_EXCEEDS_MAX_LEN : Word := 16#7FFE;\n      ERR_START_POS_OUTSIDE : Word := 16#8201;\n      ERR_COUNT_EXCEEDS_BOUNDS : Word := 16#8202;\n      ERR_COUNT_EXCEEDS_MAX_LEN : Word := 16#8203;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS / (c)Copyright 2021\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_DecodeUtf8\n\t  // Function:         Decodes a UTF-8 encoded byte stream into a WString\n\t  // Library:          LGF\n\t  // Author:           Siemens Industry Online Support\n\t  // Tested with:      CPU 1516-3 PN/DP\n\t  // Engineering:      TIA Portal V16\n\t  // Restrictions:     --\n\t  // Requirements:     S7-1200/1500\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 2022-12-16 | Online Support         | First released version\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION INITIALISATION\n\t  #tempString := WString#'';\n\t  #tempPos := #startPos;\n\t  #tempLowerBound := LOWER_BOUND(ARR := #byteStream, DIM := 1);\n\t  #tempUpperBound := UPPER_BOUND(ARR := #byteStream, DIM := 1);\n\t  #tempMaxLen := MAX_LEN(#decodedString);\n\t  #tempStatus := #STATUS_NO_ERROR;\n\t  \n\t  // Check parameters\n\t  IF #startPos < #tempLowerBound OR #startPos > #tempUpperBound THEN\n\t    #tempStatus := #ERR_START_POS_OUTSIDE;\n\t  ELSIF #startPos + #count > #tempUpperBound THEN\n\t    #tempStatus := #ERR_COUNT_EXCEEDS_BOUNDS;\n\t  ELSIF #count > #tempMaxLen THEN\n\t    #tempStatus := #ERR_COUNT_EXCEEDS_MAX_LEN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION PROGRAM LOGIC\n\t  IF #tempStatus = 0 THEN // No error\n\t    REPEAT\n\t      // Check length of decoded string\n\t      IF LEN(#tempString) >= #tempMaxLen THEN // Max. length reached and more data to decode\n\t        #tempStatus := #WARN_STREAM_EXCEEDS_MAX_LEN; // Output warning and exit loop\n\t        EXIT;\n\t      END_IF;\n\t      \n\t      IF #byteStream[#tempPos].%X7 = FALSE THEN // Character is encoded in 1 byte\n\t        IF #byteStream[#tempPos] <> 16#00 THEN // Character is not NUL\n\t          #tempCodepoint := #byteStream[#tempPos];\n\t          #tempPos += 1;\n\t        ELSE\n\t          EXIT; // End of stream found, exit loop\n\t        END_IF;\n\t        \n\t      ELSIF #tempPos = #tempUpperBound THEN // Character is last byte in byte stream but not encoded in 1 byte\n\t        #tempCodepoint := #REPLACEMENT_CHAR;\n\t        #tempPos += 1;\n\t        #tempStatus := #WARN_UNSUPPORTED_CHAR;\n\t        \n\t      ELSIF (#byteStream[#tempPos] AND #START_BYTE_FOUR) = #START_BYTE_FOUR THEN // Character is encoded in 4 bytes\n\t        // #tempCodepoint := #bytestream[#tempPos] AND NOT #START_BYTE_FOUR; // Mask start byte\n\t        \n\t        // FOR #tempPos := #tempPos + 1 TO #tempPos + 3 DO // Next byte and two more\n\t        //   #tempCodepoint := SHL(IN := #tempCodepoint, N := #NUM_NET_BITS); // Make space for follow byte\n\t        //   #tempCodepoint := #tempCodepoint OR (#bytestream[#tempPos] AND NOT #FOLLOW_BYTE); // Add follow byte\n\t        // END_FOR;\n\t        \n\t        #tempCodepoint := #REPLACEMENT_CHAR; // WChar only supports codepoints <= 16#D7FF\n\t        #tempPos += 4;\n\t        #tempStatus := #WARN_UNSUPPORTED_CHAR;\n\t        \n\t      ELSIF (#byteStream[#tempPos] AND #START_BYTE_THREE) = #START_BYTE_THREE THEN // Character is encoded in 3 bytes\n\t        #tempCodepoint := #byteStream[#tempPos] AND NOT #START_BYTE_THREE; // Mask start byte\n\t        \n\t        FOR #tempPos := #tempPos + 1 TO #tempPos + 2 DO // Next byte and one more\n\t          #tempCodepoint := SHL(IN := #tempCodepoint, N := #NUM_NET_BITS); // Make space for follow byte\n\t          #tempCodepoint := #tempCodepoint OR (#byteStream[#tempPos] AND NOT #FOLLOW_BYTE); // Add follow byte\n\t        END_FOR;\n\t        \n\t        // Check compatibility, WChar only supports codepoints <= 16#D7FF\n\t        IF #tempCodepoint > #MAX_CODEPOINT THEN\n\t          #tempCodepoint := #REPLACEMENT_CHAR;\n\t          #tempStatus := #WARN_UNSUPPORTED_CHAR;\n\t        END_IF;\n\t        \n\t      ELSIF (#byteStream[#tempPos] AND #START_BYTE_TWO) = #START_BYTE_TWO THEN // Character is encoded in 2 bytes\n\t        #tempCodepoint := #byteStream[#tempPos] AND NOT #START_BYTE_TWO; // Mask start byte\n\t        #tempCodepoint := SHL(IN := #tempCodepoint, N := #NUM_NET_BITS); // Make space for follow byte\n\t        #tempCodepoint := #tempCodepoint OR (#byteStream[#tempPos + 1] AND NOT #FOLLOW_BYTE); // Add follow byte\n\t        #tempPos += 2;\n\t        \n\t      ELSIF (#byteStream[#tempPos] AND #FOLLOW_BYTE) = #FOLLOW_BYTE THEN // Character starts with follow byte\n\t        #tempPos += 1; // Ignore unexpected follow bytes\n\t        CONTINUE;\n\t        \n\t      ELSE // Unsupported character\n\t        #tempCodepoint := #REPLACEMENT_CHAR;\n\t        #tempPos += 1;\n\t        #tempStatus := #WARN_UNSUPPORTED_CHAR;\n\t      END_IF;\n\t      \n\t      // Concatenate decoded characters\n\t      #tempString := CONCAT(IN1 := #tempString, IN2 := DWORD_TO_WCHAR(#tempCodepoint));\n\t      \n\t    UNTIL ((#count <> 0 AND LEN(#tempString) >= #count) OR #tempPos > #tempUpperBound) END_REPEAT;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  // Write application specific temp values to outputs\n\t  IF #tempStatus.%X15 = TRUE THEN // An error occured\n\t    #decodedString := WString#'';\n\t  ELSE // Successful or with warning\n\t    #decodedString := #tempString;\n\t  END_IF;\n\t  \n\t  // Write status\n\t  ENO := #tempStatus.%X15;\n\t  #LGF_DecodeUtf8 := #tempStatus;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Word"}]}
{"title": "DTLToJulianDate", "description": "This function converts the date and time of data type DTL to the Julian date and as well the modified Julian Date to data type LReal (Double). The timestamp is calculated based on UTC. This means that the time zone is not considered. Only times after 01/01/1990 are permitted.", "type": "FUNCTION", "name": "LGF_DTLToJulianDate", "vars": [{"name": "timeDTL", "type": "DTL", "description": "Date and time as DTL to convert to Julian Date"}, {"name": "Ret_Val", "type": "Void", "description": "---"}, {"name": "julianDate", "type": "LReal", "description": "Converted Julian date"}, {"name": "modifiedJulianDate", "type": "LReal", "description": "Converted modified Julian date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "timeDTL", "type": "DTL", "description": "Date and time as DTL to convert to Julian Date"}], "output": [{"name": "julianDate", "type": "LReal", "description": "Converted Julian date"}, {"name": "modifiedJulianDate", "type": "LReal", "description": "Converted modified Julian date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_DTLToJulianDate\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_DTLToJulianDate\n   VAR_INPUT \n      timeDTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n   END_VAR\n\n   VAR_OUTPUT \n      julianDate : LReal;\n      modifiedJulianDate : LReal;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTimeDtl {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempUnixTime : DInt;\n      tempJulianDate : LReal;\n      tempModifiedJulianDate : LReal;\n   END_VAR\n\n   VAR CONSTANT \n      DELTA_1970_1990 : DInt := 631_152_000;\n      SEC_PER_DAY : DInt := 86400;\n      OFFSET_JULIAN_DATE_TO_UNIX : LReal := 2440587.5;\n      OFFSET_MODIFIED_JULIAN_DATE_TO_JULIAN_DATE : LReal := 2400000.5;\n      TIME_ZERO_FORCE_UPDATE : Time := t#0d;\n      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_DTL_INPUT_VALUE_INVALID : Word := 16#8000;\n      ERR_TIME_BEFORE_1990 : Word := 16#8001;\n      CONVERSION_LIMIT {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1990-01-01-00:00:00;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Comment/Function: This function converts the date and time of data type DTL to the Julian date and as well the modified Julian Date to data type LReal (Double).  \n\t  //                   The timestamp is calculated based on UTC. This means that the time zone is not considered.\n\t  //                   Only times after 01/01/1990 are permitted.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-1516F (V2.9)\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     Date type (range from 01.01.1990) is used in the \"Function\" therefore the conversion limit is set.\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 14.04.2023 | Siemens Industry Online Support\n\t  //                         First released version\n\t  //===============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION INITIALISATION\n\t  #tempUnixTime := 0;\n\t  #tempJulianDate := 0.0;\n\t  #tempModifiedJulianDate := 0.0;\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t  // adding zero forces the PLC to update the tag and sets EON in case an error happend to the DTL value\n\t  #tempTimeDtl := #timeDTL + #TIME_ZERO_FORCE_UPDATE;\n\t  \n\t  IF NOT ENO THEN // Check if DTL has valid format and data\n\t    #julianDate := #tempJulianDate;\n\t    #modifiedJulianDate := #tempModifiedJulianDate;\n\t    #error := TRUE;\n\t    #status := #ERR_DTL_INPUT_VALUE_INVALID;\n\t    RETURN;\n\t  ELSIF (#tempTimeDtl < #CONVERSION_LIMIT) THEN // Check if timeUnix less than 01.01.1990\n\t    #julianDate := #tempJulianDate;\n\t    #modifiedJulianDate := #tempModifiedJulianDate;\n\t    #error := TRUE;\n\t    #status := #ERR_TIME_BEFORE_1990;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Convert System Time (UTC) to UNIX time\n\t  // DATE range D#1990-01-01 to D#2169-06-06\n\t  // DATE_TO_DINT conversion - The number of days since 1/1/1990 is returned as result.\n\t  #tempUnixTime := (DATE_TO_DINT(DTL_TO_DATE(#tempTimeDtl)) * #SEC_PER_DAY) + (TOD_TO_DINT(DTL_TO_TOD(#tempTimeDtl)) / 1000) + #DELTA_1970_1990;\n\t  \n\t  // Convert Unix time to Julian Date\n\t  #tempJulianDate := (DINT_TO_LREAL(#tempUnixTime) / #SEC_PER_DAY) + #OFFSET_JULIAN_DATE_TO_UNIX;\n\t  // Convert regular Julian date to modified Julian date\n\t  #tempModifiedJulianDate := #tempJulianDate - #OFFSET_MODIFIED_JULIAN_DATE_TO_JULIAN_DATE;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #julianDate := #tempJulianDate;\n\t  #modifiedJulianDate := #tempModifiedJulianDate;\n\t  #error := FALSE;\n\t  #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "DTLToString", "description": "This function converts a date of data type DTL into a character string of data type STRING in the traditional German format (DE) (DD MM YYYYY…).", "type": "FUNCTION", "name": "LGF_DTLToString_DE", "vars": [{"name": "date", "type": "DTL", "description": "Date to convert as DTL tag"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output date."}, {"name": "separatorDateAndTime", "type": "Char", "description": "Separator between the components date and time."}, {"name": "Ret_Val", "type": "Ret_Val", "description": "Output string according to the traditional German format.Example: `22-01-2019 14:07:57.696417000`"}], "input": [{"name": "date", "type": "DTL", "description": "Date to convert as DTL tag"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output date."}, {"name": "separatorDateAndTime", "type": "Char", "description": "Separator between the components date and time."}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_DTLToString_DE\" : String\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_DTLToString_DE\n   VAR_INPUT \n      \"date\" {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      separator { S7_HiddenAssignment := 'Hide'; S7_PredefinedAssignment := '$'-$''; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : Char;\n      separatorDateAndTime { S7_HiddenAssignment := 'Hide'; S7_PredefinedAssignment := '$' $''; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : Char;\n   END_VAR\n\n   VAR_TEMP \n      tempString : String;\n      tempIndex : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      CONVERT_SIZE_YEAR : USInt := 4;\n      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;\n      CONVERT_SIZE_NANOSECOND : USInt := 9;\n      CONVERT_PRECISION : USInt := 0;\n      CONVERT_FORMAT_TO_STRING : Word := 16#0000;\n      CONVERT_START_POSITION_YEAR : UInt := 7;\n      CONVERT_START_POSITION_MONTH : UInt := 4;\n      CONVERT_START_POSITION_DAY : UInt := 1;\n      CONVERT_START_POSITION_HOUR : UInt := 12;\n      CONVERT_START_POSITION_MINUTE : UInt := 15;\n      CONVERT_START_POSITION_SECOND : UInt := 18;\n      CONVERT_START_POSITION_NANOSECOND : UInt := 21;\n      SEPARATOR_POSITION_YEAR_MONTH : UInt := 6;\n      SEPARATOR_POSITION_MONTH_DAY : UInt := 3;\n      SEPARATOR_POSITION_DATE_AND_TIME : UInt := 11;\n      SEPARATOR_POSITION_HOUR_MINUTE : UInt := 14;\n      SEPARATOR_POSITION_MINUTE_SECOND : UInt := 17;\n      SEPARATOR_POSITION_SECOND_NANOSECOND : UInt := 20;\n      SEPARATOR_NANOSECOND : Char := '.';\n      SEPARATOR_TIME : Char := ':';\n      SEPARATOR_DATE : Char := '-';\n      SEPARATOR_DATE_AND_TIME : Char := ' ';\n      REPLACE_NANOSECOND_COUNT : DInt := 8;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_DTLToString_DE\n\t  // Comment/Function: This function converts a date of data type DTL into a character string of data type STRING in the traditional format (DD MM YYYYY…).\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO mechanism is not used, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 18.07.2019 | Simatic Systems Support\n\t  //                         First released version\n\t  //                         Split from \"LGF_DTLToString\"\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  // 03.01.00 | 25.07.2025 | Simatic Systems Support\n\t  //                         Insert parameter for separator between Data and time\n\t  //                         Assign default value '-' for separator parameter\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION\n\t  #tempString := '';\n\tEND_REGION\n\t\n\tREGION CONVERTER\n\t  // Set format parameters for output string\n\t  // Traditional (EU)\n\t  // DTL  | D| D| -| M| M| -| Y| Y| Y| Y|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS\n\t  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--\n\t  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29\n\t  \n\t  // Convert \"Value\" into \"String\" and place at the right position\n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.YEAR,\n\t           P      := #CONVERT_START_POSITION_YEAR,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_YEAR,\n\t           OUT    => #tempString);    // DTL YEAR --> String --> #tempPosYear\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.MONTH,\n\t           P      := #CONVERT_START_POSITION_MONTH,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL MONTH --> String --> #tempPosMonth\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.DAY,\n\t           P      := #CONVERT_START_POSITION_DAY,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL DAY --> String --> #tempPosDay\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.HOUR,\n\t           P      := #CONVERT_START_POSITION_HOUR,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL HOUR --> String --> #tempPosHour\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.MINUTE,\n\t           P      := #CONVERT_START_POSITION_MINUTE,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL MINUTE --> String --> #tempPosMinute\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.SECOND,\n\t           P      := #CONVERT_START_POSITION_SECOND,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL SECOND --> String --> #tempPosSecond\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.NANOSECOND,\n\t           P      := #CONVERT_START_POSITION_NANOSECOND,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_NANOSECOND,\n\t           OUT    => #tempString);     // DTL NANOSECOND --> String --> #tempPosNanosecond\n\t  \n\t  // Place separators at the right position in the string\n\t  IF #separator = '$00' THEN\n\t    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #SEPARATOR_DATE;\n\t    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #SEPARATOR_DATE;\n\t  ELSE\n\t    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #separator;\n\t    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #separator;\n\t  END_IF;\n\t  \n\t  IF #separatorDateAndTime = '$00' THEN\n\t    #tempString[#SEPARATOR_POSITION_DATE_AND_TIME] := #SEPARATOR_DATE_AND_TIME;\n\t  ELSE\n\t    #tempString[#SEPARATOR_POSITION_DATE_AND_TIME] := #separatorDateAndTime;\n\t  END_IF;\n\t  \n\t  #tempString[#SEPARATOR_POSITION_HOUR_MINUTE] := #SEPARATOR_TIME;\n\t  #tempString[#SEPARATOR_POSITION_MINUTE_SECOND] := #SEPARATOR_TIME;\n\t  #tempString[#SEPARATOR_POSITION_SECOND_NANOSECOND] := #SEPARATOR_NANOSECOND;\n\t  \n\t  // Correcting the string, due to the conversion of a leading \"0\" value into a \"blank\".\n\t  // Replacing of \"blank\" by \"0\"\n\t  IF (#tempString[#CONVERT_START_POSITION_MONTH] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_MONTH] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_DAY] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_DAY] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_HOUR] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_HOUR] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_MINUTE] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_MINUTE] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_SECOND] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_SECOND] := '0';\n\t  END_IF;\n\t  \n\t  FOR #tempIndex := 0 TO #REPLACE_NANOSECOND_COUNT DO\n\t    IF (#tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] = ' ') THEN\n\t      #tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] := '0';\n\t    ELSE\n\t      EXIT;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_DTLToString_DE := #tempString;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "String"}]}
{"title": "DTLToString", "description": "This function converts a date of data type DTL into a character string of data type STRING in international format (ISO) (YYYY MM DD…).", "type": "FUNCTION", "name": "LGF_DTLToString_ISO", "vars": [{"name": "date", "type": "DTL", "description": "Date to convert as DTL tag"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output date."}, {"name": "separatorDateAndTime", "type": "Char", "description": "Separator between the components date and time."}, {"name": "Ret_Val", "type": "String", "description": "Output string in accordance with the international format (ISO 8601).Example: `2019-01-22 14:06:51.524621000`"}], "input": [{"name": "date", "type": "DTL", "description": "Date to convert as DTL tag"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output date."}, {"name": "separatorDateAndTime", "type": "Char", "description": "Separator between the components date and time."}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_DTLToString_ISO\" : String\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_DTLToString_ISO\n   VAR_INPUT \n      \"date\" {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      separator { S7_PredefinedAssignment := '$'-$''; S7_HiddenAssignment := 'Hide'; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : Char;\n      separatorDateAndTime { S7_HiddenAssignment := 'Hide'; S7_PredefinedAssignment := '$' $''; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : Char;\n   END_VAR\n\n   VAR_TEMP \n      tempString : String;\n      tempIndex : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      CONVERT_SIZE_YEAR : USInt := 4;\n      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;\n      CONVERT_SIZE_NANOSECOND : USInt := 9;\n      CONVERT_PRECISION : USInt := 0;\n      CONVERT_FORMAT_TO_STRING : Word := 16#0000;\n      CONVERT_START_POSITION_YEAR : UInt := 1;\n      CONVERT_START_POSITION_MONTH : UInt := 6;\n      CONVERT_START_POSITION_DAY : UInt := 9;\n      CONVERT_START_POSITION_HOUR : UInt := 12;\n      CONVERT_START_POSITION_MINUTE : UInt := 15;\n      CONVERT_START_POSITION_SECOND : UInt := 18;\n      CONVERT_START_POSITION_NANOSECOND : UInt := 21;\n      SEPARATOR_POSITION_YEAR_MONTH : UInt := 5;\n      SEPARATOR_POSITION_MONTH_DAY : UInt := 8;\n      SEPARATOR_POSITION_DATE_AND_TIME : UInt := 11;\n      SEPARATOR_POSITION_HOUR_MINUTE : UInt := 14;\n      SEPARATOR_POSITION_MINUTE_SECOND : UInt := 17;\n      SEPARATOR_POSITION_SECOND_NANOSECOND : UInt := 20;\n      SEPARATOR_NANOSECOND : Char := '.';\n      SEPARATOR_TIME : Char := ':';\n      SEPARATOR_DATE : Char := '-';\n      SEPARATOR_DATE_AND_TIME : Char := ' ';\n      REPLACE_NANOSECOND_COUNT : DInt := 8;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_DTLToString_ISO\n\t  // Comment/Function: This function converts a date of data type DTL into a character string of data type STRING in international format (YYYY MM DD…).\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO mechanism is not used, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 15.06.2016 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 02.01.2017 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.02 | 17.08.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15 Update 2\n\t  // 01.00.03 | 23.11.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15.1\n\t  // 01.00.04 | 17.07.2019 | Simatic Systems Support\n\t  //                         Bugfix - nanosecond precision and '0' filling\n\t  // 01.00.05 | 18.07.2019 | Simatic Systems Support\n\t  //                         Renamed from \"LGF_DTLtoString\" to \"LGF_DTLToString_ISO\"\n\t  //                         Split into two blocks, removed \"format\" input\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  // 03.01.00 | 25.07.2025 | Simatic Systems Support\n\t  //                         Insert parameter for separator between Data and time\n\t  //                         Assign default value '-' for separator parameter\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION\n\t  #tempString := '';\n\tEND_REGION\n\t\n\tREGION CONVERTER\n\t  // Set format parameters for output string\n\t  // International ISO 8601\n\t  // DTL  | Y| Y| Y| Y| -| M| M| -| D| D|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS\n\t  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--\n\t  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29\n\t  \n\t  // Convert \"Value\" into \"String\" and place at the right position\n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.YEAR,\n\t           P      := #CONVERT_START_POSITION_YEAR,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_YEAR,\n\t           OUT    => #tempString);    // DTL YEAR --> String --> #tempPosYear\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.MONTH,\n\t           P      := #CONVERT_START_POSITION_MONTH,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL MONTH --> String --> #tempPosMonth\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.DAY,\n\t           P      := #CONVERT_START_POSITION_DAY,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL DAY --> String --> #tempPosDay\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.HOUR,\n\t           P      := #CONVERT_START_POSITION_HOUR,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL HOUR --> String --> #tempPosHour\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.MINUTE,\n\t           P      := #CONVERT_START_POSITION_MINUTE,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL MINUTE --> String --> #tempPosMinute\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.SECOND,\n\t           P      := #CONVERT_START_POSITION_SECOND,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL SECOND --> String --> #tempPosSecond\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.NANOSECOND,\n\t           P      := #CONVERT_START_POSITION_NANOSECOND,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_NANOSECOND,\n\t           OUT    => #tempString);     // DTL NANOSECOND --> String --> #tempPosNanosecond\n\t  \n\t  // Place separators at the right position in the string\n\t  IF #separator = '$00' THEN\n\t    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #SEPARATOR_DATE;\n\t    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #SEPARATOR_DATE;\n\t  ELSE\n\t    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #separator;\n\t    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #separator;\n\t  END_IF;\n\t  \n\t  IF #separatorDateAndTime = '$00' THEN\n\t    #tempString[#SEPARATOR_POSITION_DATE_AND_TIME] := #SEPARATOR_DATE_AND_TIME;\n\t  ELSE\n\t    #tempString[#SEPARATOR_POSITION_DATE_AND_TIME] := #separatorDateAndTime;\n\t  END_IF;\n\t  \n\t  #tempString[#SEPARATOR_POSITION_HOUR_MINUTE] := #SEPARATOR_TIME;\n\t  #tempString[#SEPARATOR_POSITION_MINUTE_SECOND] := #SEPARATOR_TIME;\n\t  #tempString[#SEPARATOR_POSITION_SECOND_NANOSECOND] := #SEPARATOR_NANOSECOND;\n\t  \n\t  // Correcting the string, due to the conversion of a leading \"0\" value into a \"blank\".\n\t  // Replacing of \"blank\" by \"0\"\n\t  IF (#tempString[#CONVERT_START_POSITION_MONTH] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_MONTH] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_DAY] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_DAY] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_HOUR] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_HOUR] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_MINUTE] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_MINUTE] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_SECOND] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_SECOND] := '0';\n\t  END_IF;\n\t  \n\t  FOR #tempIndex := 0 TO #REPLACE_NANOSECOND_COUNT DO\n\t    IF (#tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] = ' ') THEN\n\t      #tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] := '0';\n\t    ELSE\n\t      EXIT;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_DTLToString_ISO := #tempString;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "String"}]}
{"title": "DTLToString", "description": "This function converts a date of data type DTL into a character string of data type STRING in American format (US) (MM DD YYYY…).", "type": "FUNCTION", "name": "LGF_DTLToString_US", "vars": [{"name": "date", "type": "DTL", "description": "Date to convert as DTL tag"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output date."}, {"name": "separatorDateAndTime", "type": "Char", "description": "Separator between the components date and time."}, {"name": "Ret_Val", "type": "Ret_Val", "description": "Output string in accordance with the American format (US).Example: `01-22-2019 14:06:51.524621000`"}], "input": [{"name": "date", "type": "DTL", "description": "Date to convert as DTL tag"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output date."}, {"name": "separatorDateAndTime", "type": "Char", "description": "Separator between the components date and time."}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_DTLToString_US\" : String\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_DTLToString_US\n   VAR_INPUT \n      \"date\" {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      separator { S7_HiddenAssignment := 'Hide'; S7_PredefinedAssignment := '$'-$''; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : Char;\n      separatorDateAndTime { S7_HiddenAssignment := 'Hide'; S7_PredefinedAssignment := '$' $''; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : Char;\n   END_VAR\n\n   VAR_TEMP \n      tempString : String;\n      tempIndex : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      CONVERT_SIZE_YEAR : USInt := 4;\n      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;\n      CONVERT_SIZE_NANOSECOND : USInt := 9;\n      CONVERT_PRECISION : USInt := 0;\n      CONVERT_FORMAT_TO_STRING : Word := 16#0000;\n      CONVERT_START_POSITION_YEAR : UInt := 7;\n      CONVERT_START_POSITION_MONTH : UInt := 1;\n      CONVERT_START_POSITION_DAY : UInt := 4;\n      CONVERT_START_POSITION_HOUR : UInt := 12;\n      CONVERT_START_POSITION_MINUTE : UInt := 15;\n      CONVERT_START_POSITION_SECOND : UInt := 18;\n      CONVERT_START_POSITION_NANOSECOND : UInt := 21;\n      SEPARATOR_POSITION_MONTH_DAY : UInt := 3;\n      SEPARATOR_POSITION_DAY_YEAR : UInt := 6;\n      SEPARATOR_POSITION_DATE_AND_TIME : UInt := 11;\n      SEPARATOR_POSITION_HOUR_MINUTE : UInt := 14;\n      SEPARATOR_POSITION_MINUTE_SECOND : UInt := 17;\n      SEPARATOR_POSITION_SECOND_NANOSECOND : UInt := 20;\n      SEPARATOR_NANOSECOND : Char := '.';\n      SEPARATOR_TIME : Char := ':';\n      SEPARATOR_DATE : Char := '-';\n      SEPARATOR_DATE_AND_TIME : Char := ' ';\n      REPLACE_NANOSECOND_COUNT : DInt := 8;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_DTLToString_US\n\t  // Comment/Function: This function converts a date of data type DTL into a character string of data type STRING in American format (MM DD YYYY…).\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO mechanism is not used, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 28.07.2025 | Siemens Industry Online Support\n\t  //                         First released version\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION\n\t  #tempString := '';\n\tEND_REGION\n\t\n\tREGION CONVERTER\n\t  // Set format parameters for output string\n\t  // American format\n\t  // DTL  | M| M| -| D| D| -| Y| Y| Y| Y|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS\n\t  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--\n\t  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29\n\t  \n\t  // Convert \"Value\" into \"String\" and place at the right position\n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.YEAR,\n\t           P      := #CONVERT_START_POSITION_YEAR,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_YEAR,\n\t           OUT    => #tempString);    // DTL YEAR --> String --> #tempPosYear\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.MONTH,\n\t           P      := #CONVERT_START_POSITION_MONTH,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL MONTH --> String --> #tempPosMonth\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.DAY,\n\t           P      := #CONVERT_START_POSITION_DAY,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL DAY --> String --> #tempPosDay\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.HOUR,\n\t           P      := #CONVERT_START_POSITION_HOUR,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL HOUR --> String --> #tempPosHour\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.MINUTE,\n\t           P      := #CONVERT_START_POSITION_MINUTE,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL MINUTE --> String --> #tempPosMinute\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.SECOND,\n\t           P      := #CONVERT_START_POSITION_SECOND,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL SECOND --> String --> #tempPosSecond\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.NANOSECOND,\n\t           P      := #CONVERT_START_POSITION_NANOSECOND,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_NANOSECOND,\n\t           OUT    => #tempString);     // DTL NANOSECOND --> String --> #tempPosNanosecond\n\t  \n\t  // Place separators at the right position in the string\n\t  IF #separator = '$00' THEN\n\t    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #SEPARATOR_DATE;\n\t    #tempString[#SEPARATOR_POSITION_DAY_YEAR] := #SEPARATOR_DATE;\n\t  ELSE\n\t    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #separator;\n\t    #tempString[#SEPARATOR_POSITION_DAY_YEAR] := #separator;\n\t  END_IF;\n\t  \n\t  IF #separatorDateAndTime = '$00' THEN\n\t    #tempString[#SEPARATOR_POSITION_DATE_AND_TIME] := #SEPARATOR_DATE_AND_TIME;\n\t  ELSE\n\t    #tempString[#SEPARATOR_POSITION_DATE_AND_TIME] := #separatorDateAndTime;\n\t  END_IF;\n\t  \n\t  #tempString[#SEPARATOR_POSITION_HOUR_MINUTE] := #SEPARATOR_TIME;\n\t  #tempString[#SEPARATOR_POSITION_MINUTE_SECOND] := #SEPARATOR_TIME;\n\t  #tempString[#SEPARATOR_POSITION_SECOND_NANOSECOND] := #SEPARATOR_NANOSECOND;\n\t  \n\t  // Correcting the string, due to the conversion of a leading \"0\" value into a \"blank\".\n\t  // Replacing of \"blank\" by \"0\"\n\t  IF (#tempString[#CONVERT_START_POSITION_MONTH] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_MONTH] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_DAY] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_DAY] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_HOUR] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_HOUR] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_MINUTE] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_MINUTE] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_SECOND] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_SECOND] := '0';\n\t  END_IF;\n\t  \n\t  FOR #tempIndex := 0 TO #REPLACE_NANOSECOND_COUNT DO\n\t    IF (#tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] = ' ') THEN\n\t      #tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] := '0';\n\t    ELSE\n\t      EXIT;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_DTLToString_US := #tempString;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "String"}]}
{"title": "DTLToUnixTime", "description": "This function converts the date and time of data type DTL to the UNIX time of data type DInt. The timestamp is calculated in UTC. This means that the time zone is not considered. Only times after 01/01/1990 are permitted.", "type": "FUNCTION", "name": "LGF_DTLToUnixTime", "vars": [{"name": "timeDTL", "type": "DTL", "description": "Date and time as DTL to convert to UNIX time"}, {"name": "Ret_Val", "type": "DInt", "description": "Converted UNIX time"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "timeDTL", "type": "DTL", "description": "Date and time as DTL to convert to UNIX time"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_DTLToUnixTime\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_DTLToUnixTime\n   VAR_INPUT \n      timeDTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTimeDtl {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempUnixTime : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      DELTA_1970_1990 : DInt := 631_152_000;\n      SEC_PER_DAY : DInt := 86400;\n      TIME_ZERO_FORCE_UPDATE : Time := t#0d;\n      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_TIME_BEFORE_1990 : Word := 16#8000;\n      ERR_DTL_INPUT_VALUE_INVALID : Word := 16#8001;\n      CONVERSION_LIMIT {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1990-01-01-00:00:00;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_DTLToUnixTime\n\t  // Comment/Function: This function converts the date and time of data type DTL to a Unix time of data type DInt.\n\t  //                   The timestamp is calculated in UTC. This means that the time zone is not taken into account.\n\t  //                   Only times after 01/01/1990 are permitted.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15\n\t  // Restrictions:     Date type (range from 01.01.1990) is used in the \"Function\" therefore the conversion limit is set.\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 16.10.2018 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 20.06.2019 | Simatic Systems Support\n\t  //                         Standard header and block parameters update, status parameter added\n\t  // 01.00.02 | 10.07.2019 | Simatic Systems Support\n\t  //                         Commends added and code refactoring\n\t  //                         Add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  // 03.00.02 | 14.04.2023 | Simatic Systems Support\n\t  //                         Improve data verification for input `timeDTL` for valid data\n\t  //===============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION INITIALISATION\n\t  #tempUnixTime := 0;\n\tEND_REGION\n\t\n\tREGION CONVERT  IF NOT ENO THEN\n\t  // adding zero forces the PLC to update the tag and sets EON in case an error happend to the DTL value\n\t  #tempTimeDtl := #timeDTL + #TIME_ZERO_FORCE_UPDATE;\n\t  \n\t  IF NOT ENO THEN // Check if DTL has valid format and data\n\t    #LGF_DTLToUnixTime := #tempUnixTime;\n\t    #error := TRUE;\n\t    #status := #ERR_DTL_INPUT_VALUE_INVALID;\n\t    RETURN;\n\t    \n\t  ELSIF (#tempTimeDtl < #CONVERSION_LIMIT) THEN // Check if timeUnix less than 01.01.1990\n\t    #LGF_DTLToUnixTime := #tempUnixTime;\n\t    #error := TRUE;\n\t    #status := #ERR_TIME_BEFORE_1990;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Convert System Time (UTC) to UNIX time\n\t  // DATE range D#1990-01-01 to D#2169-06-06\n\t  // DATE_TO_DINT conversion - The number of days since 1/1/1990 is returned as result.\n\t  #tempUnixTime := (DATE_TO_DINT(DTL_TO_DATE(#tempTimeDtl)) * #SEC_PER_DAY) + (TOD_TO_DINT(DTL_TO_TOD(#tempTimeDtl)) / 1000) + #DELTA_1970_1990;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_DTLToUnixTime := #tempUnixTime;\n\t  #error := FALSE;\n\t  #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DInt"}]}
{"title": "EncodeUtf8", "description": "Encodes a WString into an UTF-8 encoded byte stream.", "type": "FUNCTION", "name": "LGF_EncodeUtf8", "vars": [{"name": "sourceString", "type": "WString", "description": "Character that shall be converted to UTF-8"}, {"name": "startPos", "type": "DInt", "description": "Position in encoded byte stream to start insert encoded WChars\n(Array lower bound is added)"}, {"name": "Ret_Val", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FC, 16#8000 - 16#FFFF: Erroridentification"}, {"name": "bytesUsed", "type": "UInt", "description": "Number of Bytes converted. Ranges from 1 to 3."}, {"name": "encodedByteStream", "type": "Array[*] of Byte", "description": "UTF-8 conformant byte sequence. B0 stores first Byte, B1 second\nand B2 third Byte. B3 is not used"}], "input": [{"name": "sourceString", "type": "WString", "description": "Character that shall be converted to UTF-8"}, {"name": "startPos", "type": "DInt", "description": "Position in encoded byte stream to start insert encoded WChars\n(Array lower bound is added)"}], "output": [{"name": "bytesUsed", "type": "UInt", "description": "Number of Bytes converted. Ranges from 1 to 3."}], "in/out": [{"name": "encodedByteStream", "type": "Array[*] of Byte", "description": "UTF-8 conformant byte sequence. B0 stores first Byte, B1 second\nand B2 third Byte. B3 is not used"}], "answer": "FUNCTION \"LGF_EncodeUtf8\" : Word\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Online Support'\nFAMILY : LGF\nNAME : LGF_EncodeUtf8\n   VAR_INPUT \n      sourceString : WString;\n      startPos : DInt;\n   END_VAR\n\n   VAR_OUTPUT \n      bytesUsed : UInt;\n   END_VAR\n\n   VAR_IN_OUT \n      encodedByteStream : Array[*] of Byte;\n   END_VAR\n\n   VAR_TEMP \n      tempStatus : Word;\n      tempConvertedUtf8 : DWord;\n      tempBytesUsed : UInt;\n      tempCharacter : WChar;\n      tempIndex : DInt;\n      tempArrayIndex : DInt;\n      tempUpperBound : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      USINT_NULL : USInt := 0;\n      DWORD_NULL : DWord := 16#0000_0000;\n      EMPTY_WCHAR : WChar := WCHAR#' ';\n      BELOW_7F : Word := 16#007F;\n      BELOW_7FF : Word := 16#07FF;\n      BELOW_MAX_FFFF : Word := 16#FFFF;\n      BYTE_3F : Byte := 16#3F;\n      BYTE_80 : Byte := 16#80;\n      BYTE_C0 : Byte := 16#C0;\n      BYTE_E0 : Byte := 16#E0;\n      USINT_ONE : USInt := 1;\n      USINT_TWO : USInt := 2;\n      USINT_THREE : USInt := 3;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_START_POS_OUTSIDE : Word := 16#8201;\n      ERR_COUNT_EXCEEDS_BOUNDS : Word := 16#8202;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS / (c)Copyright 2021\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_EncodeUtf8\n\t  // Function:         Encodes a WString into an UTF-8 encoded byte stream.\n\t  // Library:          LGF\n\t  // Author:           Siemens Industry Online Support\n\t  // Tested with:      CPU 1516-3 PN/DP\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     --\n\t  // Requirements:     S7-1200/1500\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 2022-12-16 | Siemens Online Support | First released version\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION INITIALISATION  \n\t  // Initialize functionality: reset of variables, diagnostics, etc.\n\t  #tempConvertedUtf8 := #DWORD_NULL;\n\t  #tempBytesUsed := #USINT_NULL;\n\t  #tempStatus := #STATUS_NO_ERROR;\n\t  #tempArrayIndex := LOWER_BOUND(ARR := #encodedByteStream, DIM := 1) + #startPos;\n\t  #tempUpperBound := UPPER_BOUND(ARR := #encodedByteStream, DIM := 1);\n\t  \n\t  // Check parameters\n\t  IF #tempArrayIndex < #tempArrayIndex OR #startPos > #tempUpperBound THEN\n\t    #tempStatus := #ERR_START_POS_OUTSIDE;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION PROGRAM LOGIC\n\t  FOR #tempIndex := 1 TO LEN(#sourceString) DO\n\t    // Assign temp value from input\n\t    #tempCharacter := #sourceString[#tempIndex];\n\t    \n\t    // Use this region for application specific code\n\t    IF FALSE\n\t      OR (#tempCharacter = #EMPTY_WCHAR)\n\t      OR (WCHAR_TO_WORD(#tempCharacter) <= (#BELOW_7F))\n\t    THEN\n\t      IF #tempArrayIndex > #tempUpperBound THEN\n\t        #tempStatus := #ERR_COUNT_EXCEEDS_BOUNDS;\n\t        EXIT;\n\t      ELSE\n\t        //will be only 1 byte occupied\n\t        #tempConvertedUtf8 := WCHAR_TO_DWORD(#tempCharacter);\n\t        #encodedByteStream[#tempArrayIndex] := #tempConvertedUtf8.%B0;\n\t        #tempArrayIndex += #USINT_ONE;\n\t        #tempBytesUsed += #USINT_ONE;\n\t      END_IF;\n\t      \n\t    ELSIF (WCHAR_TO_WORD(#tempCharacter) <= (#BELOW_7FF)) THEN\n\t      IF #tempArrayIndex + #USINT_ONE > #tempUpperBound THEN\n\t        #tempStatus := #ERR_COUNT_EXCEEDS_BOUNDS;\n\t        EXIT;\n\t      ELSE\n\t        //will be 2 byte occupied\n\t        #tempConvertedUtf8.%B1 := (WCHAR_TO_BYTE(#tempCharacter) AND #BYTE_3F) OR #BYTE_80;\n\t        #tempConvertedUtf8.%B0 := WORD_TO_BYTE(SHR(IN := WCHAR_TO_WORD(#tempCharacter), N := 6)) OR #BYTE_C0;\n\t        #encodedByteStream[#tempArrayIndex] := #tempConvertedUtf8.%B0;\n\t        #tempArrayIndex += #USINT_ONE;\n\t        #encodedByteStream[#tempArrayIndex] := #tempConvertedUtf8.%B1;\n\t        #tempArrayIndex += #USINT_ONE;\n\t        #tempBytesUsed += #USINT_TWO;\n\t      END_IF;\n\t      \n\t    ELSIF (WCHAR_TO_WORD(#tempCharacter) <= (#BELOW_MAX_FFFF)) THEN\n\t      IF #tempArrayIndex + #USINT_ONE > #tempUpperBound THEN\n\t        #tempStatus := #ERR_COUNT_EXCEEDS_BOUNDS;\n\t        EXIT;\n\t      ELSE\n\t        //will be 3 byte occupied\n\t        #tempConvertedUtf8.%B2 := (WCHAR_TO_BYTE(#tempCharacter) AND #BYTE_3F) OR #BYTE_80;\n\t        #tempConvertedUtf8.%B1 := (WORD_TO_BYTE(SHR(IN := WCHAR_TO_WORD(#tempCharacter), N := 6)) AND #BYTE_3F) OR #BYTE_80;\n\t        #tempConvertedUtf8.%B0 := WORD_TO_BYTE(SHR(IN := WCHAR_TO_WORD(#tempCharacter), N := 12)) OR #BYTE_E0;\n\t        #encodedByteStream[#tempArrayIndex] := #tempConvertedUtf8.%B0;\n\t        #tempArrayIndex += #USINT_ONE;\n\t        #encodedByteStream[#tempArrayIndex] := #tempConvertedUtf8.%B1;\n\t        #tempArrayIndex += #USINT_ONE;\n\t        #encodedByteStream[#tempArrayIndex] := #tempConvertedUtf8.%B2;\n\t        #tempArrayIndex += #USINT_ONE;\n\t        #tempBytesUsed += #USINT_THREE;\n\t      END_IF;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  // Write application specific temp values to outputs\n\t  IF #tempStatus.%X15 = TRUE THEN // An error occured\n\t    #bytesUsed := 0;\n\t  ELSE\n\t    #bytesUsed := #tempBytesUsed;\n\t  END_IF;\n\t  \n\t  // Write status\n\t  ENO := #tempStatus.%X15;\n\t  #LGF_EncodeUtf8 := #tempStatus;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Word"}]}
{"title": "GpsDDToGps", "description": "This function converts a given GPS-DD data type (decimal degrees) into a GPS data type (direction, degrees, minutes, and seconds). GPS decimal degree to GPS “native”.", "type": "FUNCTION", "name": "LGF_GpsDDToGps", "vars": [{"name": "gps", "type": "LGF_typeGPS_DD", "description": "GPS-Data to be converted (decimal degrees),\ne.g. 52.520817 13.40945"}, {"name": "Ret_Val", "type": "LGF_typeGPS", "description": "Converted GPS-Data (direction, degrees, minutes, and seconds),e.g. N52° 31′ 14.941″ E13° 24′ 34.020″"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "latitude", "type": "Real", "description": "Degrees latitude with decimal places\n(Unit: degree decimal), North = positive; South =\nnegative)\nvalid value range [-90.00000..90.00000]"}, {"name": "longitude", "type": "Real", "description": "Degrees longitude in degrees with decimal places\n(Unit: degree decimal), East = positive; West =\nnegative)\nvalid range [-180.0000..180.0000]"}, {"name": "latitude", "type": "LGF_typeGPS_D\nMS", "description": "Latitude child element"}, {"name": "longitude", "type": "LGF_typeGPS_D\nMS", "description": "Longitude child element"}], "input": [{"name": "gps", "type": "LGF_typeGPS_DD", "description": "GPS-Data to be converted (decimal degrees),\ne.g. 52.520817 13.40945"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_GpsDDToGps\" : \"LGF_typeGPS\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_GpsToDD\n   VAR_INPUT \n      gps : \"LGF_typeGPS_DD\";\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempGPS_DD : \"LGF_typeGPS_DD\";\n      tempGPS : \"LGF_typeGPS\";\n      tempRealStorage : Real;\n      tempStatus : Word;\n   END_VAR\n\n   VAR CONSTANT \n      NORTH : Char := 'N';\n      SOUTH : Char := 'S';\n      EAST : Char := 'E';\n      WEST : Char := 'W';\n      MINUTES_PER_HOUR : Real := 60.0;\n      SECONDS_PER_MINUTE : Real := 60.0;\n      MAX_MIN_OR_SEC_59 : UInt := 59;\n      DEGREE_0 : Real := 0.0;\n      DEGREE_90 : UInt := 90;\n      DEGREE_180 : UInt := 180;\n      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_LATITUDE_VALUE : Word := 16#8201;\n      ERR_LONGITUDE_VALUE : Word := 16#8203;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_GpsDDToGps\n\t  // Comment/Function: This function converts a given GPS DD type to GPS Type native\n\t  //                   GPS DD (decimal degree) to native GPS format\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V14 Update 1\n\t  // Restrictions:     ENO mechanism is not used, Error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  //----------|------------|-------------------------|------------------------------\n\t  // 01.00.00 | 2019.09.11 | SIMATIC Systems Support | First released version\n\t  // 03.00.00 | 2019.04.23 | Siemens Industry Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.02 | 20.01.2021 | Simatic Systems Support\n\t  //                         Fix `tempStatus` initialization\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Converion\n\t  // init status\n\t  #tempStatus := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t  // copy input to temp\n\t  #tempGPS_DD := #gps;\n\t  \n\t  REGION Latitude\n\t    // convert direction\n\t    IF #tempGPS_DD.latitude >= #DEGREE_0 THEN\n\t      #tempGPS.latitude.dir := #NORTH;\n\t    ELSE\n\t      #tempGPS.latitude.dir := #SOUTH;\n\t      #tempGPS_DD.latitude := - (#tempGPS_DD.latitude);\n\t    END_IF;\n\t    \n\t    // Convert decimal degrees to nativ GPS coordinates\n\t    #tempGPS.latitude.deg := REAL_TO_UINT(#tempGPS_DD.latitude);\n\t    \n\t    #tempRealStorage := FRAC(#tempGPS_DD.latitude) * #MINUTES_PER_HOUR;\n\t    #tempGPS.latitude.min := REAL_TO_UINT(#tempRealStorage);\n\t    \n\t    #tempRealStorage := FRAC(#tempRealStorage) * #SECONDS_PER_MINUTE;\n\t    #tempGPS.latitude.sec := REAL_TO_UINT(#tempRealStorage);\n\t    \n\t    // check valueinput limits, latitude decimal degrees > 90°, set fault\n\t    IF (#tempGPS.latitude.deg > #DEGREE_90) THEN\n\t      #tempStatus := #ERR_LATITUDE_VALUE;\n\t      \n\t      // Check value input limits, latitude minutes > 59, set fault\n\t    ELSIF (#tempGPS.latitude.min > #MAX_MIN_OR_SEC_59) THEN\n\t      #tempStatus := #ERR_LATITUDE_VALUE;\n\t      \n\t      // Check value limits input, latitude seconds > 59, set fault\n\t    ELSIF (#tempGPS.latitude.sec > #MAX_MIN_OR_SEC_59) THEN\n\t      #tempStatus := #ERR_LATITUDE_VALUE;\n\t    END_IF;\n\t  END_REGION Latitude\n\t  \n\t  REGION Longitude\n\t    // convert direction\n\t    IF #tempGPS_DD.longitude >= #DEGREE_0 THEN\n\t      #tempGPS.longitude.dir := #EAST;\n\t    ELSE\n\t      #tempGPS.longitude.dir := #WEST;\n\t      #tempGPS_DD.longitude := - (#tempGPS_DD.longitude);\n\t    END_IF;\n\t    \n\t    // Convert decimal degrees to nativ GPS coordinates\n\t    #tempGPS.longitude.deg := REAL_TO_UINT(#tempGPS_DD.longitude);\n\t    \n\t    #tempRealStorage := FRAC(#tempGPS_DD.longitude) * #MINUTES_PER_HOUR;\n\t    #tempGPS.longitude.min := REAL_TO_UINT(#tempRealStorage);\n\t    \n\t    #tempRealStorage := FRAC(#tempRealStorage) * #SECONDS_PER_MINUTE;\n\t    #tempGPS.longitude.sec := REAL_TO_UINT(#tempRealStorage);\n\t    \n\t    // Sum of longitude decimal degrees, minutes and seconds > 180°\n\t    IF (#tempGPS.longitude.deg > #DEGREE_180) THEN\n\t      #tempStatus := #ERR_LONGITUDE_VALUE;\n\t      \n\t      // Check value limits input, longitude minutes > 59, set fault\n\t    ELSIF (#tempGPS.longitude.min > #MAX_MIN_OR_SEC_59) THEN\n\t      #tempStatus := #ERR_LONGITUDE_VALUE;\n\t      \n\t      // Check value limits input,  longitude seconds > 59, set fault\n\t    ELSIF (#tempGPS.longitude.sec > #MAX_MIN_OR_SEC_59) THEN\n\t      #tempStatus := #ERR_LONGITUDE_VALUE;\n\t    END_IF;\n\t    \n\t    // Case of wrong DMS input \n\t    IF (#tempStatus.%X15 = true) THEN\n\t      #tempGPS.latitude.deg := 0; // Set value latitude to zero\n\t      #tempGPS.longitude.deg := 0; // Set value longitude to zero\n\t    ELSE\n\t      #tempStatus := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t    END_IF;\n\t  END_REGION Longitude\n\tEND_REGION Conversion\n\t\n\tREGION OUTPUTS\n\t  // Copy DMS values to work variables\n\t  #LGF_GpsDDToGps := #tempGPS;\n\t  // Error outputs\n\t  #error := #tempStatus.%X15;\n\t  #status := #tempStatus;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\t  RETURN;\n\tEND_REGION\nEND_FUNCTION", "return_value": [{"type": "\"LGF_typeGPS\""}]}
{"title": "GpsToGpsDD", "description": "This function converts a given GPS data type (format direction, degrees, minutes, and seconds) into a GPS-DD data type (decimal degrees). GPS “native” to GPS decimal Degree.", "type": "FUNCTION", "name": "LGF_GpsToGpsDD", "vars": [{"name": "gps", "type": "LGF_typeGPS", "description": "GPS-Data to be converted (direction, degrees, minutes, and\nseconds),\ne.g. N52° 31′ 14.941″ E13° 24′ 34.020″"}, {"name": "Ret_Val", "type": "LGF_typeGPS_DD", "description": "Converted GPS-Data (decimal degrees),e.g. 52.520817 13.40945"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "latitude", "type": "LGF_typeGPS_D\nMS", "description": "Latitude child element"}, {"name": "longitude", "type": "LGF_typeGPS_D\nMS", "description": "Longitude child element"}, {"name": "latitude", "type": "Real", "description": "Degrees latitude with decimal places\n(Unit: degree decimal), North = positive; South =\nnegative)\nvalid value range [-90.00000..90.00000]"}, {"name": "longitude", "type": "Real", "description": "Degrees longitude in degrees with decimal places\n(Unit: degree decimal), East = positive; West =\nnegative)\nvalid range [-180.0000..180.0000]"}], "input": [{"name": "gps", "type": "LGF_typeGPS", "description": "GPS-Data to be converted (direction, degrees, minutes, and\nseconds),\ne.g. N52° 31′ 14.941″ E13° 24′ 34.020″"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_GpsToGpsDD\" : \"LGF_typeGPS_DD\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_GpsToDD\n   VAR_INPUT \n      gps : \"LGF_typeGPS\";\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempGPS : \"LGF_typeGPS_DD\";\n      tempStatus : Word;\n   END_VAR\n\n   VAR CONSTANT \n      NORTH1 : Char := 'n';\n      NORTH2 : Char := 'N';\n      SOUTH1 : Char := 's';\n      SOUTH2 : Char := 'S';\n      EAST1 : Char := 'e';\n      EAST2 : Char := 'E';\n      WEST1 : Char := 'w';\n      WEST2 : Char := 'W';\n      MINUTES_PER_HOUR : Real := 60.0;\n      SECONDS_PER_HOUR : Real := 3600.0;\n      MAX_MIN_OR_SEC_59 : UInt := 59;\n      DEGREE_0 : Real := 0.0;\n      DEGREE_15 : Real := 15.0;\n      DEGREE_90 : Real := 90.0;\n      DEGREE_180 : Real := 180.0;\n      DEGREE_360 : Real := 360.0;\n      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_LATITUDE_DIRECTION : Word := 16#8200;\n      ERR_LATITUDE_VALUE : Word := 16#8201;\n      ERR_LONGITUDE_DIRECTION : Word := 16#8202;\n      ERR_LONGITUDE_VALUE : Word := 16#8203;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_GpsToGpsDD\n\t  // Comment/Function: This function converts a give GPS type to GPS Type DD\n\t  //                   GPS native to GPS decimal Degree\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V14 Update 1\n\t  // Restrictions:     ENO mechanism is not used, Error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  //----------|------------|-------------------------|------------------------------\n\t  // 01.00.00 | 2019.09.11 | SIMATIC Systems Support | First released version\n\t  // 03.00.00 | 2019.04.23 | Siemens Industry Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.02 | 20.01.2021 | Simatic Systems Support\n\t  //                         Fix `tempStatus` initialization\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Converion\n\t  // init status\n\t  #tempStatus := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t  \n\t  REGION Latitude\n\t    // Convert seconds to decimal degrees\n\t    #tempGPS.latitude := UINT_TO_REAL(#gps.latitude.sec) / #SECONDS_PER_HOUR;\n\t    \n\t    // Convert minutes to decimal degrees\n\t    #tempGPS.latitude += UINT_TO_REAL(#gps.latitude.min) / #MINUTES_PER_HOUR;\n\t    \n\t    // Convert degreesto decimal degrees\n\t    #tempGPS.latitude += #gps.latitude.deg;\n\t    \n\t    // Negate value if south 's' OR 'S'\n\t    IF (#gps.latitude.dir = #SOUTH1) OR (#gps.latitude.dir = #SOUTH2) THEN\n\t      #tempGPS.latitude := - (#tempGPS.latitude);\n\t      \n\t      // Positive value if north 'n' OR 'N'\n\t    ELSIF (#gps.latitude.dir = #NORTH1) OR (#gps.latitude.dir = #NORTH2) THEN\n\t      ;\n\t      \n\t      // Error direction\n\t    ELSE\n\t      #tempStatus := #ERR_LATITUDE_DIRECTION;\n\t    END_IF;\n\t    \n\t    // Check value input limits,  degrees > 90°, set fault\n\t    IF (ABS(#tempGPS.latitude) > #DEGREE_90) THEN\n\t      #tempStatus := #ERR_LATITUDE_VALUE;\n\t      \n\t      // Check value input limits, latitude minutes > 59, set fault\n\t    ELSIF (#gps.latitude.min > #MAX_MIN_OR_SEC_59) THEN\n\t      #tempStatus := #ERR_LATITUDE_VALUE;\n\t      \n\t      // Check value limits input, latitude seconds > 59, set fault\n\t    ELSIF (#gps.latitude.sec > #MAX_MIN_OR_SEC_59) THEN\n\t      #tempStatus := #ERR_LATITUDE_VALUE;\n\t    END_IF;\n\t    \n\t  END_REGION Latitude\n\t  \n\t  REGION Longitude\n\t    // Convert seconds to decimal degrees\n\t    #tempGPS.longitude := UINT_TO_REAL(#gps.longitude.sec) / #SECONDS_PER_HOUR;\n\t    \n\t    // Convert minutes to decimal degrees\n\t    #tempGPS.longitude += UINT_TO_REAL(#gps.longitude.min) / #MINUTES_PER_HOUR;\n\t    \n\t    // Convert degress to decimal degrees \n\t    #tempGPS.longitude += #gps.longitude.deg;\n\t    \n\t    // Negate value if west 'w' OR 'W'\n\t    IF (#gps.longitude.dir = #WEST1) OR (#gps.longitude.dir = #WEST2) THEN\n\t      #tempGPS.longitude := - (#tempGPS.longitude);\n\t      \n\t      // Positive value if east 'e' OR 'E'\n\t    ELSIF (#gps.longitude.dir = #EAST1) OR (#gps.longitude.dir = #EAST2) THEN\n\t      ;\n\t      \n\t      // Error direction\n\t    ELSE\n\t      #tempStatus := #ERR_LONGITUDE_DIRECTION;\n\t    END_IF;\n\t    \n\t    // Sum of longitude decimal degrees, minutes and seconds > 180°\n\t    IF (ABS(#tempGPS.longitude) > #DEGREE_180) THEN\n\t      #tempStatus := #ERR_LONGITUDE_VALUE;\n\t      \n\t      // Check value limits input, longitude minutes > 59, set fault\n\t    ELSIF (#gps.longitude.min > #MAX_MIN_OR_SEC_59) THEN\n\t      #tempStatus := #ERR_LONGITUDE_VALUE;\n\t      \n\t      // Check value limits input,  longitude seconds > 59, set fault\n\t    ELSIF (#gps.longitude.sec > #MAX_MIN_OR_SEC_59) THEN\n\t      #tempStatus := #ERR_LONGITUDE_VALUE;\n\t    END_IF;\n\t    \n\t  END_REGION Longitude\n\t  \n\t  // Case of wrong DMS input \n\t  IF (#tempStatus.%X15 = true) THEN\n\t    #tempGPS.latitude := #DEGREE_0; // Set value latitude to zero\n\t    #tempGPS.longitude := #DEGREE_0; // Set value longitude to zero\n\t  ELSE\n\t    #tempStatus := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t  END_IF;\n\tEND_REGION Conversion\n\t\n\tREGION OUTPUTS\n\t  // Copy DMS values to work variables\n\t  #LGF_GpsToGpsDD := #tempGPS;\n\t  // Error outputs\n\t  #error := #tempStatus.%X15;\n\t  #status := #tempStatus;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\t  RETURN;\n\tEND_REGION\nEND_FUNCTION", "return_value": [{"type": "\"LGF_typeGPS_DD\""}]}
{"title": "GrayToBinary", "description": "This function converts a gray coded value into a binary coded value.", "type": "FUNCTION", "name": "LGF_GrayToBinary", "vars": [{"name": "variableGray", "type": "DWord", "description": "Gray coded value to convert to binary value"}, {"name": "Ret_Val", "type": "DWord", "description": "Binary value"}], "input": [{"name": "variableGray", "type": "DWord", "description": "Gray coded value to convert to binary value"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_GrayToBinary\" : DWord\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_GrayToBinary\n   VAR_INPUT \n      variableGray : DWord;\n   END_VAR\n\n   VAR_TEMP \n      tempBinaryBits : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      BIT_SHIFT_16 : USInt := 16;\n      BIT_SHIFT_8 : USInt := 8;\n      BIT_SHIFT_4 : USInt := 4;\n      BIT_SHIFT_2 : USInt := 2;\n      BIT_SHIFT_1 : USInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_GrayToBinary\n\t  // Comment/Function: This function converts a gray coded value to a binary.\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V14 Update 1\n\t  // Restrictions:     ENO disabled - no error handling needed\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 19.08.2015 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 28.10.2015 | Siemens Industry Online Support\n\t  //                         Name changed\n\t  // 01.00.02 | 02.01.2017 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.03 | 17.08.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15 Update 2\n\t  // 01.00.04 | 23.11.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15.1\n\t  // 01.00.05 | 11.06.2019 | Simatic Systems Support\n\t  //                         Standard header, block parameters update and performance update\n\t  //                         Add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION INITIALISATION\n\t  #tempBinaryBits := #variableGray;\n\tEND_REGION\n\t\n\tREGION PROGRAM LOGIC\n\t  #tempBinaryBits := #tempBinaryBits XOR SHR(IN := #tempBinaryBits, N := #BIT_SHIFT_16);\n\t  #tempBinaryBits := #tempBinaryBits XOR SHR(IN := #tempBinaryBits, N := #BIT_SHIFT_8);\n\t  #tempBinaryBits := #tempBinaryBits XOR SHR(IN := #tempBinaryBits, N := #BIT_SHIFT_4);\n\t  #tempBinaryBits := #tempBinaryBits XOR SHR(IN := #tempBinaryBits, N := #BIT_SHIFT_2);\n\t  #tempBinaryBits := #tempBinaryBits XOR SHR(IN := #tempBinaryBits, N := #BIT_SHIFT_1);\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_GrayToBinary := #tempBinaryBits;\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DWord"}]}
{"title": "IntToString", "description": "This function converts a variable of the data type DInt into a variable of the data type String.", "type": "FUNCTION", "name": "LGF_IntToString", "vars": [{"name": "value", "type": "DInt", "description": "Double-Integer value to convert"}, {"name": "Ret_Val", "type": "String", "description": "Converted value as string.Example: ‘+16927’"}], "input": [{"name": "value", "type": "DInt", "description": "Double-Integer value to convert"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_IntToString\" : String\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_IntToString\n   VAR_INPUT \n      value : DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempString : String;\n   END_VAR\n\n   VAR CONSTANT \n      CONVERT_SIZE : USInt := 0;\n      CONVERT_PRECISION : USInt := 0;\n      CONVERT_FORMAT_TO_STRING : Word := 16#0000;\n      CONVERT_START_POSITION : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_IntToString\n\t  // Comment/Function: This function converts a variable of the system data type `DInt` into a variable of the data type `String`.\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V14 SP1 Upd 5\n\t  // Restrictions:     ENO disabled - no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 04.07.2018 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 17.08.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15 Update 2\n\t  // 01.00.02 | 23.11.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15.1\n\t  // 01.00.05 | 07.06.2019 | Simatic Systems Support\n\t  //                         Standard header and block parameters update\n\t  //                         Program changed to VAL_STRG wrapper\n\t  // 01.00.06 | 30.07.2019 | Simatic Systems Support\n\t  //                         Add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION CONVERSION\n\t  VAL_STRG(IN     := #value,\n\t           SIZE   := #CONVERT_SIZE,\n\t           PREC   := #CONVERT_PRECISION,\n\t           FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           P      := #CONVERT_START_POSITION,\n\t           OUT    => #tempString);\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  #LGF_IntToString := #tempString;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\nEND_FUNCTION", "return_value": [{"type": "String"}]}
{"title": "JulianTimeToDTL", "description": "This function converts a given Julian Date (regular or modified) of data type LReal (Double) to a date and time of data type DTL. The timestamp is calculated based on UTC. This means that the time zone is not considered. Only times after 01/01/1990 are permitted.", "type": "FUNCTION", "name": "LGF_JulianTimeToDTL", "vars": [{"name": "julianDate", "type": "LReal", "description": "Julian date to convert\n(standard or modified, depends on `isModifiedDate`)"}, {"name": "isModifiedDate", "type": "Bool", "description": "TRUE: `julianDate` is the modified Julian date\nFALSE: `julianDate` is the regular Julian date"}, {"name": "Ret_Val", "type": "DTL", "description": "Converted time (Date and time).In case of Error DTL default value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "julianDate", "type": "LReal", "description": "Julian date to convert\n(standard or modified, depends on `isModifiedDate`)"}, {"name": "isModifiedDate", "type": "Bool", "description": "TRUE: `julianDate` is the modified Julian date\nFALSE: `julianDate` is the regular Julian date"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_JulianTimeToDTL\" : DTL\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_JulianTimeToDTL\n   VAR_INPUT \n      julianDate : LReal;\n      isModifiedDate { S7_PredefinedAssignment := 'FALSE'} : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempJulianDate : LReal;\n      tempUnixTime : DInt;\n      tempDate : DInt;\n      tempTime : DInt;\n      tempDTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n   END_VAR\n\n   VAR CONSTANT \n      DELTA_1970_1990 : DInt := 631_152_000;\n      SEC_PER_DAY : DInt := 86400;\n      SEC_PER_HOUR : DInt := 3600;\n      SEC_PER_MINUTE : DInt := 60;\n      OFFSET_JULIAN_DATE_TO_UNIX : LReal := 2440587.5;\n      OFFSET_MODIFIED_JULIAN_DATE_TO_JULIAN_DATE : LReal := 2400000.5;\n      STATUS_NO_ERRROR : Word := 16#0000;\n      ERR_TIME_BEFORE_1990 : Word := 16#8000;\n      WARN_CONVERSION_LIMIT : Word := 16#6001;\n      CONVERSION_LIMIT {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1990-01-01-00:00:00;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Comment/Function: This function converts a given Julian Date (regular or modified) of data type LReal (Double) to a date and time of data type DTL.  \n\t  //                   The timestamp is calculated based on UTC. This means that the time zone is not considered.\n\t  //                   Only times after 01/01/1990 are permitted.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15\n\t  // Restrictions:     ENO mechanism is not used, Error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 14.04.2023 | Siemens Industry Online Support\n\t  //                         First released version\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION CONVERT\n\t  // convert from Julian Date to UNIX time\n\t  IF #isModifiedDate THEN\n\t    #tempJulianDate := #julianDate + #OFFSET_MODIFIED_JULIAN_DATE_TO_JULIAN_DATE;\n\t  ELSE\n\t    #tempJulianDate := #julianDate;\n\t  END_IF;\n\t  #tempUnixTime := LREAL_TO_DINT((#tempJulianDate - #OFFSET_JULIAN_DATE_TO_UNIX) * #SEC_PER_DAY);\n\t  \n\t  // Check if timeUnix less than 01.01.1990\n\t  IF (#tempUnixTime < #DELTA_1970_1990) THEN\n\t    #LGF_JulianTimeToDTL := #CONVERSION_LIMIT;\n\t    #error := TRUE;\n\t    #status := #ERR_TIME_BEFORE_1990;\n\t    RETURN;\n\t    \n\t    // Check if timeUnix is exactly on lower limitation of 01.01.1990\n\t  ELSIF (#tempUnixTime = #DELTA_1970_1990) THEN\n\t    #LGF_JulianTimeToDTL := #CONVERSION_LIMIT;\n\t    #error := FALSE;\n\t    #status := #WARN_CONVERSION_LIMIT;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Convert date\n\t  #tempDate := (#tempUnixTime - #DELTA_1970_1990) / #SEC_PER_DAY;\n\t  #tempDTL := DATE_TO_DTL(DINT_TO_DATE(#tempDate));\n\t  \n\t  // Convert time\n\t  #tempTime := #tempUnixTime - #DELTA_1970_1990 - (#tempDate * #SEC_PER_DAY);\n\t  #tempDTL.HOUR := DINT_TO_USINT(#tempTime / #SEC_PER_HOUR);\n\t  #tempDTL.MINUTE := DINT_TO_USINT(#tempTime MOD #SEC_PER_HOUR / #SEC_PER_MINUTE);\n\t  #tempDTL.SECOND := DINT_TO_USINT(#tempTime MOD #SEC_PER_MINUTE);\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_JulianTimeToDTL := #tempDTL;\n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERRROR;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DTL"}]}
{"title": "StringToDTL", "description": "This function converts a character string in the traditional German format (DE) with date and time components into the data type DTL.", "type": "FUNCTION", "name": "LGF_StringToDTL_DE", "vars": [{"name": "date", "type": "String", "description": "Date as a character string according to the format.\nExample: `22-01-2019 14:07:57.696417000`."}, {"name": "Ret_Val", "type": "DTL", "description": "The converted date and time in the format DTL"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "date", "type": "String", "description": "Date as a character string according to the format.\nExample: `22-01-2019 14:07:57.696417000`."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_StringToDTL_DE\" : DTL\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_StringToDTL_DE\n   VAR_INPUT \n      \"date\" : String;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempIndex : DInt;\n      tempDateAndTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempDateString : String;\n   END_VAR\n\n   VAR CONSTANT \n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      STATUS_NO_CURRENT_JOBS : Word := 16#7000;\n      ERR_DATE_STRING_TO_SHORT : Word := 16#8401;\n      ERR_DATE_STRING_EMPTY : Word := 16#8400;\n      ERR_FORMAT_YEAR : Word := 16#8201;\n      ERR_FORMAT_MONTH : Word := 16#8202;\n      ERR_FORMAT_DAY : Word := 16#8203;\n      ERR_FORMAT_HOUR : Word := 16#8204;\n      ERR_FORMAT_MINUTE : Word := 16#8205;\n      ERR_FORMAT_SECOND : Word := 16#8206;\n      ERR_FORMAT_NANOSECOND : Word := 16#8207;\n      INITIAL_VALUE {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1970-01-01-00:00:00.0;\n      CONVERT_PRECISION : USInt := 0;\n      CONVERT_FORMAT_TO_DECIMAL : Word := 16#0000;\n      CONVERT_START_POSITION : UInt := 1;\n      CONVERT_START_POSITION_YEAR : SInt := 7;\n      CONVERT_START_POSITION_MONTH : SInt := 4;\n      CONVERT_START_POSITION_DAY : SInt := 1;\n      CONVERT_START_POSITION_HOUR : SInt := 12;\n      CONVERT_START_POSITION_MINUTE : SInt := 15;\n      CONVERT_START_POSITION_SECOND : SInt := 18;\n      CONVERT_START_POSITION_NANOSECOND : SInt := 21;\n      CONVERT_SIZE_YEAR : USInt := 4;\n      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;\n      CONVERT_SIZE_NANOSECOND : USInt := 9;\n      MINIMUM_DATE_STRING_LENGTH : Int := 19;\n      YEAR_MIN : UInt := 1970;\n      YEAR_MAX : UInt := 2262;\n      MONTH_MIN : USInt := 1;\n      MONTH_MAX : USInt := 12;\n      DAY_MIN : USInt := 1;\n      DAY_MAX : USInt := 31;\n      HOUR_MIN : USInt := 0;\n      HOUR_MAX : USInt := 23;\n      SECOND_MINUTE_MIN : USInt := 0;\n      SECOND_MINUTE_MAX : USInt := 59;\n      NANOSECOND_MIN : UDInt := 0;\n      NANOSECOND_MAX : UDInt := 999999999;\n      NANOSECOND_FOR_COUNTER : DInt := 9;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_StringToDTL_DE\n\t  // Comment/Function: This function converts a character string in the traditional German format (DE)\n\t  //                   with date components into the data type DTL.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO mechanism is not used, Error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 22.07.2019 | Simatic Systems Support\n\t  //                         First released version\n\t  //                         Split from \"LGF_StringToDTL\"\n\t  //                         Correction of the weekday of DTL, comments added\n\t  //                         Add ENO handling, adjust comments in interface\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  // 03.01.00 | 31.07.2025 | Simatic Systems Support\n\t  //                         Fix bug - missing error code in case of wrong date string\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION CONVERTER\n\t  IF #date = '' THEN\n\t    #error := TRUE;\n\t    #status := #ERR_DATE_STRING_EMPTY;\n\t    #LGF_StringToDTL_DE := #INITIAL_VALUE;\n\t    RETURN;\n\t  ELSIF LEN(#date) < #MINIMUM_DATE_STRING_LENGTH THEN\n\t    #error := TRUE;\n\t    #status := #ERR_DATE_STRING_TO_SHORT;\n\t    #LGF_StringToDTL_DE := #INITIAL_VALUE;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Set format parameters for input string\n\t  // Traditional (EU)\n\t  // DTL  | D| D| -| M| M| -| Y| Y| Y| Y|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS\n\t  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--\n\t  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29\n\t  \n\t  REGION YEAR\n\t    // Separating the input string into components of DTL\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_YEAR, P := #CONVERT_START_POSITION_YEAR);\n\t    // Converting separated String components into DTL values\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.YEAR,\n\t             P      := #CONVERT_START_POSITION);\n\t    // Format check\n\t    IF (#tempDateAndTime.YEAR < #YEAR_MIN) OR (#YEAR_MAX < #tempDateAndTime.YEAR) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_YEAR;\n\t      #LGF_StringToDTL_DE := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION MONTH\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_MONTH);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.MONTH,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.MONTH < #MONTH_MIN) OR (#MONTH_MAX < #tempDateAndTime.MONTH) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_MONTH;\n\t      #LGF_StringToDTL_DE := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION DAY\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_DAY);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.DAY,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.DAY < #DAY_MIN) OR (#DAY_MAX < #tempDateAndTime.DAY) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_DAY;\n\t      #LGF_StringToDTL_DE := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION HOUR\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_HOUR);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.HOUR,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.HOUR < #HOUR_MIN) OR (#HOUR_MAX < #tempDateAndTime.HOUR) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_HOUR;\n\t      #LGF_StringToDTL_DE := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION MINUTE\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_MINUTE);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.MINUTE,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.MINUTE < #SECOND_MINUTE_MIN) OR (#SECOND_MINUTE_MAX < #tempDateAndTime.MINUTE) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_MINUTE;\n\t      #LGF_StringToDTL_DE := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION SECOND\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_SECOND);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.SECOND,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.SECOND < #SECOND_MINUTE_MIN) OR (#SECOND_MINUTE_MAX < #tempDateAndTime.SECOND) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_SECOND;\n\t      #LGF_StringToDTL_DE := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION NANOSECOND\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_NANOSECOND, P := #CONVERT_START_POSITION_NANOSECOND);\n\t    // Replacing of the \"blan\" in the nanosecond string by \"0\"\n\t    // Effect:   xx.1 --> xx.1 AND NOT xx.1 --> xx.000000001\n\t    FOR #tempIndex := 1 TO #NANOSECOND_FOR_COUNTER DO\n\t      IF #tempDateString[#tempIndex] = ' ' THEN\n\t        #tempDateString[#tempIndex] := '0';\n\t      END_IF;\n\t    END_FOR;\n\t    \n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.NANOSECOND,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.NANOSECOND < #NANOSECOND_MIN) OR (#NANOSECOND_MAX < #tempDateAndTime.NANOSECOND) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_NANOSECOND;\n\t      #LGF_StringToDTL_DE := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  // Correction of the weekday of DTL\n\t  #tempDateAndTime := #tempDateAndTime + t#0ms;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #LGF_StringToDTL_DE := #tempDateAndTime;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DTL"}]}
{"title": "StringToDTL", "description": "This function converts a character string in international format (ISO 8601) with date and time components into the data type DTL.", "type": "FUNCTION", "name": "LGF_StringToDTL_ISO", "vars": [{"name": "date", "type": "String", "description": "Date as a character string according to the format.\nExample: `2019-01-22 14:07:57.696417000`."}, {"name": "Ret_Val", "type": "DTL", "description": "The converted date and time in the format DTL"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "date", "type": "String", "description": "Date as a character string according to the format.\nExample: `2019-01-22 14:07:57.696417000`."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_StringToDTL_ISO\" : DTL\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_StringToDTL_ISO\n   VAR_INPUT \n      \"date\" : String;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempIndex : DInt;\n      tempDateAndTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempDateString : String;\n   END_VAR\n\n   VAR CONSTANT \n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      STATUS_NO_JOB : Word := 16#7000;\n      ERR_DATE_STRING_EMPTY : Word := 16#8400;\n      ERR_DATE_STRING_TO_SHORT : Word := 16#8401;\n      ERR_FORMAT_YEAR : Word := 16#8201;\n      ERR_FORMAT_MONTH : Word := 16#8202;\n      ERR_FORMAT_DAY : Word := 16#8203;\n      ERR_FORMAT_HOUR : Word := 16#8204;\n      ERR_FORMAT_MINUTE : Word := 16#8205;\n      ERR_FORMAT_SECOND : Word := 16#8206;\n      ERR_FORMAT_NANOSECOND : Word := 16#8207;\n      INITIAL_VALUE {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1970-01-01-00:00:00.0;\n      CONVERT_PRECISION : USInt := 0;\n      CONVERT_FORMAT_TO_DECIMAL : Word := 16#0000;\n      CONVERT_START_POSITION : UInt := 1;\n      CONVERT_START_POSITION_YEAR : SInt := 1;\n      CONVERT_START_POSITION_MONTH : SInt := 6;\n      CONVERT_START_POSITION_DAY : SInt := 9;\n      CONVERT_START_POSITION_HOUR : SInt := 12;\n      CONVERT_START_POSITION_MINUTE : SInt := 15;\n      CONVERT_START_POSITION_SECOND : SInt := 18;\n      CONVERT_START_POSITION_NANOSECOND : SInt := 21;\n      CONVERT_SIZE_YEAR : USInt := 4;\n      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;\n      CONVERT_SIZE_NANOSECOND : USInt := 9;\n      MINIMUM_DATE_STRING_LENGTH : Int := 19;\n      YEAR_MIN : UInt := 1970;\n      YEAR_MAX : UInt := 2262;\n      MONTH_MIN : USInt := 1;\n      MONTH_MAX : USInt := 12;\n      DAY_MIN : USInt := 1;\n      DAY_MAX : USInt := 31;\n      HOUR_MIN : USInt := 0;\n      HOUR_MAX : USInt := 23;\n      SECOND_MINUTE_MIN : USInt := 0;\n      SECOND_MINUTE_MAX : USInt := 59;\n      NANOSECOND_MIN : UDInt := 0;\n      NANOSECOND_MAX : UDInt := 999999999;\n      NANOSECOND_FOR_COUNTER : DInt := 9;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_StringToDTL_ISO\n\t  // Comment/Function: This function converts a character string in international format\n\t  //                   with date components into the data type DTL.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO mechanism is not used, Error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 15.06.2016 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 02.01.2017 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.02 | 17.08.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15 Update 2\n\t  // 01.00.03 | 23.11.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15.1\n\t  // 01.00.04 | 17.07.2019 | Simatic Systems Support\n\t  //                         Reworked from \"LGF_StringToDTL\" to \"LGF_StringToDTL_ISO\"\n\t  //                         Removed format and split into two blocks\n\t  //                         Bugfix - set weekday correctly\n\t  //                         Correction of the weekday of DTL, comments added\n\t  //                         Add ENO handling, adjust comments in interface\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  // 03.01.00 | 31.07.2025 | Simatic Systems Support\n\t  //                         Fix bug - missing error code in case of wrong date string\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION CONVERTER\n\t  IF #date = '' THEN\n\t    #error := TRUE;\n\t    #status := #ERR_DATE_STRING_EMPTY;\n\t    #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t    RETURN;\n\t  ELSIF LEN(#date) < #MINIMUM_DATE_STRING_LENGTH THEN\n\t    #error := TRUE;\n\t    #status := #ERR_DATE_STRING_TO_SHORT;\n\t    #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Set format parameters for input string\n\t  // International ISO 8601\n\t  // DTL  | Y| Y| Y| Y| -| M| M| -| D| D|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS\n\t  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--\n\t  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29\n\t  \n\t  REGION YEAR\n\t    // Separating the input string into components of DTL\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_YEAR, P := #CONVERT_START_POSITION_YEAR);\n\t    // Converting separated String components into DTL values\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.YEAR,\n\t             P      := #CONVERT_START_POSITION);\n\t    // Format check\n\t    IF (#tempDateAndTime.YEAR < #YEAR_MIN) OR (#YEAR_MAX < #tempDateAndTime.YEAR) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_YEAR;\n\t      #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION MONTH\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_MONTH);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.MONTH,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.MONTH < #MONTH_MIN) OR (#MONTH_MAX < #tempDateAndTime.MONTH) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_MONTH;\n\t      #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION DAY\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_DAY);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.DAY,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.DAY < #DAY_MIN) OR (#DAY_MAX < #tempDateAndTime.DAY) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_DAY;\n\t      #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION HOUR\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_HOUR);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.HOUR,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.HOUR < #HOUR_MIN) OR (#HOUR_MAX < #tempDateAndTime.HOUR) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_HOUR;\n\t      #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION MINUTE\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_MINUTE);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.MINUTE,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.MINUTE < #SECOND_MINUTE_MIN) OR (#SECOND_MINUTE_MAX < #tempDateAndTime.MINUTE) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_MINUTE;\n\t      #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION SECOND\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_SECOND);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.SECOND,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.SECOND < #SECOND_MINUTE_MIN) OR (#SECOND_MINUTE_MAX < #tempDateAndTime.SECOND) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_SECOND;\n\t      #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION NANOSECOND\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_NANOSECOND, P := #CONVERT_START_POSITION_NANOSECOND);\n\t    // Replacing of the \"blan\" in the nanosecond string by \"0\"\n\t    // Effect:   xx.1 --> xx.1 AND NOT xx.1 --> xx.000000001\n\t    FOR #tempIndex := 1 TO #NANOSECOND_FOR_COUNTER DO\n\t      IF #tempDateString[#tempIndex] = ' ' THEN\n\t        #tempDateString[#tempIndex] := '0';\n\t      END_IF;\n\t    END_FOR;\n\t    \n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.NANOSECOND,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.NANOSECOND < 0) OR (999999999 < #tempDateAndTime.NANOSECOND) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_NANOSECOND;\n\t      #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  // Correction of the weekday of DTL\n\t  #tempDateAndTime := #tempDateAndTime + t#0ms;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_StringToDTL_ISO := #tempDateAndTime;\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  // no error handling needed because of error bit output\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DTL"}]}
{"title": "StringToDTL", "description": "This function converts a character string in American format (US) with date and time components into the data type DTL.", "type": "FUNCTION", "name": "LGF_StringToDTL_US", "vars": [{"name": "date", "type": "String", "description": "Date as a character string according to the format.\nExample: `01-22-2019 14:07:57.696417000`."}, {"name": "Ret_Val", "type": "DTL", "description": null}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "date", "type": "String", "description": "Date as a character string according to the format.\nExample: `01-22-2019 14:07:57.696417000`."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_StringToDTL_US\" : DTL\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_StringToDTL_US\n   VAR_INPUT \n      \"date\" : String;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempIndex : DInt;\n      tempDateAndTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempDateString : String;\n   END_VAR\n\n   VAR CONSTANT \n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      STATUS_NO_JOB : Word := 16#7000;\n      ERR_DATE_STRING_EMPTY : Word := 16#8400;\n      ERR_DATE_STRING_TO_SHORT : Word := 16#8401;\n      ERR_FORMAT_YEAR : Word := 16#8201;\n      ERR_FORMAT_MONTH : Word := 16#8202;\n      ERR_FORMAT_DAY : Word := 16#8203;\n      ERR_FORMAT_HOUR : Word := 16#8204;\n      ERR_FORMAT_MINUTE : Word := 16#8205;\n      ERR_FORMAT_SECOND : Word := 16#8206;\n      ERR_FORMAT_NANOSECOND : Word := 16#8207;\n      INITIAL_VALUE {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1970-01-01-00:00:00.0;\n      CONVERT_PRECISION : USInt := 0;\n      CONVERT_FORMAT_TO_DECIMAL : Word := 16#0000;\n      CONVERT_START_POSITION : UInt := 1;\n      CONVERT_START_POSITION_YEAR : SInt := 7;\n      CONVERT_START_POSITION_MONTH : SInt := 1;\n      CONVERT_START_POSITION_DAY : SInt := 4;\n      CONVERT_START_POSITION_HOUR : SInt := 12;\n      CONVERT_START_POSITION_MINUTE : SInt := 15;\n      CONVERT_START_POSITION_SECOND : SInt := 18;\n      CONVERT_START_POSITION_NANOSECOND : SInt := 21;\n      CONVERT_SIZE_YEAR : USInt := 4;\n      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;\n      CONVERT_SIZE_NANOSECOND : USInt := 9;\n      MINIMUM_DATE_STRING_LENGTH : Int := 19;\n      YEAR_MIN : UInt := 1970;\n      YEAR_MAX : UInt := 2262;\n      MONTH_MIN : USInt := 1;\n      MONTH_MAX : USInt := 12;\n      DAY_MIN : USInt := 1;\n      DAY_MAX : USInt := 31;\n      HOUR_MIN : USInt := 0;\n      HOUR_MAX : USInt := 23;\n      SECOND_MINUTE_MIN : USInt := 0;\n      SECOND_MINUTE_MAX : USInt := 59;\n      NANOSECOND_MIN : UDInt := 0;\n      NANOSECOND_MAX : UDInt := 999999999;\n      NANOSECOND_FOR_COUNTER : DInt := 9;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_StringToDTL_US\n\t  // Comment/Function: This function converts a character string in American format\n\t  //                   with date components into the data type DTL.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V5.0\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO mechanism is not used, Error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 28.07.2025 | Siemens Industry Online Support\n\t  //                         First released version\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION CONVERTER\n\t  IF #date = '' THEN\n\t    #error := TRUE;\n\t    #status := #ERR_DATE_STRING_EMPTY;\n\t    #LGF_StringToDTL_US := #INITIAL_VALUE;\n\t    RETURN;\n\t  ELSIF LEN(#date) < #MINIMUM_DATE_STRING_LENGTH THEN\n\t    #error := TRUE;\n\t    #status := #ERR_DATE_STRING_TO_SHORT;\n\t    #LGF_StringToDTL_US := #INITIAL_VALUE;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Set format parameters for input string\n\t  // American format\n\t  // DTL  | M| M| -| D| D| -| Y| Y| Y| Y|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS\n\t  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--\n\t  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29\n\t  \n\t  REGION YEAR\n\t    // Separating the input string into components of DTL\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_YEAR, P := #CONVERT_START_POSITION_YEAR);\n\t    // Converting separated String components into DTL values\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.YEAR,\n\t             P      := #CONVERT_START_POSITION);\n\t    // Format check\n\t    IF (#tempDateAndTime.YEAR < #YEAR_MIN) OR (#YEAR_MAX < #tempDateAndTime.YEAR) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_YEAR;\n\t      #LGF_StringToDTL_US := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION MONTH\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_MONTH);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.MONTH,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.MONTH < #MONTH_MIN) OR (#MONTH_MAX < #tempDateAndTime.MONTH) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_MONTH;\n\t      #LGF_StringToDTL_US := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION DAY\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_DAY);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.DAY,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.DAY < #DAY_MIN) OR (#DAY_MAX < #tempDateAndTime.DAY) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_DAY;\n\t      #LGF_StringToDTL_US := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION HOUR\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_HOUR);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.HOUR,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.HOUR < #HOUR_MIN) OR (#HOUR_MAX < #tempDateAndTime.HOUR) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_HOUR;\n\t      #LGF_StringToDTL_US := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION MINUTE\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_MINUTE);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.MINUTE,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.MINUTE < #SECOND_MINUTE_MIN) OR (#SECOND_MINUTE_MAX < #tempDateAndTime.MINUTE) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_MINUTE;\n\t      #LGF_StringToDTL_US := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION SECOND\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_SECOND);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.SECOND,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.SECOND < #SECOND_MINUTE_MIN) OR (#SECOND_MINUTE_MAX < #tempDateAndTime.SECOND) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_SECOND;\n\t      #LGF_StringToDTL_US := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION NANOSECOND\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_NANOSECOND, P := #CONVERT_START_POSITION_NANOSECOND);\n\t    // Replacing of the \"blan\" in the nanosecond string by \"0\"\n\t    // Effect:   xx.1 --> xx.1 AND NOT xx.1 --> xx.000000001\n\t    FOR #tempIndex := 1 TO #NANOSECOND_FOR_COUNTER DO\n\t      IF #tempDateString[#tempIndex] = ' ' THEN\n\t        #tempDateString[#tempIndex] := '0';\n\t      END_IF;\n\t    END_FOR;\n\t    \n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.NANOSECOND,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.NANOSECOND < 0) OR (999999999 < #tempDateAndTime.NANOSECOND) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_NANOSECOND;\n\t      #LGF_StringToDTL_US := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  // Correction of the weekday of DTL\n\t  #tempDateAndTime := #tempDateAndTime + t#0ms;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_StringToDTL_US := #tempDateAndTime;\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  // no error handling needed because of error bit output\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DTL"}]}
{"title": "StringToInt", "description": "This function converts a variable of data type String into a variable of data type DInt.", "type": "FUNCTION", "name": "LGF_StringToInt", "vars": [{"name": "value", "type": "String", "description": "String value to be converted to Double-Integer.\nExample: ‘+16927’"}, {"name": "Ret_Val", "type": "DInt", "description": "Converted Double-Integer value"}], "input": [{"name": "value", "type": "String", "description": "String value to be converted to Double-Integer.\nExample: ‘+16927’"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_StringToInt\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_StringToInt\n   VAR_INPUT \n      value : String;\n   END_VAR\n\n   VAR_TEMP \n      tempDoubleInteger : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      CONVERT_FORMAT_TO_INTEGER : Word := 16#0000;\n      CONVERT_START_POSITION : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_StringToInt\n\t  // Comment/Function: This function converts a string to an integer value\n\t  //                   Vice versa of the LGF_IntToString - wrapper of the system function VAL_STRG.\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      \n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO handling done by STRG_VAL\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.01 | 12.06.2019 | Simatic Systems Support\n\t  //                         First released version\n\t  // 01.00.03 | 30.07.2019 | Simatic Systems Support\n\t  //                         Add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //                         ENO handling done by STRG_VAL system function\n\t  //===============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION CONVERSION\n\t  STRG_VAL(IN     := #value,\n\t           FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t           P      := #CONVERT_START_POSITION,\n\t           OUT    => #tempDoubleInteger);\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  #LGF_StringToInt := #tempDoubleInteger;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DInt"}]}
{"title": "StringToTaddr", "description": "The system data type TADDR_Param contains address information consisting of an IPV4 address and the port number. The LGF_StringToTaddr function converts a variable od data type String to a TADDR_Param system data type variable.", "type": "FUNCTION", "name": "LGF_StringToTaddr", "vars": [{"name": "ipAddressString", "type": "String", "description": "IPV4 address string in the format of `192.168.1.200:55047`\n[Port number including colon `:` is optional]"}, {"name": "Ret_Val", "type": "TADDR_Param", "description": "IP-Address and Port number as `TADDR_Param` data type"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "ipAddressString", "type": "String", "description": "IPV4 address string in the format of `192.168.1.200:55047`\n[Port number including colon `:` is optional]"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_StringToTaddr\" : TADDR_Param\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_StringToTaddr\n   VAR_INPUT \n      ipAddressString : String;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempOctetIndex : Int;\n      tempCharPosition : Int;\n      tempAddressString : String;\n      tempOctetString : String[#MAX_CHAR_FOR_IP_OCTET_NUMBER];\n      tempNumber : UDInt;\n      tempPortNumberIsSpecified : Bool;\n      tempIpAdressTaddr {InstructionName := 'TADDR_Param'; LibVersion := '1.0'} : TADDR_Param;\n   END_VAR\n\n   VAR CONSTANT \n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_OCTET_WRONG_NUMBER_OF_CHAR : Word := 16#8110;\n      ERR_OCTET_STRING_IS_EMPTY : Word := 16#8120;\n      ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS : Word := 16#8130;\n      ERR_PORT_WRONG_NUMBER_OF_CHAR : Word := 16#8150;\n      ERR_PORT_STRING_IS_EMPTY : Word := 16#8151;\n      ERR_PORT_EXCEEDS_MAX_PORT : Word := 16#8152;\n      MAX_IP_ADDRESS_OCTET_NUMBER : USInt := 255;\n      MAX_PORT_NUMBER : UInt := 65535;\n      EMPTY_STRING : Int := 0;\n      MAX_CHAR_FOR_IP_OCTET_NUMBER : Int := 4;\n      MAX_CHAR_FOR_PORT_NUMBER : Int := 5;\n      INIT_VAL : USInt := 0;\n      NUMBER_OF_IP_OCTETS : Int := 4;\n      CHAR_DOT : Char := '.';\n      CHAR_COLON : Char := ':';\n      CONVERT_FORMAT_TO_INTEGER : Word := 16#0000;\n      CONVERT_START_POSITION : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_StringToTaddr\n\t  // Comment/Function: This function converts a string IP Address into TADDR Parameter format.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V14 Update 1\n\t  // Restrictions:     ENO mechanism is not used - Error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 30.01.2017 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 17.08.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15 Update 2\n\t  // 01.00.02 | 23.11.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15.1\n\t  // 01.00.03 | 10.06.2019 | Simatic Systems Support\n\t  //                         Standard header and block parameters update\n\t  // 01.00.04 | 10.07.2019 | Simatic Systems Support\n\t  //                         Code refactoring and performance improvements\n\t  // 01.00.06 | 14.11.2019 | Simatic Systems Support\n\t  //                         Add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization\n\t  #tempAddressString := #ipAddressString;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[1] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[2] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[3] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[4] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_PORT_NR := #INIT_VAL;\n\t  #LGF_StringToTaddr := #tempIpAdressTaddr;\n\tEND_REGION\n\t\n\tREGION Process Address String  \n\t  REGION Process octests 1-4\n\t    FOR #tempOctetIndex := 1 TO #NUMBER_OF_IP_OCTETS BY 1 DO\n\t      // check if loop has not reached the last octet\n\t      IF #tempOctetIndex < #NUMBER_OF_IP_OCTETS THEN\n\t        // search for dot as octet seperator\n\t        // there has to be a dot present between the octets\n\t        #tempCharPosition := FIND(IN1 := #tempAddressString, IN2 := #CHAR_DOT);\n\t        \n\t      ELSE\n\t        // search for colon as port seperator after the last Octet\n\t        #tempCharPosition := FIND(IN1 := #tempAddressString, IN2 := #CHAR_COLON);\n\t        \n\t        // if colon is present, there is a port number specified / check if Port number added\n\t        #tempPortNumberIsSpecified := (#tempCharPosition > 0);\n\t        \n\t        // if no port is spezified, its just the last octet\n\t        IF NOT #tempPortNumberIsSpecified THEN\n\t          // need to set the char position to the end of string + one for later cobesion and checks\n\t          #tempCharPosition := LEN(#tempAddressString) + 1;\n\t        END_IF;\n\t      END_IF;\n\t      \n\t      REGION Octet conversion\n\t        // check if IP Octet contains more then three digits --> Error\n\t        IF #tempCharPosition > #MAX_CHAR_FOR_IP_OCTET_NUMBER THEN\n\t          #error := TRUE;\n\t          #status := #ERR_OCTET_WRONG_NUMBER_OF_CHAR OR INT_TO_WORD(#tempOctetIndex);\n\t          #LGF_StringToTaddr := #tempIpAdressTaddr;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        // extract octet string\n\t        #tempOctetString := LEFT(IN := #tempAddressString, L := #tempCharPosition - 1);\n\t        // Check if Octet string is empty --> Error\n\t        IF LEN(#tempOctetString) = #EMPTY_STRING THEN\n\t          #error := TRUE;\n\t          #status := #ERR_OCTET_STRING_IS_EMPTY OR INT_TO_WORD(#tempOctetIndex);\n\t          #LGF_StringToTaddr := #tempIpAdressTaddr;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        // Convert the octet string to numerical value\n\t        STRG_VAL(IN     := #tempOctetString,\n\t                 FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t                 P      := #CONVERT_START_POSITION,\n\t                 OUT    => #tempNumber);\n\t        \n\t        // check if the octet number exeeds the maximum possible range of 255 of USInt --> Error\n\t        IF #tempNumber > #MAX_IP_ADDRESS_OCTET_NUMBER THEN\n\t          #error := TRUE;\n\t          #status := #ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS OR INT_TO_WORD(#tempOctetIndex);\n\t          #LGF_StringToTaddr := #tempIpAdressTaddr;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        // add address octet to temp address tag\n\t        #tempIpAdressTaddr.REM_IP_ADDR[#tempOctetIndex] := UDINT_TO_USINT(#tempNumber);\n\t        \n\t        // delete octet string from address string\n\t        #tempAddressString := DELETE(IN := #tempAddressString, P := 1, L := #tempCharPosition);\n\t      END_REGION Octet conversion\n\t    END_FOR;\n\t  END_REGION Process octests 1-4\n\t  \n\t  REGION PORT number conversion\n\t    // If the string contains a port number too, parse it\n\t    IF #tempPortNumberIsSpecified THEN\n\t      // lenght of string exceeds length of port string --> Error\n\t      IF LEN(#tempAddressString) > #MAX_CHAR_FOR_PORT_NUMBER THEN\n\t        #error := TRUE;\n\t        #status := #ERR_PORT_WRONG_NUMBER_OF_CHAR;\n\t        #LGF_StringToTaddr := #tempIpAdressTaddr;\n\t        RETURN;\n\t        \n\t        // Check if string is empty --> Error\n\t      ELSIF LEN(#tempAddressString) = #EMPTY_STRING THEN\n\t        #error := TRUE;\n\t        #status := #ERR_PORT_STRING_IS_EMPTY;\n\t        #LGF_StringToTaddr := #tempIpAdressTaddr;\n\t        RETURN;\n\t      END_IF;\n\t      \n\t      // Convert the port number string to numerical value\n\t      STRG_VAL(IN     := #tempAddressString,\n\t               FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t               P      := #CONVERT_START_POSITION,\n\t               OUT    => #tempNumber);\n\t      \n\t      // check if the Port number exeeds the maximum possible range of 65535 of UInt --> Error\n\t      IF #tempNumber > #MAX_PORT_NUMBER THEN\n\t        #error := TRUE;\n\t        #status := #ERR_PORT_EXCEEDS_MAX_PORT;\n\t        #LGF_StringToTaddr := #tempIpAdressTaddr;\n\t        RETURN;\n\t      END_IF;\n\t      \n\t      // add port number to temp address tag\n\t      #tempIpAdressTaddr.REM_PORT_NR := UDINT_TO_UINT(#tempNumber);\n\t    END_IF;\n\t  END_REGION PORT number conversion\n\t  \n\tEND_REGION\n\t\n\tREGION Outputs\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #LGF_StringToTaddr := #tempIpAdressTaddr;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "TADDR_Param"}]}
{"title": "StringToTime", "description": "The function converts a variable of the data type String into a variable of the system data type Time.", "type": "FUNCTION", "name": "LGF_StringToTime", "vars": [{"name": "timeValue", "type": "String", "description": "Time to be converted as string. MUST have SEPARATOR. Example:\n`1D-3H-45M-6S-0MS`"}, {"name": "Ret_Val", "type": "Time", "description": "Converted time valueExample: `T#1D_3H_45M_6S`"}], "input": [{"name": "timeValue", "type": "String", "description": "Time to be converted as string. MUST have SEPARATOR. Example:\n`1D-3H-45M-6S-0MS`"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_StringToTime\" : Time\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_StringToTime\n   VAR_INPUT \n      timeValue : String;\n   END_VAR\n\n   VAR_TEMP \n      tempStringTime : String;\n      tempCharacterPosition : Int;\n      tempTimeNumber : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      MS_PER_DAY : DInt := 86400000;\n      MS_PER_HOUR : DInt := 3600000;\n      MS_PER_MINUTE : DInt := 60000;\n      MS_PER_SECOND : DInt := 1000;\n      DAY_CHAR : Char := 'D';\n      HOUR_CHAR : Char := 'H';\n      MINUTE_CHAR : Char := 'M';\n      SECOND_CHAR : Char := 'S';\n      MILLISECOND_CHAR : String := 'MS';\n      SEPARATOR_ADDITION : Int := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_StringToTime\n\t  // Comment/Function: This function converts a string time value to a time\n\t  //                   input format is the following := '10D20H30M20S630MS',\n\t  //                   just existing parts would be added to the string\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V4.0\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO mechanism is not used, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 02.07.2019 | Simatic Systems Support\n\t  //                         First released version\n\t  // 01.00.01 | 09.07.2019 | Simatic Systems Support\n\t  //                         Further improvements and code optimization \n\t  // 01.00.02 | 30.07.2019 | Simatic Systems Support\n\t  //                         Add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  // 03.01.00 | 17.07.2025 | Simatic Systems Support\n\t  //                         Implemented separator functionality\n\t  //===============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION INITIALISATION\n\t  #tempStringTime := #timeValue;\n\t  #tempTimeNumber := 0;\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t  // determine number of days and add to time number in DInt\n\t    #tempCharacterPosition := FIND(IN1 := #tempStringTime, IN2 := #DAY_CHAR);\n\t  IF (#tempCharacterPosition <> 0) THEN\n\t      #tempTimeNumber += STRING_TO_DINT(LEFT(IN := #tempStringTime, L := #tempCharacterPosition)) * #MS_PER_DAY;\n\t      //Value, character and separator must be deleted from the string\n\t      #tempCharacterPosition := #tempCharacterPosition + #SEPARATOR_ADDITION;\n\t      #tempStringTime := DELETE(IN := #tempStringTime, L := #tempCharacterPosition, P := 1);\n\t  END_IF;\n\t  \n\t  // determine number of hours and add to time number in DInt\n\t  #tempCharacterPosition := FIND(IN1 := #tempStringTime, IN2 := #HOUR_CHAR);\n\t  IF (#tempCharacterPosition <> 0) THEN\n\t      #tempTimeNumber += STRING_TO_DINT(LEFT(IN := #tempStringTime, L := #tempCharacterPosition)) * #MS_PER_HOUR;\n\t      //Value, character and separator must be deleted from the string\n\t      #tempCharacterPosition := #tempCharacterPosition + #SEPARATOR_ADDITION;\n\t      #tempStringTime := DELETE(IN := #tempStringTime, L := #tempCharacterPosition, P := 1);\n\t  END_IF;\n\t    \n\t  // determine number of minutes and add to time number in DInt\n\t  #tempCharacterPosition := FIND(IN1 := #tempStringTime, IN2 := #MINUTE_CHAR);\n\t  IF (#tempCharacterPosition <> 0) THEN\n\t      #tempTimeNumber += STRING_TO_DINT(LEFT(IN := #tempStringTime, L := #tempCharacterPosition)) * #MS_PER_MINUTE;\n\t      //Value, character and separator must be deleted from the string\n\t      #tempCharacterPosition := #tempCharacterPosition + #SEPARATOR_ADDITION;\n\t      #tempStringTime := DELETE(IN := #tempStringTime, L := #tempCharacterPosition, P := 1);\n\t  END_IF;\n\t  \n\t  // determine number of seconds and add to time number in DInt\n\t  #tempCharacterPosition := FIND(IN1 := #tempStringTime, IN2 := #SECOND_CHAR);\n\t  IF (#tempCharacterPosition <> 0) THEN\n\t      #tempTimeNumber += STRING_TO_DINT(LEFT(IN := #tempStringTime, L := #tempCharacterPosition)) * #MS_PER_SECOND;\n\t      //Value, character and separator must be deleted from the string\n\t      #tempCharacterPosition := #tempCharacterPosition + #SEPARATOR_ADDITION;\n\t      #tempStringTime := DELETE(IN := #tempStringTime, L := #tempCharacterPosition, P := 1);\n\t  END_IF;\n\t  \n\t  // determine number of milliseconds and add to time number in DInt\n\t  #tempCharacterPosition := FIND(IN1 := #tempStringTime, IN2 := #MILLISECOND_CHAR);\n\t  IF (#tempCharacterPosition <> 0) THEN\n\t      #tempTimeNumber += STRING_TO_DINT(LEFT(IN := #tempStringTime, L := #tempCharacterPosition));\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  // convert number given in milliseconds from DInt to Time\n\t  #LGF_StringToTime := DINT_TO_TIME(#tempTimeNumber);\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Time"}]}
{"title": "TaddrToString", "description": "The system data type TADDR_Param contains address information consisting of an IPV4 address and the port number. The LGF_TaddrToString function converts a TADDR_Param system data type variable to a String data type variable.", "type": "FUNCTION", "name": "LGF_TaddrToString", "vars": [{"name": "ipAdressTaddr", "type": "TADDR_Param", "description": "IP-Address and Port number to convert into string"}, {"name": "Ret_Val", "type": "String", "description": "IP-Address and Port number as string"}], "input": [{"name": "ipAdressTaddr", "type": "TADDR_Param", "description": "IP-Address and Port number to convert into string"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_TaddrToString\" : String\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_TaddrToString\n   VAR_INPUT \n      ipAdressTaddr {InstructionName := 'TADDR_Param'; LibVersion := '1.0'} : TADDR_Param;\n   END_VAR\n\n   VAR_TEMP \n      tempIpAddressString : String[#MAX_IP_ADDRESS_STRING_LENGHT];\n      tempSpacePosition : Int;\n   END_VAR\n\n   VAR CONSTANT \n      CONVERT_SIZE_OF_IP : USInt := 3;\n      CONVERT_SIZE_OF_PORT : USInt := 5;\n      CONVERT_PREC : USInt := 0;\n      CONVERT_FORMAT_TO_INTEGER : Word := 16#0000;\n      CONVERT_START_POSITION_OCTET_1 : UInt := 1;\n      CONVERT_START_POSITION_OCTET_2 : UInt := 5;\n      CONVERT_START_POSITION_OCTET_3 : UInt := 9;\n      CONVERT_START_POSITION_OCTET_4 : UInt := 13;\n      CONVERT_START_POSITION_PORT : UInt := 17;\n      DOT_POSITION_OCTET_1 : UInt := 4;\n      DOT_POSITION_OCTET_2 : UInt := 8;\n      DOT_POSITION_OCTET_3 : UInt := 12;\n      COLON_POSITION_PORT_ADDRESS : Int := 16;\n      OCTET_1 : UInt := 1;\n      OCTET_2 : UInt := 2;\n      OCTET_3 : UInt := 3;\n      OCTET_4 : UInt := 4;\n      CHAR_DOT : Char := '.';\n      CHAR_COLON : Char := ':';\n      CHAR_BLANK : Char := ' ';\n      MAX_IP_ADDRESS_STRING_LENGHT : DInt := 21;\n      NO_BLANK_SPACE_FOUND : Int := 0;\n      NUMBER_OF_CHAR_TO_DEL : Int := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_TaddrToString\n\t  // Comment/Function: This function converts a TADDR Parameter format into a string IP Address.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V14 Update 1\n\t  // Restrictions:     ENO mechanism is not used, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 19.01.2017 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 17.08.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15 Update 2\n\t  // 01.00.02 | 23.11.2018 | Industry Online Support\n\t  //                         Upgrade: TIA V15.1\n\t  // 01.00.03 | 17.06.2019 | Simatic Systems Support\n\t  //                         Standard header and block parameters update\n\t  // 01.00.04 | 10.07.2019 | Simatic Systems Support\n\t  //                         Refactoring of While to Do/While and constants inserted\n\t  // 01.00.05 | 30.07.2019 | Simatic Systems Support\n\t  //                         Add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization\n\t  #tempIpAddressString := '';\n\tEND_REGION\n\t\n\tREGION Convert octets\n\t  // Convert the first IP-V4 Octet to a string\n\t  VAL_STRG(IN     := #ipAdressTaddr.REM_IP_ADDR[#OCTET_1],\n\t           SIZE   := #CONVERT_SIZE_OF_IP,\n\t           PREC   := #CONVERT_PREC,\n\t           FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t           P      := #CONVERT_START_POSITION_OCTET_1,\n\t           OUT    => #tempIpAddressString);\n\t  \n\t  #tempIpAddressString[#DOT_POSITION_OCTET_1] := #CHAR_DOT;\n\t  \n\t  // Convert the second IP-V4 Octet to a string\n\t  VAL_STRG(IN     := #ipAdressTaddr.REM_IP_ADDR[#OCTET_2],\n\t           SIZE   := #CONVERT_SIZE_OF_IP,\n\t           PREC   := #CONVERT_PREC,\n\t           FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t           P      := #CONVERT_START_POSITION_OCTET_2,\n\t           OUT    => #tempIpAddressString);\n\t  \n\t  #tempIpAddressString[#DOT_POSITION_OCTET_2] := #CHAR_DOT;\n\t  \n\t  // Convert the third IP-V4 Octet to a string\n\t  VAL_STRG(IN     := #ipAdressTaddr.REM_IP_ADDR[#OCTET_3],\n\t           SIZE   := #CONVERT_SIZE_OF_IP,\n\t           PREC   := #CONVERT_PREC,\n\t           FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t           P      := #CONVERT_START_POSITION_OCTET_3,\n\t           OUT    => #tempIpAddressString);\n\t  \n\t  #tempIpAddressString[#DOT_POSITION_OCTET_3] := #CHAR_DOT;\n\t  \n\t  // Convert the fourth IP-V4 Octet to a string\n\t  VAL_STRG(IN     := #ipAdressTaddr.REM_IP_ADDR[#OCTET_4],\n\t           SIZE   := #CONVERT_SIZE_OF_IP,\n\t           PREC   := #CONVERT_PREC,\n\t           FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t           P      := #CONVERT_START_POSITION_OCTET_4,\n\t           OUT    => #tempIpAddressString);\n\tEND_REGION\n\t\n\tREGION Port number\n\t  // If the Port number is specified, copy it to the string following the ':' seperator\n\t  IF #ipAdressTaddr.REM_PORT_NR > 0 THEN\n\t    // add colon as seperator sign\n\t    #tempIpAddressString[#COLON_POSITION_PORT_ADDRESS] := #CHAR_COLON;\n\t    //Convert the port number to string\n\t    VAL_STRG(IN     := #ipAdressTaddr.REM_PORT_NR,\n\t             SIZE   := #CONVERT_SIZE_OF_PORT,\n\t             PREC   := #CONVERT_PREC,\n\t             FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t             P      := #CONVERT_START_POSITION_PORT,\n\t             OUT    => #tempIpAddressString);\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Delete spaces  \n\t  REPEAT // run trough String and delete all spaces\n\t    // search for blank's\n\t    #tempSpacePosition := FIND(IN1 := #tempIpAddressString, IN2 := #CHAR_BLANK);\n\t    // blank found, delet it from string\n\t    IF #tempSpacePosition > #NO_BLANK_SPACE_FOUND THEN\n\t      #tempIpAddressString := DELETE(IN := #tempIpAddressString, L := #NUMBER_OF_CHAR_TO_DEL, P := #tempSpacePosition);\n\t    END_IF;\n\t    // run until no more blanks found in string\n\t  UNTIL #tempSpacePosition <= #NO_BLANK_SPACE_FOUND END_REPEAT;\n\tEND_REGION\n\t\n\tREGION Output\n\t  #LGF_TaddrToString := #tempIpAddressString;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "String"}]}
{"title": "TimeToString", "description": "This function converts a variable of the system data type Time into a variable of the data type String.", "type": "FUNCTION", "name": "LGF_TimeToString", "vars": [{"name": "timeValue", "type": "Time", "description": "Time value to convert\nExample: `T#1D_3H_45M_6S`"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output string"}, {"name": "Ret_Val", "type": "String", "description": "Converted time as string.Example: `1D3H45M6S0MS`"}, {"name": "stringDay", "type": "String", "description": "Converted day as string"}, {"name": "stringHour", "type": "String", "description": "Converted hour as string"}, {"name": "stringMinute", "type": "String", "description": "Converted minute as string"}, {"name": "stringSecond", "type": "String", "description": "Converted second as string"}, {"name": "stringMilliSecond", "type": "String", "description": "Converted millisecond as string"}], "input": [{"name": "timeValue", "type": "Time", "description": "Time value to convert\nExample: `T#1D_3H_45M_6S`"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output string"}], "output": [{"name": "stringDay", "type": "String", "description": "Converted day as string"}, {"name": "stringHour", "type": "String", "description": "Converted hour as string"}, {"name": "stringMinute", "type": "String", "description": "Converted minute as string"}, {"name": "stringSecond", "type": "String", "description": "Converted second as string"}, {"name": "stringMilliSecond", "type": "String", "description": "Converted millisecond as string"}], "in/out": [], "answer": "FUNCTION \"LGF_TimeToString\" : String\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_TimeToString\n   VAR_INPUT \n      timeValue : Time;\n      separator { S7_HiddenAssignment := 'Hide'; S7_PredefinedAssignment := '$'-$''; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : Char;\n   END_VAR\n\n   VAR_OUTPUT \n      stringDay : String;\n      stringHour : String;\n      stringMinute : String;\n      stringSecond : String;\n      stringMilliSecond : String;\n   END_VAR\n\n   VAR_TEMP \n      tempTimeResult : String;\n      tempTimeMilliseconds : DInt;\n      tempDays : DInt;\n      tempHours : DInt;\n      tempMinutes : DInt;\n      tempSecond : DInt;\n      tempMillisecond : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      MS_PER_DAY : DInt := 86400000;\n      MS_PER_HOUR : DInt := 3600000;\n      MS_PER_MINUTE : DInt := 60000;\n      MS_PER_SECOND : DInt := 1000;\n      NUMBER_OF_CHAR_TO_DEL : Int := 1;\n      FIRST_POSITION : Int := 1;\n      NO_REMAINDER : Int := 0;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_TimeToString\n\t  // Comment/Function: This function converts a time value to a string\n\t  //                   When more than one time unit is specified, the value must not exceed 24 days, 23 hours, 59 minutes, 59 seconds or 999 milliseconds.\n\t  //                   Output format is the folowing := '10D20H30M20S630MS', just existing parts would be added to the string\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V4.0\n\t  // Engineering:      TIA Portal V17 \n\t  // Restrictions:     ENO mechanism is not used, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 03.07.2018 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 17.08.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15 Update 2\n\t  // 01.00.02 | 23.11.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15.1\n\t  // 01.00.03 | 02.07.2019 | Simatic Systems Support\n\t  //                         Standard header and block parameters update, status parameter added\n\t  // 01.00.05 | 09.07.2019 | Simatic Systems Support\n\t  //                         Further improvements minimization and commends added\n\t  // 01.00.06 | 30.07.2019 | Simatic Systems Support\n\t  //                         Add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  // 03.01.00 | 17.07.2025 | Simatic Systems Support\n\t  //                         Implemented separator input and functionality\n\t  //===============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION INITIALISATION\n\t  #tempTimeResult := '';\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t    // convert from time to millisecond\n\t    #tempTimeMilliseconds := TIME_TO_DINT(#timeValue);\n\t    \n\t    // calculate the days and remaining hours\n\t    #tempDays := #tempTimeMilliseconds / #MS_PER_DAY;\n\t    #tempTimeMilliseconds := #tempTimeMilliseconds MOD #MS_PER_DAY;\n\t    \n\t    // calculate the hours and remaining minutes\n\t    #tempHours := #tempTimeMilliseconds / #MS_PER_HOUR;\n\t    #tempTimeMilliseconds := #tempTimeMilliseconds MOD #MS_PER_HOUR;\n\t    \n\t    // calculate the minutes and remaining seconds\n\t    #tempMinutes := #tempTimeMilliseconds / #MS_PER_MINUTE;\n\t    #tempTimeMilliseconds := #tempTimeMilliseconds MOD #MS_PER_MINUTE;\n\t    \n\t    // calculate the seconds and remaining milliseconds\n\t    #tempSecond := #tempTimeMilliseconds / #MS_PER_SECOND;\n\t    #tempMillisecond := #tempTimeMilliseconds MOD #MS_PER_SECOND;\n\t    \n\t    // check if value is greater then zero and add to result string without leading \"+\"\n\t    IF (#tempMillisecond > #NO_REMAINDER) THEN\n\t        #stringMilliSecond := DELETE(IN := DINT_TO_STRING(#tempMillisecond), L := #NUMBER_OF_CHAR_TO_DEL, P := #FIRST_POSITION);\n\t        #tempTimeResult := CONCAT(IN1 := #separator, IN2 := #stringMilliSecond, IN3 := 'MS');\n\t    END_IF;\n\t    \n\t    // check if value is greater then zero and add to result string without leading \"+\"\n\t    IF (#tempSecond > #NO_REMAINDER) THEN\n\t        #stringSecond := DELETE(IN := DINT_TO_STRING(#tempSecond), L := #NUMBER_OF_CHAR_TO_DEL, P := #FIRST_POSITION);\n\t        #tempTimeResult := CONCAT(IN1 := #separator, IN2 := #stringSecond, IN3 := 'S', IN4 := #tempTimeResult);\n\t    END_IF;\n\t    \n\t    // check if value is greater then zero and add to result string without leading \"+\"\n\t    IF (#tempMinutes > #NO_REMAINDER) THEN\n\t        #stringMinute := DELETE(IN := DINT_TO_STRING(#tempMinutes), L := #NUMBER_OF_CHAR_TO_DEL, P := #FIRST_POSITION);\n\t        #tempTimeResult := CONCAT(IN1 := #separator, IN2 := #stringMinute, IN3 := 'M', IN4 := #tempTimeResult);\n\t    END_IF;\n\t    \n\t    // check if value is greater then zero and add to result string without leading \"+\"\n\t    IF (#tempHours > #NO_REMAINDER) THEN\n\t        #stringHour := DELETE(IN := DINT_TO_STRING(#tempHours), L := #NUMBER_OF_CHAR_TO_DEL, P := #FIRST_POSITION);\n\t        #tempTimeResult := CONCAT(IN1 := #separator, IN2 := #stringHour, IN3 := 'H', IN4 := #tempTimeResult);\n\t    END_IF;\n\t    \n\t    // check if value is greater then zero and add to result string without leading \"+\"\n\t    IF (#tempDays > #NO_REMAINDER) THEN\n\t        #stringDay := DELETE(IN := DINT_TO_STRING(#tempDays), L := #NUMBER_OF_CHAR_TO_DEL, P := #FIRST_POSITION);\n\t        #tempTimeResult := CONCAT(IN1 := #stringDay, IN2 := 'D', IN3 := #tempTimeResult);\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_TimeToString := #tempTimeResult;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "String"}]}
{"title": "UnixTimeToDTL", "description": "This function converts the Unix time of data type DInt to a date and time of data type DTL. The timestamp is calculated in UTC. This means that the time zone is not considered. Only times after 01/01/1990 are permitted.", "type": "FUNCTION", "name": "LGF_UnixTimeToDTL", "vars": [{"name": "timeUnix", "type": "DInt", "description": "UNIX time to convert"}, {"name": "Ret_Val", "type": "DTL", "description": "Converted time (Date and time).In case of Error: 0 (error = true)"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "timeUnix", "type": "DInt", "description": "UNIX time to convert"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_UnixTimeToDTL\" : DTL\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_UnixTimeToDTL\n   VAR_INPUT \n      timeUnix : DInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempDate : DInt;\n      tempTime : DInt;\n      tempDTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n   END_VAR\n\n   VAR CONSTANT \n      DELTA_1970_1990 : DInt := 631_152_000;\n      SEC_PER_DAY : DInt := 86400;\n      SEC_PER_HOUR : DInt := 3600;\n      SEC_PER_MINUTE : DInt := 60;\n      STATUS_NO_ERRROR : Word := 16#0000;\n      ERR_TIME_BEFORE_1990 : Word := 16#8000;\n      WARN_CONVERSION_LIMIT : Word := 16#6001;\n      CONVERSION_LIMIT {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1990-01-01-00:00:00;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_UnixTimeToDTL\n\t  // Comment/Function: This function converts a Unix time of data type DInt to a date and time of data type DTL.\n\t  //                   The timestamp is calculated in UTC. This means that the time zone is not taken into account.\n\t  //                   Only times after 01/01/1990 are permitted.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15\n\t  // Restrictions:     ENO mechanism is not used, Error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 16.10.2018 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 18.06.2019 | Simatic Systems Support\n\t  //                         Standard header and block parameters update, status parameter added\n\t  // 01.00.02 | 10.07.2019 | Simatic Systems Support\n\t  //                         Commends added and code intention adjusted\n\t  //                         Add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION CONVERT\n\t  // Check if timeUnix less than 01.01.1990\n\t  IF (#timeUnix < #DELTA_1970_1990) THEN\n\t    #LGF_UnixTimeToDTL := #CONVERSION_LIMIT;\n\t    #error := TRUE;\n\t    #status := #ERR_TIME_BEFORE_1990;\n\t    RETURN;\n\t    \n\t    // Check if timeUnix is exactly on lower limitation of 01.01.1990\n\t  ELSIF (#timeUnix = #DELTA_1970_1990) THEN\n\t    #LGF_UnixTimeToDTL := #CONVERSION_LIMIT;\n\t    #error := FALSE;\n\t    #status := #WARN_CONVERSION_LIMIT;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Convert date\n\t  #tempDate := (#timeUnix - #DELTA_1970_1990) / #SEC_PER_DAY;\n\t  #tempDTL := DATE_TO_DTL(DINT_TO_DATE(#tempDate));\n\t  \n\t  // Convert time\n\t  #tempTime := #timeUnix - #DELTA_1970_1990 - (#tempDate * #SEC_PER_DAY);\n\t  #tempDTL.HOUR := DINT_TO_USINT(#tempTime / #SEC_PER_HOUR);\n\t  #tempDTL.MINUTE := DINT_TO_USINT(#tempTime MOD #SEC_PER_HOUR / #SEC_PER_MINUTE);\n\t  #tempDTL.SECOND := DINT_TO_USINT(#tempTime MOD #SEC_PER_MINUTE);\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_UnixTimeToDTL := #tempDTL;\n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERRROR;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DTL"}]}
{"title": "SwapBlockDWord", "description": "Adjusts/ switches the endianness of multibyte data typed values. For this to achieve, a loop will iterate through the array elements and swap the bytes intrinsically.", "type": "FUNCTION", "name": "LGF_SwapBlockDWord", "vars": [{"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "data", "type": "Array[*] of DWord", "description": "Contains the data values, which will be endianness adjusted"}], "input": [], "output": [], "in/out": [{"name": "data", "type": "Array[*] of DWord", "description": "Contains the data values, which will be endianness adjusted"}], "answer": "FUNCTION \"LGF_SwapBlockDWord\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Industry Support'\nFAMILY : LGF\nNAME : LGF_SwapBlockDWord\n   VAR_IN_OUT \n      data : Array[*] of DWord;\n   END_VAR\n\n   VAR_TEMP \n      tempUpperIndex : DInt;\n      tempSwapIndex : DInt;\n      tempSwapValue : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      FIRST_DIMENSION : UDInt := 1;\n      NEXT_ELEMENT : DInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS / (c)Copyright 2025\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_SwapBlockDWord\n\t  // Function:         Adjusts/ switches the endianness of multibyte data typed values.  \n\t  //                   For this to achieve, a loop will iterate through the array elements\n\t  //                   and swap the bytes intrinsically.\n\t  // Library:          LGF\n\t  // Author:           Siemens Industry Support\n\t  // Tested with:      CPU 1214C DC/DC/DC\n\t  // Engineering:      TIA Portal V20\n\t  // Restrictions:     --\n\t  // Requirements:     S7-1200 G2/1500\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 13-10-2021 | Simatic Systems Support| First released version\n\t  // 01.00.01 | 16-07-2025 | Simatic Systems Support| Fixed comments and block info header\n\t  // 01.00.02 | 16-07-2025 | Simatic Systems Support| Fixed bug in loop upper index\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Info\n\t  // We are going to iterate through the provided array swapping the byte order.\n\t  // In this procedure we neither care for the endianness of the original system or the \n\t  // current target system. This allows a universal use of this block.\n\t  \n\t  // Before we can start the iteration, we need to determine at least the lowest index\n\t  // and the highest index in the provided array.\n\t  // The lowest index is required to start with the first provided element.\n\t  // With reaching the highest index we will break the iteration and return from the call\n\t  // All the values inside the array have been swapped.\n\tEND_REGION\n\t\n\tREGION Process\n\t  // First we set the swapIndex to the lowest possible array index. This is where we start\n\t  // the swap procedure.\n\t  #tempSwapIndex := LOWER_BOUND(ARR := #data, DIM := #FIRST_DIMENSION);\n\t  \n\t  // Next is to set a temporary variable to the maximum possible index of the array\n\t  // This we do to avoid continuously calling the systemfunction. This in turn reduces\n\t  // processing overhead and accelerates the processing.\n\t  #tempUpperIndex := UPPER_BOUND(ARR := #data, DIM := #FIRST_DIMENSION);\n\t  \n\t  // Now we can iterate through all the elements and adjust the byte ordering\n\t  WHILE (#tempSwapIndex <= #tempUpperIndex) DO\n\t    // Adjusting the endianness of a multibyte value simply swaps the byte order in the value\n\t    // A multibyte value can be split into their indivdual bytes. Depending on the systems endianess\n\t    // the significance of the bytes is different.\n\t    // At a BigEndian system the significance is highest at the lowest address. The byte order\n\t    // is: LowSignificanceByte HighSignificanceByte\n\t    // With LittleEndian systems the significance is highest at the highest address. The byte order is  \n\t    // reversed to the BigEndian format as: HighSignificanceByte LowSignificanceByte\n\t    \n\t    // to swap the order, we first read the value in question into a temporary variable, before\n\t    // we store it back in reversed byte order.\n\t    \n\t    #tempSwapValue := #data[#tempSwapIndex];\n\t    // We are now swapping the bytes. What was Byte0 becomes Byte3 and vice versa.\n\t    #data[#tempSwapIndex].%B0 := #tempSwapValue.%B3;\n\t    #data[#tempSwapIndex].%B1 := #tempSwapValue.%B2;\n\t    #data[#tempSwapIndex].%B2 := #tempSwapValue.%B1;\n\t    #data[#tempSwapIndex].%B3 := #tempSwapValue.%B0;\n\t    \n\t    // Let's move on to the next value\n\t    #tempSwapIndex += #NEXT_ELEMENT;\n\t  END_WHILE;\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "SwapBlockLWord", "description": "Adjusts/ switches the endianness of multibyte data typed values. For this to achieve, a loop will iterate through the array elements and swap the bytes intrinsically.", "type": "FUNCTION", "name": "LGF_SwapBlockLWord", "vars": [{"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "data", "type": "Array[*] of LWord", "description": "Contains the data values, which will be endianness adjusted"}], "input": [], "output": [], "in/out": [{"name": "data", "type": "Array[*] of LWord", "description": "Contains the data values, which will be endianness adjusted"}], "answer": "FUNCTION \"LGF_SwapBlockLWord\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Industry Support'\nFAMILY : LGF\nNAME : LGF_SwapBlockLWord\n   VAR_IN_OUT \n      data : Array[*] of LWord;\n   END_VAR\n\n   VAR_TEMP \n      tempUpperIndex : DInt;\n      tempSwapIndex : DInt;\n      tempSwapValue : LWord;\n   END_VAR\n\n   VAR CONSTANT \n      FIRST_DIMENSION : UDInt := 1;\n      NEXT_ELEMENT : DInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS / (c)Copyright 2025\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_SwapBlockLWord\n\t  // Function:         Adjusts/ switches the endianness of multibyte data typed values.  \n\t  //                   For this to achieve, a loop will iterate through the array elements\n\t  //                   and swap the bytes intrinsically.\n\t  // Library:          LGF\n\t  // Author:           Siemens Industry Support\n\t  // Tested with:      CPU 1214C DC/DC/DC\n\t  // Engineering:      TIA Portal V20\n\t  // Restrictions:     --\n\t  // Requirements:     S7-1200 G2/1500\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 13-10-2021 | Simatic Systems Support| First released version\n\t  // 01.00.01 | 16-07-2025 | Simatic Systems Support| Fixed comments and block info header\n\t  // 01.00.02 | 16-07-2025 | Simatic Systems Support| Fixed bug in loop upper index\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Info\n\t  // We are going to iterate through the provided array swapping the byte order.\n\t  // In this procedure we neither care for the endianness of the original system or the \n\t  // current target system. This allows a universal use of this block.\n\t  \n\t  // Before we can start the iteration, we need to determine at least the lowest index\n\t  // and the highest index in the provided array.\n\t  // The lowest index is required to start with the first provided element.\n\t  // With reaching the highest index we will break the iteration and return from the call\n\t  // All the values inside the array have been swapped.\n\tEND_REGION\n\t\n\tREGION Process\n\t  // First we set the swapIndex to the lowest possible array index. This is where we start\n\t  // the swap procedure.\n\t  #tempSwapIndex := LOWER_BOUND(ARR := #data, DIM := #FIRST_DIMENSION);\n\t  \n\t  // Next is to set a temporary variable to the maximum possible index of the array\n\t  // This we do to avoid continuously calling the systemfunction. This in turn reduces\n\t  // processing overhead and accelerates the processing.\n\t  #tempUpperIndex := UPPER_BOUND(ARR := #data, DIM := #FIRST_DIMENSION);\n\t  \n\t  // Now we can iterate through all the elements and adjust the byte ordering\n\t  WHILE (#tempSwapIndex <= #tempUpperIndex) DO\n\t    // Adjusting the endianness of a multibyte value simply swaps the byte order in the value\n\t    // A multibyte value can be split into their indivdual bytes. Depending on the systems endianess\n\t    // the significance of the bytes is different.\n\t    // At a BigEndian system the significance is highest at the lowest address. The byte order\n\t    // is: LowSignificanceByte HighSignificanceByte\n\t    // With LittleEndian systems the significance is highest at the highest address. The byte order is  \n\t    // reversed to the BigEndian format as: HighSignificanceByte LowSignificanceByte\n\t    \n\t    // to swap the order, we first read the value in question into a temporary variable, before\n\t    // we store it back in reversed byte order.\n\t    \n\t    #tempSwapValue := #data[#tempSwapIndex];\n\t    // We are now swapping the bytes. What was Byte0 becomes Byte7 and vice versa.\n\t    #data[#tempSwapIndex].%B0 := #tempSwapValue.%B7;\n\t    #data[#tempSwapIndex].%B1 := #tempSwapValue.%B6;\n\t    #data[#tempSwapIndex].%B2 := #tempSwapValue.%B5;\n\t    #data[#tempSwapIndex].%B3 := #tempSwapValue.%B4;\n\t    \n\t    #data[#tempSwapIndex].%B4 := #tempSwapValue.%B3;\n\t    #data[#tempSwapIndex].%B5 := #tempSwapValue.%B2;\n\t    #data[#tempSwapIndex].%B6 := #tempSwapValue.%B1;\n\t    #data[#tempSwapIndex].%B7 := #tempSwapValue.%B0;\n\t    \n\t    // Let's move on to the next value\n\t    #tempSwapIndex += #NEXT_ELEMENT;\n\t  END_WHILE;\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "SwapBlockWord", "description": "Adjusts/ switches the endianness of multibyte data typed values. For this to achieve, a loop will iterate through the array elements and swap the bytes intrinsically.", "type": "FUNCTION", "name": "LGF_SwapBlockWord", "vars": [{"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "data", "type": "Array[*] of Word", "description": "Contains the data values, which will be endianness adjusted"}], "input": [], "output": [], "in/out": [{"name": "data", "type": "Array[*] of Word", "description": "Contains the data values, which will be endianness adjusted"}], "answer": "FUNCTION \"LGF_SwapBlockWord\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Industry Support'\nFAMILY : LGF\nNAME : LGF_SwapBlockWord\n   VAR_IN_OUT \n      data : Array[*] of Word;\n   END_VAR\n\n   VAR_TEMP \n      tempUpperIndex : DInt;\n      tempSwapIndex : DInt;\n      tempSwapValue : Word;\n   END_VAR\n\n   VAR CONSTANT \n      FIRST_DIMENSION : UDInt := 1;\n      NEXT_ELEMENT : DInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS / (c)Copyright 2025\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_SwapBlockWord\n\t  // Function:         Adjusts/ switches the endianness of multibyte data typed values.  \n\t  //                   For this to achieve, a loop will iterate through the array elements\n\t  //                   and swap the bytes intrinsically.\n\t  // Library:          LGF\n\t  // Author:           Siemens Industry Support\n\t  // Tested with:      CPU 1214C DC/DC/DC\n\t  // Engineering:      TIA Portal V20\n\t  // Restrictions:     --\n\t  // Requirements:     S7-1200 G2/1500\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  //----------|------------|-------------------------|------------------------------\n\t  // 01.00.00 | 13-10-2021 | Simatic Systems Support | First released version\n\t  // 01.00.01 | 16-07-2025 | Simatic Systems Support | Fixed comments AND block info header\n\t  // 01.00.02 | 16-07-2025 | Simatic Systems Support | Fixed bug in loop upper index\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Info\n\t  // We are going to iterate through the provided array swapping the byte order.\n\t  // In this procedure we neither care for the endianness of the original system or the \n\t  // current target system. This allows a universal use of this block.\n\t  \n\t  // Before we can start the iteration, we need to determine at least the lowest index\n\t  // and the highest index in the provided array.\n\t  // The lowest index is required to start with the first provided element.\n\t  // With reaching the highest index we will break the iteration and return from the call\n\t  // All the values inside the array have been swapped.\n\tEND_REGION\n\t\n\tREGION Process\n\t  // First we set the swapIndex to the lowest possible array index. This is where we start\n\t  // the swap procedure.\n\t  #tempSwapIndex := LOWER_BOUND(ARR := #data, DIM := #FIRST_DIMENSION);\n\t  \n\t  // Next is to set a temporary variable to the maximum possible index of the array\n\t  // This we do to avoid continuously calling the systemfunction. This in turn reduces\n\t  // processing overhead and accelerates the processing.\n\t  #tempUpperIndex := UPPER_BOUND(ARR := #data, DIM := #FIRST_DIMENSION);\n\t  \n\t  // Now we can iterate through all the elements and adjust the byte ordering\n\t  WHILE (#tempSwapIndex <= #tempUpperIndex) DO\n\t    // Adjusting the endianness of a multibyte value simply swaps the byte order in the value\n\t    // A multibyte value can be split into their indivdual bytes. Depending on the systems endianess\n\t    // the significance of the bytes is different.\n\t    // At a BigEndian system the significance is highest at the lowest address. The byte order\n\t    // is: LowSignificanceByte HighSignificanceByte\n\t    // With LittleEndian systems the significance is highest at the highest address. The byte order is  \n\t    // reversed to the BigEndian format as: HighSignificanceByte LowSignificanceByte\n\t    \n\t    // to swap the order, we first read the value in question into a temporary variable, before\n\t    // we store it back in reversed byte order.\n\t    \n\t    #tempSwapValue := #data[#tempSwapIndex];\n\t    // We are now swapping the bytes. What was Byte0 becomes Byte1 and vice versa.\n\t    #data[#tempSwapIndex].%B0 := #tempSwapValue.%B1;\n\t    #data[#tempSwapIndex].%B1 := #tempSwapValue.%B0;\n\t    \n\t    // Let's move on to the next value\n\t    #tempSwapIndex += #NEXT_ELEMENT;\n\t  END_WHILE;\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "MergeBitsToByte", "description": "This function merge 8 Bits / 8 Boolean variables into one Byte variable.", "type": "FUNCTION", "name": "LGF_MergeBitsToByte", "vars": [{"name": "bit7", "type": "Bool", "description": "Input Bit 7 - MSB"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}, {"name": "Ret_Val", "type": "Byte", "description": "Composite Bit sequence stored as Byte variable"}], "input": [{"name": "bit7", "type": "Bool", "description": "Input Bit 7 - MSB"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_MergeBitsToByte\" : Byte\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_MergeBitsToByte\n   VAR_INPUT \n      bit7 : Bool;\n      bit6 : Bool;\n      bit5 : Bool;\n      bit4 : Bool;\n      bit3 : Bool;\n      bit2 : Bool;\n      bit1 : Bool;\n      bit0 : Bool;\n   END_VAR\n\n   VAR_TEMP \n      tempByte : Byte;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_MergeBitsToByte\n\t  // Comment/Function: This function merge 8 Bits / 8 Boolean variables into one Byte variable.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 / V14SP1\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible.\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION MERGE\n\t  // set the bits by slice access\n\t  #tempByte.%X7 := #bit7;\n\t  #tempByte.%X6 := #bit6;\n\t  #tempByte.%X5 := #bit5;\n\t  #tempByte.%X4 := #bit4;\n\t  #tempByte.%X3 := #bit3;\n\t  #tempByte.%X2 := #bit2;\n\t  #tempByte.%X1 := #bit1;\n\t  #tempByte.%X0 := #bit0;\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  #LGF_MergeBitsToByte := #tempByte;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Byte"}]}
{"title": "MergeBitsToDWord", "description": "This function merge 32 Bits / 32 Boolean variables into one DWord variable.", "type": "FUNCTION", "name": "LGF_MergeBitsToDWord", "vars": [{"name": "bit31", "type": "Bool", "description": "Input Bit 31 - MSB"}, {"name": "bit30", "type": "Bool", "description": "Input Bit 30"}, {"name": "bit29", "type": "Bool", "description": "Input Bit 29"}, {"name": "bit28", "type": "Bool", "description": "Input Bit 28"}, {"name": "bit27", "type": "Bool", "description": "Input Bit 27"}, {"name": "bit26", "type": "Bool", "description": "Input Bit 26"}, {"name": "bit25", "type": "Bool", "description": "Input Bit 25"}, {"name": "bit24", "type": "Bool", "description": "Input Bit 24"}, {"name": "bit23", "type": "Bool", "description": "Input Bit 23"}, {"name": "bit22", "type": "Bool", "description": "Input Bit 22"}, {"name": "bit21", "type": "Bool", "description": "Input Bit 21"}, {"name": "bit20", "type": "Bool", "description": "Input Bit 20"}, {"name": "bit19", "type": "Bool", "description": "Input Bit 19"}, {"name": "bit18", "type": "Bool", "description": "Input Bit 18"}, {"name": "bit17", "type": "Bool", "description": "Input Bit 17"}, {"name": "bit16", "type": "Bool", "description": "Input Bit 16"}, {"name": "bit15", "type": "Bool", "description": "Input Bit 15"}, {"name": "bit14", "type": "Bool", "description": "Input Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Input Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Input Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Input Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Input Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Input Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Input Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Input Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}, {"name": "Ret_Val", "type": "DWord", "description": "Composite Bit sequence stored as DWord variable"}], "input": [{"name": "bit31", "type": "Bool", "description": "Input Bit 31 - MSB"}, {"name": "bit30", "type": "Bool", "description": "Input Bit 30"}, {"name": "bit29", "type": "Bool", "description": "Input Bit 29"}, {"name": "bit28", "type": "Bool", "description": "Input Bit 28"}, {"name": "bit27", "type": "Bool", "description": "Input Bit 27"}, {"name": "bit26", "type": "Bool", "description": "Input Bit 26"}, {"name": "bit25", "type": "Bool", "description": "Input Bit 25"}, {"name": "bit24", "type": "Bool", "description": "Input Bit 24"}, {"name": "bit23", "type": "Bool", "description": "Input Bit 23"}, {"name": "bit22", "type": "Bool", "description": "Input Bit 22"}, {"name": "bit21", "type": "Bool", "description": "Input Bit 21"}, {"name": "bit20", "type": "Bool", "description": "Input Bit 20"}, {"name": "bit19", "type": "Bool", "description": "Input Bit 19"}, {"name": "bit18", "type": "Bool", "description": "Input Bit 18"}, {"name": "bit17", "type": "Bool", "description": "Input Bit 17"}, {"name": "bit16", "type": "Bool", "description": "Input Bit 16"}, {"name": "bit15", "type": "Bool", "description": "Input Bit 15"}, {"name": "bit14", "type": "Bool", "description": "Input Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Input Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Input Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Input Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Input Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Input Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Input Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Input Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_MergeBitsToDWord\" : DWord\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_MergeBitsToDWord\n   VAR_INPUT \n      bit31 : Bool;\n      bit30 : Bool;\n      bit29 : Bool;\n      bit28 : Bool;\n      bit27 : Bool;\n      bit26 : Bool;\n      bit25 : Bool;\n      bit24 : Bool;\n      bit23 : Bool;\n      bit22 : Bool;\n      bit21 : Bool;\n      bit20 : Bool;\n      bit19 : Bool;\n      bit18 : Bool;\n      bit17 : Bool;\n      bit16 : Bool;\n      bit15 : Bool;\n      bit14 : Bool;\n      bit13 : Bool;\n      bit12 : Bool;\n      bit11 : Bool;\n      bit10 : Bool;\n      bit9 : Bool;\n      bit8 : Bool;\n      bit7 : Bool;\n      bit6 : Bool;\n      bit5 : Bool;\n      bit4 : Bool;\n      bit3 : Bool;\n      bit2 : Bool;\n      bit1 : Bool;\n      bit0 : Bool;\n   END_VAR\n\n   VAR_TEMP \n      tempDWord : DWord;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_MergeBitsToDWord\n\t  // Comment/Function: This function merge 32 Bits / 32 Boolean variables into one DWord variable.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 / V14SP1\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible.\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION MERGE\n\t  // set the bits by slice access\n\t  #tempDWord.%X31 := #bit31;\n\t  #tempDWord.%X30 := #bit30;\n\t  #tempDWord.%X29 := #bit29;\n\t  #tempDWord.%X28 := #bit28;\n\t  #tempDWord.%X27 := #bit27;\n\t  #tempDWord.%X26 := #bit26;\n\t  #tempDWord.%X25 := #bit25;\n\t  #tempDWord.%X24 := #bit24;\n\t  #tempDWord.%X23 := #bit23;\n\t  #tempDWord.%X22 := #bit22;\n\t  #tempDWord.%X21 := #bit21;\n\t  #tempDWord.%X20 := #bit20;\n\t  #tempDWord.%X19 := #bit19;\n\t  #tempDWord.%X18 := #bit18;\n\t  #tempDWord.%X17 := #bit17;\n\t  #tempDWord.%X16 := #bit16;\n\t  #tempDWord.%X15 := #bit15;\n\t  #tempDWord.%X14 := #bit14;\n\t  #tempDWord.%X13 := #bit13;\n\t  #tempDWord.%X12 := #bit12;\n\t  #tempDWord.%X11 := #bit11;\n\t  #tempDWord.%X10 := #bit10;\n\t  #tempDWord.%X9 := #bit9;\n\t  #tempDWord.%X8 := #bit8;\n\t  #tempDWord.%X7 := #bit7;\n\t  #tempDWord.%X6 := #bit6;\n\t  #tempDWord.%X5 := #bit5;\n\t  #tempDWord.%X4 := #bit4;\n\t  #tempDWord.%X3 := #bit3;\n\t  #tempDWord.%X2 := #bit2;\n\t  #tempDWord.%X1 := #bit1;\n\t  #tempDWord.%X0 := #bit0;\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  #LGF_MergeBitsToDWord := #tempDWord;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DWord"}]}
{"title": "MergeBitsToWord", "description": "This function merge 16 Bits / 16 Boolean variables into one Word variable.", "type": "FUNCTION", "name": "LGF_MergeBitsToWord", "vars": [{"name": "bit15", "type": "Bool", "description": "Input Bit 15 - MSB"}, {"name": "bit14", "type": "Bool", "description": "Input Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Input Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Input Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Input Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Input Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Input Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Input Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Input Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}, {"name": "Ret_Val", "type": "Word", "description": "Composite Bit sequence stored as Word variable"}], "input": [{"name": "bit15", "type": "Bool", "description": "Input Bit 15 - MSB"}, {"name": "bit14", "type": "Bool", "description": "Input Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Input Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Input Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Input Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Input Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Input Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Input Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Input Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_MergeBitsToWord\" : Word\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_MergeBitsToWord\n   VAR_INPUT \n      bit15 : Bool;\n      bit14 : Bool;\n      bit13 : Bool;\n      bit12 : Bool;\n      bit11 : Bool;\n      bit10 : Bool;\n      bit9 : Bool;\n      bit8 : Bool;\n      bit7 : Bool;\n      bit6 : Bool;\n      bit5 : Bool;\n      bit4 : Bool;\n      bit3 : Bool;\n      bit2 : Bool;\n      bit1 : Bool;\n      bit0 : Bool;\n   END_VAR\n\n   VAR_TEMP \n      tempWord : Word;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_MergeBitsToWord\n\t  // Comment/Function: This function merge 16 Bits / 16 Boolean variables into one Word variable.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 Update 1\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible.\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 09.02.2017 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 17.08.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15 Update 2\n\t  // 01.00.02 | 23.11.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15.1\n\t  // 01.00.03 | 26.07.2019 | Simatic Systems Support\n\t  //                         Standard header, style guide\n\t  // 01.00.04 | 30.07.2019 | Simatic Systems Support\n\t  //                         add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION MERGE\n\t  #tempWord.%X15 := #bit15;\n\t  #tempWord.%X14 := #bit14;\n\t  #tempWord.%X13 := #bit13;\n\t  #tempWord.%X12 := #bit12;\n\t  #tempWord.%X11 := #bit11;\n\t  #tempWord.%X10 := #bit10;\n\t  #tempWord.%X9 := #bit9;\n\t  #tempWord.%X8 := #bit8;\n\t  #tempWord.%X7 := #bit7;\n\t  #tempWord.%X6 := #bit6;\n\t  #tempWord.%X5 := #bit5;\n\t  #tempWord.%X4 := #bit4;\n\t  #tempWord.%X3 := #bit3;\n\t  #tempWord.%X2 := #bit2;\n\t  #tempWord.%X1 := #bit1;\n\t  #tempWord.%X0 := #bit0;\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  #LGF_MergeBitsToWord := #tempWord;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Word"}]}
{"title": "MergeBytesToDWord", "description": "This function merge 4 Byte variables into one DWord variable.", "type": "FUNCTION", "name": "LGF_MergeBytesToDWord", "vars": [{"name": "byte3", "type": "Byte", "description": "Input Byte 3 - MSB"}, {"name": "byte2", "type": "Byte", "description": "Input Byte 2"}, {"name": "byte1", "type": "Byte", "description": "Input Byte 1"}, {"name": "byte0", "type": "Byte", "description": "Input Byte 0 - LSB"}, {"name": "Ret_Val", "type": "DWord", "description": "Composite Byte sequence stored as DWord variable"}], "input": [{"name": "byte3", "type": "Byte", "description": "Input Byte 3 - MSB"}, {"name": "byte2", "type": "Byte", "description": "Input Byte 2"}, {"name": "byte1", "type": "Byte", "description": "Input Byte 1"}, {"name": "byte0", "type": "Byte", "description": "Input Byte 0 - LSB"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_MergeBytesToDWord\" : DWord\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_MergeBytesToDWord\n   VAR_INPUT \n      byte3 : Byte;\n      byte2 : Byte;\n      byte1 : Byte;\n      byte0 : Byte;\n   END_VAR\n\n   VAR_TEMP \n      tempDWord : DWord;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_MergeBytesToDWord\n\t  // Comment/Function: This function merge 4 Byte variables into one DWord variable.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 / V14SP1\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible.\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION MERGE\n\t  // set the bytes by slice access\n\t  #tempDWord.%B3 := #byte3;\n\t  #tempDWord.%B2 := #byte2;\n\t  #tempDWord.%B1 := #byte1;\n\t  #tempDWord.%B0 := #byte0;\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  #LGF_MergeBytesToDWord := #tempDWord;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DWord"}]}
{"title": "MergeBytesToWord", "description": "This function merge 2 Byte variables into one Word variable.", "type": "FUNCTION", "name": "LGF_MergeBytesToWord", "vars": [{"name": "byte1", "type": "Byte", "description": "Input Byte 1 - MSB"}, {"name": "byte0", "type": "Byte", "description": "Input Byte 0 - LSB"}, {"name": "Ret_Val", "type": "Word", "description": "Composite Byte sequence stored as Word variable"}], "input": [{"name": "byte1", "type": "Byte", "description": "Input Byte 1 - MSB"}, {"name": "byte0", "type": "Byte", "description": "Input Byte 0 - LSB"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_MergeBytesToWord\" : Word\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_MergeBytesToWord\n   VAR_INPUT \n      byte1 : Byte;\n      byte0 : Byte;\n   END_VAR\n\n   VAR_TEMP \n      tempWord : Word;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_MergeBytesToWord\n\t  // Comment/Function: This function merge 2 Byte variables into one Word variable.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 / V14SP1\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible.\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION MERGE\n\t  // set the bytes by slice access\n\t  #tempWord.%B1 := #byte1;\n\t  #tempWord.%B0 := #byte0;\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  #LGF_MergeBytesToWord := #tempWord;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Word"}]}
{"title": "MergeWordsToDWord", "description": "This function merge 2 Word variables into one DWord variable.", "type": "FUNCTION", "name": "LGF_MergeWordsToDWord", "vars": [{"name": "word1", "type": "Word", "description": "Input Word 1 - MSB"}, {"name": "word0", "type": "Word", "description": "Input Word 0 - LSB"}, {"name": "Ret_Val", "type": "DWord", "description": "Composite Word sequence stored as DWord variable"}], "input": [{"name": "word1", "type": "Word", "description": "Input Word 1 - MSB"}, {"name": "word0", "type": "Word", "description": "Input Word 0 - LSB"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_MergeWordsToDWord\" : DWord\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_BitLogicOperations\n   VAR_INPUT \n      word1 : Word;\n      word0 : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempDWord : DWord;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_MergeWordsToDWord\n\t  // Comment/Function: This function merge 2 Word variables into one DWord variable.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 / V14SP1\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible.\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION MERGE\n\t  // set the words by slice access\n\t  #tempDWord.%W1 := #word1;\n\t  #tempDWord.%W0 := #word0;\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  #LGF_MergeWordsToDWord := #tempDWord;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DWord"}]}
{"title": "SplitByteToBits", "description": "This function splits a Byte variable into 8 Boolean / 8 Bit variables.", "type": "FUNCTION", "name": "LGF_SplitByteToBits", "vars": [{"name": "byte", "type": "Byte", "description": "Bit sequence to be split"}, {"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "bit7", "type": "Bool", "description": "Output Bit 7 - MSB"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "input": [{"name": "byte", "type": "Byte", "description": "Bit sequence to be split"}], "output": [{"name": "bit7", "type": "Bool", "description": "Output Bit 7 - MSB"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "answer": "FUNCTION \"LGF_SplitByteToBits\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_SplitByteToBits\n   VAR_INPUT \n      \"byte\" : Byte;\n   END_VAR\n\n   VAR_OUTPUT \n      bit7 : Bool;\n      bit6 : Bool;\n      bit5 : Bool;\n      bit4 : Bool;\n      bit3 : Bool;\n      bit2 : Bool;\n      bit1 : Bool;\n      bit0 : Bool;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_SplitByteToBits\n\t  // Comment/Function: This function splits a Byte variable into 8 Boolean / 8 Bit variables\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 / V14SP1\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible.\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  // get the bits by slice access\n\t  #bit7 := #byte.%X7;\n\t  #bit6 := #byte.%X6;\n\t  #bit5 := #byte.%X5;\n\t  #bit4 := #byte.%X4;\n\t  #bit3 := #byte.%X3;\n\t  #bit2 := #byte.%X2;\n\t  #bit1 := #byte.%X1;\n\t  #bit0 := #byte.%X0;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "SplitDWordToBits", "description": "This function splits a DWord variable into 32 Boolean / 32 Bit variables.", "type": "FUNCTION", "name": "LGF_SplitDWordToBits", "vars": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}, {"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "bit31", "type": "Bool", "description": "Output Bit 31 - MSB"}, {"name": "bit30", "type": "Bool", "description": "Output Bit 30"}, {"name": "bit29", "type": "Bool", "description": "Output Bit 29"}, {"name": "bit28", "type": "Bool", "description": "Output Bit 28"}, {"name": "bit27", "type": "Bool", "description": "Output Bit 27"}, {"name": "bit26", "type": "Bool", "description": "Output Bit 26"}, {"name": "bit25", "type": "Bool", "description": "Output Bit 25"}, {"name": "bit24", "type": "Bool", "description": "Output Bit 24"}, {"name": "bit23", "type": "Bool", "description": "Output Bit 23"}, {"name": "bit22", "type": "Bool", "description": "Output Bit 22"}, {"name": "bit21", "type": "Bool", "description": "Output Bit 21"}, {"name": "bit20", "type": "Bool", "description": "Output Bit 20"}, {"name": "bit19", "type": "Bool", "description": "Output Bit 19"}, {"name": "bit18", "type": "Bool", "description": "Output Bit 18"}, {"name": "bit17", "type": "Bool", "description": "Output Bit 17"}, {"name": "bit16", "type": "Bool", "description": "Output Bit 16"}, {"name": "bit15", "type": "Bool", "description": "Output Bit 15"}, {"name": "bit14", "type": "Bool", "description": "Output Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Output Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Output Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Output Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Output Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Output Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Output Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Output Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "input": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}], "output": [{"name": "bit31", "type": "Bool", "description": "Output Bit 31 - MSB"}, {"name": "bit30", "type": "Bool", "description": "Output Bit 30"}, {"name": "bit29", "type": "Bool", "description": "Output Bit 29"}, {"name": "bit28", "type": "Bool", "description": "Output Bit 28"}, {"name": "bit27", "type": "Bool", "description": "Output Bit 27"}, {"name": "bit26", "type": "Bool", "description": "Output Bit 26"}, {"name": "bit25", "type": "Bool", "description": "Output Bit 25"}, {"name": "bit24", "type": "Bool", "description": "Output Bit 24"}, {"name": "bit23", "type": "Bool", "description": "Output Bit 23"}, {"name": "bit22", "type": "Bool", "description": "Output Bit 22"}, {"name": "bit21", "type": "Bool", "description": "Output Bit 21"}, {"name": "bit20", "type": "Bool", "description": "Output Bit 20"}, {"name": "bit19", "type": "Bool", "description": "Output Bit 19"}, {"name": "bit18", "type": "Bool", "description": "Output Bit 18"}, {"name": "bit17", "type": "Bool", "description": "Output Bit 17"}, {"name": "bit16", "type": "Bool", "description": "Output Bit 16"}, {"name": "bit15", "type": "Bool", "description": "Output Bit 15"}, {"name": "bit14", "type": "Bool", "description": "Output Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Output Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Output Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Output Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Output Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Output Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Output Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Output Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "answer": "FUNCTION \"LGF_SplitDWordToBits\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_SplitDWordToBits\n   VAR_INPUT \n      doubleWord : DWord;\n   END_VAR\n\n   VAR_OUTPUT \n      bit31 : Bool;\n      bit30 : Bool;\n      bit29 : Bool;\n      bit28 : Bool;\n      bit27 : Bool;\n      bit26 : Bool;\n      bit25 : Bool;\n      bit24 : Bool;\n      bit23 : Bool;\n      bit22 : Bool;\n      bit21 : Bool;\n      bit20 : Bool;\n      bit19 : Bool;\n      bit18 : Bool;\n      bit17 : Bool;\n      bit16 : Bool;\n      bit15 : Bool;\n      bit14 : Bool;\n      bit13 : Bool;\n      bit12 : Bool;\n      bit11 : Bool;\n      bit10 : Bool;\n      bit9 : Bool;\n      bit8 : Bool;\n      bit7 : Bool;\n      bit6 : Bool;\n      bit5 : Bool;\n      bit4 : Bool;\n      bit3 : Bool;\n      bit2 : Bool;\n      bit1 : Bool;\n      bit0 : Bool;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_SplitDWordToBits\n\t  // Comment/Function: This function splits a DWord variable into 32 Boolean / 32 Bit variables\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 / V14SP1\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible.\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  // get the bits by slice access\n\t  #bit31 := #doubleWord.%X31;\n\t  #bit30 := #doubleWord.%X30;\n\t  #bit29 := #doubleWord.%X29;\n\t  #bit28 := #doubleWord.%X28;\n\t  #bit27 := #doubleWord.%X27;\n\t  #bit26 := #doubleWord.%X26;\n\t  #bit25 := #doubleWord.%X25;\n\t  #bit24 := #doubleWord.%X24;\n\t  #bit23 := #doubleWord.%X23;\n\t  #bit22 := #doubleWord.%X22;\n\t  #bit21 := #doubleWord.%X21;\n\t  #bit20 := #doubleWord.%X20;\n\t  #bit19 := #doubleWord.%X19;\n\t  #bit18 := #doubleWord.%X18;\n\t  #bit17 := #doubleWord.%X17;\n\t  #bit16 := #doubleWord.%X16;\n\t  #bit15 := #doubleWord.%X15;\n\t  #bit14 := #doubleWord.%X14;\n\t  #bit13 := #doubleWord.%X13;\n\t  #bit12 := #doubleWord.%X12;\n\t  #bit11 := #doubleWord.%X11;\n\t  #bit10 := #doubleWord.%X10;\n\t  #bit9 := #doubleWord.%X9;\n\t  #bit8 := #doubleWord.%X8;\n\t  #bit7 := #doubleWord.%X7;\n\t  #bit6 := #doubleWord.%X6;\n\t  #bit5 := #doubleWord.%X5;\n\t  #bit4 := #doubleWord.%X4;\n\t  #bit3 := #doubleWord.%X3;\n\t  #bit2 := #doubleWord.%X2;\n\t  #bit1 := #doubleWord.%X1;\n\t  #bit0 := #doubleWord.%X0;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "SplitDWordToBytes", "description": "This function splits a DWord variable into 4 Byte variables.", "type": "FUNCTION", "name": "LGF_SplitDWordToBytes", "vars": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}, {"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "byte3", "type": "Byte", "description": "Output Byte 3 - MSB"}, {"name": "byte2", "type": "Byte", "description": "Output Byte 2"}, {"name": "byte1", "type": "Byte", "description": "Output Byte 1"}, {"name": "byte0", "type": "Byte", "description": "Output Byte 0 - LSB"}], "input": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}], "output": [{"name": "byte3", "type": "Byte", "description": "Output Byte 3 - MSB"}, {"name": "byte2", "type": "Byte", "description": "Output Byte 2"}, {"name": "byte1", "type": "Byte", "description": "Output Byte 1"}, {"name": "byte0", "type": "Byte", "description": "Output Byte 0 - LSB"}], "in/out": [], "answer": "FUNCTION \"LGF_SplitDWordToBytes\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_SplitDWordToBytes\n   VAR_INPUT \n      doubleWord : DWord;\n   END_VAR\n\n   VAR_OUTPUT \n      byte3 : Byte;\n      byte2 : Byte;\n      byte1 : Byte;\n      byte0 : Byte;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_SplitDWordToBytes\n\t  // Comment/Function: This function splits a DWord variable into 4 Byte variables.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 / V14SP1\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible.\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  // get the bytes by slice access\n\t  #byte3 := #doubleWord.%B3;\n\t  #byte2 := #doubleWord.%B2;\n\t  #byte1 := #doubleWord.%B1;\n\t  #byte0 := #doubleWord.%B0;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "SplitDWordToWords", "description": "This function splits a DWord variable into 2 Word variables.", "type": "FUNCTION", "name": "LGF_SplitDWordToWords", "vars": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}, {"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "word1", "type": "Word", "description": "Output Word 1 - MSW"}, {"name": "word0", "type": "Word", "description": "Output Word 0 - LSW"}], "input": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}], "output": [{"name": "word1", "type": "Word", "description": "Output Word 1 - MSW"}, {"name": "word0", "type": "Word", "description": "Output Word 0 - LSW"}], "in/out": [], "answer": "FUNCTION \"LGF_SplitDWordToWords\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_SplitDWordToWords\n   VAR_INPUT \n      doubleWord : DWord;\n   END_VAR\n\n   VAR_OUTPUT \n      word1 : Word;\n      word0 : Word;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_SplitDWordToWords\n\t  // Comment/Function: This function splits a DWord variable into 2 Word variables.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 / V14SP1\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible.\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  // get the bytes by slice access\n\t  #word1 := #doubleWord.%W1;\n\t  #word0 := #doubleWord.%W0;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "SplitWordToBits", "description": "This function splits a Word variable into 16 Boolean / 16 Bit variables.", "type": "FUNCTION", "name": "LGF_SplitWordToBits", "vars": [{"name": "word", "type": "Word", "description": "Bit sequence to be split"}, {"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "bit15", "type": "Bool", "description": "Output Bit 15 - MSB"}, {"name": "bit14", "type": "Bool", "description": "Output Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Output Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Output Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Output Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Output Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Output Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Output Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Output Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "input": [{"name": "word", "type": "Word", "description": "Bit sequence to be split"}], "output": [{"name": "bit15", "type": "Bool", "description": "Output Bit 15 - MSB"}, {"name": "bit14", "type": "Bool", "description": "Output Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Output Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Output Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Output Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Output Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Output Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Output Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Output Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "answer": "FUNCTION \"LGF_SplitWordToBits\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_SplitWordToBits\n   VAR_INPUT \n      \"word\" : Word;\n   END_VAR\n\n   VAR_OUTPUT \n      bit15 : Bool;\n      bit14 : Bool;\n      bit13 : Bool;\n      bit12 : Bool;\n      bit11 : Bool;\n      bit10 : Bool;\n      bit9 : Bool;\n      bit8 : Bool;\n      bit7 : Bool;\n      bit6 : Bool;\n      bit5 : Bool;\n      bit4 : Bool;\n      bit3 : Bool;\n      bit2 : Bool;\n      bit1 : Bool;\n      bit0 : Bool;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_SplitWordToBits\n\t  // Comment/Function: This function splits a Word variable into 16 Boolean / 16 Bit variables.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 Update 1\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible.\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 09.02.2017 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 17.08.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15 Update 2\n\t  // 01.00.02 | 23.11.2018 | Industry Online Support\n\t  //                         Upgrade: TIA V15.1\n\t  // 01.00.03 | 26.07.2019 | Simatic Systems Support\n\t  //                         Standard header, style guide\n\t  // 01.00.04 | 30.07.2019 | Simatic Systems Support\n\t  //                         add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  #bit15 := #word.%X15;\n\t  #bit14 := #word.%X14;\n\t  #bit13 := #word.%X13;\n\t  #bit12 := #word.%X12;\n\t  #bit11 := #word.%X11;\n\t  #bit10 := #word.%X10;\n\t  #bit9 := #word.%X9;\n\t  #bit8 := #word.%X8;\n\t  #bit7 := #word.%X7;\n\t  #bit6 := #word.%X6;\n\t  #bit5 := #word.%X5;\n\t  #bit4 := #word.%X4;\n\t  #bit3 := #word.%X3;\n\t  #bit2 := #word.%X2;\n\t  #bit1 := #word.%X1;\n\t  #bit0 := #word.%X0;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "SplitWordToBytes", "description": "This function splits a Word variable into 2 Byte variables.", "type": "FUNCTION", "name": "LGF_SplitWordToBytes", "vars": [{"name": "word", "type": "Word", "description": "Bit sequence to be split"}, {"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "byte1", "type": "Byte", "description": "Output Byte 1 - MSB"}, {"name": "byte0", "type": "Byte", "description": "Output Byte 0 - LSB"}], "input": [{"name": "word", "type": "Word", "description": "Bit sequence to be split"}], "output": [{"name": "byte1", "type": "Byte", "description": "Output Byte 1 - MSB"}, {"name": "byte0", "type": "Byte", "description": "Output Byte 0 - LSB"}], "in/out": [], "answer": "FUNCTION \"LGF_SplitWordToBytes\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_SplitWordToBytes\n   VAR_INPUT \n      \"word\" : Word;\n   END_VAR\n\n   VAR_OUTPUT \n      byte1 : Byte;\n      byte0 : Byte;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_SplitWordToBytes\n\t  // Comment/Function: This function splits a Word variable into 2 Byte variables.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 / V14SP1\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible.\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  // get the bytes by slice access\n\t  #byte1 := #word.%B1;\n\t  #byte0 := #word.%B0;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "ExtractStringFromCharArray", "description": "The function extracts a String specified by a text before and after from an array of characters.", "type": "FUNCTION", "name": "LGF_ExtractStringFromCharArray", "vars": [{"name": "textBefore", "type": "String", "description": "Text in front of the characters which has to be extracted"}, {"name": "textAfter", "type": "String", "description": "Text behind the characters which has to be extracted"}, {"name": "Ret_Val", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "extractedString", "type": "String", "description": "Extracted string"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "input": [{"name": "textBefore", "type": "String", "description": "Text in front of the characters which has to be extracted"}, {"name": "textAfter", "type": "String", "description": "Text behind the characters which has to be extracted"}], "output": [{"name": "extractedString", "type": "String", "description": "Extracted string"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "answer": "FUNCTION \"LGF_ExtractStringFromCharArray\" : Word\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Online Support'\nFAMILY : LGF\nNAME : LGF_ExtractStringFromCharArray\n   VAR_INPUT \n      textBefore : String;\n      textAfter : String;\n   END_VAR\n\n   VAR_OUTPUT \n      extractedString : String;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      searchIn : Variant;\n   END_VAR\n\n   VAR_TEMP \n      tempNumElements : UDInt;\n      tempPosInArray : DInt;\n      tempLenTextBefore : Int;\n      tempPosTextBefore : DInt;\n      tempLenTextAfter : Int;\n      tempPosTextAfter : Int;\n      tempString : String;\n   END_VAR\n\n   VAR CONSTANT \n      LEN_STRING : UInt := 254;\n      STATUS_TEXT_FOUND : Word := 16#0000;\n      WARNING_ONLY_START : Word := 16#9001;\n      WARNING_NOTHING_FOUND : Word := 16#9002;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS / (c)Copyright 2021\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ExtractStringFromCharArray\n\t  // Function:         The function extracts a String specified by a text before and after\n\t  //                   from an array of characters.\n\t  // Library:          LGF\n\t  // Author:           Siemens Industry Online Support\n\t  // Tested with:      CPU 1516-3 PN/DP\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     --\n\t  // Requirements:     S7-1200/1500\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 01.04.2019 | Siemens Online Support | First released version (LHttp)\n\t  // 01.01.00 | 10.06.2022 | Siemens Online Support | Adaption and integration into LGF\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Initialization\n\t  #tempPosTextBefore := 0;\n\t  #tempPosTextAfter := 0;\n\t  #tempPosInArray := 0;\n\t  #tempLenTextBefore := LEN(#textBefore);\n\t  #tempLenTextAfter := LEN(#textAfter);\n\t  #extractedString := '';\n\t  #status := #STATUS_NO_ERROR;\n\t  #LGF_ExtractStringFromCharArray := #WARNING_NOTHING_FOUND;\n\t  \n\t  REGION Validation of inputs\n\t    // check whether the input is an ARRAY and TYPE of elements is CHAR or BYTE\n\t    // IF so, the number OF the ARRAY elements is read out.\n\t    // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t    IF TRUE\n\t      AND IS_ARRAY(#searchIn)\n\t      AND ((TypeOfElements(#searchIn) = Char) OR (TypeOfElements(#searchIn) = Byte))\n\t    THEN\n\t      // Get number of elements\n\t      #tempNumElements := CountOfElements(#searchIn);\n\t    ELSE\n\t      #status := #ERR_NO_ARRAY;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION Validation of inputs\n\tEND_REGION Initialization\n\t\n\tREGION Process\n\t  REPEAT // Search for text before until something was found\n\t    // Convert Chars to String\n\t    Chars_TO_Strg(Chars  := #searchIn,\n\t                  pChars := #tempPosInArray, // Subtract offset since pChars is zero based\n\t                  Cnt    := UDINT_TO_UINT(MIN(IN1 := #LEN_STRING, IN2 := #tempNumElements)),\n\t                  Strg   => #tempString);\n\t    \n\t    // Search for text before\n\t    #tempPosTextBefore := FIND(IN1 := #tempString, IN2 := #textBefore);\n\t    \n\t    // Text before was found\n\t    IF #tempPosTextBefore > 0 THEN\n\t      // Set position in array to end of text before\n\t      #tempPosInArray += #tempPosTextBefore + #tempLenTextBefore - 1;\n\t      \n\t      // Create new string from end of text before\n\t      Chars_TO_Strg(Chars  := #searchIn,\n\t                    pChars := #tempPosInArray, // Subtract offset since pChars is zero based\n\t                    Cnt    := UDINT_TO_UINT(MIN(IN1 := #LEN_STRING, IN2 := #tempNumElements)),\n\t                    Strg   => #tempString);\n\t      \n\t      // Find end of string to be extracted\n\t      #tempPosTextAfter := FIND(IN1 := #tempString, IN2 := #textAfter);\n\t      \n\t      IF #tempPosTextAfter > 0 THEN // Shorten string if text after was found\n\t        #extractedString := LEFT(IN := #tempString, L := #tempPosTextAfter - 1);\n\t        #LGF_ExtractStringFromCharArray := #STATUS_TEXT_FOUND;\n\t        EXIT;\n\t        \n\t      ELSE // Output whole string if text after was not found\n\t        #extractedString := #tempString;\n\t        #LGF_ExtractStringFromCharArray := #WARNING_ONLY_START;\n\t        EXIT;\n\t      END_IF;\n\t      \n\t    ELSE\n\t      // Otherwise continue search in next string minus length of text before to ensure\n\t      // keywords are not broken up at the end of a string and thus missed\n\t      #tempPosInArray += UINT_TO_INT(#LEN_STRING) - #tempLenTextBefore;\n\t    END_IF;\n\t    \n\t    // Repeat until end of array is reached\n\t  UNTIL (#tempPosInArray > #tempNumElements) END_REPEAT;\n\tEND_REGION Process\n\t\nEND_FUNCTION", "return_value": [{"type": "Word"}]}
{"title": "ExtractStringFromCharArrayAdv", "description": "The function extracts a String specified by a text before and after from an array of characters with extended options.", "type": "FUNCTION", "name": "LGF_ExtractStringFromCharArrayAdv", "vars": [{"name": "textBefore", "type": "String", "description": "Text in front of the characters which has to be extracted"}, {"name": "textAfter", "type": "String", "description": "Text behind the characters which has to be extracted"}, {"name": "includeBeforeAfter", "type": "Bool", "description": "TRUE: `textBefore` and `textAfter` are included in the extracted\nstring"}, {"name": "startPos", "type": "DInt", "description": "Position within the array to start search from (index zero based)"}, {"name": "Ret_Val", "type": "Word", "description": "Return value: 16#0000-16#7FFF: Status of the FB16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "extractedString", "type": "String", "description": "Extracted string"}, {"name": "position", "type": "DInt", "description": "Position (index) within the array where text begins (index zero based)"}, {"name": "length", "type": "Int", "description": "Length of text that was extracted"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "input": [{"name": "textBefore", "type": "String", "description": "Text in front of the characters which has to be extracted"}, {"name": "textAfter", "type": "String", "description": "Text behind the characters which has to be extracted"}, {"name": "includeBeforeAfter", "type": "Bool", "description": "TRUE: `textBefore` and `textAfter` are included in the extracted\nstring"}, {"name": "startPos", "type": "DInt", "description": "Position within the array to start search from (index zero based)"}], "output": [{"name": "extractedString", "type": "String", "description": "Extracted string"}, {"name": "position", "type": "DInt", "description": "Position (index) within the array where text begins (index zero based)"}, {"name": "length", "type": "Int", "description": "Length of text that was extracted"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "answer": "FUNCTION \"LGF_ExtractStringFromCharArrayAdv\" : Word\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Online Support'\nFAMILY : LGF\nNAME : LGF_ExtractStringFromCharArrayAdv\n   VAR_INPUT \n      textBefore : String;\n      textAfter : String;\n      includeBeforeAfter { S7_PredefinedAssignment := 'FALSE'} : Bool;\n      startPos { S7_PredefinedAssignment := '0'} : DInt;\n   END_VAR\n\n   VAR_OUTPUT \n      extractedString : String;\n      position : DInt;\n      length { S7_PredefinedAssignment := 'x'} : Int;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      searchIn : Variant;\n   END_VAR\n\n   VAR_TEMP \n      tempNumElements : UDInt;\n      tempPosInArray : DInt;\n      tempLenTextBefore : Int;\n      tempPosTextBefore : DInt;\n      tempLenTextAfter : Int;\n      tempPosTextAfter : Int;\n      tempString : String;\n   END_VAR\n\n   VAR CONSTANT \n      LEN_STRING : UInt := 254;\n      STATUS_TEXT_FOUND : Word := 16#0000;\n      WARNING_ONLY_START : Word := 16#9001;\n      WARNING_NOTHING_FOUND : Word := 16#9002;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS / (c)Copyright 2021\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ExtractStringFromCharArrayAdv\n\t  // Function:         Extracts a String specified by a text before and after\n\t  //                   from an array of characters with extended options.\n\t  // Library:          LGF\n\t  // Author:           Siemens Industry Online Support\n\t  // Tested with:      CPU 1516-3 PN/DP\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     --\n\t  // Requirements:     S7-1200/1500\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 01.04.2019 | Siemens Online Support | First released version (LHttp)\n\t  // 01.01.00 | 10.06.2022 | Siemens Online Support | Adaption and integration into LGF\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Initialization\n\t  #tempPosTextBefore := 0;\n\t  #tempPosTextAfter := 0;\n\t  #tempPosInArray := #startPos;\n\t  #tempLenTextBefore := LEN(#textBefore);\n\t  #tempLenTextAfter := LEN(#textAfter);\n\t  #position := -1;\n\t  #length := 0;\n\t  #extractedString := '';\n\t  #status := #STATUS_NO_ERROR;\n\t  #LGF_ExtractStringFromCharArrayAdv := #WARNING_NOTHING_FOUND;\n\t  \n\t  REGION Validation of inputs\n\t    // check whether the input is an ARRAY and TYPE of elements is CHAR or BYTE\n\t    // IF so, the number OF the ARRAY elements is read out.\n\t    // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t    IF TRUE\n\t      AND IS_ARRAY(#searchIn)\n\t      AND ((TypeOfElements(#searchIn) = Char) OR (TypeOfElements(#searchIn) = Byte))\n\t    THEN\n\t      // Get number of elements\n\t      #tempNumElements := CountOfElements(#searchIn);\n\t    ELSE\n\t      #status := #ERR_NO_ARRAY;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION Validation of inputs\n\tEND_REGION Initialization\n\t\n\tREGION Process  \n\t  REPEAT // Search for text before until something was found\n\t    // Convert Chars to String\n\t    Chars_TO_Strg(Chars  := #searchIn,\n\t                  pChars := #tempPosInArray, // Subtract offset since pChars is zero based\n\t                  Cnt    := UDINT_TO_UINT(MIN(IN1 := #LEN_STRING, IN2 := #tempNumElements)),\n\t                  Strg   => #tempString);\n\t    \n\t    // Search for text before\n\t    #tempPosTextBefore := FIND(IN1 := #tempString, IN2 := #textBefore);\n\t    \n\t    // Text before was found\n\t    IF #tempPosTextBefore > 0 THEN\n\t      // Set position in array to beginning or end of text before\n\t      IF #includeBeforeAfter THEN\n\t        #tempPosInArray += #tempPosTextBefore - 1;\n\t      ELSE\n\t        #tempPosInArray += #tempPosTextBefore + #tempLenTextBefore - 1;\n\t      END_IF;\n\t      \n\t      // Create new string from beginning or end of text before\n\t      Chars_TO_Strg(Chars  := #searchIn,\n\t                    pChars := #tempPosInArray, // Subtract offset since pChars is zero based\n\t                    Cnt    := UDINT_TO_UINT(MIN(IN1 := #LEN_STRING, IN2 := #tempNumElements)),\n\t                    Strg   => #tempString);\n\t      \n\t      // Find end of string to be extracted\n\t      #tempPosTextAfter := FIND(IN1 := #tempString, IN2 := #textAfter);\n\t      \n\t      IF #tempPosTextAfter > 0 THEN // Shorten string if text after was found\n\t        IF #includeBeforeAfter THEN\n\t          #length := #tempPosTextAfter + #tempLenTextAfter - 1;\n\t        ELSE\n\t          #length := #tempPosTextAfter - 1;\n\t        END_IF;\n\t        \n\t        #position := #tempPosInArray;\n\t        #extractedString := LEFT(IN := #tempString, L := #length);\n\t        #LGF_ExtractStringFromCharArrayAdv := #STATUS_TEXT_FOUND;\n\t        EXIT;\n\t        \n\t      ELSE // Output whole string if text after was not found\n\t        #extractedString := #tempString;\n\t        #position := #tempPosInArray;\n\t        #length := LEN(#tempString);\n\t        #LGF_ExtractStringFromCharArrayAdv := #WARNING_ONLY_START;\n\t        EXIT;\n\t      END_IF;\n\t      \n\t    ELSE\n\t      // Otherwise continue search in next string minus length of text before to ensure\n\t      // keywords are not broken up at the end of a string and thus missed\n\t      #tempPosInArray += UINT_TO_INT(#LEN_STRING) - #tempLenTextBefore;\n\t    END_IF;\n\t    \n\t    // Repeat until end of array is reached\n\t  UNTIL (#tempPosInArray > #tempNumElements) END_REPEAT;\n\tEND_REGION Process\n\t\nEND_FUNCTION", "return_value": [{"type": "Word"}]}
{"title": "FindStringInCharArray", "description": "The function searches for a specified String within an array of characters. Returning the position of the String in the Array, if the string is not found the return value is -1.", "type": "FUNCTION", "name": "LGF_FindStringInCharArray", "vars": [{"name": "searchFor", "type": "String", "description": "Text that is searched for"}, {"name": "startPos", "type": "DInt", "description": "Position within the array to start search from (index zero based)"}, {"name": "Ret_Val", "type": "DInt", "description": "Position (index) of the first character of the text that is searched forwithin the input array (index zero based).Return `-1` if nothing found."}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "input": [{"name": "searchFor", "type": "String", "description": "Text that is searched for"}, {"name": "startPos", "type": "DInt", "description": "Position within the array to start search from (index zero based)"}], "output": [{"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "answer": "FUNCTION \"LGF_FindStringInCharArray\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Online Support'\nFAMILY : LGF\nNAME : LGF_FindStringInCharArray\n   VAR_INPUT \n      searchFor : String;\n      startPos { S7_PredefinedAssignment := '0'} : DInt;\n   END_VAR\n\n   VAR_OUTPUT \n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      searchIn : Variant;\n   END_VAR\n\n   VAR_TEMP \n      tempNumElements : UDInt;\n      tempLenSearchFor : Int;\n      tempPosInArray : DInt;\n      tempPosInString : Int;\n      tempString : String;\n   END_VAR\n\n   VAR CONSTANT \n      LEN_STRING : UInt := 254;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS / (c)Copyright 2021\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_FindStringInCharArray\n\t  // Function:         The function searches for a specified String within an array of characters.\n\t  //                   Returning the position of the String in the Array,\n\t  //                   if the string is not found the return value is `-1`.\n\t  // Library:          LGF\n\t  // Author:           Siemens Industry Online Support\n\t  // Tested with:      CPU 1516-3 PN/DP\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     --\n\t  // Requirements:     S7-1200/1500\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 01.04.2019 | Siemens Online Support | First released version (LHttp)\n\t  // 01.01.00 | 10.06.2022 | Siemens Online Support | Adaption and integration into LGF\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Initialization\n\t  #tempPosInString := 0;\n\t  #tempPosInArray := #startPos;\n\t  #tempLenSearchFor := LEN(#searchFor);\n\t  #status := #STATUS_NO_ERROR;\n\t  #LGF_FindStringInCharArray := -1;\n\t  \n\t  REGION Validation of inputs\n\t    // check whether the input is an ARRAY and TYPE of elements is CHAR or BYTE\n\t    // IF so, the number OF the ARRAY elements is read out.\n\t    // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t    IF TRUE\n\t      AND IS_ARRAY(#searchIn)\n\t      AND ((TypeOfElements(#searchIn) = Char) OR (TypeOfElements(#searchIn) = Byte) )\n\t    THEN\n\t      // Get number of elements\n\t      #tempNumElements := CountOfElements(#searchIn);\n\t    ELSE\n\t      #status := #ERR_NO_ARRAY;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION Validation of inputs\n\tEND_REGION Initialization\n\t\n\tREGION Process\n\t  REPEAT // Search for beginning of text until something was found\n\t    // Convert Chars to String\n\t    Chars_TO_Strg(Chars  := #searchIn,\n\t                  pChars := #tempPosInArray,\n\t                  Cnt    := UDINT_TO_UINT(MIN(IN1 := #LEN_STRING, IN2 := #tempNumElements)),\n\t                  Strg   => #tempString);\n\t    \n\t    // Search for text at beginning\n\t    #tempPosInString := FIND(IN1 := #tempString, IN2 := #searchFor);\n\t    \n\t    // Keyword was found\n\t    IF #tempPosInString > 0 THEN\n\t      // Output position of string\n\t      #LGF_FindStringInCharArray :=  #tempPosInArray + #tempPosInString - 1;\n\t      EXIT;\n\t    ELSE\n\t      // Otherwise continue search in next string minus length of text at beginning to ensure\n\t      // keywords are not broken up at the end of a string and thus missed\n\t      #tempPosInArray += UINT_TO_INT(#LEN_STRING) - #tempLenSearchFor;\n\t    END_IF;\n\t    \n\t  UNTIL (#tempPosInString > 0) OR (#tempPosInArray > #tempNumElements) END_REPEAT;\n\tEND_REGION Process\n\t\nEND_FUNCTION", "return_value": [{"type": "DInt"}]}
{"title": "ToLower", "description": "This function converts the capital letters of a string into their lower case equivalents.", "type": "FUNCTION", "name": "LGF_ToLower", "vars": [{"name": "In", "type": "String", "description": "String input"}, {"name": "Ret_Val", "type": "String", "description": "Resulting string, after the conversion"}], "input": [{"name": "In", "type": "String", "description": "String input"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_ToLower\" : String\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Industry Online Support'\nFAMILY : LGF\nNAME : LGF_ToLower\n   VAR_INPUT \n      In : String;\n   END_VAR\n\n   VAR_TEMP \n      tempCurrentCharIndex : UInt;\n      tempStringLength : UInt;\n      tempCurrentChar : Char;\n      tempResult : String;\n   END_VAR\n\n   VAR CONSTANT \n      TO_UPPER_OFFSET : USInt := 32;\n      UPPER_CASE_A : Char := 'A';\n      UPPER_CASE_Z : Char := 'Z';\n      FIRST_CHARACTER_POSITION : UInt := 1;\n      NEXT_POSITION : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2023\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ToLower\n\t  // Comment/Function: This function converts the capital letters of a string into their lower case equivalents.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V4.0\n\t  // Engineering:      TIA Portal V16.0\n\t  // Restrictions:     ENO mechanism is not used, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 10.03.2023 | Siemens Industry Online Support\n\t  //                         First released version\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t(/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALIZATION\n\t  // First we clean up the resultstring to avoid returning random data\n\t  #tempResult := '';\n\t  #tempCurrentChar := '$00';\n\t  \n\t  // to avoid continuous system calls to LEN, we get the string length only once\n\t  // as it doesn't change during the conversion\n\t  #tempStringLength := INT_TO_UINT(LEN(#In));\n\t  \n\t  // we start converting at the beginning of the string. The first index into the string \n\t  // is 1 (not zero based counting)\n\t  #tempCurrentCharIndex := #FIRST_CHARACTER_POSITION;\n\tEND_REGION\n\t\n\tREGION CONVERSION\n\t  WHILE #tempCurrentCharIndex <= #tempStringLength DO\n\t    // We check the character at the indexed position in the string\n\t    // its ASCII code must be between 'A' and 'Z' (included) to be object of conversion\n\t    IF TRUE\n\t      AND #UPPER_CASE_A <= #In[#tempCurrentCharIndex]\n\t      AND #In[#tempCurrentCharIndex] <= #UPPER_CASE_Z\n\t    THEN\n\t      // The character is in the range of ASCII codes object to conversion\n\t      // Let's convert it into lower case\n\t      #tempCurrentChar := USINT_TO_CHAR(CHAR_TO_USINT(#In[#tempCurrentCharIndex]) + #TO_UPPER_OFFSET);\n\t    ELSE\n\t      // the character is not object to conversion. Therefore, we only copy it into the result string\n\t      #tempCurrentChar := #In[#tempCurrentCharIndex];\n\t    END_IF;\n\t    // Append the buffer character (may be converted) to the result string\n\t    #tempResult := CONCAT(IN1 := #tempResult,\n\t                          IN2 := #tempCurrentChar);\n\t    // Move on to the next character in the string\n\t    #tempCurrentCharIndex += #NEXT_POSITION;\n\t  END_WHILE;\n\tEND_REGION\n\t\n\t// Returning the converted string as function result\n\t#LGF_ToLower := #tempResult;\n\tENO := TRUE;\n\t\nEND_FUNCTION", "return_value": [{"type": "String"}]}
{"title": "ToUpper", "description": "This function converts the lowercase letters of a string into their capital equivalents.", "type": "FUNCTION", "name": "LGF_ToUpper", "vars": [{"name": "In", "type": "String", "description": "String input"}, {"name": "Ret_Val", "type": "String", "description": "Resulting string, after the conversion"}], "input": [{"name": "In", "type": "String", "description": "String input"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_ToUpper\" : String\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Industry Online Support'\nFAMILY : LGF\nNAME : LGF_ToUpper\n   VAR_INPUT \n      In : String;\n   END_VAR\n\n   VAR_TEMP \n      tempCurrentCharIndex : UInt;\n      tempStringLength : UInt;\n      tempCurrentChar : Char;\n      tempResult : String;\n   END_VAR\n\n   VAR CONSTANT \n      TO_UPPER_OFFSET : USInt := 32;\n      LOWER_CASE_A : Char := 'a';\n      LOWER_CASE_Z : Char := 'z';\n      FIRST_CHARACTER_POSITION : UInt := 1;\n      NEXT_POSITION : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2023\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ToLower\n\t  // Comment/Function: This function converts the capital letters of a string into their lower case equivalents.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V4.0\n\t  // Engineering:      TIA Portal V16.0\n\t  // Restrictions:     ENO mechanism is not used, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 10.03.2023 | Siemens Industry Online Support\n\t  //                         First released version\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t(/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALIZATION\n\t  // First we clean up the resultstring to avoid returning random data\n\t  #tempResult := '';\n\t  #tempCurrentChar := '$00';\n\t  \n\t  // to avoid continuous system calls to LEN, we get the string length only once\n\t  // as it doesn't change during the conversion\n\t  #tempStringLength := INT_TO_UINT(LEN(#In));\n\t  \n\t  // we start converting at the beginning of the string. The first index into the string \n\t  // is 1 (not zero based counting)\n\t  #tempCurrentCharIndex := #FIRST_CHARACTER_POSITION;\n\tEND_REGION\n\t\n\tREGION CONVERSION  \n\t  WHILE #tempCurrentCharIndex <= #tempStringLength DO\n\t    // We check the character at the index position in the string\n\t    // its ASCII code must be between 'a' and 'z' (included) to be object of conversion\n\t    IF TRUE\n\t      AND #LOWER_CASE_A <= #In[#tempCurrentCharIndex]\n\t      AND #In[#tempCurrentCharIndex] <= #LOWER_CASE_Z\n\t    THEN\n\t      // The character is in the range of ASCII codes object to conversion\n\t      // Let's convert it into upper case\n\t      #tempCurrentChar := USINT_TO_CHAR(CHAR_TO_USINT(#In[#tempCurrentCharIndex]) - #TO_UPPER_OFFSET);\n\t    ELSE\n\t      // the character is not object to conversion. Therefore, we only copy it into the result string\n\t      #tempCurrentChar := #In[#tempCurrentCharIndex];\n\t    END_IF;\n\t    // Append the buffer character (may be converted) to the result string\n\t    #tempResult := CONCAT(IN1 := #tempResult,\n\t                          IN2 := #tempCurrentChar);\n\t    // Move on to the next character in the string\n\t    #tempCurrentCharIndex += #NEXT_POSITION;\n\t  END_WHILE;\n\tEND_REGION\n\t\n\t// Returning the converted string as function result\n\t#LGF_ToUpper := #tempResult;\n\tENO := TRUE;\n\t\nEND_FUNCTION", "return_value": [{"type": "String"}]}
{"title": "CelsiusToFahrenheit", "description": "This function converts a temperature value - from °Celsius to °Fahrenheit.", "type": "FUNCTION", "name": "LGF_CelsiusToFahrenheit", "vars": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Celsius"}, {"name": "Ret_Val", "type": "Real", "description": "Converted temperature in °Fahrenheit"}], "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Celsius"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_CelsiusToFahrenheit\" : Real\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry_Support\nFAMILY : LGF\nNAME : LGF_CelsiusToFahrenheit\n   VAR_INPUT \n      value : Real;\n   END_VAR\n\n   VAR_TEMP \n      tempFahrenheitTemperature : Real;\n   END_VAR\n\n   VAR CONSTANT \n      TEMPERATURE_GAIN : Real := 1.8;\n      TEMPERATURE_OFFSET : Real := 32.0;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CelsiusToFahrenheit\n\t  // Comment/Function: This function converts a temperature value - from °Celsius to °Fahrenheit \n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO disabled - no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t  #tempFahrenheitTemperature := #value * #TEMPERATURE_GAIN + #TEMPERATURE_OFFSET;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_CelsiusToFahrenheit := #tempFahrenheitTemperature;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Real"}]}
{"title": "CelsiusToKelvin", "description": "This function converts a temperature value - from °Celsius to °Kelvin.", "type": "FUNCTION", "name": "LGF_CelsiusToKelvin", "vars": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Celsius"}, {"name": "Ret_Val", "type": "Real", "description": "Converted temperature in °Kelvin"}], "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Celsius"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_CelsiusToKelvin\" : Real\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry_Support\nFAMILY : LGF\nNAME : LGF_CelsiusToKelvin\n   VAR_INPUT \n      value : Real;\n   END_VAR\n\n   VAR_TEMP \n      tempKelvinTemperature : Real;\n   END_VAR\n\n   VAR CONSTANT \n      TEMPERATURE_OFFSET : Real := 273.15;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CelsiusToKelvin\n\t  // Comment/Function: This function converts a temperature value - from °Celsius to °Kelvin\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO disabled - no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t  #tempKelvinTemperature := #value + #TEMPERATURE_OFFSET;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_CelsiusToKelvin := #tempKelvinTemperature;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Real"}]}
{"title": "ConvertTemperature", "description": "This function converts a temperature value from one into another unit by using an appropriate given mode parameter.", "type": "FUNCTION", "name": "LGF_ConvertTemperature", "vars": [{"name": "mode", "type": "Int", "description": "1: Celsius to Fahrenheit,\n2: Fahrenheit to Celsius,\n3: Celsius to Kelvin,\n4: Kelvin to Celsius,\n5: Fahrenheit to Kelvin,\n6: Kelvin in Fahrenheit,\n7: Rankine to Kelvin,\n8: Kelvin to Rankine"}, {"name": "value", "type": "Real", "description": "Temperature value to be converted"}, {"name": "Ret_Val", "type": "Real", "description": "Converted temperature result"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "mode", "type": "Int", "description": "1: Celsius to Fahrenheit,\n2: Fahrenheit to Celsius,\n3: Celsius to Kelvin,\n4: Kelvin to Celsius,\n5: Fahrenheit to Kelvin,\n6: Kelvin in Fahrenheit,\n7: Rankine to Kelvin,\n8: Kelvin to Rankine"}, {"name": "value", "type": "Real", "description": "Temperature value to be converted"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_ConvertTemperature\" : Real\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry_Support\nFAMILY : LGF\nNAME : LGF_ConvertTemperature\n   VAR_INPUT \n      mode : Int;\n      value : Real;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempConversionResult : Real;\n   END_VAR\n\n   VAR CONSTANT \n      CELSIUS_TO_FAHRENHEIT : Int := 1;\n      CELSIUS_TO_FAHRENHEIT_GAIN : Real := 1.8;\n      CELSIUS_TO_FAHRENHEIT_OFFSET : Real := 32.0;\n      FAHRENHEIT_TO_CELSIUS : Int := 2;\n      FAHRENHEIT_TO_CELSIUS_GAIN : Real := 1.8;\n      FAHRENHEIT_TO_CELSIUS_OFFSET : Real := 32.0;\n      CELSIUS_TO_KELVIN : Int := 3;\n      CELSIUS_TO_KELVIN_OFFSET : Real := 273.15;\n      KELVIN_TO_CELSIUS : Int := 4;\n      KELVIN_TO_CELSIUS_OFFSET : Real := 273.15;\n      FAHRENHEIT_TO_KELVIN : Int := 5;\n      FAHRENHEIT_TO_KELVIN_GAIN : Real := 1.8;\n      FAHRENHEIT_TO_KELVIN_OFFSET_FAHRENHEIT : Real := 273.15;\n      FAHRENHEIT_TO_KELVIN_OFFSET : Real := 32.0;\n      KELVIN_TO_FAHRENHEIT : Int := 6;\n      KELVIN_TO_FAHRENHEIT_GAIN : Real := 1.8;\n      KELVIN_TO_FAHRENHEIT_OFFSET_KELVIN : Real := 273.15;\n      KELVIN_TO_FAHRENHEIT_OFFSET : Real := 32.0;\n      RANKINE_TO_KELVIN : Int := 7;\n      RANKINE_TO_KELVIN_GAIN_NUMERATOR : Real := 5.0;\n      RANKINE_TO_KELVIN_GAIN_DENOMINATOR : Real := 9.0;\n      KELVIN_TO_RANKINE : Int := 8;\n      KELVIN_TO_RANKINE_FACTOR : Real := 1.8;\n      NO_ERROR : Word := 16#0000;\n      ERR_WRONG_MODE : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ConvertTemperature\n\t  // Comment/Function: This function converts the temperature in another unit by using an appropriate mode\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO disabled - error handling done with done and status (just for a wrong mode)\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 19.08.2015   Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 02.01.2017 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.02 | 17.08.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15 Update 2\n\t  // 01.00.03 | 23.11.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15.1\n\t  // 02.00.00 | 16.12.2018 | Simatic Systems Support\n\t  //                         Rename from \"LGF_TemperatureConvert\" to \"LGF_ConvertTemperature\"\n\t  //                         to start with the verb\n\t  //                         include the Rankine conversion\n\t  //                         Code refactoring, regions, commends and constants\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t  CASE #mode OF\n\t    #CELSIUS_TO_FAHRENHEIT:\n\t      // F = C * 1.8 + 32\n\t      #tempConversionResult := #value * #CELSIUS_TO_FAHRENHEIT_GAIN + #CELSIUS_TO_FAHRENHEIT_OFFSET;\n\t      \n\t    #FAHRENHEIT_TO_CELSIUS:\n\t      // C = (F - 32) / 1.8\n\t      #tempConversionResult := (#value - #FAHRENHEIT_TO_CELSIUS_OFFSET) / #FAHRENHEIT_TO_CELSIUS_GAIN;\n\t      \n\t    #CELSIUS_TO_KELVIN:\n\t      // K = C + 273.15\n\t      #tempConversionResult := #value + #CELSIUS_TO_KELVIN_OFFSET;\n\t      \n\t    #KELVIN_TO_CELSIUS:\n\t      // C = K - 273.15\n\t      #tempConversionResult := #value - #KELVIN_TO_CELSIUS_OFFSET;\n\t      \n\t    #FAHRENHEIT_TO_KELVIN:\n\t      // K := ((C - 32.0) / 1.8) + 273.15\n\t      #tempConversionResult := ((#value - #FAHRENHEIT_TO_KELVIN_OFFSET) / #FAHRENHEIT_TO_KELVIN_GAIN) + #FAHRENHEIT_TO_KELVIN_OFFSET_FAHRENHEIT;\n\t      \n\t    #KELVIN_TO_FAHRENHEIT:\n\t      // F := (K - 273.15) * 1.8 + 32.0\n\t      #tempConversionResult := ((#value - #KELVIN_TO_FAHRENHEIT_OFFSET_KELVIN) * #KELVIN_TO_FAHRENHEIT_GAIN) + #KELVIN_TO_FAHRENHEIT_OFFSET;\n\t      \n\t    #RANKINE_TO_KELVIN:\n\t      // K =  5 / 9 *R\n\t      #tempConversionResult := #RANKINE_TO_KELVIN_GAIN_NUMERATOR * #value / #RANKINE_TO_KELVIN_GAIN_DENOMINATOR;\n\t      \n\t    #KELVIN_TO_RANKINE:\n\t      // R = 9 / 5 * K\n\t      #tempConversionResult := #KELVIN_TO_RANKINE_FACTOR * #value;\n\t      \n\t    ELSE\n\t      // no/ wrong mode selected\n\t      #LGF_ConvertTemperature := 0.0;\n\t      #error := TRUE;\n\t      #status := #ERR_WRONG_MODE;\n\t      RETURN;\n\t  END_CASE;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_ConvertTemperature := #tempConversionResult;\n\t  #error := FALSE;\n\t  #status := #NO_ERROR;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\nEND_FUNCTION", "return_value": [{"type": "Real"}]}
{"title": "FahrenheitToCelsius", "description": "This function converts a temperature value - from °Fahrenheit to °Celsius.", "type": "FUNCTION", "name": "LGF_FahrenheitToCelsius", "vars": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Fahrenheit"}, {"name": "Ret_Val", "type": "Real", "description": "Converted temperature in °Celsius"}], "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Fahrenheit"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_FahrenheitToCelsius\" : Real\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry_Support\nFAMILY : LGF\nNAME : LGF_FahrenheitToCelsius\n   VAR_INPUT \n      value : Real;\n   END_VAR\n\n   VAR_TEMP \n      tempCelsiusTemperature : Real;\n   END_VAR\n\n   VAR CONSTANT \n      TEMPERATURE_GAIN : Real := 1.8;\n      TEMPERATURE_OFFSET : Real := 32.0;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_FahrenheitToCelsius\n\t  // Comment/Function: This function converts a temperature value - from °Fahrenheit to °Celsius\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO disabled - no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t  #tempCelsiusTemperature := (#value - #TEMPERATURE_OFFSET) / #TEMPERATURE_GAIN;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_FahrenheitToCelsius := #tempCelsiusTemperature;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Real"}]}
{"title": "FahrenheitToKelvin", "description": "This function converts a temperature value - from °Fahrenheit to °Kelvin.", "type": "FUNCTION", "name": "LGF_FahrenheitToKelvin", "vars": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Fahrenheit"}, {"name": "Ret_Val", "type": "Real", "description": "Converted temperature in °Kelvin"}], "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Fahrenheit"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_FahrenheitToKelvin\" : Real\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry_Support\nFAMILY : LGF\nNAME : LGF_FahrenheitToKelvin\n   VAR_INPUT \n      value : Real;\n   END_VAR\n\n   VAR_TEMP \n      tempKelvinTemperature : Real;\n   END_VAR\n\n   VAR CONSTANT \n      TEMPERATURE_GAIN : Real := 1.8;\n      TEMPERATURE_OFFSET_FAHRENHEIT : Real := 273.15;\n      TEMPERATURE_OFFSET : Real := 32.0;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_FahrenheitToKelvin\n\t  // Comment/Function: This function converts the Fahrenheit to Kelvin temperature\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO disabled - no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t  #tempKelvinTemperature := ((#value - #TEMPERATURE_OFFSET) / #TEMPERATURE_GAIN) + #TEMPERATURE_OFFSET_FAHRENHEIT;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_FahrenheitToKelvin := #tempKelvinTemperature;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Real"}]}
{"title": "KelvinToCelsius", "description": "This function converts a temperature value - from °Kelvin to °Celsius.", "type": "FUNCTION", "name": "LGF_KelvinToCelsius", "vars": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Kelvin"}, {"name": "Ret_Val", "type": "Real", "description": "Converted temperature in °Celsius"}], "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Kelvin"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_KelvinToCelsius\" : Real\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry_Support\nFAMILY : LGF\nNAME : LGF_KelvinToCelsius\n   VAR_INPUT \n      value : Real;\n   END_VAR\n\n   VAR_TEMP \n      tempCelsiusTemperature : Real;\n   END_VAR\n\n   VAR CONSTANT \n      TEMPERATURE_OFFSET : Real := 273.15;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_KelvinToCelsius\n\t  // Comment/Function: This function converts a temperature value - from °Kelvin to °Celsius\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO disabled - no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t  #tempCelsiusTemperature := #value - #TEMPERATURE_OFFSET;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_KelvinToCelsius := #tempCelsiusTemperature;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Real"}]}
{"title": "KelvinToFahrenheit", "description": "This function converts a temperature value - from °Kelvin to °Fahrenheit.", "type": "FUNCTION", "name": "LGF_KelvinToFahrenheit", "vars": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Kelvin"}, {"name": "Ret_Val", "type": "Real", "description": "Converted temperature in °Fahrenheit"}], "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Kelvin"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_KelvinToFahrenheit\" : Real\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry_Support\nFAMILY : LGF\nNAME : LGF_KelvinToFahrenheit\n   VAR_INPUT \n      value : Real;\n   END_VAR\n\n   VAR_TEMP \n      tempFahrenheitTemperature : Real;\n   END_VAR\n\n   VAR CONSTANT \n      TEMPERATURE_GAIN : Real := 1.8;\n      TEMPERATURE_OFFSET_KELVIN : Real := 273.15;\n      TEMPERATURE_OFFSET : Real := 32.0;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_FahrenheitToKelvin\n\t  // Comment/Function: This function converts a temperature value - from °Kelvin to °Fahrenheit\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO disabled - no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t  #tempFahrenheitTemperature := ((#value - #TEMPERATURE_OFFSET_KELVIN) * #TEMPERATURE_GAIN) + #TEMPERATURE_OFFSET;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_KelvinToFahrenheit := #tempFahrenheitTemperature;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Real"}]}
{"title": "KelvinToRankine", "description": "This function converts a temperature value - from °Kelvin to °Rankine.", "type": "FUNCTION", "name": "LGF_KelvinToRankine", "vars": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Kelvin"}, {"name": "Ret_Val", "type": "Real", "description": "Converted temperature in °Rankine"}], "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Kelvin"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_KelvinToRankine\" : Real\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry_Support\nFAMILY : LGF\nNAME : LGF_KelvinToRankine\n   VAR_INPUT \n      value : Real;\n   END_VAR\n\n   VAR_TEMP \n      tempRankineTemperature : Real;\n   END_VAR\n\n   VAR CONSTANT \n      TEMPERATURE_GAIN : Real := 1.8;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_KelvinToRankine\n\t  // Comment/Function: This function converts a temperature value - from °Kelvin to °Rankine\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO disabled - no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t  #tempRankineTemperature := #value * #TEMPERATURE_GAIN;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_KelvinToRankine := #tempRankineTemperature;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Real"}]}
{"title": "RankineToKelvin", "description": "This function converts a temperature value - from °Rankine to °Kelvin.", "type": "FUNCTION", "name": "LGF_RankineToKelvin", "vars": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Rankine"}, {"name": "Ret_Val", "type": "Real", "description": "Converted temperature in °Kelvin"}], "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Rankine"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_RankineToKelvin\" : Real\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry_Support\nFAMILY : LGF\nNAME : LGF_RankineToKelvin\n   VAR_INPUT \n      value : Real;\n   END_VAR\n\n   VAR_TEMP \n      tempKelvinTemperature : Real;\n   END_VAR\n\n   VAR CONSTANT \n      TEMPERATURE_GAIN_NUMERATOR : Real := 5.0;\n      TEMPERATURE_GAIN_DENOMINATOR : Real := 9.0;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_RankineToKelvin\n\t  // Comment/Function: This function converts a temperature value - from °Rankine to °Kelvin\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO disabled - no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\t\n\tREGION CONVERT\n\t  #tempKelvinTemperature := (#TEMPERATURE_GAIN_NUMERATOR / #TEMPERATURE_GAIN_DENOMINATOR) * #value;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_RankineToKelvin := #tempKelvinTemperature;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Real"}]}
{"title": "ClockGen", "description": "This function generates the same clock signals as the system clock memory.", "type": "FUNCTION_BLOCK", "name": "LGF_ClockGen", "vars": [{"name": "clockDataType", "type": "LGF_typeSystem\nClockGen", "description": "Clock data type"}, {"name": "clockDataTypeRisingEdge", "type": "LGF_typeSystem\nClockGen", "description": "Clock edge data type (rising edges)"}, {"name": "clockDataTypeFallingEdge", "type": "LGF_typeSystem\nClockGen", "description": "Clock edge data type (falling edges)"}, {"name": "clockByte", "type": "Byte", "description": "Clock byte"}, {"name": "clockByteRisingEdge", "type": "Byte", "description": "Clock edge byte (rising edges)"}, {"name": "clockByteFallingEdge", "type": "Byte", "description": "Clock edge byte (falling edges)"}, {"name": "clk10Hz", "type": "Bool", "description": "Clock bit 10Hz"}, {"name": "clk5Hz", "type": "Bool", "description": "Clock bit 5Hz"}, {"name": "clk2Hz5", "type": "Bool", "description": "Clock bit 2.5Hz"}, {"name": "clk2Hz", "type": "Bool", "description": "Clock bit 2Hz"}, {"name": "clk1Hz25", "type": "Bool", "description": "Clock bit 1.25Hz"}, {"name": "clk1Hz", "type": "Bool", "description": "Clock bit 1Hz"}, {"name": "clk0Hz625", "type": "Bool", "description": "Clock bit 0.625Hz"}, {"name": "clk0Hz5", "type": "Bool", "description": "Clock bit 0.5Hz"}, {"name": "clk10Hz", "type": "Bool", "description": "Clock bit 10Hz"}, {"name": "clk5Hz", "type": "Bool", "description": "Clock bit 5Hz"}, {"name": "clk2Hz5", "type": "Bool", "description": "Clock bit 2.5Hz"}, {"name": "clk2Hz", "type": "Bool", "description": "Clock bit 2Hz"}, {"name": "clk1Hz25", "type": "Bool", "description": "Clock bit 1.25Hz"}, {"name": "clk1Hz", "type": "Bool", "description": "Clock bit 1Hz"}, {"name": "clk0Hz625", "type": "Bool", "description": "Clock bit 0.625Hz"}, {"name": "clk0Hz5", "type": "Bool", "description": "Clock bit 0.5Hz"}], "input": [], "output": [{"name": "clockDataType", "type": "LGF_typeSystem\nClockGen", "description": "Clock data type"}, {"name": "clockDataTypeRisingEdge", "type": "LGF_typeSystem\nClockGen", "description": "Clock edge data type (rising edges)"}, {"name": "clockDataTypeFallingEdge", "type": "LGF_typeSystem\nClockGen", "description": "Clock edge data type (falling edges)"}, {"name": "clockByte", "type": "Byte", "description": "Clock byte"}, {"name": "clockByteRisingEdge", "type": "Byte", "description": "Clock edge byte (rising edges)"}, {"name": "clockByteFallingEdge", "type": "Byte", "description": "Clock edge byte (falling edges)"}, {"name": "clk10Hz", "type": "Bool", "description": "Clock bit 10Hz"}, {"name": "clk5Hz", "type": "Bool", "description": "Clock bit 5Hz"}, {"name": "clk2Hz5", "type": "Bool", "description": "Clock bit 2.5Hz"}, {"name": "clk2Hz", "type": "Bool", "description": "Clock bit 2Hz"}, {"name": "clk1Hz25", "type": "Bool", "description": "Clock bit 1.25Hz"}, {"name": "clk1Hz", "type": "Bool", "description": "Clock bit 1Hz"}, {"name": "clk0Hz625", "type": "Bool", "description": "Clock bit 0.625Hz"}, {"name": "clk0Hz5", "type": "Bool", "description": "Clock bit 0.5Hz"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_ClockGen\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Simatic Systems Support (SICAR)'\nFAMILY : LGF\nNAME : LGF_ClockGen\n   VAR_OUTPUT \n      clockDataType { ExternalWritable := 'False'} : \"LGF_typeSystemClockGen\";\n      clockDataTypeRisingEdge { ExternalWritable := 'False'} : \"LGF_typeSystemClockGen\";\n      clockDataTypeFallingEdge { ExternalWritable := 'False'} : \"LGF_typeSystemClockGen\";\n      clockByte { ExternalWritable := 'False'} : Byte;\n      clockByteRisingEdge { ExternalWritable := 'False'} : Byte;\n      clockByteFallingEdge { ExternalWritable := 'False'} : Byte;\n      clk10Hz { ExternalWritable := 'False'} : Bool;\n      clk5Hz { ExternalWritable := 'False'} : Bool;\n      clk2Hz5 { ExternalWritable := 'False'} : Bool;\n      clk2Hz { ExternalWritable := 'False'} : Bool;\n      clk1Hz25 { ExternalWritable := 'False'} : Bool;\n      clk1Hz { ExternalWritable := 'False'} : Bool;\n      clk0Hz625 { ExternalWritable := 'False'} : Bool;\n      clk0Hz5 { ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR \n      statMemRuntime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;\n      statClockByteFallingEdge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;\n      statClockByteRisingEdge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;\n      statClockBytePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;\n      statCalcTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         clk10Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         clk5Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         clk2Hz5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         clk2Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         clk1Hz25 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         clk1Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         clk0Hz625 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         clk0Hz5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n      END_STRUCT;\n      statStateFlag { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeSystemClockGen\";\n   END_VAR\n\n   VAR_TEMP \n      tempCycleTimeMicroSecond : UDInt;\n   END_VAR\n\n   VAR CONSTANT \n      PULSE_WIDTH_CLK10HZ : UDInt := 50000;\n      PULSE_WIDTH_CLK5HZ : UDInt := 100000;\n      PULSE_WIDTH_CLK2_5HZ : UDInt := 200000;\n      PULSE_WIDTH_CLK2HZ : UDInt := 250000;\n      PULSE_WIDTH_CLK1_25HZ : UDInt := 400000;\n      PULSE_WIDTH_CLK1HZ : UDInt := 500000;\n      PULSE_WIDTH_CLK0_625HZ : UDInt := 800000;\n      PULSE_WIDTH_CLK0_5HZ : UDInt := 1000000;\n      SECOND_TO_MICROSECOND : Real := 1000000.0;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG \n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_SystemClockGen\n\t  // Comment/Function: This function generates the same clocksignals as the system clock memory.\n\t  // Library/Family:   LGF (from SICAR)\n\t  // Author:           Simatic Systems Support (SICAR)\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1 and PLC S7 1516F-3 PN/DP\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO disabled\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  //----------|------------|-------------------------|------------------------------\n\t  // 01.00.00 | 01.10.2023 | SICAR                   | First released version\n\t  // 01.00.01 | 06.05.2025 | Simatic Systems Support | Integration into LGF\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Read current cyletime\n\t  #tempCycleTimeMicroSecond := LREAL_TO_UDINT((RUNTIME(#statMemRuntime)) * #SECOND_TO_MICROSECOND);\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 10Hz\n\t  // Sum up the cycletime\n\t  #statCalcTime.clk10Hz += #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk10Hz AND #statCalcTime.clk10Hz / #PULSE_WIDTH_CLK10HZ >= 1 THEN\n\t    //Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk10Hz := TRUE;\n\t    #statCalcTime.clk10Hz := #statCalcTime.clk10Hz MOD #PULSE_WIDTH_CLK10HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk10Hz AND #statCalcTime.clk10Hz / #PULSE_WIDTH_CLK10HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk10Hz := FALSE;\n\t    #statCalcTime.clk10Hz := #statCalcTime.clk10Hz MOD #PULSE_WIDTH_CLK10HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 5Hz\n\t  // Sum up the cycletime\n\t  #statCalcTime.clk5Hz += #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk5Hz AND #statCalcTime.clk5Hz / #PULSE_WIDTH_CLK5HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk5Hz := TRUE;\n\t    #statCalcTime.clk5Hz := #statCalcTime.clk5Hz MOD #PULSE_WIDTH_CLK5HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk5Hz AND #statCalcTime.clk5Hz / #PULSE_WIDTH_CLK5HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk5Hz := FALSE;\n\t    #statCalcTime.clk5Hz := #statCalcTime.clk5Hz MOD #PULSE_WIDTH_CLK5HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 2_5Hz\n\t  // Sum up the cycletime\n\t  #statCalcTime.clk2Hz5 += #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk2Hz5 AND #statCalcTime.clk2Hz5 / #PULSE_WIDTH_CLK2_5HZ >= 1 THEN\n\t    //Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk2Hz5 := TRUE;\n\t    #statCalcTime.clk2Hz5 := #statCalcTime.clk2Hz5 MOD #PULSE_WIDTH_CLK2_5HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk2Hz5 AND #statCalcTime.clk2Hz5 / #PULSE_WIDTH_CLK2_5HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk2Hz5 := FALSE;\n\t    #statCalcTime.clk2Hz5 := #statCalcTime.clk2Hz5 MOD #PULSE_WIDTH_CLK2_5HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 2Hz\n\t  // Sum up the cycletime\n\t  #statCalcTime.clk2Hz += #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk2Hz AND #statCalcTime.clk2Hz / #PULSE_WIDTH_CLK2HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk2Hz := TRUE;\n\t    #statCalcTime.clk2Hz := #statCalcTime.clk2Hz MOD #PULSE_WIDTH_CLK2HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk2Hz AND #statCalcTime.clk2Hz / #PULSE_WIDTH_CLK2HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk2Hz := FALSE;\n\t    #statCalcTime.clk2Hz := #statCalcTime.clk2Hz MOD #PULSE_WIDTH_CLK2HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 1_25Hz\n\t  // Sum up the cycletime\n\t  #statCalcTime.clk1Hz25 += #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk1Hz25 AND #statCalcTime.clk1Hz25 / #PULSE_WIDTH_CLK1_25HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk1Hz25 := TRUE;\n\t    #statCalcTime.clk1Hz25 := #statCalcTime.clk1Hz25 MOD #PULSE_WIDTH_CLK1_25HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk1Hz25 AND #statCalcTime.clk1Hz25 / #PULSE_WIDTH_CLK1_25HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk1Hz25 := FALSE;\n\t    #statCalcTime.clk1Hz25 := #statCalcTime.clk1Hz25 MOD #PULSE_WIDTH_CLK1_25HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 1Hz\n\t  //Sum up the cycletime\n\t  #statCalcTime.clk1Hz += #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk1Hz AND #statCalcTime.clk1Hz / #PULSE_WIDTH_CLK1HZ >= 1 THEN\n\t    //Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk1Hz := TRUE;\n\t    #statCalcTime.clk1Hz := #statCalcTime.clk1Hz MOD #PULSE_WIDTH_CLK1HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk1Hz AND #statCalcTime.clk1Hz / #PULSE_WIDTH_CLK1HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk1Hz := FALSE;\n\t    #statCalcTime.clk1Hz := #statCalcTime.clk1Hz MOD #PULSE_WIDTH_CLK1HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 0_625Hz\n\t  // Sum up the cycletime\n\t  #statCalcTime.clk0Hz625 += #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk0Hz625 AND #statCalcTime.clk0Hz625 / #PULSE_WIDTH_CLK0_625HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk0Hz625 := TRUE;\n\t    #statCalcTime.clk0Hz625 := #statCalcTime.clk0Hz625 MOD #PULSE_WIDTH_CLK0_625HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk0Hz625 AND #statCalcTime.clk0Hz625 / #PULSE_WIDTH_CLK0_625HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk0Hz625 := FALSE;\n\t    #statCalcTime.clk0Hz625 := #statCalcTime.clk0Hz625 MOD #PULSE_WIDTH_CLK0_625HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 0_5Hz\n\t  // Sum up the cycletime\n\t  #statCalcTime.clk0Hz5 += + #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk0Hz5 AND #statCalcTime.clk0Hz5 / #PULSE_WIDTH_CLK0_5HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk0Hz5 := TRUE;\n\t    #statCalcTime.clk0Hz5 := #statCalcTime.clk0Hz5 MOD #PULSE_WIDTH_CLK0_5HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk0Hz5 AND #statCalcTime.clk0Hz5 / #PULSE_WIDTH_CLK0_5HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk0Hz5 := FALSE;\n\t    #statCalcTime.clk0Hz5 := #statCalcTime.clk0Hz5 MOD #PULSE_WIDTH_CLK0_5HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Writing Output\n\t  // Write statusbit to output\n\t  #clk10Hz := #statClockByte.%X0 := NOT #statStateFlag.clk10Hz;\n\t  #clk5Hz := #statClockByte.%X1 := NOT #statStateFlag.clk5Hz;\n\t  #clk2Hz5 := #statClockByte.%X2 := NOT #statStateFlag.clk2Hz5;\n\t  #clk2Hz := #statClockByte.%X3 := NOT #statStateFlag.clk2Hz;\n\t  #clk1Hz25 := #statClockByte.%X4 := NOT #statStateFlag.clk1Hz25;\n\t  #clk1Hz := #statClockByte.%X5 := NOT #statStateFlag.clk1Hz;\n\t  #clk0Hz625 := #statClockByte.%X6 := NOT #statStateFlag.clk0Hz625;\n\t  #clk0Hz5 := #statClockByte.%X7 := NOT #statStateFlag.clk0Hz5;\n\t  \n\t  REGION Generating Edges\n\t    IF #statClockByte = #statClockBytePrevious THEN\n\t      #statClockByteRisingEdge :=\n\t      #statClockByteFallingEdge := 16#00;\n\t    ELSE\n\t      #statClockByteRisingEdge := (#statClockByte XOR #statClockBytePrevious) AND #statClockByte;\n\t      #statClockByteFallingEdge := (#statClockByte XOR #statClockBytePrevious) AND NOT #statClockByte;\n\t    END_IF;\n\t    #statClockBytePrevious := #statClockByte;\n\t  END_REGION\n\t  \n\t  #clockByte := #statClockByte;\n\t  #clockByteRisingEdge := #statClockByteRisingEdge;\n\t  #clockByteFallingEdge := #statClockByteFallingEdge;\n\t  \n\t  SCATTER(IN  := #statClockByte,\n\t          OUT => #clockDataType);\n\t  SCATTER(IN  := #statClockByteRisingEdge,\n\t          OUT => #clockDataTypeRisingEdge);\n\t  SCATTER(IN  := #statClockByteFallingEdge,\n\t          OUT => #clockDataTypeFallingEdge);\n\t  \n\t  // ENO is not needed here, forced to TRUE\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "CosinusCI", "description": "This function generates a cosinusoidal signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.", "type": "FUNCTION_BLOCK", "name": "LGF_CosinusCI", "vars": [{"name": "amplitude", "type": "Real", "description": "Amplitude of the signal profile."}, {"name": "offset", "type": "Real", "description": "Offset of the signal profile in the Y-direction."}, {"name": "periode", "type": "UDInt", "description": "Period duration of the signal profile in [ms]"}, {"name": "phaseShift", "type": "Real", "description": "Phase offset in [ms]"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling cyclic interrupt OB"}, {"name": "reset", "type": "Bool", "description": "Reset of the signal profile."}, {"name": "value", "type": "Real", "description": "Current value of the cosinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [{"name": "amplitude", "type": "Real", "description": "Amplitude of the signal profile."}, {"name": "offset", "type": "Real", "description": "Offset of the signal profile in the Y-direction."}, {"name": "periode", "type": "UDInt", "description": "Period duration of the signal profile in [ms]"}, {"name": "phaseShift", "type": "Real", "description": "Phase offset in [ms]"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling cyclic interrupt OB"}, {"name": "reset", "type": "Bool", "description": "Reset of the signal profile."}], "output": [{"name": "value", "type": "Real", "description": "Current value of the cosinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_CosinusCI\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_CosinusCI\n   VAR_INPUT \n      amplitude : Real := 1.0;\n      offset : Real;\n      periode : UDInt := 1000;\n      phaseShift : Real;\n      callOB : OB_CYCLIC;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      value { ExternalWritable := 'False'} : Real;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      subFunctionStatus { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR \n      statRad { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;\n      statPhaseShift { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real := 0.0;\n      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n   END_VAR\n\n   VAR_TEMP \n      tempCycleTime : UDInt;\n      tempCyclePhase : UDInt;\n      tempCycleStatus : Word;\n      tempReadTimeStatus : Int;\n   END_VAR\n\n   VAR CONSTANT \n      SECOND_IN_MS : UDInt := 1000;\n      ZERO : Int := 0;\n      SLOPE : Int := 2;\n      TWO_PI : Real := 6.283185;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      QRY_CINT_OB_UNAVAILABLE : Word := 16#0000;\n      ERR_OB_UNAVAILABLE : Word := 16#8600;\n      ERR_QRY_CINT : Word := 16#8601;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CosinusCI\n\t  // Comment/Function: This function generates a cosinusoidal signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.03 26.09.2019  Simatic Systems Support\n\t  //                      Code refactoring, regions and more comments added\n\t  //                      phase shift availability added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  // 03.00.02 15.12.2023  Simatic Systems Support\n\t  //                      Fix callculation of 'phaseShift'\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Get sample time\n\t  // get sample time, according to the cyclic interrupt OB number\n\t  #tempReadTimeStatus := QRY_CINT(OB_NR := #callOB, CYCLE => #tempCycleTime,\n\t                                  PHASE => #tempCyclePhase, STATUS => #tempCycleStatus);\n\t  \n\t  REGION Error handling\n\t    // Generate error message of the QRY_CINT function\n\t    IF #tempReadTimeStatus <> #ZERO THEN\n\t      #error := TRUE;\n\t      #status := #ERR_QRY_CINT;\n\t      #subFunctionStatus := INT_TO_WORD(#tempReadTimeStatus);\n\t      #value := #ZERO;\n\t      RETURN;\n\t      // Generate error message when OB unavailable\n\t    ELSIF (#tempCycleStatus = #QRY_CINT_OB_UNAVAILABLE) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_OB_UNAVAILABLE;\n\t      #subFunctionStatus := #SUB_STATUS_NO_ERROR;\n\t      #value := 0;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\tEND_REGION\n\t\n\tREGION Caluclations and outputs assigment\n\t  IF #reset THEN\n\t    #statCounter := 0;\n\t    #value := #ZERO;\n\t  ELSE\n\t    // Increment Counter with each call of \"OB_Cyclic_interrupt\"\n\t    #statCounter += (#tempCycleTime) / #SECOND_IN_MS;\n\t    #statCounter := #statCounter MOD (#periode);\n\t    \n\t    // Transfer to radians\n\t    #statRad := UDINT_TO_REAL(#statCounter) * #TWO_PI / (UDINT_TO_REAL(#periode));\n\t    #statPhaseShift := (#phaseShift * #TWO_PI) / UDINT_TO_REAL(#periode);\n\t    \n\t    // Calculate output value\n\t    #value := COS(#statRad + #statPhaseShift) * #amplitude + #offset;\n\t  END_IF;\n\t  #error := false;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subFunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "Frequency", "description": "This function generates a signal that changes between the values FALSE and TRUE depending on a defined frequency and a pulse pause ratio.", "type": "FUNCTION_BLOCK", "name": "LGF_Frequency", "vars": [{"name": "frequency", "type": "Real", "description": "Clock frequency in Hz."}, {"name": "pulsePauseRatio", "type": "Real", "description": "Pulse pause ratio (standard: 1.0 corresponds to 1:1)."}, {"name": "clock", "type": "Bool", "description": "Output changes with defined frequency."}, {"name": "countdown", "type": "Time", "description": "Remaining time of the current `clock` state."}], "input": [{"name": "frequency", "type": "Real", "description": "Clock frequency in Hz."}, {"name": "pulsePauseRatio", "type": "Real", "description": "Pulse pause ratio (standard: 1.0 corresponds to 1:1)."}], "output": [{"name": "clock", "type": "Bool", "description": "Output changes with defined frequency."}, {"name": "countdown", "type": "Time", "description": "Remaining time of the current `clock` state."}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_Frequency\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_Frequency\n   VAR_INPUT \n      frequency : Real := 0.0;\n      pulsePauseRatio : Real := 1.0;\n   END_VAR\n\n   VAR_OUTPUT \n      clock { ExternalWritable := 'False'} : Bool;\n      countdown { ExternalWritable := 'False'} : Time;\n   END_VAR\n\n   VAR \n      instTofTimePulse {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TOF_TIME;\n      instTofTimePause {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TOF_TIME;\n      statFrequencyOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;\n      statPulsePauseRatioOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;\n      statTimePulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;\n      statTimePause { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;\n   END_VAR\n\n   VAR_TEMP \n      tempPulseRate : Real;\n      tempPauseRate : Real;\n      tempCountdown : Time;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : Real := 0.0;\n      ZERO_TIME : Time := T#0ms;\n      SECOND_IN_MS : Real := 1000.0;\n      ONE : Real := 1.0;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_Frequency\n\t  // Comment/Function: This function generates a signal that changes between the values `FALSE` and `TRUE` depending on a defined frequency and a pulse pause ratio.\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.01.00 25.05.2016  Siemens Industry Online Support\n\t  //                      New function: pulse pause ratio\n\t  // 01.01.01 26.05.2016  Siemens Industry Online Support\n\t  //                      Add comments\n\t  // 01.01.02 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.01.03 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.01.04 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.07 20.09.2019  Simatic Systems Support\n\t  //                      Code refactoring, regions and more comments added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Calculation of settings and program execution\n\t  // If input <= 0.0 the block is disabled\n\t  IF (#frequency <= #ZERO) OR (#pulsePauseRatio <= #ZERO) THEN\n\t    #clock := FALSE;\n\t    #tempCountdown := #ZERO_TIME;\n\t  ELSE\n\t    \n\t    //Calculating function frequency and pulse pause ratio only when an input is changed\n\t    IF #statFrequencyOld <> #frequency OR #statPulsePauseRatioOld <> #pulsePauseRatio THEN\n\t      RESET_TIMER(TIMER := #instTofTimePause);\n\t      RESET_TIMER(TIMER := #instTofTimePulse);\n\t      \n\t      #tempPulseRate := #pulsePauseRatio / (#pulsePauseRatio + #ONE); // Calculate pulse rate   \n\t      #tempPauseRate := #ONE - #tempPulseRate;                      // Calculate pause rate   \n\t      #statTimePulse := UDINT_TO_TIME(REAL_TO_UDINT((#SECOND_IN_MS * #tempPulseRate / #frequency))); // Calculate pulse time   \n\t      #statTimePause := UDINT_TO_TIME(REAL_TO_UDINT((#SECOND_IN_MS * #tempPauseRate / #frequency))); // Calculate pause time\n\t      #statFrequencyOld := #frequency;\n\t      #statPulsePauseRatioOld := #pulsePauseRatio;\n\t    END_IF;\n\t    \n\t    //Two time off-delay timers that are resetting each other on expiration\n\t    #instTofTimePulse(IN := NOT #instTofTimePause.Q,\n\t                      PT := #statTimePulse);\n\t    \n\t    //If timer for pulse is running, remaining time of the PULSE is calculated\n\t    #tempCountdown := #statTimePulse - #instTofTimePulse.ET;\n\t    \n\t    #instTofTimePause(IN := #instTofTimePulse.Q,\n\t                      PT := #statTimePause);\n\t    \n\t    //If timer for pulse is NOT running, remaining time of the PAUSE is calculated\n\t    IF #tempCountdown = #ZERO_TIME THEN\n\t      #tempCountdown := #statTimePause - #instTofTimePause.ET;\n\t    END_IF;\n\t    \n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t  // Assigning value of the pulse timer to the clock output\n\t  #clock := #instTofTimePulse.Q;\n\t  #countdown := #tempCountdown;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "Impulse", "description": "This function generates pulses at a given frequency. The pulse is always present for one (control) cycle.", "type": "FUNCTION_BLOCK", "name": "LGF_Impulse", "vars": [{"name": "frequency", "type": "Real", "description": "Clock frequency in Hz"}, {"name": "impulse", "type": "Bool", "description": "Impulse signal output"}, {"name": "countdown", "type": "Time", "description": "Time until next pulse"}], "input": [{"name": "frequency", "type": "Real", "description": "Clock frequency in Hz"}], "output": [{"name": "impulse", "type": "Bool", "description": "Impulse signal output"}, {"name": "countdown", "type": "Time", "description": "Time until next pulse"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_Impulse\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_Impulse\n   VAR_INPUT \n      frequency : Real;\n   END_VAR\n\n   VAR_OUTPUT \n      impulse { ExternalWritable := 'False'} : Bool;\n      countdown { ExternalWritable := 'False'} : Time;\n   END_VAR\n\n   VAR \n      instTofTimePulse {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TOF_TIME;\n      statFrequencyOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;\n      statTimePulse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;\n   END_VAR\n\n   VAR_TEMP \n      tempImpulse : Bool;\n      tempCountdown : Time;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : Real := 0.0;\n      ZERO_TIME : Time := T#0ms;\n      THOUSAND : Real := 1000.0;\n      THOUSAND_SECONDS : Time := t#1000s;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_Impulse\n\t  // Comment/Function: This function generates pulses at a given frequency. The pulse is always present for one (control) cycle.\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.01.01 16.06.2015  Siemens Industry Online Support\n\t  //                      LGF_Impulse calls new LGF_Frequency V1.1.1\n\t  // 01.01.02 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.02.00 02.02.2017  Siemens Industry Online Support\n\t  //                      Code optimization: no call of LGF_Frequency\n\t  //                      Fix at output \"countdown\"\n\t  // 01.02.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.02.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.02.04 20.09.2019  Simatic Systems Support\n\t  //                      Code refactoring, regions and more comments added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Calculation of settings and program execution\n\t  // If input <= 0.0 the block is disabled\n\t  IF #frequency <= #ZERO THEN\n\t    #tempImpulse := FALSE;\n\t    #tempCountdown := #ZERO_TIME;\n\t  ELSE\n\t    ////Calculating function frequency parameters - only when the input is changed\n\t    IF #frequency <> #statFrequencyOld THEN\n\t      // Assign frequency - convert frequency to period\n\t      #statTimePulse := #THOUSAND_SECONDS / TRUNC(#frequency * #THOUSAND);\n\t      #statFrequencyOld := #frequency;\n\t    END_IF;\n\t    \n\t    // Assign impulse\n\t    #tempImpulse := NOT #instTofTimePulse.Q;\n\t    \n\t    //Self-restarting timer, with time calculated from the frequency input\n\t    #instTofTimePulse(IN := NOT #instTofTimePulse.Q,\n\t                      PT := #statTimePulse);\n\t    \n\t    // Assign countdown\n\t    #tempCountdown := #statTimePulse - #instTofTimePulse.ET;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t  // Assigning value of the pulse to the output\n\t  #impulse := #tempImpulse;\n\t  #countdown := #tempCountdown;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "RectangleCI", "description": "This function generates a rectangular signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.", "type": "FUNCTION_BLOCK", "name": "LGF_RectangleCI", "vars": [{"name": "amplitude", "type": "Real", "description": "Amplitude of the signal profile."}, {"name": "offset", "type": "Real", "description": "Offset of the signal profile in the Y-direction."}, {"name": "periode", "type": "UDInt", "description": "Period duration of the signal profile in [ms]"}, {"name": "phaseShift", "type": "Real", "description": "Phase offset in [ms]"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling cyclic interrupt OB"}, {"name": "reset", "type": "Bool", "description": "Reset of the signal profile."}, {"name": "value", "type": "Real", "description": "Current value of the rectangular signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [{"name": "amplitude", "type": "Real", "description": "Amplitude of the signal profile."}, {"name": "offset", "type": "Real", "description": "Offset of the signal profile in the Y-direction."}, {"name": "periode", "type": "UDInt", "description": "Period duration of the signal profile in [ms]"}, {"name": "phaseShift", "type": "Real", "description": "Phase offset in [ms]"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling cyclic interrupt OB"}, {"name": "reset", "type": "Bool", "description": "Reset of the signal profile."}], "output": [{"name": "value", "type": "Real", "description": "Current value of the rectangular signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_RectangleCI\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_RectangleCI\n   VAR_INPUT \n      amplitude : Real := 1.0;\n      offset : Real;\n      periode : UDInt := 1000;\n      phaseShift : Real;\n      callOB : OB_CYCLIC;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      value { ExternalWritable := 'False'} : Real;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := 16#0;\n      subFunctionStatus { ExternalWritable := 'False'} : Word := 16#0;\n   END_VAR\n\n   VAR \n      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n   END_VAR\n\n   VAR_TEMP \n      tempCycleTime : UDInt;\n      tempCyclePhase : UDInt;\n      tempCycleStatus : Word;\n      tempReadTimeStatus : Int;\n      tempValue : Real;\n      tempPhaseShift : UDInt;\n   END_VAR\n\n   VAR CONSTANT \n      SECOND_IN_MS : UDInt := 1000;\n      ZERO : Int := 0;\n      RATIO : UDInt := 2;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      QRY_CINT_OB_UNAVAILABLE : Word := 16#0000;\n      ERR_OB_UNAVAILABLE : Word := 16#8600;\n      ERR_QRY_CINT : Word := 16#8601;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_RectangleCI\n\t  // Comment/Function: This function generates a rectangular signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.03 26.09.2019  Simatic Systems Support\n\t  //                      Code refactoring, regions and more comments added\n\t  //                      phase shift availability added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Get sample time\n\t  // get sample time, according to the cyclic interrupt OB number\n\t  #tempReadTimeStatus := QRY_CINT(OB_NR := #callOB, CYCLE => #tempCycleTime,\n\t                                  PHASE => #tempCyclePhase, STATUS => #tempCycleStatus);\n\t  \n\t  REGION Error handling\n\t    // Generate error message of the QRY_CINT function\n\t    IF #tempReadTimeStatus <> #ZERO THEN\n\t      #error := TRUE;\n\t      #status := #ERR_QRY_CINT;\n\t      #subFunctionStatus := INT_TO_WORD(#tempReadTimeStatus);\n\t      #value := #ZERO;\n\t      RETURN;\n\t      \n\t      // Generate error message when OB unavailable\n\t    ELSIF (#tempCycleStatus = #QRY_CINT_OB_UNAVAILABLE) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_OB_UNAVAILABLE;\n\t      #subFunctionStatus := #SUB_STATUS_NO_ERROR;\n\t      #value := #ZERO;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\tEND_REGION\n\t\n\tREGION Caluclations and outputs assigment\n\t  // calculate true phase shift with modulo\n\t  #tempPhaseShift := REAL_TO_UDINT(#phaseShift) MOD #periode;\n\t  \n\t  IF #reset THEN\n\t    #statCounter := #tempPhaseShift;\n\t    #tempValue := #ZERO;\n\t  ELSE\n\t    // Increment Counter with each call of \"OB_Cyclic_interrupt\"\n\t    #statCounter += #tempCycleTime / #SECOND_IN_MS;\n\t    #statCounter := #statCounter MOD #periode;\n\t    \n\t    // Calculate output value\n\t    #tempValue := #offset;\n\t    \n\t    IF (#statCounter >= #tempPhaseShift) AND (#statCounter < (#periode / #RATIO) + #tempPhaseShift) THEN\n\t      #tempValue += #amplitude;\n\t    ELSE\n\t      #tempValue -= #amplitude;\n\t    END_IF;\n\t  END_IF;\n\t  \n\t  #value := #tempValue;\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subFunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "SawToothCI", "description": "This function generates a sawtooth-shaped signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.", "type": "FUNCTION_BLOCK", "name": "LGF_SawToothCI", "vars": [{"name": "amplitude", "type": "Real", "description": "Amplitude of the signal profile."}, {"name": "offset", "type": "Real", "description": "Offset of the signal profile in the Y-direction."}, {"name": "periode", "type": "UDInt", "description": "Period duration of the signal profile in [ms]"}, {"name": "phaseShift", "type": "Real", "description": "Phase offset in [ms]"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling cyclic interrupt OB"}, {"name": "reset", "type": "Bool", "description": "Reset of the signal profile."}, {"name": "value", "type": "Real", "description": "Current value of the sawtooth signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [{"name": "amplitude", "type": "Real", "description": "Amplitude of the signal profile."}, {"name": "offset", "type": "Real", "description": "Offset of the signal profile in the Y-direction."}, {"name": "periode", "type": "UDInt", "description": "Period duration of the signal profile in [ms]"}, {"name": "phaseShift", "type": "Real", "description": "Phase offset in [ms]"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling cyclic interrupt OB"}, {"name": "reset", "type": "Bool", "description": "Reset of the signal profile."}], "output": [{"name": "value", "type": "Real", "description": "Current value of the sawtooth signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_SawToothCI\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_SawToothCI\n   VAR_INPUT \n      amplitude : Real := 1.0;\n      offset : Real;\n      periode : UDInt := 1000;\n      phaseShift : Real;\n      callOB : OB_CYCLIC;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      value { ExternalWritable := 'False'} : Real;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      subFunctionStatus { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR \n      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n   END_VAR\n\n   VAR_TEMP \n      tempCycleTime : UDInt;\n      tempCyclePhase : UDInt;\n      tempCycleStatus : Word;\n      tempReadTimeStatus : Int;\n      tempValue : Real;\n      tempPhaseShift : Real;\n   END_VAR\n\n   VAR CONSTANT \n      SECOND_IN_MS : UDInt := 1000;\n      ZERO : Int := 0;\n      SLOPE : Real := 2.0;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      QRY_CINT_OB_UNAVAILABLE : Word := 16#0000;\n      ERR_OB_UNAVAILABLE : Word := 16#8600;\n      ERR_QRY_CINT : Word := 16#8601;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Siemens AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_SawToothCl - Cyclic Interupt\n\t  // Comment/Function: This function generates a sawtooth-shaped signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.06 23.09.2019  Simatic Systems Support\n\t  //                      Code refactoring, regions and more comments added\n\t  //                      phase shift availability added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Get sample time\n\t  //get sample time, according to the cyclic interrupt OB number\n\t  #tempReadTimeStatus := QRY_CINT(OB_NR := #callOB, CYCLE => #tempCycleTime,\n\t                                  PHASE => #tempCyclePhase, STATUS => #tempCycleStatus);\n\t  \n\t  REGION Error handling\n\t    // Generate error message of the return value of QRY_CINT function\n\t    IF #tempReadTimeStatus <> #ZERO THEN\n\t      #error := TRUE;\n\t      #status := #ERR_QRY_CINT;\n\t      #subFunctionStatus := INT_TO_WORD(#tempReadTimeStatus);\n\t      #value := #ZERO;\n\t      RETURN;\n\t      \n\t      // Generate error message when OB unavailable\n\t    ELSIF (#tempCycleStatus = #QRY_CINT_OB_UNAVAILABLE) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_OB_UNAVAILABLE;\n\t      #subFunctionStatus := #SUB_STATUS_NO_ERROR;\n\t      #value := #ZERO;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\tEND_REGION\n\t\n\tREGION Caluclations AND outputs assigment  \n\t  IF #reset THEN\n\t    #statCounter := 0;\n\t    #tempValue := #ZERO;\n\t  ELSE\n\t    // Increment Counter with each call of \"OB_Cyclic_interrupt\"\n\t    #statCounter += #tempCycleTime / #SECOND_IN_MS;\n\t    #statCounter := #statCounter MOD #periode;\n\t    \n\t    // calculate true phase shift with modulo\n\t    #tempPhaseShift := UDINT_TO_REAL((#statCounter + REAL_TO_UDINT(#phaseShift)) MOD #periode);\n\t    \n\t    // formula to calculate saw tooth\n\t    #tempValue := #SLOPE * #amplitude / UDINT_TO_REAL(#periode) * #tempPhaseShift - #amplitude;\n\t  END_IF;\n\t  \n\t  #value := #tempValue + #offset;\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subFunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "SinusCI", "description": "This function generates a sinusoidal signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.", "type": "FUNCTION_BLOCK", "name": "LGF_SinusCI", "vars": [{"name": "amplitude", "type": "Real", "description": "Amplitude of the signal profile."}, {"name": "offset", "type": "Real", "description": "Offset of the signal profile in the Y-direction."}, {"name": "periode", "type": "UDInt", "description": "Period duration of the signal profile in [ms]"}, {"name": "phaseShift", "type": "Real", "description": "Phase offset in [ms]"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling cyclic interrupt OB"}, {"name": "reset", "type": "Bool", "description": "Reset of the signal profile."}, {"name": "value", "type": "Real", "description": "Current value of the sinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [{"name": "amplitude", "type": "Real", "description": "Amplitude of the signal profile."}, {"name": "offset", "type": "Real", "description": "Offset of the signal profile in the Y-direction."}, {"name": "periode", "type": "UDInt", "description": "Period duration of the signal profile in [ms]"}, {"name": "phaseShift", "type": "Real", "description": "Phase offset in [ms]"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling cyclic interrupt OB"}, {"name": "reset", "type": "Bool", "description": "Reset of the signal profile."}], "output": [{"name": "value", "type": "Real", "description": "Current value of the sinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_SinusCI\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_SinusCI\n   VAR_INPUT \n      amplitude : Real := 1.0;\n      offset : Real;\n      periode : UDInt := 1000;\n      phaseShift : Real;\n      callOB : OB_CYCLIC;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      value { ExternalWritable := 'False'} : Real;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      subFunctionStatus { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR \n      statRad { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;\n      statPhaseShift { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real := 0.0;\n      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n   END_VAR\n\n   VAR_TEMP \n      tempCycleTime : UDInt;\n      tempCyclePhase : UDInt;\n      tempCycleStatus : Word;\n      tempReadTimeStatus : Int;\n   END_VAR\n\n   VAR CONSTANT \n      SECOND_IN_MS : UDInt := 1000;\n      ZERO : Int := 0;\n      SLOPE : Int := 2;\n      TWO_PI : Real := 6.283185;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      QRY_CINT_OB_UNAVAILABLE : Word := 16#0000;\n      ERR_OB_UNAVAILABLE : Word := 16#8600;\n      ERR_QRY_CINT : Word := 16#8601;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_SinusCI\n\t  // Comment/Function: This function generates a sinusoidal signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.03 26.09.2019  Simatic Systems Support\n\t  //                      Code refactoring, regions and more comments added\n\t  //                      phase shift availability added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  // 03.00.02 15.12.2023  Simatic Systems Support\n\t  //                      Fix callculation of 'phaseShift'\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Get sample time\n\t  // get sample time, according to the cyclic interrupt OB number\n\t  #tempReadTimeStatus := QRY_CINT(OB_NR := #callOB, CYCLE => #tempCycleTime,\n\t                                  PHASE => #tempCyclePhase, STATUS => #tempCycleStatus);\n\t  \n\t  REGION Error handling\n\t    // Generate error message of the QRY_CINT function\n\t    IF #tempReadTimeStatus <> #ZERO THEN\n\t      #error := TRUE;\n\t      #status := #ERR_QRY_CINT;\n\t      #subFunctionStatus := INT_TO_WORD(#tempReadTimeStatus);\n\t      #value := #ZERO;\n\t      RETURN;\n\t      \n\t      // Generate error message when OB unavailable\n\t    ELSIF (#tempCycleStatus = #QRY_CINT_OB_UNAVAILABLE) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_OB_UNAVAILABLE;\n\t      #subFunctionStatus := #SUB_STATUS_NO_ERROR;\n\t      #value := #ZERO;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\tEND_REGION\n\t\n\tREGION Caluclations and outputs assigment\n\t  IF #reset THEN\n\t    #statCounter := 0;\n\t    #value := #ZERO;\n\t  ELSE\n\t    // Increment Counter with each call of \"OB_Cyclic_interrupt\"\n\t    #statCounter += (#tempCycleTime) / #SECOND_IN_MS;\n\t    #statCounter := #statCounter MOD (#periode);\n\t    \n\t    // Transfer to radians\n\t    #statRad := UDINT_TO_REAL(#statCounter) * #TWO_PI / (UDINT_TO_REAL(#periode));\n\t    #statPhaseShift := (#phaseShift * #TWO_PI) / UDINT_TO_REAL(#periode);\n\t    \n\t    // Calculate output value\n\t    #value := SIN(#statRad + #statPhaseShift) * #amplitude + #offset;\n\t  END_IF;\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subFunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "TriangleCI", "description": "This function generates a triangular signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.", "type": "FUNCTION_BLOCK", "name": "LGF_TriangleCI", "vars": [{"name": "amplitude", "type": "Real", "description": "Amplitude of the signal profile."}, {"name": "offset", "type": "Real", "description": "Offset of the signal profile in the Y-direction."}, {"name": "periode", "type": "UDInt", "description": "Period duration of the signal profile in [ms]"}, {"name": "phaseShift", "type": "Real", "description": "Phase offset in [ms]"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling cyclic interrupt OB"}, {"name": "reset", "type": "Bool", "description": "Reset of the signal profile."}, {"name": "value", "type": "Real", "description": "Current value of the triangular signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [{"name": "amplitude", "type": "Real", "description": "Amplitude of the signal profile."}, {"name": "offset", "type": "Real", "description": "Offset of the signal profile in the Y-direction."}, {"name": "periode", "type": "UDInt", "description": "Period duration of the signal profile in [ms]"}, {"name": "phaseShift", "type": "Real", "description": "Phase offset in [ms]"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling cyclic interrupt OB"}, {"name": "reset", "type": "Bool", "description": "Reset of the signal profile."}], "output": [{"name": "value", "type": "Real", "description": "Current value of the triangular signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_TriangleCI\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_TriangleCI\n   VAR_INPUT \n      amplitude : Real := 1.0;\n      offset : Real;\n      periode : UDInt := 1000;\n      phaseShift : Real;\n      callOB : OB_CYCLIC;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      value { ExternalWritable := 'False'} : Real;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := 16#0;\n      subFunctionStatus { ExternalWritable := 'False'} : Word := 16#0;\n   END_VAR\n\n   VAR \n      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n   END_VAR\n\n   VAR_TEMP \n      tempCycleTime : UDInt;\n      tempCyclePhase : UDInt;\n      tempCycleStatus : Word;\n      tempReadTimeStatus : Int;\n      tempValue : Real;\n      tempPhaseShift : Real;\n   END_VAR\n\n   VAR CONSTANT \n      SECOND_IN_MS : UDInt := 1000;\n      ZERO : Int := 0;\n      SLOPE : Real := 4.0;\n      NEGATIVE_LINE_Y_OFFSET : Real := 2.0;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      QRY_CINT_OB_UNAVAILABLE : Word := 16#0000;\n      ERR_OB_UNAVAILABLE : Word := 16#8600;\n      ERR_QRY_CINT : Word := 16#8601;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_TriangleCI\n\t  // Comment/Function: This function generates a triangular signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.03 26.09.2019  Simatic Systems Support\n\t  //                      Code refactoring, regions and more comments added\n\t  //                      phase shift availability added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Get sample time\n\t  // get sample time, according to the cyclic interrupt OB number\n\t  #tempReadTimeStatus := QRY_CINT(OB_NR := #callOB, CYCLE => #tempCycleTime,\n\t                                  PHASE => #tempCyclePhase, STATUS => #tempCycleStatus);\n\t  \n\t  REGION Error handling\n\t    // Generate error message of the QRY_CINT function\n\t    IF #tempReadTimeStatus <> #ZERO THEN\n\t      #error := TRUE;\n\t      #status := #ERR_QRY_CINT;\n\t      #subFunctionStatus := INT_TO_WORD(#tempReadTimeStatus);\n\t      #value := #ZERO;\n\t      RETURN;\n\t      \n\t      // Generate error message when OB unavailable\n\t    ELSIF (#tempCycleStatus = #QRY_CINT_OB_UNAVAILABLE) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_OB_UNAVAILABLE;\n\t      #subFunctionStatus := #SUB_STATUS_NO_ERROR;\n\t      #value := #ZERO;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\tEND_REGION\n\t\n\tREGION Caluclations and outputs assigment  \n\t  IF #reset THEN\n\t    #statCounter := 0;\n\t    #tempValue := #ZERO;\n\t  ELSE\n\t    // Increment Counter with each call of \"OB_Cyclic_interrupt\"\n\t    #statCounter += #tempCycleTime / #SECOND_IN_MS;\n\t    #statCounter := #statCounter MOD #periode;\n\t    \n\t    // calculate true phase shift with modulo\n\t    #tempPhaseShift := UDINT_TO_REAL((#statCounter + REAL_TO_UDINT(#phaseShift)) MOD #periode);\n\t    \n\t    // formula to calculate triangle\n\t    #tempValue := ABS((#SLOPE / UDINT_TO_REAL(#periode) * #tempPhaseShift - #NEGATIVE_LINE_Y_OFFSET) * #amplitude) - #amplitude;\n\t  END_IF;\n\t  \n\t  // write Output value\n\t  #value := #tempValue + #offset;\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subFunctionStatus := #STATUS_FINISHED_NO_ERROR;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "LimRateOfChangeAdvancedCI", "description": "The function LGF_LimRateOfChangeAdvanced limits the rate of change of an input variable. Jump functions become ramp functions. In addition, the block has various operating modes.", "type": "FUNCTION_BLOCK", "name": "LGF_LimRateOfChangeAdvancedCI", "vars": [{"name": "autoValue", "type": "LReal", "description": "Signal to be processed and limited in its rate of change"}, {"name": "manualValue", "type": "LReal", "description": "Manually controlled output value\n(`outputValue` = `manualValue`)"}, {"name": "setPosUpRateLim", "type": "LReal", "description": "Rate of change per second for the rising ramp in the\npositive value range (1/second)"}, {"name": "setPosDownRateLim", "type": "LReal", "description": "Rate of change per second for the falling ramp in the\npositive value range (1/second)"}, {"name": "setNegUpRateLim", "type": "LReal", "description": "Rate of change per second for the rising ramp in the\nnegative value range (1/second)"}, {"name": "setNegDownRateLim", "type": "LReal", "description": "Rate of change per second for the falling ramp in the\nnegative value range (1/second)"}, {"name": "setHighLim", "type": "LReal", "description": "High limit value"}, {"name": "setLowLim", "type": "LReal", "description": "Low limit value"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable\n(`outputValue` = `defaultOutValue`)"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value\n(`outputValue` = `defaultOutValue`)"}, {"name": "track", "type": "Bool", "description": "Follow / tracking of Input variable\n(`outputValue` = `autoValue`)"}, {"name": "manOp", "type": "Bool", "description": "Manual mode on\n(`outputValue` = `manualValue`)"}, {"name": "reset", "type": "Bool", "description": "Complete restart of function"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB (cyclic interrupt OB)"}, {"name": "outputValue", "type": "LReal", "description": "Output variable"}, {"name": "posUpRateLim", "type": "Bool", "description": "Rise limitation in positive range tripped"}, {"name": "posDownRateLim", "type": "Bool", "description": "Down rate limit in positive range reached"}, {"name": "negUpRateLim", "type": "Bool", "description": "Up rate limit in negative range reached"}, {"name": "negDownRateLim", "type": "Bool", "description": "Down rate limit in negative range reached"}, {"name": "highLim", "type": "Bool", "description": "High limit reached"}, {"name": "lowLim", "type": "Bool", "description": "Low limit reached"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [{"name": "autoValue", "type": "LReal", "description": "Signal to be processed and limited in its rate of change"}, {"name": "manualValue", "type": "LReal", "description": "Manually controlled output value\n(`outputValue` = `manualValue`)"}, {"name": "setPosUpRateLim", "type": "LReal", "description": "Rate of change per second for the rising ramp in the\npositive value range (1/second)"}, {"name": "setPosDownRateLim", "type": "LReal", "description": "Rate of change per second for the falling ramp in the\npositive value range (1/second)"}, {"name": "setNegUpRateLim", "type": "LReal", "description": "Rate of change per second for the rising ramp in the\nnegative value range (1/second)"}, {"name": "setNegDownRateLim", "type": "LReal", "description": "Rate of change per second for the falling ramp in the\nnegative value range (1/second)"}, {"name": "setHighLim", "type": "LReal", "description": "High limit value"}, {"name": "setLowLim", "type": "LReal", "description": "Low limit value"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable\n(`outputValue` = `defaultOutValue`)"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value\n(`outputValue` = `defaultOutValue`)"}, {"name": "track", "type": "Bool", "description": "Follow / tracking of Input variable\n(`outputValue` = `autoValue`)"}, {"name": "manOp", "type": "Bool", "description": "Manual mode on\n(`outputValue` = `manualValue`)"}, {"name": "reset", "type": "Bool", "description": "Complete restart of function"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB (cyclic interrupt OB)"}], "output": [{"name": "outputValue", "type": "LReal", "description": "Output variable"}, {"name": "posUpRateLim", "type": "Bool", "description": "Rise limitation in positive range tripped"}, {"name": "posDownRateLim", "type": "Bool", "description": "Down rate limit in positive range reached"}, {"name": "negUpRateLim", "type": "Bool", "description": "Up rate limit in negative range reached"}, {"name": "negDownRateLim", "type": "Bool", "description": "Down rate limit in negative range reached"}, {"name": "highLim", "type": "Bool", "description": "High limit reached"}, {"name": "lowLim", "type": "Bool", "description": "Low limit reached"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_LimRateOfChangeAdvancedCI\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_LimRateOfChangeAdvancedCI\n   VAR_INPUT \n      autoValue : LReal;\n      manualValue : LReal;\n      setPosUpRateLim : LReal;\n      setPosDownRateLim : LReal;\n      setNegUpRateLim : LReal;\n      setNegDownRateLim : LReal;\n      setHighLim : LReal;\n      setLowLim : LReal;\n      defaultOutValue : LReal;\n      enDefaultOutValue : Bool;\n      track : Bool;\n      manOp : Bool;\n      reset : Bool;\n      callOB : OB_CYCLIC;\n   END_VAR\n\n   VAR_OUTPUT \n      outputValue { ExternalWritable := 'False'} : LReal;\n      posUpRateLim { ExternalWritable := 'False'} : Bool;\n      posDownRateLim { ExternalWritable := 'False'} : Bool;\n      negUpRateLim { ExternalWritable := 'False'} : Bool;\n      negDownRateLim { ExternalWritable := 'False'} : Bool;\n      highLim { ExternalWritable := 'False'} : Bool;\n      lowLim { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      subfunctionStatus { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR \n      statPrevOutputValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 0.0;\n      statManOp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR_TEMP \n      tempPosUp : Bool;\n      tempPosDown : Bool;\n      tempNegUp : Bool;\n      tempNegDown : Bool;\n      tempHighLim : Bool;\n      tempLowLim : Bool;\n      tempCycleReal : LReal;\n      tempOutv : LReal;\n      tempVar : LReal;\n      tempCycleTime : UDInt;\n      tempCyclePhase : UDInt;\n      tempCycleStatus : Word;\n      tempReadTimeStatus : Int;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_INT : Int := 0;\n      ZERO_REAL : LReal := 0.0;\n      SECOND_IN_MICROSECONDS : LReal := 1000000.0;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_NEG_RATE_LIM : Word := 16#8200;\n      ERR_NEG_RATE_OF_CHANGE : Word := 16#8202;\n      ERR_QRY_CINT : Word := 16#8600;\n      ERR_OB_UNAVAILABLE : Word := 16#8601;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_LimRateOfChangeAdvancedCI\n\t  // Comment/Function: Generates a ramp function from a step function.\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 21.06.2016  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.02 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.03 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.07 15.11.2019  Simatic Systems Support\n\t  //                      Regions, comments and constants are added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 22.03.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization\n\t  #tempPosUp := FALSE;\n\t  #tempPosDown := FALSE;\n\t  #tempNegUp := FALSE;\n\t  #tempNegDown := FALSE;\n\t  #tempHighLim := FALSE;\n\t  #tempLowLim := FALSE;\n\t  #tempOutv := #autoValue;\n\t  \n\t  // get sample time, according to the cyclic interrupt OB number\n\t  #tempReadTimeStatus := QRY_CINT(OB_NR := #callOB, CYCLE => #tempCycleTime, PHASE => #tempCyclePhase, STATUS => #tempCycleStatus);\n\t  #tempCycleReal := UDINT_TO_REAL(#tempCycleTime) / #SECOND_IN_MICROSECONDS; // Time in seconds\n\tEND_REGION\n\t\n\tREGION Validation\n\t  // Generate error message of the QRY_CINT function\n\t  IF (#tempReadTimeStatus <> #ZERO_INT) THEN\n\t    #error := TRUE;\n\t    #subfunctionStatus := INT_TO_WORD(#tempReadTimeStatus);\n\t    #status := #ERR_QRY_CINT;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Generate error message when OB unavailable\n\t  IF #tempCycleStatus = #SUB_STATUS_NO_ERROR THEN\n\t    #error := TRUE;\n\t    #status := #ERR_OB_UNAVAILABLE;\n\t    #subfunctionStatus := #STATUS_FINISHED_NO_ERROR;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  //Check high with low limit\n\t  IF #setHighLim < #setLowLim THEN\n\t    #error := TRUE;\n\t    #status := #ERR_NEG_RATE_LIM;\n\t    #subfunctionStatus := #STATUS_FINISHED_NO_ERROR;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  //Check rate limits for negative values\n\t  IF (#setNegDownRateLim < #ZERO_REAL) OR (#setNegUpRateLim < #ZERO_REAL)\n\t    OR (#setPosDownRateLim < #ZERO_REAL) OR (#setPosUpRateLim < #ZERO_REAL) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_NEG_RATE_OF_CHANGE;\n\t    #subfunctionStatus := #STATUS_FINISHED_NO_ERROR;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Function processing\n\t  // RESTART\n\t  // reset manual mode flag \n\t  IF #reset THEN\n\t    #statManOp := FALSE;\n\t    IF #enDefaultOutValue THEN\n\t      // preset output\n\t      #tempOutv := #defaultOutValue;\n\t      // limitation of output\n\t      // High limitation\n\t      IF #tempOutv >= #setHighLim THEN\n\t        #tempOutv := #setHighLim;\n\t        #tempHighLim := TRUE;\n\t      END_IF;\n\t      \n\t      // Low limitation\n\t      IF #tempOutv <= #setLowLim THEN\n\t        #tempOutv := #setLowLim;\n\t        #tempLowLim := TRUE;\n\t      END_IF;\n\t    ELSE\n\t      // reset output\n\t      #tempOutv := #ZERO_REAL;\n\t    END_IF;\n\t  ELSE\n\t    // OPERATING MODES\n\t    // -------------------------------------------------------\n\t    IF #manOp THEN\n\t      //---// MANUAL MODE\n\t      // bumples switch between manual mode and auto mode\n\t      #tempOutv := #manualValue;\n\t      // Keep manual mode until setpoint in the space of low and high limit\n\t      #statManOp := TRUE;\n\t    ELSE\n\t      //---// AUTOMATIC MODE\n\t      IF #enDefaultOutValue THEN\n\t        // preset output by default value\n\t        #tempOutv := #defaultOutValue;\n\t      ELSE\n\t        IF #track THEN\n\t          // output has same value as input\n\t          #tempOutv := #autoValue;\n\t        ELSE\n\t          // REGULAR FUNCTION\n\t          // Negativ range\n\t          IF #statPrevOutputValue < #ZERO_INT THEN\n\t            IF #statPrevOutputValue > #autoValue THEN\n\t              // limited rate of change\n\t              #tempVar := #statPrevOutputValue - #setNegUpRateLim * #tempCycleReal;\n\t              IF #autoValue < #tempVar THEN\n\t                // Setpoint not reached yet\n\t                // set notification for up rate limit in neg range\n\t                #tempNegUp := TRUE;\n\t                #tempOutv := #tempVar;\n\t              END_IF;\n\t            ELSE\n\t              IF #setNegDownRateLim = #ZERO_REAL THEN\n\t                // set notification for down rate limit in neg range\n\t                #tempNegDown := TRUE;\n\t                IF #autoValue <= #ZERO_REAL THEN\n\t                  #tempOutv := #autoValue;\n\t                ELSE\n\t                  #tempOutv := #ZERO_REAL;\n\t                END_IF;\n\t              ELSE\n\t                IF #autoValue <= #ZERO_REAL THEN\n\t                  // limited rate of change\n\t                  #tempVar := #statPrevOutputValue + #setNegDownRateLim * #tempCycleReal;\n\t                  IF #autoValue > #tempVar THEN\n\t                    // set notification for down rate limit in neg range\n\t                    #tempNegDown := TRUE;\n\t                    #tempOutv := #tempVar;\n\t                  END_IF;\n\t                ELSE\n\t                  // changeover between neg. and pos. range\n\t                  // period till zero-crossing\n\t                  #tempVar := - #statPrevOutputValue / #setNegDownRateLim;\n\t                  \n\t                  IF #tempVar <= #tempCycleReal THEN\n\t                    // period till zero-crossing shorten than sample time\n\t                    // limited rate of change\n\t                    #tempVar := (#tempCycleReal - #tempVar) * #setPosUpRateLim;\n\t                    \n\t                    IF #autoValue > #tempVar THEN\n\t                      // set notification for rate limit \n\t                      #tempNegDown := FALSE;\n\t                      #tempPosUp := TRUE;\n\t                      #tempOutv := #tempVar;\n\t                    END_IF;\n\t                  ELSE\n\t                    // set notification for rate limit\n\t                    #tempNegDown := TRUE;\n\t                    #tempPosUp := FALSE;\n\t                    #tempOutv := #statPrevOutputValue + #tempCycleReal * #setNegDownRateLim;\n\t                  END_IF;\n\t                END_IF;\n\t              END_IF;\n\t            END_IF;\n\t          ELSE\n\t            // Positiv range + 0\n\t            IF #statPrevOutputValue < #autoValue THEN\n\t              // limited rate of change\n\t              #tempVar := #statPrevOutputValue + #setPosUpRateLim * #tempCycleReal;\n\t              IF #autoValue > #tempVar THEN\n\t                // set notification for up rate limit in pos range\n\t                #tempPosUp := TRUE;\n\t                #tempOutv := #tempVar;\n\t              END_IF;\n\t            END_IF;\n\t            \n\t            IF #statPrevOutputValue >= #autoValue THEN\n\t              IF #setPosDownRateLim = #ZERO_REAL THEN\n\t                // set notification for down rate limit in pos range\n\t                #tempPosDown := TRUE;\n\t                IF #autoValue >= #ZERO_REAL THEN\n\t                  #tempOutv := #autoValue;\n\t                ELSE\n\t                  #tempOutv := #ZERO_REAL;\n\t                END_IF;\n\t              ELSE\n\t                IF #autoValue >= #ZERO_REAL THEN\n\t                  // limited rate of change\n\t                  #tempVar := #statPrevOutputValue - #setPosDownRateLim * #tempCycleReal;\n\t                  IF #autoValue < #tempVar THEN\n\t                    // set notification for up rate limit in pos range\n\t                    #tempPosDown := TRUE;\n\t                    #tempOutv := #tempVar;\n\t                  END_IF;\n\t                ELSE  // changeover between pos. and neg. range\n\t                  // period till zero-crossing\n\t                  #tempVar := #statPrevOutputValue / #setPosDownRateLim;\n\t                  \n\t                  IF #tempVar <= #tempCycleReal THEN\n\t                    // limited rate of change\n\t                    #tempVar := - (#tempCycleReal - #tempVar) * #setNegUpRateLim;\n\t                    IF #autoValue < #tempVar THEN\n\t                      // set notification for rate limit\n\t                      #tempPosDown := False;\n\t                      #tempNegUp := TRUE;\n\t                      #tempOutv := #tempVar;\n\t                    END_IF;\n\t                  ELSE\n\t                    // set notification for rate limit\n\t                    #tempPosDown := TRUE;\n\t                    #tempNegUp := FALSE;\n\t                    #tempOutv := #statPrevOutputValue - #tempCycleReal * #setPosDownRateLim;\n\t                  END_IF;\n\t                END_IF;\n\t              END_IF;\n\t            END_IF;\n\t          END_IF;\n\t        END_IF;\n\t      END_IF;\n\t      \n\t      // high/low level limitation\n\t      IF #tempOutv >= #setHighLim THEN\n\t        #tempHighLim := TRUE;\n\t        IF NOT #statManOp THEN\n\t          #tempOutv := #setHighLim;\n\t          // correct up rate limit notification\n\t          IF #tempOutv - #statPrevOutputValue < #setPosUpRateLim * #tempCycleReal THEN\n\t            #tempPosUp := FALSE;\n\t          END_IF;\n\t        END_IF;\n\t      ELSE\n\t        IF #tempOutv <= #setLowLim THEN\n\t          #tempLowLim := TRUE;\n\t          IF NOT #statManOp THEN\n\t            #tempOutv := #setLowLim;\n\t            // correct up rate limit notification  \n\t            IF #statPrevOutputValue - #tempOutv < #setNegUpRateLim * #tempCycleReal THEN\n\t              #tempNegUp := FALSE;\n\t            END_IF;\n\t          END_IF;\n\t        ELSE\n\t          // reset manual mode flag when tempOutv between upper and lower limit\n\t          #statManOp := FALSE;\n\t        END_IF;\n\t      END_IF;\n\t    END_IF;\n\t  END_IF;\n\t  \n\t  #statPrevOutputValue := #tempOutv;\n\tEND_REGION\n\t\n\tREGION writting to outputs\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subfunctionStatus := #STATUS_FINISHED_NO_ERROR;\n\t  \n\t  #outputValue := #tempOutv;\n\t  #posUpRateLim := #tempPosUp;\n\t  #posDownRateLim := #tempPosDown;\n\t  #negUpRateLim := #tempNegUp;\n\t  #negDownRateLim := #tempNegDown;\n\t  #highLim := #tempHighLim;\n\t  #lowLim := #tempLowLim;\n\t  \n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "LimRateOfChangeCI", "description": "This function limits the rate of change of an input variable. A jump function becomes a ramp function.", "type": "FUNCTION_BLOCK", "name": "LGF_LimRateOfChangeCI", "vars": [{"name": "value", "type": "LReal", "description": "Signal to be processed and limited in its rate of change"}, {"name": "setChangeRate", "type": "LReal", "description": "Rate of change of ramp function (1/second)"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable\n(`outputValue` = `defaultOutValue`)"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value\n(`outputValue` = `defaultOutValue`)"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB (cyclic interrupt OB)"}, {"name": "delayedValue", "type": "LReal", "description": "Output variable"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [{"name": "value", "type": "LReal", "description": "Signal to be processed and limited in its rate of change"}, {"name": "setChangeRate", "type": "LReal", "description": "Rate of change of ramp function (1/second)"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable\n(`outputValue` = `defaultOutValue`)"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value\n(`outputValue` = `defaultOutValue`)"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB (cyclic interrupt OB)"}], "output": [{"name": "delayedValue", "type": "LReal", "description": "Output variable"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_LimRateOfChangeCI\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_LimRateOfChangeCI\n   VAR_INPUT \n      value : LReal;\n      setChangeRate : LReal;\n      defaultOutValue : LReal;\n      enDefaultOutValue : Bool;\n      callOB : OB_CYCLIC;\n   END_VAR\n\n   VAR_OUTPUT \n      delayedValue { ExternalWritable := 'False'} : LReal;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      subfunctionStatus { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR \n      statPrevOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempCycleTime : UDInt;\n      tempCyclePhase : UDInt;\n      tempCycleStatus : Word;\n      tempCycleTimeReal : LReal;\n      tempReadTimeStatus : Int;\n      tempOut : LReal;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_INT : Int := 0;\n      ZERO_REAL : LReal := 0.0;\n      SECOND_IN_MICROSECONDS : LReal := 1000000.0;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_NEG_RATE_LIM : Word := 16#8200;\n      ERR_QRY_CINT : Word := 16#8600;\n      ERR_OB_UNAVAILABLE : Word := 16#8601;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_LimRateOfChangeCI\n\t  // Comment/Function: Generates a ramp function from a step function.\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 21.06.2016  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.02 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.03 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.06 15.11.2019  Simatic Systems Support\n\t  //                      Regions, comments and constants are added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 22.03.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Read cycle time of the call OB\n\t  #tempReadTimeStatus := QRY_CINT(OB_NR := #callOB, CYCLE => #tempCycleTime, PHASE => #tempCyclePhase, STATUS => #tempCycleStatus);\n\t  #tempCycleTimeReal := UDINT_TO_REAL(#tempCycleTime) / #SECOND_IN_MICROSECONDS;\n\tEND_REGION\n\t\n\tREGION Validation\n\t  // Generate error message of the QRY_CINT function\n\t  IF (#tempReadTimeStatus <> #ZERO_INT) THEN\n\t    #error := TRUE;\n\t    #subfunctionStatus := INT_TO_WORD(#tempReadTimeStatus);\n\t    #status := #ERR_QRY_CINT;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Generate error message when OB unavailable\n\t  IF #tempCycleStatus = 0 THEN\n\t    #error := TRUE;\n\t    #status := #ERR_OB_UNAVAILABLE;\n\t    #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  //Check ChangeRate for negative value\n\t  IF #setChangeRate < #ZERO_REAL THEN\n\t    #error := TRUE;\n\t    #status := #ERR_NEG_RATE_LIM;\n\t    #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of rate of change\n\t  //Default value output option\n\t  IF #enDefaultOutValue THEN\n\t    #statPrevOut := #defaultOutValue;\n\t    #delayedValue := #defaultOutValue;\n\t    \n\t    #error := false;\n\t    #status := #STATUS_FINISHED_NO_ERROR;\n\t    #subfunctionStatus := #STATUS_FINISHED_NO_ERROR;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  #tempOut := #statPrevOut;\n\t  \n\t  // Ramp function\n\t  IF #value < #tempOut THEN\n\t    #tempOut := #tempOut - (#setChangeRate * #tempCycleTimeReal);\n\t    #tempOut := MAX(IN1 := #tempOut, IN2 := #value);\n\t    #statPrevOut := #tempOut;\n\t  ELSIF #value > #tempOut THEN\n\t    #tempOut := (#setChangeRate * #tempCycleTimeReal) + #tempOut;\n\t    #tempOut := MIN(IN1 := #tempOut, IN2 := #value);\n\t    #statPrevOut := #tempOut;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  #delayedValue := #tempOut;\n\t  \n\t  #error := false;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  \n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "NonLinearInterpolation", "description": "This function implements a characteristic curve. The characteristic curve is defined via an interpolation point table with linear interpolation between the interpolation points. A prescribed input value generates an output value in each cycle based on the characteristic curve from the interpolation point table.", "type": "FUNCTION_BLOCK", "name": "LGF_NonLinearInterpolation", "vars": [{"name": "value", "type": "LReal", "description": "Input value for calculating the output value over the\ndefined characteristic curve."}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable\n(`outputValue` = `defaultOutValue`)"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value\n(`outputValue` = `defaultOutValue`)"}, {"name": "track", "type": "Bool", "description": "The value of the output `outputValue` follows the value\nof the input `value` without using the characteristic\ncurve as long as this input is set. (`outputValue` =\n`value`)"}, {"name": "reset", "type": "Bool", "description": "If the interpolation point table is changed in running\noperation, the input `reset` must be activated\nafterwards. Otherwise, the block cannot guarantee\ncorrect execution.\n(`outputValue` = 0.0)"}, {"name": "outputValue", "type": "LReal", "description": "The output value that has been calculated from the input value over\nthe defined characteristic curve."}, {"name": "setpoints", "type": "Array[*] of LGF\n_typeNonLin\nSetpoints", "description": "Setpoint point table for defining the characteristic curve (polynomial)"}, {"name": "inputValue", "type": "LReal", "description": "Input value to be interpolated"}, {"name": "outputValue", "type": "LReal", "description": "Corresponding interpolated value"}], "input": [{"name": "value", "type": "LReal", "description": "Input value for calculating the output value over the\ndefined characteristic curve."}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable\n(`outputValue` = `defaultOutValue`)"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value\n(`outputValue` = `defaultOutValue`)"}, {"name": "track", "type": "Bool", "description": "The value of the output `outputValue` follows the value\nof the input `value` without using the characteristic\ncurve as long as this input is set. (`outputValue` =\n`value`)"}, {"name": "reset", "type": "Bool", "description": "If the interpolation point table is changed in running\noperation, the input `reset` must be activated\nafterwards. Otherwise, the block cannot guarantee\ncorrect execution.\n(`outputValue` = 0.0)"}], "output": [{"name": "outputValue", "type": "LReal", "description": "The output value that has been calculated from the input value over\nthe defined characteristic curve."}], "in/out": [{"name": "setpoints", "type": "Array[*] of LGF\n_typeNonLin\nSetpoints", "description": "Setpoint point table for defining the characteristic curve (polynomial)"}], "answer": "FUNCTION_BLOCK \"LGF_NonLinearInterpolation\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_NonLinearInterpolationCI\n   VAR_INPUT \n      value : LReal;\n      defaultOutValue : LReal;\n      enDefaultOutValue : Bool;\n      track : Bool;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      outputValue { ExternalWritable := 'False'} : LReal;\n   END_VAR\n\n   VAR_IN_OUT \n      setpoints : Array[*] of \"LGF_typeNonLinSetpoints\";\n   END_VAR\n\n   VAR \n      statIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n   END_VAR\n\n   VAR_TEMP \n      tempValue : LReal;\n      tempEndOfSearch : Bool;\n      tempInputValueStart : LReal;\n      tempInputValueEnd : LReal;\n      tempOutputValueStart : LReal;\n      tempOutputValueEnd : LReal;\n      tempFactor : LReal;\n      tempLowerBound : Int;\n      tempUpperBound : Int;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : Int := 0;\n      SHIFT_STAT_INDEX_BY_ONE : Int := 1;\n      DIMENSION_ONE : UDInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_NonLinearInterpolation\n\t  // Comment/Function: Interpolates a charachteristic curve via pre-defined array of setpoints.\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 04.01.2017  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.06 15.11.2019  Simatic Systems Support\n\t  //                      Regions, comments and constants are added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 22.03.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization\n\t  #tempValue := #value;\n\t  //Call \"LOWER_BOUND\" and \"UPPER_BOUND\" for the setpoints\n\t  #tempLowerBound := DINT_TO_INT(LOWER_BOUND(ARR := #setpoints, DIM := #DIMENSION_ONE));\n\t  #tempUpperBound := DINT_TO_INT(UPPER_BOUND(ARR := #setpoints, DIM := #DIMENSION_ONE));\n\t  \n\t  //Check index value\n\t  IF (#statIndex < #tempLowerBound) OR (#statIndex > #tempUpperBound) OR (#statIndex = #ZERO) THEN\n\t    #statIndex := #tempLowerBound + #SHIFT_STAT_INDEX_BY_ONE;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Different modes\n\t  IF #enDefaultOutValue THEN\n\t    //Set output value\n\t    #outputValue := #defaultOutValue;\n\t    RETURN;\n\t  ELSIF #track THEN\n\t    //Set output value\n\t    #outputValue := #tempValue;\n\t    RETURN;\n\t  ELSIF #reset THEN\n\t    //Preset search index of array\n\t    #statIndex := #tempLowerBound + #SHIFT_STAT_INDEX_BY_ONE;\n\t    #outputValue := #ZERO;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculated polynom output\n\t  //Initialize search procedure\n\t  #tempEndOfSearch := False;\n\t  \n\t  //Search procedure\n\t  REPEAT\n\t    //Preset input values of polygon\n\t    #tempInputValueStart := #setpoints[#statIndex - #SHIFT_STAT_INDEX_BY_ONE].inputValue;\n\t    #tempInputValueEnd := #setpoints[#statIndex].inputValue;\n\t    \n\t    //Check actual polynom\n\t    IF (#tempValue > #tempInputValueStart) THEN\n\t      IF (#tempValue > #tempInputValueEnd) THEN\n\t        IF (#statIndex < #tempUpperBound) THEN\n\t          #tempInputValueStart := #tempInputValueEnd;\n\t          #statIndex := #statIndex + #SHIFT_STAT_INDEX_BY_ONE;\n\t          #tempInputValueEnd := #setpoints[#statIndex].inputValue;\n\t        ELSE\n\t          #tempEndOfSearch := True;\n\t        END_IF;\n\t      ELSE\n\t        #tempEndOfSearch := True;\n\t      END_IF;\n\t    ELSE\n\t      IF (#statIndex > (#tempLowerBound + #SHIFT_STAT_INDEX_BY_ONE)) THEN\n\t        #statIndex := #statIndex - #SHIFT_STAT_INDEX_BY_ONE;\n\t        #tempInputValueEnd := #tempInputValueStart;\n\t        // #tempInputValueStart := #setpoints.Point[#statIndex - 1].InputValue;\n\t        #tempInputValueStart := #setpoints[#statIndex].inputValue;\n\t      ELSE\n\t        #tempEndOfSearch := True;\n\t      END_IF;\n\t    END_IF;\n\t  UNTIL (#tempEndOfSearch = True) END_REPEAT;\n\t  \n\t  // Set output values of polygon\n\t  #tempOutputValueStart := #setpoints[#statIndex - #SHIFT_STAT_INDEX_BY_ONE].outputValue;\n\t  #tempOutputValueEnd := #setpoints[#statIndex].outputValue;\n\t  // Calculate gradient of straight line\n\t  #tempFactor := (#tempOutputValueEnd - #tempOutputValueStart) / (#tempInputValueEnd - #tempInputValueStart);\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  // Calculate output value\n\t  #outputValue := (#tempFactor * #tempValue) + (#tempOutputValueStart - (#tempFactor * #tempInputValueStart));\n\t  \n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "RampCI", "description": "The function generates a speed curve based on an interpolation point table. Linear interpolation occurs between the points within the prescribed time.", "type": "FUNCTION_BLOCK", "name": "LGF_RampCI", "vars": [{"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable\n(`outputValue` = `defaultOutValue`)"}, {"name": "contStepNbr", "type": "Int", "description": "Number of the next interpolation point for continuing"}, {"name": "contStepTime", "type": "Time", "description": "Remaining time to continue to the interpolation point\n`contStepNbr`"}, {"name": "enDefaulftOutValue", "type": "Bool", "description": "Assign default output value\n(`outputValue` = `defaultOutValue`)"}, {"name": "start", "type": "Bool", "description": "Run down the interpolation point table"}, {"name": "hold", "type": "Bool", "description": "Freeze/ hold output at actual value"}, {"name": "continue", "type": "Bool", "description": "Continuing"}, {"name": "cyclicOP", "type": "Bool", "description": "Repeat interpolation point table cyclically"}, {"name": "updateTime", "type": "Bool", "description": "Update time values"}, {"name": "reset", "type": "Bool", "description": "Complete reset of function"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB (cyclic interrupt OB)"}, {"name": "outputValue", "type": "LReal", "description": "Output value"}, {"name": "actTimeTable", "type": "Bool", "description": "The interpolation point table will be edited."}, {"name": "stepNumber", "type": "Int", "description": "current interpolation point number\n(interpolation point that is approached)"}, {"name": "remainTime", "type": "Time", "description": "Remaining time until reaching the next interpolation point"}, {"name": "totalTime", "type": "Time", "description": "Total time for setpoint table"}, {"name": "remainTotalTime", "type": "Time", "description": "Total remaining time"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "setpoints", "type": "Array[*] of LGF\n_typeRampTime\nTable", "description": "Interpolation point table.\nYou can find information on the data type\n`LGF_typeRampTimeTable` under the item “Global data” ."}, {"name": "outputValue", "type": "LReal", "description": "Setpoint Value to reach by the interpolation curve"}, {"name": "time", "type": "Time", "description": "Time until the interpolation point is reached"}], "input": [{"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable\n(`outputValue` = `defaultOutValue`)"}, {"name": "contStepNbr", "type": "Int", "description": "Number of the next interpolation point for continuing"}, {"name": "contStepTime", "type": "Time", "description": "Remaining time to continue to the interpolation point\n`contStepNbr`"}, {"name": "enDefaulftOutValue", "type": "Bool", "description": "Assign default output value\n(`outputValue` = `defaultOutValue`)"}, {"name": "start", "type": "Bool", "description": "Run down the interpolation point table"}, {"name": "hold", "type": "Bool", "description": "Freeze/ hold output at actual value"}, {"name": "continue", "type": "Bool", "description": "Continuing"}, {"name": "cyclicOP", "type": "Bool", "description": "Repeat interpolation point table cyclically"}, {"name": "updateTime", "type": "Bool", "description": "Update time values"}, {"name": "reset", "type": "Bool", "description": "Complete reset of function"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB (cyclic interrupt OB)"}], "output": [{"name": "outputValue", "type": "LReal", "description": "Output value"}, {"name": "actTimeTable", "type": "Bool", "description": "The interpolation point table will be edited."}, {"name": "stepNumber", "type": "Int", "description": "current interpolation point number\n(interpolation point that is approached)"}, {"name": "remainTime", "type": "Time", "description": "Remaining time until reaching the next interpolation point"}, {"name": "totalTime", "type": "Time", "description": "Total time for setpoint table"}, {"name": "remainTotalTime", "type": "Time", "description": "Total remaining time"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "setpoints", "type": "Array[*] of LGF\n_typeRampTime\nTable", "description": "Interpolation point table.\nYou can find information on the data type\n`LGF_typeRampTimeTable` under the item “Global data” ."}], "answer": "FUNCTION_BLOCK \"LGF_RampCI\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_RampCI\n   VAR_INPUT \n      defaultOutValue : LReal := 0.0;\n      contStepNbr : Int := 0;\n      contStepTime : Time := T#0MS;\n      enDefaulftOutValue : Bool := FALSE;\n      start : Bool := FALSE;\n      hold : Bool := FALSE;\n      continue : Bool := FALSE;\n      cyclicOP : Bool := FALSE;\n      updateTime : Bool := FALSE;\n      reset : Bool := FALSE;\n      callOB : OB_CYCLIC;\n   END_VAR\n\n   VAR_OUTPUT \n      outputValue { ExternalWritable := 'False'} : LReal;\n      actTimeTable { ExternalWritable := 'False'} : Bool;\n      stepNumber { ExternalWritable := 'False'} : Int;\n      remainTime { ExternalWritable := 'False'} : Time;\n      totalTime { ExternalWritable := 'False'} : Time;\n      remainTotalTime { ExternalWritable := 'False'} : Time;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      subfunctionStatus { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      setpoints : Array[*] of \"LGF_typeRampTimeTable\";\n   END_VAR\n\n   VAR \n      statEndValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statOldValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 0.0;\n      statActualStep { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statActualRestTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;\n      statTotalTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;\n      statRestTotalTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;\n      statStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statTimeTableActiv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statStartMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statUpdateTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statResetMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR_TEMP \n      tempNewValue : LReal;\n      tempIndex : Int;\n      tempArrayLowLim : Int;\n      tempArrayUpLim : Int;\n      tempSampleTime : Time;\n      tempCycleTime : UDInt;\n      tempCyclePhase : UDInt;\n      tempCycleStatus : Word;\n      tempReadTimeStatus : Int;\n      tempStatus : Word;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : Int := 0;\n      NO_ERROR : Int := 0;\n      RESET_TIME : Time := T#0MS;\n      CYCLIC_OB_NOT_AVAILABLE : Word := 16#0000;\n      DIMENSION_ONE : UDInt := 1;\n      SECOND_IN_MS : UDInt := 1000;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_FURTHER_CALLS : Word := 16#7002;\n      ERR_OB_UNAVAILABLE : Word := 16#8200;\n      ERR_ARRAY_LOWER_BOUND : Word := 16#8201;\n      ERR_QRY_CINT : Word := 16#8400;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_RampCI\n\t  // Comment/Function: Generates a speed curve based on an interpolation point table.\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.02.2017  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 16.05.2017  Siemens Industry Online Support\n\t  //                      Comment correction (REGION)\n\t  // 01.00.02 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.03 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.06 15.11.2019  Siemens Industry Presales Support\n\t  //                      Code optimization, Regions, comments and constants are added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 22.03.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //                      Change UDT member name from `outValue` to `outputValue`\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Cycle time\n\t  // get sample time, according to the cyclic interrupt OB number\n\t  #tempReadTimeStatus := QRY_CINT(OB_NR := #callOB, CYCLE => #tempCycleTime, PHASE => #tempCyclePhase, STATUS => #tempCycleStatus);\n\t  #tempCycleTime := #tempCycleTime / #SECOND_IN_MS; // microsecond --> milisecond \n\t  #tempSampleTime := UDINT_TO_TIME(#tempCycleTime); // Format: TIME\n\t  \n\t  #tempStatus := #STATUS_NO_CALL;\n\t  \n\t  // Generate error message of the QRY_CINT function\n\t  IF (#tempReadTimeStatus <> #NO_ERROR) THEN\n\t    #error := TRUE;\n\t    #subfunctionStatus := INT_TO_WORD(#tempReadTimeStatus);\n\t    #status := #ERR_QRY_CINT;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Generate error message when OB unavailable\n\t  IF #tempCycleStatus = #CYCLIC_OB_NOT_AVAILABLE THEN\n\t    #error := TRUE;\n\t    #status := #ERR_OB_UNAVAILABLE;\n\t    #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION Cycle time\n\t\n\tREGION Array lower/upper bound\n\t  #tempArrayLowLim := DINT_TO_INT(LOWER_BOUND(ARR := #setpoints, DIM := #DIMENSION_ONE));\n\t  #tempArrayUpLim := DINT_TO_INT(UPPER_BOUND(ARR := #setpoints, DIM := #DIMENSION_ONE));\n\t  \n\t  IF #tempArrayLowLim <> #ZERO THEN\n\t    #error := TRUE;\n\t    #status := #ERR_ARRAY_LOWER_BOUND;\n\t    #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION Array lower/upper bound\n\t\n\tREGION Function  \n\t  REGION First Call\n\t    // START by positive edge\n\t    IF #start AND NOT #statStartMem THEN\n\t      #tempStatus := #STATUS_FIRST_CALL;\n\t      #statStart := TRUE;\n\t      #statTotalTime := #RESET_TIME; // reset total time \n\t      \n\t      FOR #tempIndex := #tempArrayLowLim TO #tempArrayUpLim DO // calculate total time \n\t        #statTotalTime := #statTotalTime + #setpoints[#tempIndex].\"time\"; // total time \n\t      END_FOR;\n\t      #statRestTotalTime := #statTotalTime;\n\t      #statReset := FALSE;\n\t    ELSIF NOT #start THEN\n\t      #error := false;\n\t      #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t      #status := #STATUS_FINISHED_NO_ERROR;\n\t    END_IF;\n\t    // store old value for edge detection\n\t    #statStartMem := #start;\n\t  END_REGION First Call\n\t  \n\t  REGION Reset    \n\t    // RESET by positiv edge on reset\n\t    IF #reset AND NOT #statResetMem THEN\n\t      #tempStatus := #STATUS_FINISHED_NO_ERROR;\n\t      #statTotalTime := #RESET_TIME; // reset total time \n\t      \n\t      FOR #tempIndex := #tempArrayLowLim TO #tempArrayUpLim DO // calculate total time \n\t        #statTotalTime := #statTotalTime + #setpoints[#tempIndex].\"time\"; // total time \n\t      END_FOR;\n\t      \n\t      #tempNewValue := #ZERO;                   // output outValue = 0 \n\t      #statRestTotalTime := #statTotalTime;     // update remaining total time \n\t      #statEndValue := #ZERO;                   // reset statEndValue    \n\t      #statActualStep := #ZERO;                 // reset statActualStep  \n\t      #statActualRestTime := #RESET_TIME;       // reset statActualTime \n\t      #statStart := TRUE;                       // set start condition \n\t      #statTimeTableActiv := FALSE;             // reset statTimeTableActive \n\t      #statReset := TRUE;\n\t    END_IF;\n\t    // store old value for edge detection\n\t    #statResetMem := #reset;\n\t  END_REGION Reset\n\t  \n\t  REGION Operation \n\t    IF #start AND NOT #statReset THEN\n\t      // start function ramp soak \n\t      IF #statStart THEN\n\t        // Set up start conditions \n\t        #tempNewValue := #setpoints[#tempArrayLowLim].outputValue;\n\t        #statEndValue := #setpoints[#tempArrayLowLim + 1].outputValue;\n\t        #statActualRestTime := #setpoints[#tempArrayLowLim].\"time\";\n\t        #statRestTotalTime := #statTotalTime;\n\t        #statActualStep := 1;\n\t        #statStart := FALSE;\n\t        #statTimeTableActiv := TRUE;\n\t      ELSE\n\t        IF #hold THEN\n\t          // Freeze operation \n\t          #statTimeTableActiv := FALSE;\n\t          #tempNewValue := #statOldValue;\n\t          \n\t          IF #continue THEN\n\t            // Set up continue conditions \n\t            // Continue step and remaining time untill continue step\n\t            #statEndValue := #setpoints[#contStepNbr].outputValue;\n\t            #statRestTotalTime := #contStepTime;\n\t            #statActualRestTime := #contStepTime;\n\t            #statActualStep := #contStepNbr;\n\t            \n\t            FOR #tempIndex := #statActualStep TO #tempArrayUpLim DO // calculating remaining total time  \n\t              #statRestTotalTime := #statRestTotalTime + #setpoints[#tempIndex].\"time\"; // Remaining total time\n\t            END_FOR;\n\t          END_IF;\n\t        ELSE\n\t          // normal operation \n\t          // remaining time until actual step \n\t          IF #statActualRestTime > #tempSampleTime THEN\n\t            // calculate new output value, if remaining time has not yet expired\n\t            #tempNewValue := #statOldValue + (#statEndValue - #statOldValue) / DINT_TO_REAL(TIME_TO_DINT(#statActualRestTime)) * UDINT_TO_REAL(#tempCycleTime);\n\t            // update remaining time till actual step \n\t            #statActualRestTime := #statActualRestTime - #tempSampleTime;\n\t            // update remaining total time \n\t            #statRestTotalTime := #statRestTotalTime - #tempSampleTime;\n\t          ELSE\n\t            // remaining actual rest time expired \n\t            #statActualRestTime := #RESET_TIME;\n\t            // End of step numbers not reached yet    \n\t            IF #statActualStep < #tempArrayUpLim THEN\n\t              // set new end value \n\t              #statEndValue := #setpoints[#statActualStep + 1].outputValue;\n\t              // set new output value \n\t              #tempNewValue := #setpoints[#statActualStep].outputValue;\n\t              // new remaining actual time \n\t              #statActualRestTime := #setpoints[#statActualStep].\"time\";\n\t              #statActualStep := #statActualStep + 1;\n\t              #statTimeTableActiv := TRUE;\n\t              #statRestTotalTime := #statRestTotalTime - #tempSampleTime;\n\t            ELSE\n\t              // end of step numbers reached \n\t              #tempStatus := #SUB_STATUS_NO_ERROR;\n\t              #statRestTotalTime := #RESET_TIME;\n\t              // cyclic operation\n\t              IF #cyclicOP THEN\n\t                #statStart := TRUE;\n\t                #tempStatus := #STATUS_FURTHER_CALLS;\n\t              ELSE\n\t                #statTimeTableActiv := FALSE;\n\t              END_IF;\n\t              // set new output value \n\t              #tempNewValue := #setpoints[#statActualStep].outputValue;\n\t            END_IF;\n\t          END_IF;\n\t        END_IF;\n\t      END_IF;\n\t    ELSE\n\t      #tempNewValue := #ZERO;\n\t      // time table not active \n\t      #statTimeTableActiv := FALSE;\n\t    END_IF;\n\t  END_REGION Operation \n\t  \n\t  REGION Update time\n\t    // Update total time and remaining total time\n\t    // Positive edge detection of update time input\n\t    IF #updateTime AND NOT #statUpdateTime THEN\n\t      #statTotalTime := #RESET_TIME; // reset total time \n\t      #statRestTotalTime := #statActualRestTime; // copy remaining actual time to remaining total time\n\t      \n\t      FOR #tempIndex := #tempArrayLowLim TO #tempArrayUpLim DO // calculate totel time \n\t        #statTotalTime := #statTotalTime + #setpoints[#tempIndex].\"time\"; // total time \n\t      END_FOR;\n\t      \n\t      FOR #tempIndex := #statActualStep TO #tempArrayUpLim DO // calculate remaining total time \n\t        #statRestTotalTime := #statRestTotalTime + #setpoints[#tempIndex].\"time\"; // remaining total time \n\t      END_FOR;\n\t    END_IF;\n\t    // store old value for edge detection\n\t    #statUpdateTime := #updateTime;\n\t  END_REGION Update time\n\t  \n\t  REGION Default output\n\t    // default value activated: overwrite output by default value\n\t    IF #enDefaulftOutValue THEN\n\t      #tempNewValue := #defaultOutValue; // preset output \n\t      #statTimeTableActiv := FALSE; // timetable not active \n\t    END_IF;\n\t  END_REGION Default output\n\tEND_REGION Function \n\t\n\tREGION Write outputs\n\t  #outputValue := #tempNewValue; // output\n\t  #statOldValue := #tempNewValue; // store prvious value\n\t  #actTimeTable := #statTimeTableActiv; //time table active\n\t  #stepNumber := #statActualStep; // number of acting step\n\t  #remainTime := #statActualRestTime; // remaining time till actual step\n\t  #totalTime := #statTotalTime; // total time\n\t  #remainTotalTime := #statRestTotalTime; //remaining total time\n\t  \n\t  #error := #tempStatus.%X15;\n\t  #status := #tempStatus;\n\t  #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  \n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION Write outputs\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "AverageAndDeviation", "description": "This function calculates the arithmetic mean and the standard deviation from a series of numbers.", "type": "FUNCTION", "name": "LGF_AverageAndDeviation", "vars": [{"name": "variableArray", "type": "Array[*] of LReal", "description": "Sequence of numbers to calculate with"}, {"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "arithmeticAverage", "type": "LReal", "description": "Calculated arithmetic average value"}, {"name": "standardDeviation", "type": "LReal", "description": "Calculated standard deviation"}], "input": [{"name": "variableArray", "type": "Array[*] of LReal", "description": "Sequence of numbers to calculate with"}], "output": [{"name": "arithmeticAverage", "type": "LReal", "description": "Calculated arithmetic average value"}, {"name": "standardDeviation", "type": "LReal", "description": "Calculated standard deviation"}], "in/out": [], "answer": "FUNCTION \"LGF_AverageAndDeviation\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_AverageAndDeviation\n   VAR_INPUT \n      variableArray : Array[*] of LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      arithmeticAverage : LReal;\n      standardDeviation : LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempLowerBound : Int;\n      tempUpperBound : Int;\n      tempNumberOfElements : Int;\n      tempSizeCounter : Int;\n      tempArithmeticAverage : LReal;\n      tempStandardDeviation : LReal;\n   END_VAR\n\n   VAR CONSTANT \n      NUMBER_OF_ELEMENTS_CORRECTION : Int := 1;\n      DIMENSION_ONE : UDInt := 1;\n      ZERO : LReal := 0.0;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_AverageAndDeviation\n\t  // Comment/Function: This function calculates the arithmetic average and the\n\t  //                   standard deviation of a array of numbers\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - no error handling, ENO forced to true\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|-----------------------------\n\t  // 01.00.00 | 19.08.2015 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 01.00.01 | 16.11.2015 | Siemens Industry Online Support\n\t  //                       | Bug fix at WRONG_TYPE:  #error := true\n\t  // 01.00.02 | 02.01.2017 | Siemens Industry Online Support\n\t  //                       | Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.03 | 17.08.2018 | Siemens Industry Online Support\n\t  //                       | Upgrade: TIA V15 Update 2\n\t  // 01.00.04 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | Upgrade: TIA V15.1\n\t  // 02.00.00 | 25.01.2019 | Simatic Systems Support\n\t  //                       | Data type changed from Variant to Array[*] of LReal\n\t  // 02.00.01 | 31.10.2019 | Simatic Systems Support\n\t  //                       | Regions, comments and constants are added\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Checking number of lower and upper bound\n\t  #tempLowerBound := DINT_TO_INT(LOWER_BOUND(ARR := #variableArray, DIM := #DIMENSION_ONE));\n\t  #tempUpperBound := DINT_TO_INT(UPPER_BOUND(ARR := #variableArray, DIM := #DIMENSION_ONE));\n\t  \n\t  // Upper - Lower bound gives the number of elements. +1 should be added for correct calculation.\n\t  #tempNumberOfElements := #tempUpperBound - #tempLowerBound + #NUMBER_OF_ELEMENTS_CORRECTION;\n\tEND_REGION\n\t\n\tREGION Calculation of the arithmetic average\n\t  #tempArithmeticAverage := #ZERO;\n\t  FOR #tempSizeCounter := #tempLowerBound TO #tempUpperBound DO\n\t    #tempArithmeticAverage += #variableArray[#tempSizeCounter];\n\t  END_FOR;\n\t  \n\t  #tempArithmeticAverage /= DINT_TO_REAL(#tempNumberOfElements);\n\tEND_REGION\n\t\n\tREGION Calculation of the standard deviation\n\t  #tempStandardDeviation := #ZERO;\n\t  FOR #tempSizeCounter := #tempLowerBound TO #tempUpperBound DO\n\t    #tempStandardDeviation += SQR((#variableArray[#tempSizeCounter] - #tempArithmeticAverage));\n\t  END_FOR;\n\t  \n\t  #tempStandardDeviation := SQRT(#tempStandardDeviation / DINT_TO_REAL(#tempNumberOfElements));\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  #arithmeticAverage := #tempArithmeticAverage;\n\t  #standardDeviation := #tempStandardDeviation;\n\t\n\t  // ENO mechanism is not used - forced to true\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "DifferenceQuotientFC", "description": "This function numerically differentiates a signal sampled equidistantly in time. For example, the velocity can be calculated from a measured locus curve, or the acceleration can be calculated from the measured velocity. In order to minimize the effects of a scattering measurement signal, this algorithm uses a compensating polynomial. The function calculates the differentiated values acyclically. The function reads an array that is differentiated. 𝑁−4 smoothed measured values can be calculated from N measured values. The output array contains the value 0 in the index (0,1,N-1,N). However, replacement values can be calculated.", "type": "FUNCTION", "name": "LGF_DifferenceQuotientFC", "vars": [{"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values. (e.g. 1s)"}, {"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "values", "type": "Array[*] of LReal", "description": "Values that will be included in the differentiation."}, {"name": "derivatedValues", "type": "Array[*] of LReal", "description": "The differentiated value range."}], "input": [{"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values. (e.g. 1s)"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that will be included in the differentiation."}, {"name": "derivatedValues", "type": "Array[*] of LReal", "description": "The differentiated value range."}], "answer": "FUNCTION \"LGF_DifferenceQuotientFC\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_DifferenceQuotientFC\n   VAR_INPUT \n      deltaT : LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of LReal;\n      derivatedValues : Array[*] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempLowerBound : Int;\n      tempUpperBound : Int;\n      tempNumberOfElements : Int;\n      tempLowerBoundOut : Int;\n      tempUpperBoundOut : Int;\n      tempNumberOfElementsOut : Int;\n      tempCount : Int;\n      tempDivision : LReal;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : LReal := 0.0;\n      NUMBER_OF_ELEMENTS_CORRECTION : Int := 1;\n      DIMENSION_ONE : UDInt := 1;\n      MINIMUM_ARRAY_ELEMENTS : UDInt := 4;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_DELTA_T : Word := 16#8200;\n      ERR_ARRAYS_DIFFERENT : Word := 16#8400;\n      ERR_NOT_ENOUGH_VALUES : Word := 16#8401;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_DifferenceQuotientFC\n\t  // Comment/Function: This function differentiates a signal\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //----------|------------|------------------------|----------------------------\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|----------------------------\n\t  // 01.00.00 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 01.00.01 | 15.11.2019 | Simatic Systems Support\n\t  //                       | Regions, comments and constants are added\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Checking number of lower and upper bound  \n\t  #tempLowerBound := DINT_TO_INT(LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE));\n\t  #tempUpperBound := DINT_TO_INT(UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE));\n\t  \n\t  #tempNumberOfElements := #tempUpperBound - #tempLowerBound + #NUMBER_OF_ELEMENTS_CORRECTION;\n\t  \n\t  #tempLowerBoundOut := DINT_TO_INT(LOWER_BOUND(ARR := #derivatedValues, DIM := #DIMENSION_ONE));\n\t  #tempUpperBoundOut := DINT_TO_INT(UPPER_BOUND(ARR := #derivatedValues, DIM := #DIMENSION_ONE));\n\t  \n\t  #tempNumberOfElementsOut := #tempUpperBoundOut - #tempLowerBoundOut + #NUMBER_OF_ELEMENTS_CORRECTION;\n\t  \n\t  //check if size of arrays is ok\n\t  IF #tempNumberOfElementsOut <> #tempNumberOfElements THEN\n\t    #error := true;\n\t    #status := #ERR_ARRAYS_DIFFERENT;\n\t    RETURN;\n\t    // check size of arrays if the are big enough\n\t  ELSIF #tempNumberOfElements <= #MINIMUM_ARRAY_ELEMENTS THEN\n\t    #error := true;\n\t    #status := #ERR_NOT_ENOUGH_VALUES;\n\t    RETURN;\n\t    // DeltaT cannot be zero, devision by zero not possible.\n\t  ELSIF #deltaT = #ZERO THEN\n\t    #error := true;\n\t    #status := #ERR_DELTA_T;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating the derrivate values  \n\t  // calculate derivate value \n\t  // keep the \"Magic Numbers\" as they are part of the Math equation and would extent the formular in a unreadable way\n\t  // ẏ(n)=1/12h*(y(n-2)-8y(n-1)+8y(n+1)-y(n+2))\n\t  // h = deltaT\n\t  #tempDivision := 1.0 / (12.0 * #deltaT);\n\t  FOR #tempCount := #tempLowerBound + 2 TO #tempUpperBound - 2 DO\n\t    #derivatedValues[#tempCount] := #tempDivision * (#values[#tempCount - 2] - 8 * #values[#tempCount - 1] + 8 * #values[#tempCount + 1] - #values[#tempCount + 2]);\n\t  END_FOR;\n\t  \n\t  // ẏ(n-2)=1/84h*(-125y(n-2)+136y(n-1)+48y(n)-88y(n+1)+29y(n+2))\n\t  // h = deltaT\n\t  #tempDivision := 1.0 / (84.0 * #deltaT);\n\t  #derivatedValues[0] := #tempDivision * (-125 * #values[0] + 136 * #values[1] + 48 * #values[2] - 88 * #values[3] + 29 * #values[4]);\n\t  \n\t  // ẏ(n-1)=1/84h*(-38y(n-2)-2y(n-1)+24y(n)+26y(n+1)-10y(n+2))\n\t  // h = deltaT\n\t  #derivatedValues[1] := #tempDivision * (-38 * #values[0] - 2 * #values[1] + 24 * #values[2] + 26 * #values[3] - 10 * #values[4]);\n\t  \n\t  // ẏ(n+1)=1/84h(10y(n-2)-26y(n-1)-24y(n)+2y(n+1)+38y(n+2))\n\t  // h = deltaT\n\t  #derivatedValues[#tempUpperBound - 1] := #tempDivision * (10 * #values[#tempUpperBound - 4] - 26 * #values[#tempUpperBound - 3] - 24 * #values[#tempUpperBound - 2] + 2 * #values[#tempUpperBound - 1] + 38 * #values[#tempUpperBound]);\n\t  \n\t  // y(n-2)=1/84h(-29y(n-2)+88y(n-1)-48y(n)-136y(n+1)+125y(n+2))\n\t  // h = deltaT\n\t  #derivatedValues[#tempUpperBound] := #tempDivision * (-29 * #values[#tempUpperBound - 4] + 88 * #values[#tempUpperBound - 3] - 48 * #values[#tempUpperBound - 2] - 136 * #values[#tempUpperBound - 1] + 125 * #values[#tempUpperBound]);\n\t  \n\t  #error := false;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  // ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "RegressionLine", "description": "The simplest case of a regression is the regression line. This means that the assumed relationship between the input and output signal is a linear straight line. Figure: Regression line", "type": "FUNCTION", "name": "LGF_RegressionLine", "vars": [{"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "slope", "type": "LReal", "description": "Gradient of straight line"}, {"name": "intercept", "type": "LReal", "description": "The intersection with the Y axis"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "values", "type": "Array[*] of LGF\n_typeRegression\nLine", "description": "The data points are transferred with their X- and Y-values.\nThe data type `LGF_typeRegressionLine` has the following structure:\n• x (Real)\n• y (Real)"}, {"name": "x", "type": "Real", "description": "X-Axis value"}, {"name": "y", "type": "Real", "description": "Y-Axis value"}], "input": [], "output": [{"name": "slope", "type": "LReal", "description": "Gradient of straight line"}, {"name": "intercept", "type": "LReal", "description": "The intersection with the Y axis"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "values", "type": "Array[*] of LGF\n_typeRegression\nLine", "description": "The data points are transferred with their X- and Y-values.\nThe data type `LGF_typeRegressionLine` has the following structure:\n• x (Real)\n• y (Real)"}], "answer": "FUNCTION \"LGF_RegressionLine\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_RegressionLine\n   VAR_OUTPUT \n      slope : LReal;\n      intercept : LReal;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of \"LGF_typeRegressionLine\";\n   END_VAR\n\n   VAR_TEMP \n      tempRegressionPoint : \"LGF_typeRegressionLine\";\n      tempIndex : DInt;\n      tempNumberOfElements : DInt;\n      tempLowerBound : DInt;\n      tempUpperBound : DInt;\n      tempSumXY : LReal;\n      tempSumX : LReal;\n      tempSumY : LReal;\n      tempSumX2 : LReal;\n      tempIntercept : LReal;\n      tempSlope : LReal;\n   END_VAR\n\n   VAR CONSTANT \n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      ELEMENTS_COUNT_CORRECTION : DInt := 1;\n      ELEMENTS_NUMBER_THRESHOLD : DInt := 2;\n      STATUS_EXECUTION_FINISHED : Word := 16#0000;\n      ERR_NOT_ENOUGH_VALUES : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_RegressionLine\n\t  // Comment/Function: This function calculates the regression line\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 01.00.04 | 15.11.2019 | Simatic Systems Support\n\t  //                       | Code refactoring, comments added\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and input data processing\n\t  //calculate number of elements\n\t  #tempLowerBound := LOWER_BOUND(ARR := #values, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperBound := UPPER_BOUND(ARR := #values, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // Array elements calculation\n\t  // (example: 6 - 2 = 4; but real number of elements is 5)\n\t  #tempNumberOfElements := #tempUpperBound - #tempLowerBound + #ELEMENTS_COUNT_CORRECTION;\n\t  \n\t  // Check whether the array contains less than the maximum possible amount of elements\n\t  IF #tempNumberOfElements < #ELEMENTS_NUMBER_THRESHOLD THEN\n\t    #slope := 0.0;\n\t    #intercept := 0.0;\n\t    #error := TRUE;\n\t    #status := #ERR_NOT_ENOUGH_VALUES;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Regression line calculation\n\t  // caluclate sum of all needed values\n\t  FOR #tempIndex := #tempLowerBound TO #tempUpperBound DO\n\t    // make a temp copy first\n\t    #tempRegressionPoint := #values[#tempIndex];\n\t    \n\t    // Sum of x(n) * y(n)\n\t    #tempSumXY += #tempRegressionPoint.x * #tempRegressionPoint.y;\n\t    // Sum of x(n) \n\t    #tempSumX += #tempRegressionPoint.x;\n\t    // Sum of y(n)\n\t    #tempSumY += #tempRegressionPoint.y;\n\t    // Sum of x²(n)\n\t    #tempSumX2 += SQR(#tempRegressionPoint.x);\n\t  END_FOR;\n\t  \n\t  // b = (n * ∑(x(n) * y(n) - ( ∑x(n) * ∑y(n)))/\n\t  //    (n * (∑x(n)^2) -(∑x(n) * ∑x(n)))\n\t  #tempSlope := (#tempNumberOfElements * #tempSumXY - (#tempSumX * #tempSumY)) / (#tempNumberOfElements * #tempSumX2 - (#tempSumX * #tempSumX));\n\t  \n\t  // a = Y - bX : X and Y are the average values of x and y\n\t  #tempIntercept := #tempSumY / #tempNumberOfElements - (#tempSlope * (#tempSumX / #tempNumberOfElements));\n\tEND_REGION\n\t\n\tREGION Outputs assignment\n\t  // f(x)= a + b*x\n\t  #slope := #tempSlope;\n\t  #intercept := #tempIntercept;\n\t  \n\t  #error := false;\n\t  #status := #STATUS_EXECUTION_FINISHED;\n\t  // ENO not in use - force to true\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "SimpleSmoothingFC", "description": "The function calculates the linear mean value acyclically. The simplest form of smoothing a sequence of measured values is to calculate the linear mean value by three points. The function reads an array that is smoothed. 𝑁−2 smoothed measured values can be calculated from N measured values. Therefore, the output array in the index (0) and index (N) contains the value 0.", "type": "FUNCTION", "name": "LGF_SimpleSmoothingFC", "vars": [{"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "values", "type": "Array[*] of LReal", "description": "Values that are to be included in the smoothing."}, {"name": "smoothedValues", "type": "Array[*] of LReal", "description": "The smoothed values."}], "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that are to be included in the smoothing."}, {"name": "smoothedValues", "type": "Array[*] of LReal", "description": "The smoothed values."}], "answer": "FUNCTION \"LGF_SimpleSmoothingFC\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_SimpleSmoothingFC\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of LReal;\n      smoothedValues : Array[*] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempCount : Int;\n      tempNumberOfElements : Int;\n      tempNumberOfElementsOut : Int;\n      tempLowerBound : Int;\n      tempUpperBound : Int;\n      tempLowerBoundOut : Int;\n      tempUpperBoundOut : Int;\n   END_VAR\n\n   VAR CONSTANT \n      NUMBER_OF_ELEMENTS_CORRECTION : Int := 1;\n      DIMENSION_ONE : UDInt := 1;\n      MINIMUM_ARRAY_ELEMENTS : UDInt := 3;\n      NUMBER_OF_VALUES : UDInt := 3;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_NOT_ENOUGH_VALUES : Word := 16#8400;\n      ERR_ARRAY_DIFFERENT : Word := 16#8401;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_SimpleSmoothingFC\n\t  // Comment/Function: This function calculates the smoothed values\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 01.00.01 | 15.11.2019 | Simatic Systems Support\n\t  //                       | Regions, comments and constants are added\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Checking number of lower and upper bound\n\t  #tempLowerBound := DINT_TO_INT(LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE));\n\t  #tempUpperBound := DINT_TO_INT(UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE));\n\t  \n\t  #tempNumberOfElements := #tempUpperBound - #tempLowerBound + #NUMBER_OF_ELEMENTS_CORRECTION;\n\t  \n\t  #tempLowerBoundOut := DINT_TO_INT(LOWER_BOUND(ARR := #smoothedValues, DIM := #DIMENSION_ONE));\n\t  #tempUpperBoundOut := DINT_TO_INT(UPPER_BOUND(ARR := #smoothedValues, DIM := #DIMENSION_ONE));\n\t  \n\t  #tempNumberOfElementsOut := #tempUpperBoundOut - #tempLowerBoundOut + #NUMBER_OF_ELEMENTS_CORRECTION;\n\t  \n\t  // Check if size of arrays is ok\n\t  IF #tempNumberOfElements <> #tempNumberOfElementsOut THEN\n\t    #error := true;\n\t    #status := #ERR_ARRAY_DIFFERENT;\n\t    RETURN;\n\t    // Check size of arrays if the are big enough\n\t  ELSIF #tempNumberOfElements < #MINIMUM_ARRAY_ELEMENTS THEN\n\t    #error := true;\n\t    #status := #ERR_NOT_ENOUGH_VALUES;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Caluclating smoothed value\n\t  // y(Nsmoothed)= (y(n-1)+y(n)+y(n+1)) / 3\n\t  FOR #tempCount := #tempLowerBound + 1 TO #tempUpperBound - 1 DO\n\t    #smoothedValues[#tempCount] := (#values[#tempCount - 1] + #values[#tempCount] + #values[#tempCount + 1]) / #NUMBER_OF_VALUES;\n\t  END_FOR;\n\t  \n\t  #error := false;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  // ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "SmoothByPolynomFC", "description": "This function calculates the smoothed values by polynomial acyclically. For smoothing, a 3rd degree polynomial is placed through five value points. The error squares of the distances between polynomial and real value are minimized. The smoothed values can be determined from the polynomial parameters obtained in this way. The function reads an array that is smoothed. 𝑁−4 smoothed measured values can be calculated from N measured values. The output array contains the value 0 in the index (0,1,N-1,N). However, replacement values can be calculated.", "type": "FUNCTION", "name": "LGF_SmoothByPolynomFC", "vars": [{"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "values", "type": "Array[*] of LReal", "description": "Values that are to be included in the smoothing."}, {"name": "smoothedValues", "type": "Array[*] of LReal", "description": "The smoothed values."}], "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that are to be included in the smoothing."}, {"name": "smoothedValues", "type": "Array[*] of LReal", "description": "The smoothed values."}], "answer": "FUNCTION \"LGF_SmoothByPolynomFC\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_SmoothByPolynomFC\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of LReal;\n      smoothedValues : Array[*] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempCount : Int;\n      tempNumberOfElements : Int;\n      tempNumberOfElementsOut : Int;\n      tempLowerBound : Int;\n      tempUpperBound : Int;\n      tempLowerBoundOut : Int;\n      tempUpperBoundOut : Int;\n   END_VAR\n\n   VAR CONSTANT \n      NUMBER_OF_ELEMENTS_CORRECTION : Int := 1;\n      DIMENSION_ONE : UDInt := 1;\n      MINIMUM_ARRAY_ELEMENTS : UDInt := 5;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_ARRAYS_DIFFERENT : Word := 16#8400;\n      ERR_NOT_ENOUGH_VALUES : Word := 16#8401;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_SmoothByPolynomFC\n\t  // Comment/Function: This function calculates the smoothed values by polynom\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 01.00.05 | 15.11.2019 | Simatic Systems Support\n\t  //                       | Regions, comments and constants are added\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Checking number of lower and upper bound\n\t  #tempLowerBound := DINT_TO_INT(LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE)); \n\t  #tempUpperBound := DINT_TO_INT(UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE));\n\t  \n\t  #tempNumberOfElements := #tempUpperBound - #tempLowerBound + #NUMBER_OF_ELEMENTS_CORRECTION;\n\t  \n\t  #tempLowerBoundOut := DINT_TO_INT(LOWER_BOUND(ARR := #smoothedValues, DIM := #DIMENSION_ONE));\n\t  #tempUpperBoundOut := DINT_TO_INT(UPPER_BOUND(ARR := #smoothedValues, DIM := #DIMENSION_ONE));\n\t  \n\t  #tempNumberOfElementsOut := #tempUpperBoundOut - #tempLowerBoundOut + #NUMBER_OF_ELEMENTS_CORRECTION;\n\t  \n\t  //check if size of arrays is ok\n\t  IF #tempNumberOfElementsOut <> #tempNumberOfElements THEN\n\t    #error := true;\n\t    #status := #ERR_ARRAYS_DIFFERENT;\n\t    RETURN;\n\t  ELSIF #tempNumberOfElements <= #MINIMUM_ARRAY_ELEMENTS THEN\n\t    #error := true;\n\t    #status := #ERR_NOT_ENOUGH_VALUES;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  FOR #tempCount := #tempLowerBound + 2 TO #tempUpperBound - 2 DO\n\t    // calculate new smoothed value\n\t    // keep the \"Magic Numbers\" as they are part of the Math equation and would extent the formular in a unreadable way\n\t    // y(n)=1/35*(-3*y(n-2)+12*y(n-1)+17*y(n)+12*y(n+1)-3*y(n+2))\n\t    // 1/35 = 0.028571\n\t    #smoothedValues[#tempCount] := 0.028571 * (-3 * #values[#tempCount - 2] + 12 * #values[#tempCount - 1] + 17 * #values[#tempCount] + 12 * #values[#tempCount + 1] - 3 * #values[#tempCount + 2]);\n\t  END_FOR;\n\t  \n\t  // calculate Replacementvalues for 0,1 and n-1,n\n\t  // y(0) =1/70*(69*y(0)+4*y(1)-6*y(2)+4*y(3)-y(4))\n\t  // 1/70 = 0.014286\n\t  #smoothedValues[#tempLowerBound] := 0.014286 * (69 * #values[#tempLowerBound] + 4 * #values[#tempLowerBound + 1] - 6 * #values[#tempLowerBound + 2] + 4 * #values[#tempLowerBound + 3] - #values[#tempLowerBound + 4]);\n\t  // y(1) =2/70*(2*y(0)+27*y(1)+12*y(2)-8*y(3)+2*y(4))\n\t  // 2/70 = 0.028571\n\t  #smoothedValues[#tempLowerBound + 1] := 0.028571 * (2 * #values[#tempLowerBound] + 27 * #values[#tempLowerBound + 1] + 12 * #values[#tempLowerBound + 2] - 8 * #values[#tempLowerBound + 3] + 2 * #values[#tempLowerBound + 4]);\n\t  // y(n-1) =2/70*(2*y(n-4)-8*y(n-3)+12*y(n-2)+27*y(n-1)+2*y(n))\n\t  // 2/70 = 0.028571\n\t  #smoothedValues[#tempUpperBound - 1] := 0.028571 * (2 * #values[#tempUpperBound - 4] - 8 * #values[#tempUpperBound - 3] + 12 * #values[#tempUpperBound - 2] + 27 * #values[#tempUpperBound - 1] + 2 * #values[#tempUpperBound]);\n\t  // y(n) =1/70*(-y(n-4)+4*y(n-3)-6*y(n-2)+4*y(n-1)+69*y(n))\n\t  // 1/70 = 0.014286\n\t  #smoothedValues[#tempUpperBound] := 0.014286 * (- #values[#tempUpperBound - 4] + 4 * #values[#tempUpperBound - 3] - 6 * #values[#tempUpperBound - 2] + 4 * #values[#tempUpperBound - 1] + 69 * #values[#tempUpperBound]);\n\t  \n\t  #error := false;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  // ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "Boxplot_DInt", "description": "If you want to get an overview of existing data, you can use a Boxplot diagram. A Boxplot shows you in which area the data is located and how it is distributed over this area. A Boxplot consists of the following parameters: • Minimum (smallest occurring value of the sample) • Lower or first quartile (below this value are 25% of the sample values) • Median or second quartile (below this value are 50% of the sample values) • Upper or third quartile (below this value are 75% of the sample values) • Maximum (largest occurring value of the sample) Figure: Boxplot WinCC-Control To visualize the Boxplot, the Siemens Industry Online Support offers you a Net-Control, which you can use in conjunction with WinCC Runtime Professional. You can find the controls in the UserFiles folder of this library. Figure: .Net Control “Boxplot” Entry ID: 109479728 | V5.2.0 | 08/2025 Generated with Code2Docu © Siemens 2025 | 312 Program blocks", "type": "FUNCTION_BLOCK", "name": "LGF_Boxplot_DInt", "vars": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection:\n* 0: Outlier detection is deactivated\n* 0-1: Invalid value\n* >1: Outlier detection is activated."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %."}, {"name": "max", "type": "DInt", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "DInt", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %."}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}, {"name": "values", "type": "Array[*] of DInt", "description": "The array containing the data series that is to be used for the\ncalculation"}], "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection:\n* 0: Outlier detection is deactivated\n* 0-1: Invalid value\n* >1: Outlier detection is activated."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %."}, {"name": "max", "type": "DInt", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "DInt", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %."}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "The array containing the data series that is to be used for the\ncalculation"}], "answer": "FUNCTION_BLOCK \"LGF_Boxplot_DInt\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_Boxplot_DInt\n   VAR_INPUT \n      execute : Bool;\n      rangeOutlier : LReal := 1.5;\n   END_VAR\n\n   VAR_OUTPUT \n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      subfunctionStatus { ExternalWritable := 'False'} : Word;\n      outlierMax { ExternalWritable := 'False'} : LReal;\n      max { ExternalWritable := 'False'} : DInt;\n      q75 { ExternalWritable := 'False'} : LReal;\n      median { ExternalWritable := 'False'} : LReal;\n      q25 { ExternalWritable := 'False'} : LReal;\n      min { ExternalWritable := 'False'} : DInt;\n      outlierMin { ExternalWritable := 'False'} : LReal;\n      skewness { ExternalWritable := 'False'} : LReal;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of DInt;\n   END_VAR\n\n   VAR \n      statMaxNew { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statMinNew { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statSubfuncStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statExecuteOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      instShellSort { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_ShellSort_DInt\";\n      statMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statQuartil25 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statQuartil75 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statNumberOfElements { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statMedian { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statDeltaQuartil { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statOutlierMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statOutlierMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statSkewness { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statBorderOutlier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempK : LReal;\n      tempValueDInt : DInt;\n      tempValueDInt1 : DInt;\n      tempArrLowBound : DInt;\n      tempArrUppBound : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_LREAL : LReal := 0.0;\n      ZERO_DINT : DInt := 0;\n      RANGE_OUTLIER_LOWER_BORDER : LReal := 1.0;\n      ELEMENTS_COUNT_CORRECTION : Int := 1;\n      CONVERT_TO_PERCENT : Int := 100;\n      DIMENSION_ONE : UDInt := 1;\n      NO_REMAINDER : Int := 0;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_EXECUTION_FINISHED : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      ERR_NEG_ARR_BOUND : Word := 16#8200;\n      ERR_SHELL_SORT : Word := 16#8600;\n      ERR_RANGE_NOT_OK : Word := 16#9101;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_Boxplot_Dint\n\t  // Comment/Function: The function block sorts the data row and calculates\n\t  //                   the so-called \"five point summary\" for an array of double integers\n\t  //                   Auto ENO disabled, forced to true - error handling done by error and status\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V5.0 \n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO disabled, forced to true - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //----------|------------|------------------------|----------------------------\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|----------------------------\n\t  // 01.00.00 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 01.00.01 | 05.11.2019 | Simatic Systems Support\n\t  //                       | Code reworked, regions, comments and constants are added\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  // 03.00.02 | 05.09.2024 | Simatic Systems Support\n\t  //                       | Fixed bug for array starting index\n\t  // 03.00.03 | 16.07.2025 | Simatic Systems Support\n\t  //                       | Fixed comments and block info header                    \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t    (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Dectect execution bit\n\t    //Positive edge detection\n\t    IF #execute AND NOT #statExecuteOld THEN\n\t        //count array elements\n\t        #tempArrLowBound := LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t        #tempArrUppBound := UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t        \n\t        //Reset outputs and statics\n\t        #statStatus := #STATUS_FIRST_CALL;\n\t        #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t        #statQuartil25 := #ZERO_LREAL;\n\t        #statMedian := #ZERO_LREAL;\n\t        #statQuartil75 := #ZERO_LREAL;\n\t        #statOutlierMax := #ZERO_LREAL;\n\t        #statOutlierMin := #ZERO_LREAL;\n\t        #statSkewness := #ZERO_LREAL;\n\t        #statMaxNew := #ZERO_DINT;\n\t        #statMinNew := #ZERO_DINT;\n\t        #statMin := #ZERO_DINT;\n\t        #statMax := #ZERO_DINT;\n\t        \n\t        //FB is currently inactive\n\t    ELSIF NOT #execute THEN\n\t        #statStatus := #STATUS_NO_CALL;\n\t        #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t    END_IF;\n\t    #statExecuteOld := #execute;\n\tEND_REGION\n\t\n\tREGION Validation\n\t    //Check rangeOutlier\n\t    IF #statStatus = #STATUS_FIRST_CALL THEN\n\t        //Value is not ok. Range have to be > 1.0 or 0.0\n\t        IF #rangeOutlier <> #ZERO_LREAL AND #rangeOutlier <= #RANGE_OUTLIER_LOWER_BORDER THEN\n\t            #statStatus := #ERR_RANGE_NOT_OK;\n\t            \n\t            //Check array boundry\n\t        ELSIF #tempArrLowBound < 0 THEN\n\t            #statStatus := #ERR_NEG_ARR_BOUND;\n\t        END_IF;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Boxplot calculation\n\t    IF #statStatus = #STATUS_FIRST_CALL THEN\n\t        //Get number of elents of the array\n\t        #statNumberOfElements := (#tempArrUppBound - #tempArrLowBound + #ELEMENTS_COUNT_CORRECTION);\n\t        \n\t        //Sort array\n\t        #instShellSort(array := #values);\n\t        \n\t        IF #instShellSort.error THEN\n\t            #statStatus := #ERR_SHELL_SORT;\n\t            #statSubfuncStatus := #instShellSort.status;\n\t        ELSE\n\t            #statMin := #values[#tempArrLowBound];\n\t            #statMax := #values[#tempArrUppBound];\n\t            //calculate median (Q50) - different calculation if the Number of Elements is even or odd \n\t            IF (#statNumberOfElements MOD 2) = #NO_REMAINDER THEN\n\t                // if n is even -> calculate MEDIAN = (x(n/2)+x(n/2+1))/2 \n\t                #tempValueDInt := #values[((#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION) / 2) + #tempArrLowBound];\n\t                #tempValueDInt1 := #values[(((#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION) / 2) + 1) + #tempArrLowBound];\n\t                #statMedian := DINT_TO_LREAL(((#tempValueDInt1 + #tempValueDInt) / 2));\n\t            ELSE\n\t                // if n is odd -> MEDIAN = x(n+1/2)\n\t                #statMedian := DINT_TO_LREAL(#values[((#statNumberOfElements + 1 - #ELEMENTS_COUNT_CORRECTION) / 2) + #tempArrLowBound]);\n\t            END_IF;\n\t            \n\t            //calculate 1.quartil(Q25)\n\t            // q1 = x(k) with  k=(n+3)/4 \n\t            #tempK := (DINT_TO_LREAL(#statNumberOfElements + 3 - #ELEMENTS_COUNT_CORRECTION) / 4.0) + #tempArrLowBound;\n\t            \n\t            \n\t            \n\t            #tempValueDInt := #values[TRUNC(#tempK)];\n\t            #tempValueDInt1 := #values[TRUNC(#tempK) + 1];\n\t            #statQuartil25 := DINT_TO_LREAL(#tempValueDInt) + (FRAC_LREAL(#tempK) * DINT_TO_LREAL(#tempValueDInt1 - #tempValueDInt));\n\t            \n\t            //calculate 3.quartil(Q75)\n\t            //q3 = x(n+1-k) with k=(3n+1)/4\n\t            #tempK := (3 * DINT_TO_LREAL(#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION + 1) / 4.0) + #tempArrLowBound;\n\t            \n\t            #tempValueDInt := #values[TRUNC(#tempK)];\n\t            #tempValueDInt1 := #values[TRUNC(#tempK) + 1];\n\t            #statQuartil75 := DINT_TO_LREAL(#tempValueDInt) + FRAC_LREAL(#tempK) * DINT_TO_REAL(#tempValueDInt1 - #tempValueDInt);\n\t            \n\t            //only if RANGE_OUTLIER is not zero\n\t            IF #rangeOutlier <> 0 THEN\n\t                //calculate Delta Q75-Q25\n\t                #statDeltaQuartil := #statQuartil75 - #statQuartil25;\n\t                \n\t                //check for min outlier\n\t                //calculate border for outlier\n\t                #statBorderOutlier := #statQuartil25 - #rangeOutlier * #statDeltaQuartil;\n\t                \n\t                //search in array for values outside the border\n\t                FOR #statCounter := 0 TO DINT_TO_INT(#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION) DO\n\t                    #tempValueDInt := #values[#statCounter + #tempArrLowBound];\n\t                    IF #tempValueDInt < LREAL_TO_DINT(#statBorderOutlier) THEN\n\t                        //detected a value as outlier, check next value\n\t                        ;\n\t                    ELSE\n\t                        //all outlier detected. Calulate new Min Value in range and calulate outlier in %\n\t                        #statOutlierMin := DINT_TO_LREAL((#CONVERT_TO_PERCENT * #statCounter)) / DINT_TO_LREAL(#statNumberOfElements);\n\t                        #statMinNew := #tempValueDInt;\n\t                        EXIT;\n\t                    END_IF;\n\t                END_FOR;\n\t                \n\t                //check for max outlier\n\t                //calculate border for outlier\n\t                #statBorderOutlier := #statQuartil75 + #rangeOutlier * #statDeltaQuartil;\n\t                //search in array for values outside the border \n\t                FOR #statCounter := DINT_TO_INT(#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION) TO 0 BY - 1 DO\n\t                    #tempValueDInt := #values[#statCounter + #tempArrLowBound];\n\t                    IF #tempValueDInt > LREAL_TO_DINT(#statBorderOutlier) THEN\n\t                        //detected a value as outlier, check next value\n\t                        ;\n\t                    ELSE\n\t                        //all outlier detected. Calulate new Max Value in range and calulate outliers in %\n\t                        #statOutlierMax := DINT_TO_REAL((#CONVERT_TO_PERCENT * (#statNumberOfElements - INT_TO_DINT(#statCounter) - #ELEMENTS_COUNT_CORRECTION))) / DINT_TO_REAL(#statNumberOfElements);\n\t                        #statMaxNew := #tempValueDInt;\n\t                        EXIT;\n\t                    END_IF;\n\t                END_FOR;\n\t            END_IF;\n\t            \n\t            //calculate Skewness\n\t            //S= ((Q25 + Q75)-2*Q50) / (Q75 - Q25)\n\t            #statSkewness := (#statQuartil75 + #statQuartil25 - 2.0 * #statMedian) / (#statQuartil75 - #statQuartil25);\n\t            \n\t            #statStatus := #STATUS_EXECUTION_FINISHED;\n\t            #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t            \n\t        END_IF;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Write Outputs\n\t    IF #rangeOutlier <> #ZERO_LREAL THEN\n\t        #min := #statMinNew;\n\t        #max := #statMaxNew;\n\t    ELSE\n\t        #min := #statMin;\n\t        #max := #statMax;\n\t    END_IF;\n\t    \n\t    #q25 := #statQuartil25;\n\t    #median := #statMedian;\n\t    #q75 := #statQuartil75;\n\t    #outlierMin := #statOutlierMin;\n\t    #outlierMax := #statOutlierMax;\n\t    #skewness := #statSkewness;\n\t    \n\t    #error := #statStatus.%X15;\n\t    #status := #statStatus;\n\t    #subfunctionStatus := #statSubfuncStatus;\n\t    \n\t    // ENO mechanism is not used - forced to true.\n\t    ENO := TRUE;\n\tEND_REGION\n\t\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "Boxplot_LReal", "description": "If you want to get an overview of existing data, you can use a Boxplot diagram. A Boxplot shows you in which area the data is located and how it is distributed over this area. A Boxplot consists of the following parameters: • Minimum (smallest occurring value of the sample) • Lower or first quartile (below this value are 25% of the sample values) • Median or second quartile (below this value are 50% of the sample values) • Upper or third quartile (below this value are 75% of the sample values) • Maximum (largest occurring value of the sample) Figure: Boxplot WinCC-Control To visualize the Boxplot, the Siemens Industry Online Support offers you a Net-Control, which you can use in conjunction with WinCC Runtime Professional. You can find the controls in the UserFiles folder of this library. Figure: .Net Control “Boxplot” Entry ID: 109479728 | V5.2.0 | 08/2025 Generated with Code2Docu © Siemens 2025 | 316 Program blocks", "type": "FUNCTION_BLOCK", "name": "LGF_Boxplot_LReal", "vars": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection:\n* 0: Outlier detection is deactivated\n* 0-1: Invalid value\n* >1: Outlier detection is activated."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %."}, {"name": "max", "type": "LReal", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "LReal", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %."}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}, {"name": "values", "type": "Array[*] of LReal", "description": "The array containing the data series that is to be used for the\ncalculation"}], "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection:\n* 0: Outlier detection is deactivated\n* 0-1: Invalid value\n* >1: Outlier detection is activated."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %."}, {"name": "max", "type": "LReal", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "LReal", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %."}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "The array containing the data series that is to be used for the\ncalculation"}], "answer": "FUNCTION_BLOCK \"LGF_Boxplot_LReal\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_Boxplot_LReal\n   VAR_INPUT \n      execute : Bool;\n      rangeOutlier : LReal := 1.5;\n   END_VAR\n\n   VAR_OUTPUT \n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := 16#0;\n      subfunctionStatus { ExternalWritable := 'False'} : Word;\n      outlierMax { ExternalWritable := 'False'} : LReal;\n      max { ExternalWritable := 'False'} : LReal;\n      q75 { ExternalWritable := 'False'} : LReal;\n      median { ExternalWritable := 'False'} : LReal;\n      q25 { ExternalWritable := 'False'} : LReal;\n      min { ExternalWritable := 'False'} : LReal;\n      outlierMin { ExternalWritable := 'False'} : LReal;\n      skewness { ExternalWritable := 'False'} : LReal;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of LReal;\n   END_VAR\n\n   VAR \n      statMaxNew { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statMinNew { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statSubfuncStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statExecuteOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      instShellSort { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_ShellSort_LReal\";\n      statMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statQuartil25 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statQuartil75 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statNumberOfElements { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statMedian { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statDeltaQuartil { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statOutlierMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statOutlierMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statSkewness { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statBorderOutlier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempK : LReal;\n      tempValueLReal : LReal;\n      tempValueLReal1 : LReal;\n      tempArrLowBound : DInt;\n      tempArrUppBound : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_LREAL : LReal := 0.0;\n      ZERO_DINT : DInt := 0;\n      RANGE_OUTLIER_LOWER_BORDER : LReal := 1.0;\n      ELEMENTS_COUNT_CORRECTION : Int := 1;\n      CONVERT_TO_PERCENT : Int := 100;\n      DIMENSION_ONE : UDInt := 1;\n      NO_REMAINDER : UDInt := 0;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_EXECUTION_FINISHED : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      ERR_NEG_ARR_BOUND : Word := 16#8200;\n      ERR_SHELL_SORT : Word := 16#8600;\n      ERR_RANGE_NOT_OK : Word := 16#9101;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_Boxplot_LReal\n\t  // Comment/Function: The function block sorts the data row and calculates\n\t  //                   the so-called \"five point summary\" for an array of long real\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V5.0 \n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO disabled, forced to true - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //----------|------------|------------------------|----------------------------\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|----------------------------\n\t  // 01.00.00 | 05.11.2019 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  // 03.00.02 | 05.09.2024 | Simatic Systems Support\n\t  //                       | Fixed bug for array starting index\n\t  // 03.00.03 | 16.07.2025 | Simatic Systems Support\n\t  //                       | Fixed comments and block info header \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Dectect execution bit\n\t  //Positive edge detection\n\t  IF #execute AND NOT #statExecuteOld THEN\n\t    //count array elements\n\t    #tempArrLowBound := LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t    #tempArrUppBound := UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t    \n\t    //Reset outputs and statics\n\t    #statStatus := #STATUS_FIRST_CALL;\n\t    #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t    #statQuartil25 := #ZERO_LREAL;\n\t    #statMedian := #ZERO_LREAL;\n\t    #statQuartil75 := #ZERO_LREAL;\n\t    #statOutlierMax := #ZERO_LREAL;\n\t    #statOutlierMin := #ZERO_LREAL;\n\t    #statSkewness := #ZERO_LREAL;\n\t    #statMaxNew := #ZERO_DINT;\n\t    #statMinNew := #ZERO_DINT;\n\t    #statMin := #ZERO_DINT;\n\t    #statMax := #ZERO_DINT;\n\t    \n\t    //FB is currently inactive\n\t  ELSIF NOT #execute THEN\n\t    #statStatus := #STATUS_NO_CALL;\n\t    #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t  END_IF;\n\t  #statExecuteOld := #execute;\n\tEND_REGION\n\t\n\tREGION Validation\n\t  //Check rangeOutlier\n\t  IF #statStatus = #STATUS_FIRST_CALL THEN\n\t    //Value is not ok. Range have to be > 1.0 or 0.0\n\t    IF #rangeOutlier <> #ZERO_LREAL AND #rangeOutlier <= #RANGE_OUTLIER_LOWER_BORDER THEN\n\t      #statStatus := #ERR_RANGE_NOT_OK;\n\t      \n\t      //Check array boundry\n\t    ELSIF #tempArrLowBound < 0 THEN\n\t      #statStatus := #ERR_NEG_ARR_BOUND;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Boxplot calculation\n\t  IF #statStatus = #STATUS_FIRST_CALL THEN\n\t    //Get number of elents of the array\n\t    #statNumberOfElements := (#tempArrUppBound - #tempArrLowBound + #ELEMENTS_COUNT_CORRECTION);\n\t    \n\t    //Sort array\n\t    #instShellSort(array := #values);\n\t    \n\t    IF #instShellSort.error THEN\n\t      #statStatus := #ERR_SHELL_SORT;\n\t      #statSubfuncStatus := #instShellSort.status;\n\t    ELSE\n\t      #statMin := #values[#tempArrLowBound];\n\t      #statMax := #values[#tempArrUppBound];\n\t      //calculate median (Q50) - different calculation if the Number of Elements is even or odd \n\t      IF (#statNumberOfElements MOD 2) = #NO_REMAINDER THEN\n\t        // if n is even -> calculate MEDIAN = (x(n/2)+x(n/2+1))/2 \n\t          #tempValueLReal := #values[((#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION) / 2) + #tempArrLowBound];\n\t          #tempValueLReal1 := #values[(((#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION) / 2) + 1) + #tempArrLowBound];\n\t        #statMedian := ((#tempValueLReal1 + #tempValueLReal) / 2);\n\t      ELSE\n\t        // if n is odd -> MEDIAN = x(n+1/2)\n\t          #statMedian := #values[((#statNumberOfElements + 1 - #ELEMENTS_COUNT_CORRECTION) / 2) + #tempArrLowBound];\n\t      END_IF;\n\t      \n\t      //calculate 1.quartil(Q25)\n\t      // q1 = x(k) with  k=(n+3)/4 \n\t      #tempK := (DINT_TO_LREAL(#statNumberOfElements + 3 - #ELEMENTS_COUNT_CORRECTION) / 4.0) + #tempArrLowBound;\n\t      \n\t      #tempValueLReal := #values[TRUNC(#tempK)];\n\t      #tempValueLReal1 := #values[TRUNC(#tempK) + 1];\n\t      #statQuartil25 := #tempValueLReal + (FRAC_LREAL(#tempK) * (#tempValueLReal1 - #tempValueLReal));\n\t      \n\t      //calculate 3.quartil(Q75)\n\t      //q3 = x(n+1-k) with k=(3n+1)/4\n\t      #tempK := ((3 * DINT_TO_LREAL(#statNumberOfElements + 1 - #ELEMENTS_COUNT_CORRECTION)) / 4.0)+ #tempArrLowBound;\n\t      \n\t      #tempValueLReal := #values[TRUNC(#tempK)];\n\t      #tempValueLReal1 := #values[TRUNC(#tempK) + 1];\n\t      #statQuartil75 := #tempValueLReal + FRAC_LREAL(#tempK) * (#tempValueLReal1 - #tempValueLReal);\n\t      \n\t      //only if RANGE_OUTLIER <> 0\n\t      IF #rangeOutlier <> 0 THEN\n\t        //calculate Delta Q75-Q25\n\t        #statDeltaQuartil := #statQuartil75 - #statQuartil25;\n\t        //check for min outlier\n\t        //calculate border for outlier\n\t        #statBorderOutlier := #statQuartil25 - #rangeOutlier * #statDeltaQuartil;\n\t        \n\t        //search in array for values outside the border\n\t        FOR #statCounter := 0 TO DINT_TO_INT(#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION) DO\n\t            #tempValueLReal := #values[#statCounter + #tempArrLowBound];\n\t          \n\t          IF #tempValueLReal < LREAL_TO_DINT(#statBorderOutlier) THEN\n\t            //detected a value as outlier, check next value\n\t            ;\n\t          ELSE\n\t            //all outlier detected. Calulate new Min Value in range and calulate outlier in %\n\t            #statOutlierMin := DINT_TO_LREAL((#CONVERT_TO_PERCENT * #statCounter)) / DINT_TO_LREAL(#statNumberOfElements);\n\t            #statMinNew := #tempValueLReal;\n\t            EXIT;\n\t          END_IF;\n\t        END_FOR;\n\t        \n\t        //check for max outlier\n\t        //calculate border for outlier\n\t        #statBorderOutlier := #statQuartil75 + #rangeOutlier * #statDeltaQuartil;\n\t        //search in array for values outside the border \n\t        FOR #statCounter := DINT_TO_INT(#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION) TO 0 BY - 1 DO\n\t            #tempValueLReal := #values[#statCounter + #tempArrLowBound];\n\t          IF #tempValueLReal > LREAL_TO_DINT(#statBorderOutlier) THEN\n\t            //detected a value as outlier, check next value\n\t            ;\n\t          ELSE\n\t            //all outlier detected. Calulate new Max Value in range and calulate outliers in %\n\t            #statOutlierMax := DINT_TO_LREAL((#CONVERT_TO_PERCENT * (#statNumberOfElements - INT_TO_DINT(#statCounter) - #ELEMENTS_COUNT_CORRECTION))) / DINT_TO_LREAL(#statNumberOfElements);\n\t            #statMaxNew := #tempValueLReal;\n\t            EXIT;\n\t          END_IF;\n\t        END_FOR;\n\t      END_IF;\n\t      \n\t      //calculate Skewness\n\t      //S= ((Q25 + Q75)-2*Q50) / (Q75 - Q25)\n\t      #statSkewness := (#statQuartil75 + #statQuartil25 - 2.0 * #statMedian) / (#statQuartil75 - #statQuartil25);\n\t      \n\t      #statStatus := #STATUS_EXECUTION_FINISHED;\n\t      #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t      \n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Write Outputs\n\t  IF #rangeOutlier <> #ZERO_DINT THEN\n\t    #min := #statMinNew;\n\t    #max := #statMaxNew;\n\t  ELSE\n\t    #min := #statMin;\n\t    #max := #statMax;\n\t  END_IF;\n\t  \n\t  #q25 := #statQuartil25;\n\t  #median := #statMedian;\n\t  #q75 := #statQuartil75;\n\t  #outlierMin := #statOutlierMin;\n\t  #outlierMax := #statOutlierMax;\n\t  #skewness := #statSkewness;\n\t  \n\t  #error := #statStatus.%X15;\n\t  #status := #statStatus;\n\t  #subfunctionStatus := #statSubfuncStatus;\n\t  \n\t  // ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "Boxplot_UDInt", "description": "If you want to get an overview of existing data, you can use a Boxplot diagram. A Boxplot shows you in which area the data is located and how it is distributed over this area. A Boxplot consists of the following parameters: • Minimum (smallest occurring value of the sample) • Lower or first quartile (below this value are 25% of the sample values) • Median or second quartile (below this value are 50% of the sample values) • Upper or third quartile (below this value are 75% of the sample values) • Maximum (largest occurring value of the sample) Figure: Boxplot WinCC-Control To visualize the Boxplot, the Siemens Industry Online Support offers you a Net-Control, which you can use in conjunction with WinCC Runtime Professional. You can find the controls in the UserFiles folder of this library. Figure: .Net Control “Boxplot” Entry ID: 109479728 | V5.2.0 | 08/2025 Generated with Code2Docu © Siemens 2025 | 320 Program blocks", "type": "FUNCTION_BLOCK", "name": "LGF_Boxplot_UDInt", "vars": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection:\n* 0: Outlier detection is deactivated\n* 0-1: Invalid value\n* >1: Outlier detection is activated."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %."}, {"name": "max", "type": "UDInt", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "UDInt", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %."}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}, {"name": "values", "type": "Array[*] of UDInt", "description": "The array containing the data series that is to be used for the\ncalculation"}], "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection:\n* 0: Outlier detection is deactivated\n* 0-1: Invalid value\n* >1: Outlier detection is activated."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %."}, {"name": "max", "type": "UDInt", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "UDInt", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %."}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "The array containing the data series that is to be used for the\ncalculation"}], "answer": "FUNCTION_BLOCK \"LGF_Boxplot_UDInt\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_Boxplot_UDInt\n   VAR_INPUT \n      execute : Bool;\n      rangeOutlier : LReal := 1.5;\n   END_VAR\n\n   VAR_OUTPUT \n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      subfunctionStatus { ExternalWritable := 'False'} : Word;\n      outlierMax { ExternalWritable := 'False'} : LReal;\n      max { ExternalWritable := 'False'} : UDInt;\n      q75 { ExternalWritable := 'False'} : LReal;\n      median { ExternalWritable := 'False'} : LReal;\n      q25 { ExternalWritable := 'False'} : LReal;\n      min { ExternalWritable := 'False'} : UDInt;\n      outlierMin { ExternalWritable := 'False'} : LReal;\n      skewness { ExternalWritable := 'False'} : LReal;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of UDInt;\n   END_VAR\n\n   VAR \n      statMaxNew { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n      statMinNew { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statSubfuncStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statExecuteOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      instShellSort { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_ShellSort_UDInt\";\n      statMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n      statMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n      statQuartil25 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statQuartil75 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statNumberOfElements { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statMedian { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statDeltaQuartil { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statOutlierMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statOutlierMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statSkewness { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statBorderOutlier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempK : LReal;\n      tempValueUDInt : UDInt;\n      tempValueUDInt1 : UDInt;\n      tempArrLowBound : DInt;\n      tempArrUppBound : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_LREAL : LReal := 0.0;\n      ZERO_UINT : UInt := 0;\n      RANGE_OUTLIER_LOWER_BORDER : LReal := 1.0;\n      ELEMENTS_COUNT_CORRECTION : Int := 1;\n      CONVERT_TO_PERCENT : Int := 100;\n      DIMENTION_ONE : UDInt := 1;\n      NO_REMAINDER : UDInt := 0;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_EXECUTION_FINISHED : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      ERR_NEG_ARR_BOUND : Word := 16#8200;\n      ERR_SHELL_SORT : Word := 16#8600;\n      ERR_RANGE_NOT_OK : Word := 16#9101;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_Boxplot_UDInt\n\t  // Comment/Function: The function block sorts the data row and calculates\n\t  //                   the so-called \"five point summary\" for an array of unsigned double integers\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V5.0 \n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO disabled, forced to true - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //----------|------------|------------------------|----------------------------\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|----------------------------\n\t  // 01.00.00 | 05.11.2019 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  // 03.00.02 | 05.09.2024 | Simatic Systems Support\n\t  //                       | Fixed bug for array starting index\n\t  // 03.00.03 | 16.07.2025 | Simatic Systems Support\n\t  //                       | Fixed comments and block info header \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Dectect execution bit\n\t  //Positive edge detection\n\t  IF #execute AND NOT #statExecuteOld THEN\n\t    //Get array boundaries\n\t    #tempArrLowBound := LOWER_BOUND(ARR := #values, DIM := #DIMENTION_ONE);\n\t    #tempArrUppBound := UPPER_BOUND(ARR := #values, DIM := #DIMENTION_ONE);\n\t    \n\t    //Reset outputs and statics\n\t    #statStatus := #STATUS_FIRST_CALL;\n\t    #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t    #statQuartil25 := #ZERO_LREAL;\n\t    #statMedian := #ZERO_LREAL;\n\t    #statQuartil75 := #ZERO_LREAL;\n\t    #statOutlierMax := #ZERO_LREAL;\n\t    #statOutlierMin := #ZERO_LREAL;\n\t    #statSkewness := #ZERO_LREAL;\n\t    #statMaxNew := #ZERO_UINT;\n\t    #statMinNew := #ZERO_UINT;\n\t    #statMin := #ZERO_UINT;\n\t    #statMax := #ZERO_UINT;\n\t    \n\t    //FB is currently inactive\n\t  ELSIF NOT #execute THEN\n\t    #statStatus := #STATUS_NO_CALL;\n\t    #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t  END_IF;\n\t  #statExecuteOld := #execute;\n\tEND_REGION\n\t\n\tREGION Validation\n\t  //Check rangeOutlier\n\t  IF #statStatus = #STATUS_FIRST_CALL THEN\n\t    //Value is not ok. Range have to be > 1.0 or 0.0\n\t    IF #rangeOutlier <> #ZERO_LREAL AND #rangeOutlier <= #RANGE_OUTLIER_LOWER_BORDER THEN\n\t      #statStatus := #ERR_RANGE_NOT_OK;\n\t      \n\t      //Check array boundry\n\t    ELSIF #tempArrLowBound < 0 THEN\n\t      #statStatus := #ERR_NEG_ARR_BOUND;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Boxplot calculation\n\t  IF #statStatus = #STATUS_FIRST_CALL THEN\n\t    //Get number of elements of the array\n\t    #statNumberOfElements := (#tempArrUppBound - #tempArrLowBound + #ELEMENTS_COUNT_CORRECTION);\n\t    \n\t    //Sort array\n\t    #instShellSort(array := #values);\n\t    \n\t    IF #instShellSort.error THEN\n\t      #statStatus := #ERR_SHELL_SORT;\n\t      #statSubfuncStatus := #instShellSort.status;\n\t    ELSE\n\t      #statMin := #values[#tempArrLowBound];\n\t      #statMax := #values[#tempArrUppBound];\n\t      //calculate median (Q50)\n\t      IF (#statNumberOfElements MOD 2) = #NO_REMAINDER THEN\n\t        // if n is even -> calculate MEDIAN = (x(n/2)+x(n/2+1))/2 \n\t          #tempValueUDInt := #values[((#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION) / 2) + #tempArrLowBound];\n\t          #tempValueUDInt1 := #values[(((#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION) / 2) + 1) + #tempArrLowBound];\n\t        #statMedian := ((#tempValueUDInt1 + #tempValueUDInt) / 2);\n\t      ELSE\n\t        // if n is odd -> MEDIAN = x(n+1/2)\n\t          #statMedian := #values[((#statNumberOfElements + 1 - #ELEMENTS_COUNT_CORRECTION) / 2) + #tempArrLowBound];\n\t      END_IF;\n\t      \n\t      //calculate 1.quartil(Q25)\n\t      // q1 = x(k) with  k=(n+3)/4 \n\t      #tempK := (DINT_TO_LREAL(#statNumberOfElements + 3 - #ELEMENTS_COUNT_CORRECTION) / 4.0) + #tempArrLowBound;\n\t      \n\t      #tempValueUDInt := #values[TRUNC(#tempK)];\n\t      #tempValueUDInt1 := #values[TRUNC(#tempK) + 1];\n\t      #statQuartil25 := UDINT_TO_LREAL(#tempValueUDInt) + (FRAC_LREAL(#tempK) * UDINT_TO_LREAL(#tempValueUDInt1 - #tempValueUDInt));\n\t      \n\t      //calculate 3.quartil(Q75)\n\t      //q3 = x(n+1-k) with k=(3n+1)/4\n\t      #tempK := (3 * DINT_TO_LREAL(#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION + 1) / 4.0) + #tempArrLowBound;\n\t      \n\t      #tempValueUDInt := #values[TRUNC(#tempK)];\n\t      #tempValueUDInt1 := #values[TRUNC(#tempK) + 1];\n\t      #statQuartil75 := UDINT_TO_LREAL(#tempValueUDInt) + FRAC_LREAL(#tempK) * UDINT_TO_LREAL(#tempValueUDInt1 - #tempValueUDInt);\n\t      \n\t      //only if RANGE_OUTLIER <> 0\n\t      IF #rangeOutlier <> 0 THEN\n\t        //calculate Delta Q75-Q25\n\t        #statDeltaQuartil := #statQuartil75 - #statQuartil25;\n\t        //check for min outlier\n\t        //calculate border for outlier\n\t        #statBorderOutlier := #statQuartil25 - #rangeOutlier * #statDeltaQuartil;\n\t        \n\t        //search in array for values outside the border\n\t        FOR #statCounter := 0 TO (DINT_TO_INT(#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION)) DO\n\t            #tempValueUDInt := #values[#statCounter + #tempArrLowBound];\n\t          \n\t          IF #tempValueUDInt < LREAL_TO_DINT(#statBorderOutlier) THEN\n\t            //detected a value as outlier, check next value\n\t            ;\n\t          ELSE\n\t            //all outlier detected. Calulate new Min Value in range and calulate outlier in %\n\t            #statOutlierMin := DINT_TO_LREAL((#CONVERT_TO_PERCENT * #statCounter)) / DINT_TO_LREAL(#statNumberOfElements);\n\t            #statMinNew := #tempValueUDInt;\n\t            EXIT;\n\t          END_IF;\n\t        END_FOR;\n\t        \n\t        //check for max outlier\n\t        //calculate border for outlier\n\t        #statBorderOutlier := #statQuartil75 + #rangeOutlier * #statDeltaQuartil;\n\t        //search in array for values outside the border \n\t        FOR #statCounter := DINT_TO_INT((#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION)) TO 0 BY - 1 DO\n\t            #tempValueUDInt := #values[#statCounter + #tempArrLowBound];\n\t          IF #tempValueUDInt > LREAL_TO_DINT(#statBorderOutlier) THEN\n\t            //detected a value as outlier, check next value\n\t            ;\n\t          ELSE\n\t            //all outlier detected. Calulate new Max Value in range and calulate outliers in %\n\t            #statOutlierMax := DINT_TO_LREAL((#CONVERT_TO_PERCENT * (#statNumberOfElements - INT_TO_DINT(#statCounter) - #ELEMENTS_COUNT_CORRECTION))) / DINT_TO_LREAL(#statNumberOfElements);\n\t            #statMaxNew := #tempValueUDInt;\n\t            EXIT;\n\t          END_IF;\n\t        END_FOR;\n\t      END_IF;\n\t      \n\t      //calculate Skewness\n\t      //S= ((Q25 + Q75)-2*Q50) / (Q75 - Q25)\n\t      #statSkewness := (#statQuartil75 + #statQuartil25 - 2.0 * #statMedian) / (#statQuartil75 - #statQuartil25);\n\t      \n\t      #statStatus := #STATUS_EXECUTION_FINISHED;\n\t      #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t      \n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Write outputs\n\t  IF #rangeOutlier <> #ZERO_LREAL THEN\n\t    #min := #statMinNew;\n\t    #max := #statMaxNew;\n\t  ELSE\n\t    #min := #statMin;\n\t    #max := #statMax;\n\t  END_IF;\n\t  \n\t  #q25 := #statQuartil25;\n\t  #median := #statMedian;\n\t  #q75 := #statQuartil75;\n\t  #outlierMin := #statOutlierMin;\n\t  #outlierMax := #statOutlierMax;\n\t  #skewness := #statSkewness;\n\t  \n\t  #error := #statStatus.%X15;\n\t  #status := #statStatus;\n\t  #subfunctionStatus := #statSubfuncStatus;\n\t  \n\t  // ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "DifferenceQuotientFB", "description": "This function numerically differentiates a signal sampled equidistantly in time. For example, the velocity can be calculated from a measured locus curve, or the acceleration can be calculated from the measured velocity. In order to minimize the effects of a scattering measurement signal, this algorithm uses a compensating polynomial. The function block calculates the differentiated values cyclically. The function block reads-in a value with each positive edge on the insert been read in, the block calculates a differentiated value and outputs it.", "type": "FUNCTION_BLOCK", "name": "LGF_DifferenceQuotientFB", "vars": [{"name": "enable", "type": "Bool", "description": "Activates the block. As long as enable is `TRUE`, the\nblock can accept values on the parameter `value`."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge\nand outputs a `derivatedValue` if five values have been\nread in."}, {"name": "value", "type": "LReal", "description": "Value that must be included in the differentiation."}, {"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values.\n(e.g. 1s)"}, {"name": "derivatedValue", "type": "LReal", "description": "The differentiated value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "enable", "type": "Bool", "description": "Activates the block. As long as enable is `TRUE`, the\nblock can accept values on the parameter `value`."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge\nand outputs a `derivatedValue` if five values have been\nread in."}, {"name": "value", "type": "LReal", "description": "Value that must be included in the differentiation."}, {"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values.\n(e.g. 1s)"}], "output": [{"name": "derivatedValue", "type": "LReal", "description": "The differentiated value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_DifferenceQuotientFB\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_DifferenceQuotientFB\n   VAR_INPUT \n      enable : Bool;\n      insert : Bool;\n      value : LReal;\n      deltaT : LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      derivatedValue { ExternalWritable := 'False'} : LReal;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR \n      statValues { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#MINIMUM_NUMBER_OF_VALUES] of LReal;\n      statCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statDerivatedValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statEnableOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statInsertOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : LReal := 0.0;\n      MINIMUM_NUMBER_OF_VALUES : UDInt := 4;\n      INCREMENT_VALUE : Int := 1;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      STATUS_NOT_ENOUGH_VALUES : Word := 16#7010;\n      ERR_DELTA_T : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_DifferenceQuotientFB\n\t  // Comment/Function: This function block differentiates a signal\n\t  //                   Magic numbers that are part of mathematics formula are\n\t  //                   left without constants.\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled, forced to true - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //----------|------------|------------------------|----------------------------\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|----------------------------\n\t  // 01.00.00 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 01.00.01 | 04.11.2019 | Simatic Systems Support\n\t  //                       | Code reworked.\n\t  //                       | Regions, comments and constants are added\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Check function block call \n\t  // // Check if FB is triggered - rising edge on enable\n\t  IF #enable AND NOT #statEnableOld THEN\n\t    // Reset \n\t    #statCount := 0;\n\t    #statValues[0] := #ZERO;\n\t    #statValues[1] := #ZERO;\n\t    #statValues[2] := #ZERO;\n\t    #statValues[3] := #ZERO;\n\t    #statValues[4] := #ZERO;\n\t    \n\t    // Set status for first call\n\t    #statStatus := #STATUS_FIRST_CALL;\n\t    \n\t    // enabled after edge trigger\n\t  ELSIF #enable AND #statEnableOld THEN\n\t    REGION Values inserting and smoothing calculation\n\t      // positive edge of insert detected \n\t      IF #insert AND NOT #statInsertOld THEN\n\t        // copy new value\n\t        #statValues[0] := #statValues[1]; // -> n-2\n\t        #statValues[1] := #statValues[2]; // -> n-1\n\t        #statValues[2] := #statValues[3]; // -> n\n\t        #statValues[3] := #statValues[4]; // -> n+1\n\t        #statValues[4] := #value; // -> n+2\n\t        \n\t        // Check if the minimum needed insered values is reached\n\t        // Increase the count of added values\n\t        IF #statCount <= #MINIMUM_NUMBER_OF_VALUES THEN\n\t          #statCount += #INCREMENT_VALUE;\n\t          #statStatus := #STATUS_NOT_ENOUGH_VALUES;\n\t          \n\t          // DeltaT cannot be zero, devision by zero not possible.\n\t        ELSIF #deltaT = #ZERO THEN\n\t          #statStatus := #ERR_DELTA_T;\n\t        ELSE\n\t          // calculate derivate value \n\t          // keep the \"Magic Numbers\" as they are part of the Math equation and would extent the formular in a unreadable way\n\t          // ẏ(n)=1/12deltaT*(y(n-2)-8y(n-1)+8y(n+1)-y(n+2))\n\t          #statDerivatedValue := (1.0 / (12.0 * #deltaT)) * (#statValues[0] - 8 * #statValues[1] + 8 * #statValues[3] - #statValues[4]);\n\t          #statStatus := #STATUS_SUBSEQUENT_CALL;\n\t        END_IF;\n\t      END_IF;\n\t    END_REGION\n\t  ELSE\n\t    #statDerivatedValue := #ZERO;\n\t    #statStatus := #STATUS_NO_CALL;\n\t  END_IF;\n\t  \n\t  // store previous values for edge dedection\n\t  #statEnableOld := #enable;\n\t  #statInsertOld := #insert;\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  #error := #statStatus.%X15;\n\t  #status := #statStatus;\n\t  #derivatedValue := #statDerivatedValue;\n\t  \n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "FloatingAverage", "description": "This function calculates a moving arithmetic mean value from REAL values. This method can be used to smooth data series. The values can be read in cyclically or triggered.", "type": "FUNCTION_BLOCK", "name": "LGF_FloatingAverage", "vars": [{"name": "cyclicExecution", "type": "Bool", "description": "TRUE: cyclic operation, trigger not in use"}, {"name": "trigger", "type": "Bool", "description": "Read in `value` with every pulse at input `trigger`"}, {"name": "value", "type": "LReal", "description": "Value/s from which the moving average is to be\ndetermined."}, {"name": "windowSize", "type": "Int", "description": "Window length for sliding averaging in the range from\n1..100.\nThe standard value is 100."}, {"name": "reset", "type": "Bool", "description": "TRUE: The block is reset and the calculation starts\nagain."}, {"name": "average", "type": "LReal", "description": "Moving / Floating average"}, {"name": "windowSizeReached", "type": "Bool", "description": "FALSE: Maximum window width not yet reached,\nTRUE: Maximum window width reached"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "cyclicExecution", "type": "Bool", "description": "TRUE: cyclic operation, trigger not in use"}, {"name": "trigger", "type": "Bool", "description": "Read in `value` with every pulse at input `trigger`"}, {"name": "value", "type": "LReal", "description": "Value/s from which the moving average is to be\ndetermined."}, {"name": "windowSize", "type": "Int", "description": "Window length for sliding averaging in the range from\n1..100.\nThe standard value is 100."}, {"name": "reset", "type": "Bool", "description": "TRUE: The block is reset and the calculation starts\nagain."}], "output": [{"name": "average", "type": "LReal", "description": "Moving / Floating average"}, {"name": "windowSizeReached", "type": "Bool", "description": "FALSE: Maximum window width not yet reached,\nTRUE: Maximum window width reached"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_FloatingAverage\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_FloatingAverage\n   VAR_INPUT \n      cyclicExecution : Bool := false;\n      trigger : Bool;\n      value : LReal;\n      windowSize : Int := 100;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      average { ExternalWritable := 'False'} : LReal;\n      windowSizeReached { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR \n      statValues { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[#ZERO_INT..#MAX_WINDOW_SIZE] of LReal;\n      statValuesSum { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 0.0;\n      statArithmeticAverage { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 0.0;\n      statWindowSizeOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;\n      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;\n      statwindowSizeReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statTriggerOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;\n   END_VAR\n\n   VAR_TEMP \n      tempValue : LReal;\n      tempIndex : Int;\n      tempTriggerEdge : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_INT : Int := 0;\n      ZERO_LREAL : LReal := 0.0;\n      MAX_WINDOW_SIZE : Int := 100;\n      INCREMENT : Int := 1;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_WRONG_WINDOW_SIZE : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_FloatingAverage\n\t  // Comment/Function: This function block calculates the floating arithmetic average\n\t  //                   of incoming REAL values each cycle or each trigger impulse.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled, forced to true - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 16.06.2016 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 01.00.01 | 02.01.2017 | Siemens Industry Online Support\n\t  //                       | Upgrade: TIA Portal V14 Update 1\n\t  // 01.01.00 | 21.02.2017 | Siemens Industry Online Support\n\t  //                       | Adding variable window size for calculation\n\t  //                       | Optimizing calculation algorithm\n\t  // 01.01.01 | 17.08.2018 | Siemens Industry Online Support\n\t  //                       | Upgrade: TIA V15 Update 2\n\t  // 01.01.02 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | Upgrade: TIA V15.1\n\t  // 01.01.03 | 07.11.2019 | Simatic Systems Support\n\t  //                       | Code refactoring, comments added\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 16.06.2020 | Simatic Systems Support\n\t  //                       | refactor and simplify code\n\t  // 03.00.02 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and input data processing\n\t  // Copy commonly used data to temp variables\n\t  #tempValue := #value;\n\t  \n\t  // Positive edge detection for triggering of calculation\n\t  #tempTriggerEdge := #trigger AND NOT #statTriggerOld;\n\t  #statTriggerOld := #trigger;\n\t  \n\t  // Reset OR if window size changes the calculation\n\t  IF #reset OR (#windowSize <> #statWindowSizeOld) THEN\n\t    #statWindowSizeOld := #windowSize;\n\t    #statCounter := #ZERO_INT;\n\t    #statValuesSum := #ZERO_LREAL;\n\t    #statArithmeticAverage := #ZERO_LREAL;\n\t    #average := #ZERO_LREAL;\n\t    #windowSizeReached := FALSE;\n\t    #statwindowSizeReached := FALSE;\n\t    #error := false;\n\t    #status := #STATUS_FINISHED_NO_ERROR;\n\t    RETURN;\n\t    \n\t    // Check window size, in case of incorrect window size setup an error\n\t  ELSIF (#windowSize <= #ZERO_INT) OR (#windowSize > #MAX_WINDOW_SIZE) THEN\n\t    #statWindowSizeOld := #windowSize;\n\t    #statCounter := #ZERO_INT;\n\t    #statValuesSum := #ZERO_LREAL;\n\t    #statArithmeticAverage := #ZERO_LREAL;\n\t    #average := #ZERO_LREAL;\n\t    #statwindowSizeReached := FALSE;\n\t    #windowSizeReached := FALSE;\n\t    #error := TRUE;\n\t    #status := #ERR_WRONG_WINDOW_SIZE; // Info \"No correct set of window size\"\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Floating average calculation\n\t  // Triggered calculation OR cyclicly operation\n\t  IF #cyclicExecution OR #tempTriggerEdge THEN\n\t    \n\t    //Calculate array counter by using modulo\n\t    #tempIndex := #statCounter MOD #windowSize;\n\t    \n\t    // First step - fill the Array with values\n\t    // as long as desired window size is not reached\n\t    // counter and array starts with zero\n\t    IF (#statCounter < #windowSize) THEN\n\t      // Add value to sum\n\t      #statValuesSum += #tempValue;\n\t      // Add value to window\n\t      #statValues[#tempIndex] := #tempValue;\n\t      // Increment counter\n\t      #statCounter += #INCREMENT;\n\t      // Calculate avarage value\n\t      #statArithmeticAverage := #statValuesSum / #statCounter;\n\t      \n\t    ELSE\n\t      // wuindow size is reached, set output\n\t      #statwindowSizeReached := TRUE;\n\t      // Add value to sum\n\t      #statValuesSum += #tempValue - #statValues[#tempIndex];\n\t      // Add value to window\n\t      #statValues[#tempIndex] := #tempValue;\n\t      // Calculate avarage value\n\t      #statArithmeticAverage := #statValuesSum / #windowSize;\n\t      \n\t      // Manipulate counter value of window if modulo calc result is zero\n\t      IF (#tempIndex = #ZERO_INT) THEN\n\t        #statCounter := #windowSize + #INCREMENT;\n\t      ELSE\n\t        // Increment counter\n\t        #statCounter += #INCREMENT;\n\t      END_IF;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Outputs\n\t  #average := #statArithmeticAverage;\n\t  #windowSizeReached := #statwindowSizeReached;\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  \n\t  // ENO mechanism is not used - forced to true\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "Histogram_DInt", "description": "The histogram shows the frequency distribution of a sample by class. A class describes a value interval in which the individual frequencies are added together. After specifying the number of classes, the class width and the respective class center are calculated. The number of classes is limited to 15. The distribution is represented as a rectangle around the class mean with the class width and the cumulated frequency as height. Figure: Distribution WinCC-Control To visualize the Boxplot, the Siemens Industry Online Support offers you a Net-Control, which you can use in conjunction with WinCC Runtime Professional. You can find the controls in the UserFiles folder of this library. Figure: .Net Control “Histogram” Entry ID: 109479728 | V5.2.0 | 08/2025 Generated with Code2Docu © Siemens 2025 | 328 Program blocks", "type": "FUNCTION_BLOCK", "name": "LGF_Histogram_DInt", "vars": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#\nCLASSES_COUNTE\nR_\nUP_LIMIT] of L\nReal", "description": "Outputs the calculated values in a two-dimensional array.\n• `histValues[0,0..14]` displays the relative frequency of the individual\nclasses.\n• `histValues[1,0..14]` displays the class centers.\n• If fewer than 15 classes are desired, the array elements that are not\nrequired are output with 0."}, {"name": "axis", "type": "Array[0..3] of L\nReal", "description": "Specifies the axis values:\n• Lower X axis value\n• Upper X axis value\n• Lower Y axis value\n• Upper Y axis value"}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}, {"name": "values", "type": "Array[*] of DInt", "description": "The array containing the data series that is to be used for the\ncalculation"}], "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#\nCLASSES_COUNTE\nR_\nUP_LIMIT] of L\nReal", "description": "Outputs the calculated values in a two-dimensional array.\n• `histValues[0,0..14]` displays the relative frequency of the individual\nclasses.\n• `histValues[1,0..14]` displays the class centers.\n• If fewer than 15 classes are desired, the array elements that are not\nrequired are output with 0."}, {"name": "axis", "type": "Array[0..3] of L\nReal", "description": "Specifies the axis values:\n• Lower X axis value\n• Upper X axis value\n• Lower Y axis value\n• Upper Y axis value"}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "The array containing the data series that is to be used for the\ncalculation"}], "answer": "FUNCTION_BLOCK \"LGF_Histogram_DInt\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_Histogram_DInt\n   VAR_INPUT \n      execute : Bool;\n      numberOfClasses : UInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      subFunctionStatus { ExternalWritable := 'False'} : Word := 16#0;\n      histValues { ExternalWritable := 'False'} : Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal;\n      axis { ExternalWritable := 'False'} : Array[0..3] of LReal;\n      classWidth { ExternalWritable := 'False'} : LReal;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of DInt;\n   END_VAR\n\n   VAR \n      statArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#MAX_ARRAY_ELEMENTS] of DInt;\n      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statSubfuncStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statExecuteOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      instShellSort { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_ShellSort_DInt\";\n      statMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statWidth { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statFrequencyValues { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statIndexOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 0;\n      statBound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statMaxFrequency { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statHistFrequencyAbs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#CLASSES_COUNTER_UP_LIMIT] of Int;\n      statHistFrequencyRel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#CLASSES_COUNTER_UP_LIMIT] of LReal;\n      statHistMiddleOfClass { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#CLASSES_COUNTER_UP_LIMIT] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempNumberOfElements : DInt;\n      tempLowerBound : DInt;\n      tempUpperBound : DInt;\n      tempValueDInt : DInt;\n      tempMinDInt : DInt;\n      tempMaxDInt : DInt;\n      tempLoopIndex : DInt;\n      tempArrayOffset : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_INT : Int := 0;\n      ZERO_LREAL : LReal := 0.0;\n      DIMENSION_ONE : UInt := 1;\n      ARRAY_START_INDEX : DInt := 0;\n      ELEMENTS_COUNT_CORRECTION : DInt := 1;\n      INCREMENT : DInt := 1;\n      COUNTER_CORRECTION : DInt := 1;\n      MIN_CLASSES_NUMBER : DInt := 1;\n      MAX_CLASSES_NUMBER : DInt := 15;\n      CLASSES_COUNTER_LOW_LIMIT : DInt := 0;\n      CLASSES_COUNTER_UP_LIMIT : DInt := 14;\n      RATIO : Int := 2;\n      PERCENT_CORRECTION : Int := 100;\n      MAX_ARRAY_ELEMENTS : DInt := 999;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_EXECUTION_FINISHED : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      ERR_SHELL_SORT : Word := 16#8600;\n      ERR_WRONG_NO_CLASSES : Word := 16#9101;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_Histogram_DInt\n\t  // Comment/Function: This function block calculates from measurement list all DInt\n\t  //                   values for creating a histogram with WinCC\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO disabled, forced to true - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 02.00.00 | 06.11.2019 | Simatic Systems Support\n\t  //                       | Code refactoring, comments added\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  // 03.00.02 | 19.11.2024 | Simatic Systems Support\n\t  //                       | Fixed bug for histValues Array\n\t  // 03.00.03 | 16.07.2025 | Simatic Systems Support\n\t  //                       | Fixed comments and block info header \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Detect execution bit\n\t  //Positive edge\n\t  IF #execute AND NOT #statExecuteOld THEN\n\t    //Get array boundaries\n\t    #tempLowerBound := LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t    #tempUpperBound := UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t    \n\t    //Reset and initialize tags\n\t    FOR #statCounter := #CLASSES_COUNTER_LOW_LIMIT TO #CLASSES_COUNTER_UP_LIMIT DO\n\t      #statHistFrequencyAbs[#statCounter] := #ZERO_INT;\n\t      #statHistFrequencyRel[#statCounter] := #ZERO_LREAL;\n\t      #statHistMiddleOfClass[#statCounter] := #ZERO_LREAL;\n\t    END_FOR;\n\t    \n\t    #statStatus := #STATUS_FIRST_CALL;\n\t    #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t    #statFrequencyValues := #ZERO_INT;\n\t    #statMaxFrequency := #ZERO_INT;\n\t    #statIndex := #ZERO_INT;\n\t    #statIndexOld := #ZERO_INT;\n\t    \n\t    //FB is currently inactive\n\t  ELSIF NOT #execute THEN\n\t    #statStatus := #STATUS_NO_CALL;\n\t    #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t  END_IF;\n\t  #statExecuteOld := #execute;\n\tEND_REGION\n\t\n\tREGION Validation\n\t  IF #statStatus = #STATUS_FIRST_CALL THEN\n\t    //check number of classes\n\t    IF ((#numberOfClasses > #MAX_CLASSES_NUMBER) OR (#numberOfClasses < #MIN_CLASSES_NUMBER)) THEN\n\t      #statStatus := #ERR_WRONG_NO_CLASSES;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Histogram calculation \n\t  IF #statStatus = #STATUS_FIRST_CALL THEN\n\t    // Array elements calculation\n\t    // (for example: 6 - 2 = 4; but real number of elements is 5)\n\t    #tempNumberOfElements := #tempUpperBound - #tempLowerBound + #ELEMENTS_COUNT_CORRECTION;\n\t    \n\t    // Shift array index to range 0..n\n\t    #tempArrayOffset := - #tempLowerBound;\n\t    \n\t    //Sort array\n\t    #instShellSort(array := #values);\n\t    \n\t    IF #instShellSort.error THEN\n\t      #statStatus := #ERR_SHELL_SORT;\n\t      #statSubfuncStatus := #instShellSort.status;\n\t    ELSE\n\t      //Identify max and min value\n\t      #tempMinDInt := #values[#tempLowerBound];\n\t      #tempMaxDInt := #values[#tempUpperBound];\n\t      \n\t      #statMin := DINT_TO_LREAL(#tempMinDInt);\n\t      #statMax := DINT_TO_LREAL(#tempMaxDInt);\n\t      \n\t      //calculate classwidth\n\t      #statWidth := (#statMax - #statMin) / #numberOfClasses;\n\t      #statBound := (#statMin + #statWidth);\n\t      \n\t      // Fill temporary array\n\t      FOR #tempLoopIndex := #tempLowerBound TO #tempUpperBound DO\n\t        #statArray[#tempLoopIndex + #tempArrayOffset] := #values[#tempLoopIndex];\n\t      END_FOR;\n\t    \n\t      //Start Value for tempValueDInt\n\t      #tempValueDInt := #statArray[#ARRAY_START_INDEX];\n\t      \n\t      //search for all values\n\t      FOR #statCounter := #ZERO_INT TO UINT_TO_INT(#numberOfClasses) - #COUNTER_CORRECTION DO\n\t          \n\t          //Count Values for Class \n\t          WHILE (#tempValueDInt <= LREAL_TO_DINT(#statBound)) AND (#statIndex < #tempNumberOfElements) DO\n\t              \n\t              IF #statIndex = #tempNumberOfElements THEN\n\t                  EXIT;\n\t              END_IF;\n\t              #statIndex := #statIndex + #INCREMENT;\n\t              #tempValueDInt := #statArray[#statIndex];\n\t              \n\t          END_WHILE;\n\t          \n\t          // Evaluate frequency values\n\t          #statFrequencyValues := DINT_TO_INT(#statIndex - #statIndexOld);\n\t          \n\t          #statHistFrequencyAbs[#statCounter] := #statFrequencyValues;\n\t          #statHistFrequencyRel[#statCounter] := INT_TO_LREAL(#statFrequencyValues) / DINT_TO_LREAL(#tempNumberOfElements) * #PERCENT_CORRECTION;\n\t          \n\t          //Max values in one class for y-axis \n\t          IF #statMaxFrequency < #statFrequencyValues THEN\n\t              #statMaxFrequency := #statFrequencyValues;\n\t          END_IF;\n\t          \n\t          #statBound := #statBound + #statWidth;\n\t          #statIndexOld := #statIndex;\n\t      END_FOR;\n\t  END_IF;\n\t    \n\t    //find the middle of each class\n\t    FOR #statCounter := #ZERO_INT TO UINT_TO_INT(#numberOfClasses) - #COUNTER_CORRECTION DO\n\t      #statHistMiddleOfClass[#statCounter] := #statMin + (DINT_TO_LREAL(#statCounter) * #statWidth) + #statWidth / #RATIO;\n\t    END_FOR;\n\t    \n\t    //Keeping those outputs in this IF statement and not in the out region\n\t    //because filling of the array is needed only once on first call\n\t    //copy values to output array\n\t    FOR #statCounter := #CLASSES_COUNTER_LOW_LIMIT TO #CLASSES_COUNTER_UP_LIMIT DO\n\t      #histValues[0, #statCounter] := #statHistFrequencyRel[#statCounter];\n\t      #histValues[1, #statCounter] := #statHistMiddleOfClass[#statCounter];\n\t    END_FOR;\n\t    #statStatus := #STATUS_EXECUTION_FINISHED;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Write outputs \n\t  // Assign Axis values\n\t  #axis[0] := #statMin;\n\t  #axis[1] := #statMax;\n\t  #axis[2] := #ZERO_LREAL;\n\t  #axis[3] := INT_TO_LREAL(#statMaxFrequency);\n\t  \n\t  // Write class width\n\t  #classWidth := #statWidth;\n\t  \n\t  #error := #statStatus.%X15;\n\t  #status := #statStatus;\n\t  #subFunctionStatus := #statSubfuncStatus;\n\t  \n\t  // ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "Histogram_LReal", "description": "The histogram shows the frequency distribution of a sample by class. A class describes a value interval in which the individual frequencies are added together. After specifying the number of classes, the class width and the respective class center are calculated. The number of classes is limited to 15. The distribution is represented as a rectangle around the class mean with the class width and the cumulated frequency as height. Figure: Distribution WinCC-Control To visualize the Boxplot, the Siemens Industry Online Support offers you a Net-Control, which you can use in conjunction with WinCC Runtime Professional. You can find the controls in the UserFiles folder of this library. Figure: .Net Control “Histogram” Entry ID: 109479728 | V5.2.0 | 08/2025 Generated with Code2Docu © Siemens 2025 | 331 Program blocks", "type": "FUNCTION_BLOCK", "name": "LGF_Histogram_LReal", "vars": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#\nCLASSES_COUNTE\nR_\nUP_LIMIT] of L\nReal", "description": "Outputs the calculated values in a two-dimensional array.\n• `histValues[0,0..14]` displays the relative frequency of the individual\nclasses.\n• `histValues[1,0..14]` displays the class centers.\n• If fewer than 15 classes are desired, the array elements that are not\nrequired are output with 0."}, {"name": "axis", "type": "Array[0..3] of L\nReal", "description": "Specifies the axis values:\n• Lower X axis value\n• Upper X axis value\n• Lower Y axis value\n• Upper Y axis value"}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}, {"name": "values", "type": "Array[*] of LReal", "description": "The array containing the data series that is to be used for the\ncalculation"}], "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#\nCLASSES_COUNTE\nR_\nUP_LIMIT] of L\nReal", "description": "Outputs the calculated values in a two-dimensional array.\n• `histValues[0,0..14]` displays the relative frequency of the individual\nclasses.\n• `histValues[1,0..14]` displays the class centers.\n• If fewer than 15 classes are desired, the array elements that are not\nrequired are output with 0."}, {"name": "axis", "type": "Array[0..3] of L\nReal", "description": "Specifies the axis values:\n• Lower X axis value\n• Upper X axis value\n• Lower Y axis value\n• Upper Y axis value"}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "The array containing the data series that is to be used for the\ncalculation"}], "answer": "FUNCTION_BLOCK \"LGF_Histogram_LReal\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_Histogram_LReal\n   VAR_INPUT \n      execute : Bool;\n      numberOfClasses : UInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      subfunctionStatus { ExternalWritable := 'False'} : Word := 16#0;\n      histValues { ExternalWritable := 'False'} : Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal;\n      axis { ExternalWritable := 'False'} : Array[0..3] of LReal;\n      classWidth { ExternalWritable := 'False'} : LReal;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of LReal;\n   END_VAR\n\n   VAR \n      statArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#MAX_ARRAY_ELEMENTS] of LReal;\n      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statSubfuncStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statExecuteOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      instShellSort { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_ShellSort_LReal\";\n      statMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statWidth { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statFrequencyValues { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statIndexOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 0;\n      statBound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statMaxFrequency { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statHistFrequencyAbs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#CLASSES_COUNTER_UP_LIMIT] of Int;\n      statHistFrequencyRel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#CLASSES_COUNTER_UP_LIMIT] of LReal;\n      statHistMiddleOfClass { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#CLASSES_COUNTER_UP_LIMIT] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempNumberOfElements : DInt;\n      tempLowerBound : DInt;\n      tempUpperBound : DInt;\n      tempValueLReal : LReal;\n      tempMinLReal : LReal;\n      tempMaxLReal : LReal;\n      tempLoopIndex : DInt;\n      tempArrayOffset : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_INT : Int := 0;\n      ZERO_LREAL : LReal := 0.0;\n      DIMENSION_ONE : UInt := 1;\n      ARRAY_START_INDEX : DInt := 0;\n      ELEMENTS_COUNT_CORRECTION : DInt := 1;\n      INCREMENT : DInt := 1;\n      COUNTER_CORRECTION : DInt := 1;\n      MIN_CLASSES_NUMBER : DInt := 1;\n      MAX_CLASSES_NUMBER : DInt := 15;\n      CLASSES_COUNTER_LOW_LIMIT : DInt := 0;\n      CLASSES_COUNTER_UP_LIMIT : DInt := 14;\n      RATIO : Int := 2;\n      PERCENT_CORRECTION : Int := 100;\n      MAX_ARRAY_ELEMENTS : DInt := 999;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_EXECUTION_FINISHED : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      ERR_SHELL_SORT : Word := 16#8600;\n      ERR_WRONG_NO_CLASSES : Word := 16#9101;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_Histogram_LReal\n\t  // Comment/Function: This function block calculates from measurement list all LReal\n\t  //                   values for creating a histogram with WinCC\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO disabled, forced to true - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 02.00.00 | 06.11.2019 | Simatic Systems Support\n\t  //                       | Code refactoring, comments added\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  // 03.00.02 | 19.11.2024 | Simatic Systems Support\n\t  //                       | Fixed bug for histValues Array\n\t  // 03.00.03 | 16.07.2025 | Simatic Systems Support\n\t  //                       | Fixed comments and block info header \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Detect execution bit\n\t  //Positive edge\n\t  IF #execute AND NOT #statExecuteOld THEN\n\t    //Get array boundaries\n\t    #tempLowerBound := LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t    #tempUpperBound := UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t    \n\t    //Reset and initialize tags\n\t    FOR #statCounter := #CLASSES_COUNTER_LOW_LIMIT TO #CLASSES_COUNTER_UP_LIMIT DO\n\t      #statHistFrequencyAbs[#statCounter] := #ZERO_INT;\n\t      #statHistFrequencyRel[#statCounter] := #ZERO_LREAL;\n\t      #statHistMiddleOfClass[#statCounter] := #ZERO_LREAL;\n\t    END_FOR;\n\t    \n\t    #statStatus := #STATUS_FIRST_CALL;\n\t    #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t    #statFrequencyValues := #ZERO_INT;\n\t    #statMaxFrequency := #ZERO_INT;\n\t    #statIndex := #ZERO_INT;\n\t    #statIndexOld := #ZERO_INT;\n\t    \n\t    //FB is currently inactive\n\t  ELSIF NOT #execute THEN\n\t    #statStatus := #STATUS_NO_CALL;\n\t    #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t  END_IF;\n\t  #statExecuteOld := #execute;\n\tEND_REGION\n\t\n\tREGION Validation\n\t  IF #statStatus = #STATUS_FIRST_CALL THEN\n\t    //check number of classes\n\t    IF ((#numberOfClasses > #MAX_CLASSES_NUMBER) OR (#numberOfClasses < #MIN_CLASSES_NUMBER)) THEN\n\t      #statStatus := #ERR_WRONG_NO_CLASSES;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Histogram calculation \n\t  IF #statStatus = #STATUS_FIRST_CALL THEN\n\t    // Array elements calculation\n\t    // (for example: 6 - 2 = 4; but real number of elements is 5)\n\t    #tempNumberOfElements := #tempUpperBound - #tempLowerBound + #ELEMENTS_COUNT_CORRECTION;\n\t    \n\t    // Shift array index to range 0..n\n\t    #tempArrayOffset := - #tempLowerBound;\n\t    \n\t    //Sort array\n\t    #instShellSort(array := #values);\n\t    \n\t    IF #instShellSort.error THEN\n\t      #statStatus := #ERR_SHELL_SORT;\n\t      #statSubfuncStatus := #instShellSort.status;\n\t    ELSE\n\t      //Identify max and min value\n\t      #tempMinLReal := #values[#tempLowerBound];\n\t      #tempMaxLReal := #values[#tempUpperBound];\n\t      \n\t      #statMin := #tempMinLReal;\n\t      #statMax := #tempMaxLReal;\n\t      \n\t      //calculate classwidth\n\t      #statWidth := (#statMax - #statMin) / #numberOfClasses;\n\t      #statBound := (#statMin + #statWidth);\n\t      \n\t      // Fill temporary array\n\t      FOR #tempLoopIndex := #tempLowerBound TO #tempUpperBound DO\n\t        #statArray[#tempLoopIndex + #tempArrayOffset] := #values[#tempLoopIndex];\n\t      END_FOR;\n\t      \n\t      //Starting value for tempValueLReal\n\t      #tempValueLReal := #statArray[#ARRAY_START_INDEX];\n\t      \n\t      //search for all values\n\t      FOR #statCounter := #ZERO_INT TO UINT_TO_INT(#numberOfClasses) - #COUNTER_CORRECTION DO\n\t        \n\t        //Count Values for Class \n\t        \n\t        WHILE (#tempValueLReal <= LREAL_TO_DINT(#statBound)) AND #statIndex < #tempNumberOfElements DO\n\t          \n\t          IF #statIndex = #tempNumberOfElements THEN\n\t            EXIT;\n\t          END_IF;\n\t          #statIndex := #statIndex + #INCREMENT;\n\t          #tempValueLReal := #statArray[#statIndex];\n\t        END_WHILE;\n\t        \n\t        // Evaluate frequency values\n\t        #statFrequencyValues := DINT_TO_INT(#statIndex - #statIndexOld);\n\t        \n\t        #statHistFrequencyAbs[#statCounter] := #statFrequencyValues;\n\t        #statHistFrequencyRel[#statCounter] := INT_TO_LREAL(#statFrequencyValues) / DINT_TO_LREAL(#tempNumberOfElements) * #PERCENT_CORRECTION;\n\t        \n\t        // Max values in one class for y-axis \n\t        IF #statMaxFrequency < #statFrequencyValues THEN\n\t          #statMaxFrequency := #statFrequencyValues;\n\t        END_IF;\n\t        \n\t        #statBound := #statBound + #statWidth;\n\t        #statIndexOld := #statIndex;\n\t      END_FOR;\n\t    END_IF;\n\t    \n\t    //find the middle of each class\n\t    FOR #statCounter := #ZERO_INT TO UINT_TO_INT(#numberOfClasses) - #COUNTER_CORRECTION DO\n\t      #statHistMiddleOfClass[#statCounter] := #statMin + (DINT_TO_LREAL(#statCounter) * #statWidth) + #statWidth / #RATIO;\n\t    END_FOR;\n\t    \n\t    //Keeping those outputs in this IF statement and not in the out region\n\t    //because filling of the array is needed only once on first call\n\t    //copy values to output array\n\t    FOR #statCounter := #CLASSES_COUNTER_LOW_LIMIT TO #CLASSES_COUNTER_UP_LIMIT DO\n\t      #histValues[0, #statCounter] := #statHistFrequencyRel[#statCounter];\n\t      #histValues[1, #statCounter] := #statHistMiddleOfClass[#statCounter];\n\t    END_FOR;\n\t    #statStatus := #STATUS_EXECUTION_FINISHED;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Write outputs \n\t  // Assign Axis values\n\t  #axis[0] := #statMin;\n\t  #axis[1] := #statMax;\n\t  #axis[2] := #ZERO_LREAL;\n\t  #axis[3] := INT_TO_LREAL(#statMaxFrequency);\n\t  \n\t  // Write class width\n\t  #classWidth := #statWidth;\n\t  \n\t  #error := #statStatus.%X15;\n\t  #status := #statStatus;\n\t  #subfunctionStatus := #statSubfuncStatus;\n\t  \n\t  // ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "Histogram_UDInt", "description": "The histogram shows the frequency distribution of a sample by class. A class describes a value interval in which the individual frequencies are added together. After specifying the number of classes, the class width and the respective class center are calculated. The number of classes is limited to 15. The distribution is represented as a rectangle around the class mean with the class width and the cumulated frequency as height. Figure: Distribution WinCC-Control To visualize the Boxplot, the Siemens Industry Online Support offers you a Net-Control, which you can use in conjunction with WinCC Runtime Professional. You can find the controls in the UserFiles folder of this library. Figure: .Net Control “Histogram” Entry ID: 109479728 | V5.2.0 | 08/2025 Generated with Code2Docu © Siemens 2025 | 334 Program blocks", "type": "FUNCTION_BLOCK", "name": "LGF_Histogram_UDInt", "vars": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#\nCLASSES_COUNTE\nR_\nUP_LIMIT] of L\nReal", "description": "Outputs the calculated values in a two-dimensional array.\n• `histValues[0,0..14]` displays the relative frequency of the individual\nclasses.\n• `histValues[1,0..14]` displays the class centers.\n• If fewer than 15 classes are desired, the array elements that are not\nrequired are output with 0."}, {"name": "axis", "type": "Array[0..3] of L\nReal", "description": "Specifies the axis values:\n• Lower X axis value\n• Upper X axis value\n• Lower Y axis value\n• Upper Y axis value"}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}, {"name": "values", "type": "Array[*] of UDInt", "description": "The array containing the data series that is to be used for the\ncalculation"}], "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#\nCLASSES_COUNTE\nR_\nUP_LIMIT] of L\nReal", "description": "Outputs the calculated values in a two-dimensional array.\n• `histValues[0,0..14]` displays the relative frequency of the individual\nclasses.\n• `histValues[1,0..14]` displays the class centers.\n• If fewer than 15 classes are desired, the array elements that are not\nrequired are output with 0."}, {"name": "axis", "type": "Array[0..3] of L\nReal", "description": "Specifies the axis values:\n• Lower X axis value\n• Upper X axis value\n• Lower Y axis value\n• Upper Y axis value"}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "The array containing the data series that is to be used for the\ncalculation"}], "answer": "FUNCTION_BLOCK \"LGF_Histogram_UDInt\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_Histogram_UDInt\n   VAR_INPUT \n      execute : Bool;\n      numberOfClasses : UInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      subfunctionStatus { ExternalWritable := 'False'} : Word := 16#0;\n      histValues { ExternalWritable := 'False'} : Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal;\n      axis { ExternalWritable := 'False'} : Array[0..3] of LReal;\n      classWidth { ExternalWritable := 'False'} : LReal;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of UDInt;\n   END_VAR\n\n   VAR \n      statArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#MAX_ARRAY_ELEMENTS] of UDInt;\n      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statSubfuncStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statExecuteOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      instShellSort { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_ShellSort_UDInt\";\n      statMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statWidth { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statFrequencyValues { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statIndexOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 0;\n      statBound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statMaxFrequency { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statHistFrequencyAbs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#CLASSES_COUNTER_UP_LIMIT] of Int;\n      statHistFrequencyRel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#CLASSES_COUNTER_UP_LIMIT] of LReal;\n      statHistMiddleOfClass { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#CLASSES_COUNTER_UP_LIMIT] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempNumberOfElements : DInt;\n      tempLowerBound : DInt;\n      tempUpperBound : DInt;\n      tempValueUDInt : UDInt;\n      tempMinUDInt : UDInt;\n      tempMaxUDInt : UDInt;\n      tempLoopIndex : DInt;\n      tempArrayOffset : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_INT : Int := 0;\n      ZERO_LREAL : LReal := 0.0;\n      DIMENSION_ONE : UInt := 1;\n      ARRAY_START_INDEX : DInt := 0;\n      ELEMENTS_COUNT_CORRECTION : DInt := 1;\n      INCREMENT : DInt := 1;\n      COUNTER_CORRECTION : DInt := 1;\n      MIN_CLASSES_NUMBER : DInt := 1;\n      MAX_CLASSES_NUMBER : DInt := 15;\n      CLASSES_COUNTER_LOW_LIMIT : DInt := 0;\n      CLASSES_COUNTER_UP_LIMIT : DInt := 14;\n      RATIO : Int := 2;\n      PERCENT_CORRECTION : Int := 100;\n      MAX_ARRAY_ELEMENTS : DInt := 999;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_EXECUTION_FINISHED : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      ERR_SHELL_SORT : Word := 16#8600;\n      ERR_WRONG_NO_CLASSES : Word := 16#9101;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_Histogram_UDInt\n\t  // Comment/Function: This function block calculates from measurement list all UDInt\n\t  //                   values for creating a histogram with WinCC\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO disabled, forced to true - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 02.00.00 | 06.11.2019 | Simatic Systems Support\n\t  //                       | Code refactoring, comments added\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  // 03.00.02 | 19.11.2024 | Simatic Systems Support\n\t  //                       | Fixed bug for histValues Array\n\t  // 03.00.03 | 16.07.2025 | Simatic Systems Support\n\t  //                       | Fixed comments and block info header\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Detect execution bit\n\t  //Positive edge\n\t  IF #execute AND NOT #statExecuteOld THEN\n\t    //Get array boundaries\n\t    #tempLowerBound := LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t    #tempUpperBound := UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t    \n\t    //Reset and initialize tags\n\t    FOR #statCounter := #CLASSES_COUNTER_LOW_LIMIT TO #CLASSES_COUNTER_UP_LIMIT DO\n\t      #statHistFrequencyAbs[#statCounter] := #ZERO_INT;\n\t      #statHistFrequencyRel[#statCounter] := #ZERO_LREAL;\n\t      #statHistMiddleOfClass[#statCounter] := #ZERO_LREAL;\n\t    END_FOR;\n\t    \n\t    #statStatus := #STATUS_FIRST_CALL;\n\t    #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t    #statFrequencyValues := #ZERO_INT;\n\t    #statMaxFrequency := #ZERO_INT;\n\t    #statIndex := #ZERO_INT;\n\t    #statIndexOld := #ZERO_INT;\n\t    \n\t    //FB is currently inactive\n\t  ELSIF NOT #execute  THEN\n\t    #statStatus := #STATUS_NO_CALL;\n\t    #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t  END_IF;\n\t  #statExecuteOld := #execute;\n\tEND_REGION\n\t\n\tREGION Validation\n\t  IF #statStatus = #STATUS_FIRST_CALL THEN\n\t    //check number of classes\n\t    IF ((#numberOfClasses > #MAX_CLASSES_NUMBER) OR (#numberOfClasses < #MIN_CLASSES_NUMBER)) THEN\n\t      #statStatus := #ERR_WRONG_NO_CLASSES;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Histogram calculation \n\t  IF #statStatus = #STATUS_FIRST_CALL THEN\n\t    // Array elements calculation\n\t    // (for example: 6 - 2 = 4; but real number of elements is 5)\n\t    #tempNumberOfElements := #tempUpperBound - #tempLowerBound + #ELEMENTS_COUNT_CORRECTION;\n\t    \n\t    // Shift array index to range 0..n\n\t    #tempArrayOffset := - #tempLowerBound;\n\t    \n\t    //Sort array\n\t    #instShellSort(array := #values);\n\t    \n\t    IF #instShellSort.error THEN\n\t      #statStatus := #ERR_SHELL_SORT;\n\t      #statSubfuncStatus := #instShellSort.status;\n\t    ELSE\n\t      //Identify max and min value\n\t      #tempMinUDInt := #values[#tempLowerBound];\n\t      #tempMaxUDInt := #values[#tempUpperBound];\n\t      \n\t      #statMin := UDINT_TO_REAL(#tempMinUDInt);\n\t      #statMax := UDINT_TO_REAL(#tempMaxUDInt);\n\t      \n\t      //calculate classwidth\n\t      #statWidth := (#statMax - #statMin) / #numberOfClasses;\n\t      #statBound := (#statMin + #statWidth);\n\t      \n\t      // Fill temporary array\n\t      FOR #tempLoopIndex := #tempLowerBound TO #tempUpperBound DO\n\t        #statArray[#tempLoopIndex + #tempArrayOffset] := #values[#tempLoopIndex];\n\t      END_FOR;\n\t      \n\t      //Starting value for tempValueUDint\n\t      #tempValueUDInt := #statArray[#ARRAY_START_INDEX];\n\t      \n\t      //search for all values\n\t      FOR #statCounter := #ZERO_INT TO UINT_TO_INT(#numberOfClasses) - #COUNTER_CORRECTION DO\n\t        \n\t        //Count Values for Class \n\t          WHILE (#tempValueUDInt <= LREAL_TO_UDINT(#statBound)) AND #statIndex < (#tempNumberOfElements) DO\n\t          \n\t          IF #statIndex = #tempNumberOfElements THEN\n\t            EXIT;\n\t          END_IF;\n\t          #statIndex := #statIndex + #INCREMENT;\n\t          #tempValueUDInt := #statArray[#statIndex];\n\t        END_WHILE;\n\t        \n\t        //the last value is not counted, because of rounding errors\n\t        IF #statIndex = #tempNumberOfElements - #COUNTER_CORRECTION THEN\n\t          #statIndex := #statIndex + #INCREMENT;\n\t        END_IF;\n\t        \n\t        // Evaluate frequency values\n\t        #statFrequencyValues := DINT_TO_INT(#statIndex - #statIndexOld);\n\t        \n\t        #statHistFrequencyAbs[#statCounter] := #statFrequencyValues;\n\t        #statHistFrequencyRel[#statCounter] := INT_TO_REAL(#statFrequencyValues) / DINT_TO_REAL(#tempNumberOfElements) * #PERCENT_CORRECTION;\n\t        \n\t        //Max values in one class for y-axis \n\t        IF #statMaxFrequency < #statFrequencyValues THEN\n\t          #statMaxFrequency := #statFrequencyValues;\n\t        END_IF;\n\t        \n\t        #statBound := #statBound + #statWidth;\n\t        #statIndexOld := #statIndex;\n\t      END_FOR;\n\t    END_IF;\n\t    \n\t    //find the middle of each class\n\t    FOR #statCounter := #ZERO_INT TO UINT_TO_INT(#numberOfClasses) - #COUNTER_CORRECTION DO\n\t      #statHistMiddleOfClass[#statCounter] := #statMin + (DINT_TO_REAL(#statCounter) * #statWidth) + #statWidth / #RATIO;\n\t    END_FOR;\n\t    \n\t    //Keeping those outputs in this IF statement and not in the out region\n\t    //because filling of the array is needed only once on first call\n\t    //copy values to output array\n\t    FOR #statCounter := #CLASSES_COUNTER_LOW_LIMIT TO #CLASSES_COUNTER_UP_LIMIT DO\n\t      #histValues[0, #statCounter] := #statHistFrequencyRel[#statCounter];\n\t      #histValues[1, #statCounter] := #statHistMiddleOfClass[#statCounter];\n\t    END_FOR;\n\t    #statStatus := #STATUS_EXECUTION_FINISHED;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Write outputs \n\t  // Aassign Axis values\n\t  #axis[0] := #statMin;\n\t  #axis[1] := #statMax;\n\t  #axis[2] := #ZERO_LREAL;\n\t  #axis[3] := INT_TO_LREAL(#statMaxFrequency);\n\t  \n\t  // Write class width\n\t  #classWidth := #statWidth;\n\t  \n\t  #error := #statStatus.%X15;\n\t  #status := #statStatus;\n\t  #subfunctionStatus := #statSubfuncStatus;\n\t  \n\t  // ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "SimpleSmoothingFB", "description": "The function calculates the linear mean value cyclically. The simplest form of smoothing a sequence of measured values is to calculate the linear mean value by three points. The function reads-in a value with each positive edge on the insert input. As soon as three values have been read in, the block calculates a smoothed value and outputs it.", "type": "FUNCTION_BLOCK", "name": "LGF_SimpleSmoothingFB", "vars": [{"name": "enable", "type": "Bool", "description": "Activates the block. As long as enable is `TRUE`, the\nblock can accept values on the parameter `value`."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge\nand outputs a `smoothedValue` if three values have\nbeen read in."}, {"name": "value", "type": "LReal", "description": "Value that is to be included in the smoothing."}, {"name": "smoothedValue", "type": "LReal", "description": "The smoothed value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "enable", "type": "Bool", "description": "Activates the block. As long as enable is `TRUE`, the\nblock can accept values on the parameter `value`."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge\nand outputs a `smoothedValue` if three values have\nbeen read in."}, {"name": "value", "type": "LReal", "description": "Value that is to be included in the smoothing."}], "output": [{"name": "smoothedValue", "type": "LReal", "description": "The smoothed value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_SimpleSmoothingFB\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_SimpleSmoothingFB\n   VAR_INPUT \n      enable : Bool;\n      insert : Bool;\n      value : LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      smoothedValue { ExternalWritable := 'False'} : LReal;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n   END_VAR\n\n   VAR \n      statValues { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#MINIMUM_NUMBER_OF_VALUES] of LReal;\n      statCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statSmoothedValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statEnableOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statInsertOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_REAL : Real := 0.0;\n      MINIMUM_NUMBER_OF_VALUES : UDInt := 2;\n      NUMBER_OF_VALUES : UDInt := 3;\n      INCREMENT_VALUE : Int := 1;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      STATUS_NOT_ENOUGH_VALUES : Word := 16#7010;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_SimpleSmoothingFB\n\t  // Comment/Function: This function block calculates smoothed values of a variable\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled, forced to true - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 01.00.03 | 05.11.2019 | Simatic Systems Support\n\t  //                       | Regions, comments and constants are added  \n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Check function block call\n\t  // Check if FB is triggered - rising edge on enable\n\t  IF #enable AND NOT #statEnableOld THEN\n\t    // Reset static values\n\t    #statCount := 0;\n\t    #statValues[0] := #ZERO_REAL;\n\t    #statValues[1] := #ZERO_REAL;\n\t    #statValues[2] := #ZERO_REAL;\n\t    \n\t    //Set status for first call\n\t    #statStatus := #STATUS_FIRST_CALL;\n\t    \n\t    // Enabled after edge trigger\n\t  ELSIF #enable AND #statEnableOld THEN\n\t    REGION Values inserting and smoothing calculation\n\t      // positive edge of insert detected \n\t      IF #insert AND NOT #statInsertOld THEN\n\t        \n\t        // Copy new value\n\t        #statValues[0] := #statValues[1];\n\t        #statValues[1] := #statValues[2];\n\t        #statValues[2] := #value;\n\t        \n\t        // Check if the minimum needed insered values is reached\n\t        // Increase the count of added values\n\t        IF #statCount <= #MINIMUM_NUMBER_OF_VALUES THEN\n\t          #statCount += #INCREMENT_VALUE;\n\t          #statStatus := #STATUS_NOT_ENOUGH_VALUES;\n\t        ELSE\n\t          // 3 values inserted, calculate smoothed value\n\t          #statSmoothedValue := (#statValues[0] + #statValues[1] + #statValues[2]) / #NUMBER_OF_VALUES;\n\t          #statStatus := #STATUS_SUBSEQUENT_CALL;\n\t        END_IF;\n\t      END_IF;\n\t    END_REGION\n\t  ELSE\n\t    #statStatus := #STATUS_NO_CALL;\n\t    #statSmoothedValue := #ZERO_REAL;\n\t  END_IF;\n\t  \n\t  // Store previous values for edge dedection\n\t  #statEnableOld := #enable;\n\t  #statInsertOld := #insert;\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  #error := #statStatus.%X15;\n\t  #status := #statStatus;\n\t  #smoothedValue := #statSmoothedValue;\n\t  \n\t  // ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "SmoothByPolynomFB", "description": "This function calculates the smoothed values by polynomial cyclically. For smoothing, a 3rd degree polynomial is placed through five value points. The error squares of the distances between polynomial and real value are minimized. The smoothed values can be determined from the polynomial parameters obtained in this way. The function reads-in a value with each positive edge on the insert input. As soon as five values have been read in, the block calculates a smoothed value and outputs it.", "type": "FUNCTION_BLOCK", "name": "LGF_SmoothByPolynomFB", "vars": [{"name": "enable", "type": "Bool", "description": "Activates the block. As long as enable is `TRUE`, the\nblock can accept values on the parameter `value`."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge\nand outputs a `smoothedValue` if five values have\nbeen read in."}, {"name": "value", "type": "LReal", "description": "Value that is to be included in the smoothing."}, {"name": "smoothedValue", "type": "LReal", "description": "The smoothed value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "enable", "type": "Bool", "description": "Activates the block. As long as enable is `TRUE`, the\nblock can accept values on the parameter `value`."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge\nand outputs a `smoothedValue` if five values have\nbeen read in."}, {"name": "value", "type": "LReal", "description": "Value that is to be included in the smoothing."}], "output": [{"name": "smoothedValue", "type": "LReal", "description": "The smoothed value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_SmoothByPolynomFB\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_SmoothByPolynomFB\n   VAR_INPUT \n      enable : Bool;\n      insert : Bool;\n      value : LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      smoothedValue { ExternalWritable := 'False'} : LReal;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n   END_VAR\n\n   VAR \n      statValues { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#MINIMUM_NUMBER_OF_VALUES] of LReal;\n      statCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 0;\n      statSmoothedValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statEnableOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;\n      statInsertOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_REAL : Real := 0.0;\n      MINIMUM_NUMBER_OF_VALUES : UDInt := 4;\n      INCREMENT_VALUE : Int := 1;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      STATUS_NOT_ENOUGH_VALUES : Word := 16#7010;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_SmoothByPolynomFB\n\t  // Comment/Function: Calculates smoothed values by placing 3rd degree polynomial\n\t  //                   through five value points.\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled, forced to true - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 01.00.01 | 05.11.2019 | Simatic Systems Support\n\t  //                       | Bugfixes, regions, comments and constants are added\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Check function block call\n\t  // Check if FB is triggered - rising edge on enable\n\t  IF #enable AND NOT #statEnableOld THEN\n\t    // Reset static values\n\t    #statCount := 0;\n\t    #statValues[0] := #ZERO_REAL;\n\t    #statValues[1] := #ZERO_REAL;\n\t    #statValues[2] := #ZERO_REAL;\n\t    #statValues[3] := #ZERO_REAL;\n\t    #statValues[4] := #ZERO_REAL;\n\t    \n\t    // Set status for first call\n\t    #statStatus := #STATUS_FIRST_CALL;\n\t    \n\t    // Enabled after edge trigger\n\t  ELSIF #enable AND #statEnableOld THEN\n\t    REGION Values inserting and smoothing calculation\n\t      // Positive edge of insert detected \n\t      IF #insert AND NOT #statInsertOld THEN\n\t        \n\t        // Copy new value\n\t        #statValues[0] := #statValues[1]; // -> n-2\n\t        #statValues[1] := #statValues[2]; // -> n-1\n\t        #statValues[2] := #statValues[3]; // -> n\n\t        #statValues[3] := #statValues[4]; // -> n+1\n\t        #statValues[4] := #value;         // -> n+2\n\t        \n\t        // Check if the minimum needed insered values is reached\n\t        // Increase the count of added values\n\t        IF #statCount <= #MINIMUM_NUMBER_OF_VALUES THEN\n\t          #statCount += #INCREMENT_VALUE;\n\t          #statStatus := #STATUS_NOT_ENOUGH_VALUES;\n\t        ELSE\n\t          // Calculate new smoothed value // keep the \"Magic Numbers\" as they are part of the Math equation and would extent the formular in a unreadable way\n\t          // y(n)=1/35*(-3*y(n-2)+12*y(n-1)+17*y(n)+12*y(n+1)-3*y(n+2))\n\t          // 1/35 = 0.028571\n\t          #statSmoothedValue := 0.028571 * (-3 * #statValues[0] + 12 * #statValues[1] + 17 * #statValues[2] + 12 * #statValues[3] - 3 * #statValues[4]);\n\t          #statStatus := #STATUS_SUBSEQUENT_CALL;\n\t        END_IF;\n\t      END_IF;\n\t    END_REGION\n\t  ELSE\n\t    #statStatus := #STATUS_NO_CALL;\n\t    #statSmoothedValue := #ZERO_REAL;\n\t  END_IF;\n\t  \n\t  // Store previous values for edge dedection\n\t  #statEnableOld := #enable;\n\t  #statInsertOld := #insert;\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  #error := #statStatus.%X15;\n\t  #status := #statStatus;\n\t  #smoothedValue := #statSmoothedValue;\n\t  \n\t  // ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "IsBigEndian", "description": "The function detects the endianness of the executing system.", "type": "FUNCTION", "name": "LGF_IsBigEndian", "vars": [{"name": "Ret_Val", "type": "Bool", "description": "TRUE: If big endianness is detected"}], "input": [], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_IsBigEndian\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Industry Support'\nFAMILY : LGF\nNAME : LGF_IsBigEndian\n   VAR_TEMP \n      tempSixteenBits : Word;\n   END_VAR\n\n   VAR CONSTANT \n      BIT_PATTERN_ONE : Word := 16#0001;\n      MOVE_BIT_POS : UDInt := 15;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS / (c)Copyright 2021\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_IsBigEndian\n\t  // Function:         The function detects the endianness of the executing system.\n\t  // Library:          LGF\n\t  // Author:           Siemens Industry Support\n\t  // Tested with:      CPU 1516-3 PN/DP\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     --\n\t  // Requirements:     S7-1200/1500\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 2022-12-16 | ScheeO                 | First released version\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Info\n\t(/**/)\n\tEND_REGION\n\t\n\tREGION Process\n\t  // We prepare the bit pattern\n\t  #tempSixteenBits := SHL(IN := #BIT_PATTERN_ONE, N := #MOVE_BIT_POS);\n\t  #LGF_IsBigEndian := #tempSixteenBits.%B0 <> B#16#00;\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "IsLittleEndian", "description": "The function detects the endianness of the executing system.", "type": "FUNCTION", "name": "LGF_IsLittleEndian", "vars": [{"name": "Ret_Val", "type": "Bool", "description": "TRUE: If little endianness is detected"}], "input": [], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_IsLittleEndian\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Industry Support'\nFAMILY : LGF\nNAME : LGF_IsLittleEndian\n   VAR_TEMP \n      tempSixteenBits : Word;\n   END_VAR\n\n   VAR CONSTANT \n      BIT_PATTERN_ONE : Word := 16#0001;\n      MOVE_BIT_POS : UDInt := 15;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS / (c)Copyright 2021\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_IsLittleEndian\n\t  // Function:         The function detects the endianness of the executing system.\n\t  // Library:          LGF\n\t  // Author:           Siemens Industry Support\n\t  // Tested with:      CPU 1516-3 PN/DP\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     --\n\t  // Requirements:     S7-1200/1500\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 2022-12-16 | ScheeO                 | First released version\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Info\n\t(/**/)\n\tEND_REGION\n\t\n\tREGION Process\n\t  // We prepare the bit pattern\n\t  #tempSixteenBits := SHL(IN := #BIT_PATTERN_ONE, N := #MOVE_BIT_POS);\n\t  #LGF_IsLittleEndian := #tempSixteenBits.%B0 = B#16#00;\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "ActDeactDevice", "description": "LGF_ActDeactDevice implements a compact state machine to activate or deactivate a decentral device.", "type": "FUNCTION_BLOCK", "name": "LGF_ActDeactDevice", "vars": [{"name": "deactivate", "type": "Bool", "description": "Rising edge: Deactivate device given by `hwId`"}, {"name": "activate", "type": "Bool", "description": "Rising edge: Activate device given by `hwId`"}, {"name": "hwId", "type": "HW_DEVICE", "description": "Hardware ID of the device which should be activated /\ndeactivated (`Device~PnIf~IODevice`)"}, {"name": "parameter", "type": "LGF_typeActDeact\nDeviceParameter", "description": "Parameter dataset for the function\n`LGF_ActDeactDevice`"}, {"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "deactivatingActive", "type": "Bool", "description": "TRUE: Deactivating of device active"}, {"name": "deactivatingDone", "type": "Bool", "description": "TRUE: Device deactivated"}, {"name": "activatingActive", "type": "Bool", "description": "TRUE: Activation of device active"}, {"name": "activatingDone", "type": "Bool", "description": "TRUE: Device activated"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}, {"name": "activation\nRetries", "type": "SInt", "description": "Number of activation & deactiviation retries until an\nerror is set."}, {"name": "timeOutActDeact", "type": "Time", "description": "Time to monitor the commands `activate` and\n`deactivate`\nshould be greater than the configured `configuration\ntime` in the PLC hardware configuration section\n`Startup`"}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [{"name": "deactivate", "type": "Bool", "description": "Rising edge: Deactivate device given by `hwId`"}, {"name": "activate", "type": "Bool", "description": "Rising edge: Activate device given by `hwId`"}, {"name": "hwId", "type": "HW_DEVICE", "description": "Hardware ID of the device which should be activated /\ndeactivated (`Device~PnIf~IODevice`)"}, {"name": "parameter", "type": "LGF_typeActDeact\nDeviceParameter", "description": "Parameter dataset for the function\n`LGF_ActDeactDevice`"}], "output": [{"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "deactivatingActive", "type": "Bool", "description": "TRUE: Deactivating of device active"}, {"name": "deactivatingDone", "type": "Bool", "description": "TRUE: Device deactivated"}, {"name": "activatingActive", "type": "Bool", "description": "TRUE: Activation of device active"}, {"name": "activatingDone", "type": "Bool", "description": "TRUE: Device activated"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_ActDeactDevice\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Simatic Systems Support'\nFAMILY : LGF\nNAME : LGF_ActDeactDevice\n   VAR_INPUT \n      deactivate : Bool;\n      activate : Bool;\n      hwId { S7_PredefinedAssignment := '\"HW ID of Device (`Device~PnIf~IODevice`)\"'} : HW_DEVICE;\n      parameter : \"LGF_typeActDeactDeviceParameter\";\n   END_VAR\n\n   VAR_OUTPUT \n      done { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      deactivatingActive { ExternalWritable := 'False'} : Bool;\n      deactivatingDone { ExternalWritable := 'False'} : Bool;\n      activatingActive { ExternalWritable := 'False'} : Bool;\n      activatingDone { ExternalWritable := 'False'} : Bool;\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR \n      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         activatePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         deactivatePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         status { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n         internalDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\";\n      END_STRUCT;\n      statActDeact { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         request { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         hasPreviousError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         remainingRetries { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : SInt;\n         neededRetrieCyclesUntilActivation { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : SInt;\n         hwIdDevice { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_DEVICE;\n         mode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;\n         result { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      END_STRUCT;\n      statDeviceState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         geoAddr {InstructionName := 'GEOADDR'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : GEOADDR;\n         geoAddrIoSystem {InstructionName := 'GEOADDR'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : GEOADDR := (1, (), (), (), (), ());\n         devicesState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..1024] of Bool;\n         hwIdIoSystem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_IOSYSTEM;\n         resultDeviceStates { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n         resultLog2Geo { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n         resultGeo2Log { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n         deviceStateOK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      END_STRUCT;\n      instWatchdog {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;\n      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;\n   END_VAR\n\n   VAR_TEMP \n      tempExecute : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      MODE_INFORMATION : USInt := 0;\n      MODE_ACTIVATE : USInt := 1;\n      MODE_DEACTIVATE : USInt := 2;\n      DEVICE_IS_ACTIVE : Word := 16#0001;\n      DEVICE_IS_PASSIVE : Word := 16#0002;\n      DEVICE_ACTIVATION_TIMEOUT : Word := 16#80A7;\n      RESULT_SUCCESS : Word := 16#0000;\n      SLAVE_EXISTS : UInt := 4;\n      SLAVE_FAULTY : UInt := 2;\n      SLAVE_DISBALED : UInt := 3;\n      FB_STATE_NO_PROCESSING : DInt := 0;\n      FB_STATE_START_PROCESSING : DInt := 1;\n      FB_STATE_DEACTIVATE_INIT : DInt := 40;\n      FB_STATE_DEACTIVATE_INIT_WAIT : DInt := 41;\n      FB_STATE_DEACTIVATE_START : DInt := 44;\n      FB_STATE_DEACTIVATE_WAIT : DInt := 45;\n      FB_STATE_DEACTIVATE_DONE : DInt := 49;\n      FB_STATE_ACTIVATE_INIT : DInt := 60;\n      FB_STATE_ACTIVATE_INIT_WAIT : DInt := 61;\n      FB_STATE_ACTIVATE_START : DInt := 64;\n      FB_STATE_ACTIVATE_WAIT : DInt := 65;\n      FB_STATE_ACTIVATE_DONE : DInt := 69;\n      FB_STATE_LAST : DInt := 99;\n      STATUS_DEACTIVATION_DONE : Word := 16#0000;\n      STATUS_ACTIVATION_DONE : Word := 16#0001;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_DEACTIVATION : Word := 16#7040;\n      STATUS_ACTIVATION : Word := 16#7060;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n      ERR_LOG2GEO : Word := 16#8601;\n      ERR_GEO2LOG : Word := 16#8602;\n      ERR_DEVICE_DEACTIVATING : Word := 16#8640;\n      ERR_DEVICE_DEACTIVATING_TIME_OUT : Word := 16#8641;\n      ERR_DEVICE_DEACTIVATING_RETRIES_REACHED : Word := 16#8642;\n      ERR_READ_ACTIVATION_STATE_WHILE_DEACTIVATED : Word := 16#8650;\n      ERR_DEVICE_ACTIVATING : Word := 16#8660;\n      ERR_DEVICE_ACTIVATING_TIME_OUT : Word := 16#8661;\n      ERR_DEVICE_ACTIVATING_RETRIES_REACHED : Word := 16#8662;\n      ERR_READ_DEVICES_STATES_DURING_ACTIVATION : Word := 16#8663;\n      ERR_READ_DEVICES_STATES_WHILE_ACTIVE : Word := 16#8670;\n      ERR_DEVICE_STATE_WHILE_ACTIVE : Word := 16#8671;\n      ERR_READ_ACTIVATION_STATE_WHILE_ACTIVE : Word := 16#8672;\n      ERR_DISABLING_DEACT_DEVICE : Word := 16#8690;\n      ERR_DISABLING_WATCHDOG : Word := 16#8691;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // (C)Copyright Siemens 2023 - 2025\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ActDeactDevice\n\t  // Comment/Function: `LGF_ActDeactDevice` implements an compact statemaschine to activate or deactivate decentral devices. \n\t  //                   It works for PN (S7-1200 / S7-1500) and DP (S7-1500) devices.\n\t  // Library/Family:   LGF - library of general functions\n\t  // Author:           Simatic Systems Support\n\t  // Tested with:      S7-1200 V4.6 / S7-1500 V2.9\n\t  // Engineering:      TIA Portal (V17)\n\t  // Restrictions:     ---\n\t  // Requirements:     Decentral PN / DP Device\n\t  //--------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  //----------|------------|-------------------------|------------------------------\n\t  // 01.00.00 | 06.04.2024 | Simatic Systems Support | First released version in different project\n\t  // 02.00.00 | 10.03.2025 | Simatic Systems Support | Refactoring & Improve Code for LGF Integration\n\t  //          |            |                         | Thats why we start here with V2.0 for the LGF integration\n\t  //          |            |                         | Copy of `LGF_ActDeactMonitorDevice` without device monitoring, just executing activation and deactivation\n\t  //================================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t(/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION TRIGGERING\n\t  #tempExecute := #activate OR #deactivate; // Work with temporary value / create process image\n\t  IF (#tempExecute = TRUE) // Check if FB is triggered\n\t    AND NOT #statInternal.activatePrevious\n\t    AND NOT #statInternal.deactivatePrevious\n\t    // TODO(optional): delete next line and comment line if FB shall finish current job before new job can be started with rising edge of execute\n\t    AND (#statInternal.status = #STATUS_NO_CALL)\n\t  THEN // First call; initialize FB\n\t    #statInternal.error := FALSE;\n\t    #diagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.internalDiagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.diagnostics := #statInternal.emptyDiagnostics;\n\t    \n\t    #statMainState := #FB_STATE_START_PROCESSING;\n\t  END_IF;\n\t  \n\t  // Edge detection 'activate' / 'deactivate' input\n\t  #statInternal.activatePrevious := #activate;\n\t  #statInternal.deactivatePrevious := #deactivate;\n\tEND_REGION TRIGGERING\n\t\n\tIF (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION STATE MACHINE\n\t  CASE #statMainState OF // State machine of FB\n\t    #FB_STATE_NO_PROCESSING:\n\t      REGION No Processing\n\t        ; // No processing active (Note: this state must always be present and left empty)\n\t      END_REGION No Processing\n\t      \n\t    #FB_STATE_START_PROCESSING:\n\t      REGION Start Processing\n\t        // Initialize functionality: reset of variables, diagnostics, etc.\n\t        #statActDeact.request := FALSE;\n\t        #statActDeact.mode := #MODE_INFORMATION;\n\t        // Store HW ID internal\n\t        #statActDeact.hwIdDevice := #hwId;\n\t        \n\t        #statActDeact.hasPreviousError := FALSE;\n\t        #statActDeact.remainingRetries := #parameter.activationRetries;\n\t        #statActDeact.neededRetrieCyclesUntilActivation := 0;\n\t        \n\t        // Gets the station number of the given device by its HW ID\n\t        #statDeviceState.resultLog2Geo := INT_TO_WORD(LOG2GEO(LADDR := #statActDeact.hwIdDevice, GEOADDR := #statDeviceState.geoAddr));\n\t        \n\t        // Gets the IO System HW ID for the given device connection by the device HW ID / Geo Information\n\t        #statDeviceState.geoAddrIoSystem.AREA := #statDeviceState.geoAddr.AREA;\n\t        #statDeviceState.geoAddrIoSystem.IOSYSTEM := #statDeviceState.geoAddr.IOSYSTEM;\n\t        #statDeviceState.resultGeo2Log := INT_TO_WORD(GEO2LOG(GEOADDR := #statDeviceState.geoAddrIoSystem, LADDR => #statDeviceState.hwIdIoSystem));\n\t        \n\t        // Froof if hardware ID has an error / points to a wrong device\n\t        IF (#statDeviceState.resultLog2Geo <> #RESULT_SUCCESS) THEN\n\t          #statInternal.diagnostics.status := #ERR_LOG2GEO;\n\t          #statInternal.diagnostics.subfunctionStatus := #statDeviceState.resultLog2Geo;\n\t          \n\t        ELSIF (#statDeviceState.resultGeo2Log <> #RESULT_SUCCESS) THEN\n\t          #statInternal.diagnostics.status := #ERR_GEO2LOG;\n\t          #statInternal.diagnostics.subfunctionStatus := #statDeviceState.resultGeo2Log;\n\t\n\t        ELSIF #activate THEN\n\t          #statInternal.status := #STATUS_ACTIVATION;\n\t          #statMainState := #FB_STATE_ACTIVATE_INIT;\n\t        ELSIF #deactivate THEN\n\t          #statInternal.status := #STATUS_DEACTIVATION;\n\t          #statMainState := #FB_STATE_DEACTIVATE_INIT;\n\t        END_IF;\n\t        \n\t        #instWatchdog.TON(IN := FALSE,\n\t                          PT := #parameter.timeOutActDeact);\n\t      END_REGION Start Processing\n\t      \n\t    #FB_STATE_DEACTIVATE_INIT..\n\t    #FB_STATE_LAST:\n\t      REGION Processing\n\t        CASE #statMainState OF\n\t          #FB_STATE_DEACTIVATE_INIT..\n\t          #FB_STATE_DEACTIVATE_WAIT:\n\t            REGION Deactivate\n\t              CASE #statMainState OF\n\t                #FB_STATE_DEACTIVATE_INIT:\n\t                  REGION Deactivate init\n\t                    #statActDeact.request := FALSE;\n\t                    #statActDeact.mode := #MODE_DEACTIVATE;\n\t                    #statActDeact.remainingRetries -= 1;\n\t                    IF #statActDeact.remainingRetries < 0 THEN\n\t                      #statActDeact.remainingRetries := 0;\n\t                    END_IF;\n\t                    \n\t                    #statInternal.status := #STATUS_DEACTIVATION;\n\t                    #statMainState := #FB_STATE_DEACTIVATE_INIT_WAIT;\n\t                  END_REGION\n\t                  \n\t                #FB_STATE_DEACTIVATE_INIT_WAIT:\n\t                  REGION Deactivate init wait\n\t                    IF TRUE\n\t                      AND NOT #statActDeact.busy\n\t                    THEN\n\t                      #statMainState := #FB_STATE_DEACTIVATE_START;\n\t                    END_IF;\n\t                  END_REGION\n\t                  \n\t                #FB_STATE_DEACTIVATE_START:\n\t                  REGION Deactivate start\n\t                    #statActDeact.request := TRUE;\n\t                    #statActDeact.mode := #MODE_DEACTIVATE;\n\t                    \n\t                    #statMainState := #FB_STATE_DEACTIVATE_WAIT;\n\t                  END_REGION\n\t                  \n\t                #FB_STATE_DEACTIVATE_WAIT:\n\t                  REGION Deactivate wait\n\t                    #statActDeact.request := FALSE;\n\t                    \n\t                    // Device deactivation completed successfully\n\t                    IF TRUE\n\t                      AND NOT #statActDeact.busy\n\t                      AND (FALSE\n\t                      OR (#statActDeact.result = #DEVICE_IS_PASSIVE)\n\t                      OR (#statActDeact.result = #RESULT_SUCCESS)\n\t                      )\n\t                    THEN\n\t                      #statActDeact.request := FALSE;\n\t                      #statMainState := #FB_STATE_DEACTIVATE_DONE;\n\t                      \n\t                    ELSIF #statActDeact.result.%X15 THEN // Error occured first time\n\t                      // Write infos into internal Diagnostic buffer for info reasons\n\t                      #statInternal.internalDiagnostics.status := #ERR_DEVICE_DEACTIVATING;\n\t                      #statInternal.internalDiagnostics.subfunctionStatus := #statActDeact.result;\n\t                      #statMainState := #FB_STATE_DEACTIVATE_INIT;\n\t                      // Set flag that error has happend\n\t                      // This is to detect if the error is still present over more than one cycle\n\t                      #statActDeact.hasPreviousError := TRUE;\n\t                      \n\t                      // Watchdog or retries reached and previously dedected error occured\n\t                    ELSIF TRUE\n\t                      AND #statInternal.internalDiagnostics.status.%X15\n\t                      AND (FALSE\n\t                      OR #instWatchdog.Q\n\t                      OR #statActDeact.remainingRetries <= 0\n\t                      )\n\t                    THEN\n\t                      #statInternal.diagnostics.status := #statInternal.internalDiagnostics.status;\n\t                      \n\t                    ELSIF #instWatchdog.Q THEN\n\t                      #statInternal.diagnostics.status := #ERR_DEVICE_DEACTIVATING_TIME_OUT;\n\t                      #statInternal.diagnostics.subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t                      \n\t                    ELSIF #statActDeact.remainingRetries <= 0 THEN\n\t                      #statInternal.diagnostics.status := #ERR_DEVICE_DEACTIVATING_RETRIES_REACHED;\n\t                      #statInternal.diagnostics.subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t                      \n\t                    ELSIF NOT #statActDeact.busy THEN\n\t                      #statInternal.status := #STATUS_DEACTIVATION;\n\t                      #statMainState := #FB_STATE_DEACTIVATE_INIT;\n\t                    END_IF;\n\t                  END_REGION\n\t              END_CASE;\n\t            END_REGION\n\t            \n\t          #FB_STATE_DEACTIVATE_DONE:\n\t            REGION Deactivated\n\t              ;// nothing to do here...\n\t              #statInternal.status := #STATUS_DEACTIVATION_DONE;\n\t            END_REGION\n\t            \n\t          #FB_STATE_ACTIVATE_INIT..\n\t          #FB_STATE_ACTIVATE_WAIT:\n\t            REGION Activate\n\t              CASE #statMainState OF\n\t                #FB_STATE_ACTIVATE_INIT:\n\t                  REGION Activate init\n\t                    #statActDeact.request := FALSE;\n\t                    #statActDeact.mode := #MODE_ACTIVATE;\n\t                    #statActDeact.neededRetrieCyclesUntilActivation += 1;\n\t                    #statActDeact.remainingRetries -= 1;\n\t                    IF #statActDeact.remainingRetries < 0 THEN\n\t                      #statActDeact.remainingRetries := 0;\n\t                    END_IF;\n\t                    \n\t                    #statInternal.status := #STATUS_ACTIVATION;\n\t                    #statMainState := #FB_STATE_ACTIVATE_INIT_WAIT;\n\t                  END_REGION\n\t                  \n\t                #FB_STATE_ACTIVATE_INIT_WAIT:\n\t                  REGION Activate init wait\n\t                    IF TRUE\n\t                      AND NOT #statActDeact.busy\n\t                    THEN\n\t                      #statMainState := #FB_STATE_ACTIVATE_START;\n\t                    END_IF;\n\t                  END_REGION\n\t                  \n\t                #FB_STATE_ACTIVATE_START:\n\t                  REGION Activate start\n\t                    #statActDeact.request := TRUE;\n\t                    #statActDeact.mode := #MODE_ACTIVATE;\n\t                    \n\t                    #statMainState := #FB_STATE_ACTIVATE_WAIT;\n\t                  END_REGION\n\t                  \n\t                #FB_STATE_ACTIVATE_WAIT:\n\t                  REGION Activate wait\n\t                    #statActDeact.request := FALSE;\n\t                    \n\t                    // Device activation completed successfully\n\t                    IF TRUE\n\t                      AND #statDeviceState.deviceStateOK\n\t                      AND NOT #statActDeact.busy\n\t                      AND (FALSE\n\t                      OR (#statActDeact.result = #DEVICE_IS_ACTIVE)\n\t                      OR (#statActDeact.result = #RESULT_SUCCESS)\n\t                      )\n\t                    THEN\n\t                      #statMainState := #FB_STATE_ACTIVATE_DONE;\n\t                      \n\t                    ELSIF #statActDeact.result.%X15 THEN // Error occured first time in Activation SFC\n\t                      // Write infos into internal Diagnostic buffer for info reasons\n\t                      #statInternal.internalDiagnostics.status := #ERR_DEVICE_ACTIVATING;\n\t                      #statInternal.internalDiagnostics.subfunctionStatus := #statActDeact.result;\n\t                      #statMainState := #FB_STATE_ACTIVATE_INIT;\n\t                      // Set flag that error has happend\n\t                      // This is to detect if the error is still present over more than one cycle\n\t                      #statActDeact.hasPreviousError := TRUE;\n\t                      \n\t                    ELSIF #statDeviceState.resultDeviceStates.%X15 THEN // Error occured first time in Device state SFC\n\t                      #statInternal.internalDiagnostics.status := #ERR_READ_DEVICES_STATES_DURING_ACTIVATION;\n\t                      #statInternal.internalDiagnostics.subfunctionStatus := #statDeviceState.resultDeviceStates;\n\t                      #statMainState := #FB_STATE_ACTIVATE_INIT;\n\t                      // Set flag that error has happend\n\t                      // This is to detect if the error is still present over more than one cycle\n\t                      #statActDeact.hasPreviousError := TRUE;\n\t                      \n\t                      // Watchdog or retries reached and previously dedected error occured\n\t                    ELSIF TRUE\n\t                      AND #statInternal.internalDiagnostics.status.%X15\n\t                      AND (FALSE\n\t                      OR #instWatchdog.Q\n\t                      OR #statActDeact.remainingRetries <= 0\n\t                      )\n\t                    THEN\n\t                      #statInternal.diagnostics := #statInternal.internalDiagnostics;\n\t                      \n\t                      // Watchdog or retries reached and previously dedected error occured\n\t                    ELSIF #instWatchdog.Q THEN\n\t                      #statInternal.diagnostics.status := #ERR_DEVICE_ACTIVATING_TIME_OUT;\n\t                      #statInternal.diagnostics.subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t                      \n\t                      // Watchdog or retries reached and previously dedected error occured\n\t                    ELSIF #statActDeact.remainingRetries <= 0 THEN\n\t                      #statInternal.diagnostics.status := #ERR_DEVICE_ACTIVATING_RETRIES_REACHED;\n\t                      #statInternal.diagnostics.subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t                      \n\t                    ELSIF NOT #statActDeact.busy THEN\n\t                      #statInternal.status := #STATUS_ACTIVATION;\n\t                      #statMainState := #FB_STATE_ACTIVATE_INIT;\n\t                    END_IF;\n\t                  END_REGION\n\t              END_CASE;\n\t            END_REGION\n\t            \n\t          #FB_STATE_ACTIVATE_DONE:\n\t            REGION Activated\n\t              ;// nothing to do here...\n\t              #statInternal.status := #STATUS_ACTIVATION_DONE;\n\t            END_REGION\n\t            \n\t          ELSE // Undefined state in state machine reached\n\t            REGION Undefined state\n\t              #statInternal.diagnostics.#status := #ERR_UNDEFINED_STATE;\n\t            END_REGION Undefined state\n\t        END_CASE;\n\t        \n\t        REGION Timer handling\n\t          CASE #statMainState OF\n\t            #FB_STATE_DEACTIVATE_INIT..\n\t            #FB_STATE_DEACTIVATE_WAIT,\n\t            #FB_STATE_ACTIVATE_INIT..\n\t            #FB_STATE_ACTIVATE_WAIT:\n\t              #instWatchdog.TON(IN := TRUE,\n\t                                PT := #parameter.timeOutActDeact);\n\t              \n\t            ELSE\n\t              #instWatchdog.TON(IN := FALSE,\n\t                                PT := #parameter.timeOutActDeact);\n\t          END_CASE;\n\t        END_REGION Timer handling\n\t        \n\t        // Call activate / Deactivate system function\n\t        #statActDeact.result := INT_TO_WORD(D_ACT_DP(REQ := #statActDeact.request, MODE := #statActDeact.mode, LADDR := #statActDeact.hwIdDevice, BUSY => #statActDeact.busy));\n\t        \n\t        // Gets the device stations states\n\t        #statDeviceState.resultDeviceStates := INT_TO_WORD(DeviceStates(LADDR := #statDeviceState.hwIdIoSystem, MODE := #SLAVE_EXISTS, STATE := #statDeviceState.devicesState));\n\t        // Read the returned status bit of this device\n\t        // In case the LOG2GEO block is working without errors --> fetch the value of the array on the postion Device.StationNumber\n\t        #statDeviceState.deviceStateOK := #statDeviceState.devicesState[#statDeviceState.geoAddr.STATION] AND NOT #statDeviceState.resultDeviceStates.%X15;\n\t      END_REGION\n\t      \n\t    ELSE // Undefined state in state machine reached\n\t      REGION Undefined state\n\t        #statInternal.diagnostics.#status := #ERR_UNDEFINED_STATE;\n\t      END_REGION Undefined state\n\t  END_CASE;\n\tEND_REGION STATE MACHINE\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  \n\t  IF TRUE\n\t    AND NOT #tempExecute\n\t    AND (FALSE\n\t    OR #statInternal.done\n\t    OR #statInternal.error\n\t    )\n\t  THEN // Reset outputs\n\t    REGION Execute reseted\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t      #statInternal.error := FALSE;\n\t      #statInternal.status := #STATUS_NO_CALL;\n\t    END_REGION Execute reseted\n\t    \n\t  ELSIF TRUE\n\t    AND #statInternal.diagnostics.status.%X15\n\t    AND NOT #statInternal.error\n\t    AND #statMainState <> #FB_STATE_NO_PROCESSING\n\t  THEN // Error occurred (#statStatus is 16#8000 to 16#FFFF)\n\t    REGION Error occured\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #statInternal.diagnostics.stateNumber := #statMainState;\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // execution aborted --> set state no processing\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION Error occured\n\t  END_IF;\n\t  \n\t  REGION Write static values to outputs\n\t    #done := #statInternal.done :=  FALSE\n\t    OR (#statMainState = #FB_STATE_DEACTIVATE_DONE)\n\t    OR (#statMainState = #FB_STATE_ACTIVATE_DONE)\n\t    ;\n\t    \n\t    #deactivatingActive := (#statMainState >= #FB_STATE_DEACTIVATE_INIT) AND (#statMainState <= #FB_STATE_DEACTIVATE_DONE);\n\t    #deactivatingDone := (#statMainState = #FB_STATE_DEACTIVATE_DONE);\n\t    #activatingActive := (#statMainState >= #FB_STATE_ACTIVATE_INIT) AND (#statMainState <= #FB_STATE_ACTIVATE_DONE);\n\t    #activatingDone := (#statMainState = #FB_STATE_ACTIVATE_DONE);\n\t    #busy := (#statMainState > #FB_STATE_NO_PROCESSING) AND (#statMainState < #FB_STATE_LAST);\n\t    #error := #statInternal.error;\n\t    IF #statInternal.error THEN\n\t      #status := #statInternal.diagnostics.status;\n\t    ELSE\n\t      #status := #statInternal.status;\n\t    END_IF;\n\t    // if ENO mechanism is not used / not wanted replace the following line by --> ENO := TRUE;\n\t    ENO := NOT #statInternal.error;\n\t  END_REGION Write static values to outputs\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "MeasureCpuLoad", "description": "Measurement and calculation of PLC CPU load for different OB types", "type": "FUNCTION_BLOCK", "name": "LGF_MeasureCpuLoad", "vars": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "reset", "type": "Bool", "description": "Rising edge: Reset all internal values and as well PLC\nCPU timing statistic"}, {"name": "loadCascade", "type": "Real", "description": "Percentage Load Value from another\n`LGF_MeasureCpuLoad` [%] (Connect `cpuLoad` from\npredecessor instance call)"}, {"name": "configuration", "type": "LGF_typeMeasure\nCpuLoad_\nConfiguration", "description": "This UDT belongs to the Module\n`LGF_MeasureCpuLoad` and lists all possible\nparameter to configure its behavior."}, {"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished, and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "averagingActive", "type": "Bool", "description": "TRUE: Averaging of actual values active"}, {"name": "loadCascadeActive", "type": "Bool", "description": "TRUE: Load calculation cascade active"}, {"name": "cycleTimeMin", "type": "LTime", "description": "Minimum cycle time [ms]"}, {"name": "cycleTimeActual", "type": "LTime", "description": "Actual cycle time [ms]"}, {"name": "cycleTimeMax", "type": "LTime", "description": "Maximum cycle time [ms]"}, {"name": "cycleTimeMaxConfigured", "type": "LTime", "description": "Configured maximum cycle time [ms] (in plc hardware configuration)"}, {"name": "runtime", "type": "LReal", "description": "Actual cycle time incl. interrupts [ms]"}, {"name": "cpuLoad", "type": "Real", "description": "Actual PLC CPU load [%]"}, {"name": "comLoad", "type": "Real", "description": "Actual communication load [%]"}, {"name": "comLoadConfigured", "type": "Real", "description": "Configured communication load [%]"}, {"name": "limitWarning", "type": "Bool", "description": "Load more than configured threshold value\n'configuration.limitWarning'"}, {"name": "limitAlarm", "type": "Bool", "description": "Load more than configured threshold value 'configuration.limitAlarm'"}, {"name": "resultsCyclic", "type": "Array[0..#LAST_\nCYCLIC_BLOCK_\nINDEX] of LGF\n_typeMeasureCpu\nLoad_ResultBlock", "description": "Results of Cyclic OB read outs"}, {"name": "results", "type": "Array[0..#LAST_\nBLOCK_INDEX] of\nLGF_typeMeasure\nCpuLoad_Result\nBlock", "description": "Results of NON-Cyclic OB read outs"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}, {"name": "cfcRun", "type": "Bool", "description": "CFC Run (OB No is shifted to 10xx)"}, {"name": "averagingValues", "type": "USInt", "description": "Averaging the measured values by building the\narithmetic average value"}, {"name": "comLoadSim", "type": "UInt", "description": "Com Load Simulation [%]\nIF > 0.0 used as value for calculation\nIF <= 0.0 take real com load value read from PLC"}, {"name": "limitWarning", "type": "Real", "description": "Warning threshold value [%]"}, {"name": "limitAlarm", "type": "Real", "description": "Alarming threshold value [%]"}, {"name": "organization\nBlocksCyclic", "type": "Array[0..10] of\nLGF_typeMeasur\ne\nCpuLoad_\nConfiguration\nBlock", "description": "Cyclic Blocks to measure"}, {"name": "organization\nBlocks", "type": "Array[0..30] of\nLGF_typeMeasur\ne\nCpuLoad_\nConfiguration\nBlock", "description": "NON-Cyclic Blocks to measure"}, {"name": "obNumber", "type": "Int", "description": "Organisation Block Number"}, {"name": "runtime", "type": "LTime", "description": "Runtime of Organization block [ms]"}, {"name": "cycleLoad", "type": "Real", "description": "Load of block calculated using the cycle time [%]"}, {"name": "maxCycleLoad", "type": "Real", "description": "Load of block calculated using the MAX cycle time [%]"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during reading block statistic"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the `RT_INFO`,\n16#8000 - 16#FFFF: Error identification"}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "reset", "type": "Bool", "description": "Rising edge: Reset all internal values and as well PLC\nCPU timing statistic"}, {"name": "loadCascade", "type": "Real", "description": "Percentage Load Value from another\n`LGF_MeasureCpuLoad` [%] (Connect `cpuLoad` from\npredecessor instance call)"}, {"name": "configuration", "type": "LGF_typeMeasure\nCpuLoad_\nConfiguration", "description": "This UDT belongs to the Module\n`LGF_MeasureCpuLoad` and lists all possible\nparameter to configure its behavior."}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished, and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "averagingActive", "type": "Bool", "description": "TRUE: Averaging of actual values active"}, {"name": "loadCascadeActive", "type": "Bool", "description": "TRUE: Load calculation cascade active"}, {"name": "cycleTimeMin", "type": "LTime", "description": "Minimum cycle time [ms]"}, {"name": "cycleTimeActual", "type": "LTime", "description": "Actual cycle time [ms]"}, {"name": "cycleTimeMax", "type": "LTime", "description": "Maximum cycle time [ms]"}, {"name": "cycleTimeMaxConfigured", "type": "LTime", "description": "Configured maximum cycle time [ms] (in plc hardware configuration)"}, {"name": "runtime", "type": "LReal", "description": "Actual cycle time incl. interrupts [ms]"}, {"name": "cpuLoad", "type": "Real", "description": "Actual PLC CPU load [%]"}, {"name": "comLoad", "type": "Real", "description": "Actual communication load [%]"}, {"name": "comLoadConfigured", "type": "Real", "description": "Configured communication load [%]"}, {"name": "limitWarning", "type": "Bool", "description": "Load more than configured threshold value\n'configuration.limitWarning'"}, {"name": "limitAlarm", "type": "Bool", "description": "Load more than configured threshold value 'configuration.limitAlarm'"}, {"name": "resultsCyclic", "type": "Array[0..#LAST_\nCYCLIC_BLOCK_\nINDEX] of LGF\n_typeMeasureCpu\nLoad_ResultBlock", "description": "Results of Cyclic OB read outs"}, {"name": "results", "type": "Array[0..#LAST_\nBLOCK_INDEX] of\nLGF_typeMeasure\nCpuLoad_Result\nBlock", "description": "Results of NON-Cyclic OB read outs"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_MeasureCpuLoad\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Simatic Systems Support'\nFAMILY : LGF\nNAME : LGF_MeasureCpuLoad\n   VAR_INPUT \n      enable : Bool;\n      reset : Bool;\n      loadCascade { S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Real;\n      configuration : \"LGF_typeMeasureCpuLoad_Configuration\";\n   END_VAR\n\n   VAR_OUTPUT \n      valid { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      averagingActive { ExternalWritable := 'False'} : Bool;\n      loadCascadeActive { ExternalWritable := 'False'} : Bool;\n      cycleTimeMin { ExternalWritable := 'False'} : LTime;\n      cycleTimeActual { ExternalWritable := 'False'} : LTime;\n      cycleTimeMax { ExternalWritable := 'False'} : LTime;\n      cycleTimeMaxConfigured { ExternalWritable := 'False'} : LTime;\n      runtime { ExternalWritable := 'False'} : LReal;\n      cpuLoad { ExternalWritable := 'False'} : Real;\n      comLoad { ExternalWritable := 'False'} : Real;\n      comLoadConfigured { ExternalWritable := 'False'} : Real;\n      limitWarning { ExternalWritable := 'False'} : Bool;\n      limitAlarm { ExternalWritable := 'False'} : Bool;\n      resultsCyclic { ExternalWritable := 'False'} : Array[0..#LAST_CYCLIC_BLOCK_INDEX] of \"LGF_typeMeasureCpuLoad_ResultBlock\";\n      results { ExternalWritable := 'False'} : Array[0..#LAST_BLOCK_INDEX] of \"LGF_typeMeasureCpuLoad_ResultBlock\";\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR \n      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         enablePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         resetPrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         valid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorUserCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorAutoCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         disablingCompleted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         runTimeInternalMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n         runTimeMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 0.0;\n         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\";\n      END_STRUCT;\n      statResultsCyclic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[0..#LAST_CYCLIC_BLOCK_INDEX] of \"LGF_typeMeasureCpuLoad_ResultBlock\";\n      statResults { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[0..#LAST_BLOCK_INDEX] of \"LGF_typeMeasureCpuLoad_ResultBlock\";\n      statPrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         cycleTimeActual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LTime;\n         comLoadActual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;\n         runtimesCyclic { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#LAST_CYCLIC_BLOCK_INDEX] of LTime;\n         runtimes { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#LAST_BLOCK_INDEX] of LTime;\n      END_STRUCT;\n      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;\n      statModuleRunTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statCycleTimeMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LTime;\n      statCycleTimeActual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LTime;\n      statCycleTimeMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LTime;\n      statCycleTimeMaxConfigured { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LTime;\n      statCpuLoadPerc { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;\n      statComLoadActual { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;\n      statComLoadConfigured { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;\n   END_VAR\n\n   VAR_TEMP \n      tempEnable : Bool;\n      tempRuntimeModul : LReal;\n      tempRuntime : LReal;\n      tempIndex : DInt;\n      tempResultValue : Word;\n      tempComLoadPercent : Real;\n      tempResult : \"LGF_typeMeasureCpuLoad_ResultBlock\";\n      tempRuntimePercentage : Real;\n      tempComLoadActual : UInt;\n   END_VAR\n\n   VAR CONSTANT \n      LAST_CYCLIC_BLOCK_INDEX : DInt := 10;\n      LAST_BLOCK_INDEX : DInt := 30;\n      CFC_ENV_OB_NUMBER_OFFSET : Int := 1000;\n      OB_MEASURMENT_DISABLED : Int := -1;\n      OB_MEASURMENT_DISABLED_LOAD : Real := -1.0;\n      RT_INFO_RUNTIME : UInt := 1;\n      RT_INFO_COM_LOAD : UInt := 21;\n      RT_INFO_CYCLETIME : UInt := 25;\n      RT_INFO_CONFIGURED_CYCLETIME_MAX : UInt := 30;\n      RT_INFO_CONFIGURED_COM_LOAD : UInt := 32;\n      RT_INFO_RESET_CYCLE_STATISTIC : UInt := 44;\n      RT_INFO_READ_LONGEST_CYCLE_TIME : UInt := 23;\n      RT_INFO_READ_SHORTEST_CYCLE_TIME : UInt := 24;\n      FB_STATE_NO_PROCESSING : DInt := 0;\n      FB_STATE_ENABLING : DInt := 10;\n      FB_STATE_PROCESSING : DInt := 50;\n      FB_STATE_DISABLING : DInt := 90;\n      NO_ERROR : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      ERROR_RTINFO_CONFIGURED_MAX_CYCLETIME : Word := 16#8601;\n      ERROR_RTINFO_CONFIGURED_COM_LOAD : Word := 16#8602;\n      ERROR_RTINFO_ACTUAL_CYCLETIME : Word := 16#8610;\n      ERROR_RTINFO_ACTUAL_MIN_CYCLETIME : Word := 16#8611;\n      ERROR_RTINFO_ACTUAL_MAX_CYCLETIME : Word := 16#8612;\n      ERROR_RTINFO_ACTUAL_COM_LOAD : Word := 16#8620;\n      ERROR_RTINFO_RESET_STATISTICS : Word := 16#8630;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n      ERROR_RTINFO_RUNTIME_OB_CYCLIC : Word := 16#9000;\n      ERROR_RTINFO_RUNTIME_OB : Word := 16#9100;\n      STATUSRANGE_DEFINITIONS_ERR_IN_BLOCK_OPERATION : Word := 16#8001;\n      STATUSRANGE_DEFINITIONS_ERR_PARAMETRIZATION : Word := 16#8200;\n      STATUSRANGE_DEFINITIONS_ERR_PROCESSING_EXTERN : Word := 16#8400;\n      STATUSRANGE_DEFINITIONS_ERR_PROCESSING_INTERN : Word := 16#8600;\n      STATUSRANGE_DEFINITIONS_ERR_AREA_RESERVED : Word := 16#8800;\n      STATUSRANGE_DEFINITIONS_ERR_USER_DEFINED_CLASSES : Word := 16#9000;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  //Siemens AG / (c)Copyright 2020\n\t  //-------------------------------------------------------------------------------\n\t  //Title:            LGF_MeasureCpuLoad\n\t  //Comment/Function: Measurement and calculation of PLC CPU load for different OB types\n\t  //Messung und Berechnung der SPS-CPU-Last für verschiedene OB-Typen\n\t  //Library/Family:   LGF - Library of general functions\n\t  //Author:           Simatic Systems Support\n\t  //Tested with:      S7-1500\n\t  //Engineering:      TIA Portal V19\n\t  //Restrictions:     S7-1500 only\n\t  //ENO mechanism is NOT used - forced TO true.\n\t  //Requirements:     PLC S7-1500\n\t  //-------------------------------------------------------------------------------\n\t  //Change log table:\n\t  //Version   | Date       | Expert in charge | Changes applied\n\t  //----------|------------|------------------|------------------------------------\n\t  //01.00.00  | 19.05.2024 | SAG BG           | First Release\n\t  //01.01.00  | 06.05.2024 | SAG BG           | Add Output with overall runtime incl. interrupts\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION ENABLING/DISABLING\n\t  #tempEnable := #enable; // Work with temporary value / create process image\n\t  IF (#tempEnable = TRUE) AND (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Enable FB\n\t    // First call; initialize FB\n\t    #statInternal.valid := TRUE;\n\t    #statInternal.busy := TRUE;\n\t    #statInternal.error := FALSE;\n\t    #statInternal.errorUserCleared := FALSE;\n\t    #statInternal.errorAutoCleared := FALSE;\n\t    #statInternal.disablingCompleted := FALSE;\n\t    #statInternal.diagnostics := #statInternal.emptyDiagnostics;\n\t    #diagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;\n\t    // State machine - start processing\n\t    #statMainState := #FB_STATE_ENABLING;\n\t    \n\t  ELSIF (#tempEnable = FALSE) AND (#statInternal.enablePrevious = TRUE) THEN // Disable FB \n\t    #statMainState := #FB_STATE_DISABLING;\n\t    \n\t  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN // Set status identifier of subsequent call\n\t    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t  END_IF;\n\t  \n\t  // Edge detection 'enable' input\n\t  #statInternal.enablePrevious := #tempEnable;\n\tEND_REGION ENABLING/DISABLING\n\t\n\tIF (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\t#tempRuntimeModul := RUNTIME(#statInternal.runTimeInternalMem);\n\t#tempRuntime := RUNTIME(#statInternal.runTimeMem);\n\tREGION STATE MACHINE\n\t  CASE #statMainState OF // State machine of FB\n\t    #FB_STATE_NO_PROCESSING:\n\t      REGION No Processing\n\t        ; // No processing active (Note: this state must always be present and left empty)\n\t      END_REGION No Processing\n\t      \n\t    #FB_STATE_ENABLING: // Enabling active\n\t      REGION Enabling\n\t        // Reset auto cleard flag in case we comming from reset command\n\t        #statInternal.errorAutoCleared := FALSE;\n\t        \n\t        // Preset values\n\t        #tempResult.obNumber := #OB_MEASURMENT_DISABLED;\n\t        #tempResult.cycleLoad :=\n\t        #tempResult.cycleLoad := #OB_MEASURMENT_DISABLED_LOAD;\n\t        #tempResult.runtime := t#0ms;\n\t        #statResultsCyclic[#tempIndex].error := FALSE;\n\t        #statResultsCyclic[#tempIndex].status := #NO_ERROR;\n\t        \n\t        // Reset internal memory\n\t        FOR #tempIndex := 0 TO #LAST_CYCLIC_BLOCK_INDEX DO\n\t          #statResultsCyclic[#tempIndex] := #tempResult;\n\t          IF #configuration.organizationBlocksCyclic[#tempIndex].enableMeasurement THEN\n\t            #statResultsCyclic[#tempIndex].obNumber := #configuration.organizationBlocksCyclic[#tempIndex].obNumber;\n\t            #statResultsCyclic[#tempIndex].cycleLoad := #configuration.organizationBlocksCyclic[#tempIndex].initialLoad;\n\t            #statResultsCyclic[#tempIndex].maxCycleLoad := #configuration.organizationBlocksCyclic[#tempIndex].initialLoad;\n\t            #statResultsCyclic[#tempIndex].runtime := t#0ms;\n\t          ELSE\n\t            ; // ELSE not used\n\t          END_IF;\n\t        END_FOR;\n\t        \n\t        FOR #tempIndex := 0 TO #LAST_BLOCK_INDEX DO\n\t          #statResultsCyclic[#tempIndex] := #tempResult;\n\t          IF #configuration.organizationBlocks[#tempIndex].enableMeasurement THEN\n\t            #statResults[#tempIndex].obNumber := #configuration.organizationBlocks[#tempIndex].obNumber;\n\t            #statResults[#tempIndex].cycleLoad := #configuration.organizationBlocks[#tempIndex].initialLoad;\n\t            #statResults[#tempIndex].maxCycleLoad := #configuration.organizationBlocks[#tempIndex].initialLoad;\n\t            #statResults[#tempIndex].runtime := t#0ms;\n\t          ELSE\n\t            ; // ELSE not used\n\t          END_IF;\n\t        END_FOR;\n\t        \n\t        IF #configuration.cfcRun THEN\n\t          // The module is used in CFC enviroment\n\t          // We need to ad the Offset to OB numbers\n\t          FOR #tempIndex := 0 TO #LAST_BLOCK_INDEX DO\n\t            #statResults[#tempIndex].obNumber += #CFC_ENV_OB_NUMBER_OFFSET;\n\t          END_FOR;\n\t        ELSE\n\t          ; // ELSE not used\n\t        END_IF;\n\t        \n\t        #statCycleTimeActual := t#0ms;\n\t        #statCycleTimeMaxConfigured := t#0ms;\n\t        #statComLoadActual := 0;\n\t        #statCpuLoadPerc := 0.0;\n\t        #statComLoadActual := 0;\n\t        #statComLoadConfigured := 0;\n\t        \n\t        #statPrevious.cycleTimeActual := t#0ms;\n\t        #statPrevious.comLoadActual := 0;\n\t        \n\t        FOR #tempIndex := 0 TO #LAST_CYCLIC_BLOCK_INDEX DO\n\t          #statPrevious.runtimesCyclic[#tempIndex] := t#0ms;\n\t        END_FOR;\n\t        \n\t        FOR #tempIndex := 0 TO #LAST_BLOCK_INDEX DO\n\t          #statPrevious.runtimes[#tempIndex] := t#0ms;\n\t        END_FOR;\n\t        \n\t        REGION Read max Cycle time setting\n\t          #tempResultValue := INT_TO_WORD(RT_INFO(MODE := #RT_INFO_CONFIGURED_CYCLETIME_MAX, OB := 1, INFO := #statCycleTimeMaxConfigured));\n\t          IF #tempResultValue.%X15 THEN\n\t            #statCycleTimeMaxConfigured := t#0ms;\n\t            #statInternal.diagnostics.status := #ERROR_RTINFO_CONFIGURED_MAX_CYCLETIME;\n\t            #statInternal.diagnostics.subfunctionStatus := #tempResultValue;\n\t          ELSE\n\t            ; // ELSE not used\n\t          END_IF;\n\t        END_REGION\n\t        \n\t        REGION Read configured com load\n\t          #tempResultValue := INT_TO_WORD(RT_INFO(MODE := #RT_INFO_CONFIGURED_COM_LOAD, OB := 1, INFO := #statComLoadConfigured));\n\t          IF #tempResultValue.%X15 THEN\n\t            #statComLoadConfigured := 0;\n\t            #statInternal.diagnostics.status := #ERROR_RTINFO_CONFIGURED_COM_LOAD;\n\t            #statInternal.diagnostics.subfunctionStatus := #tempResultValue;\n\t          ELSE\n\t            ; // ELSE not used\n\t          END_IF;\n\t        END_REGION\n\t        \n\t        REGION Reset RT_INFO statistics\n\t          #tempResultValue := INT_TO_WORD(RT_INFO(MODE := #RT_INFO_RESET_CYCLE_STATISTIC, OB := 1, INFO := #tempIndex));\n\t          IF #tempResultValue.%X15 THEN\n\t            #statComLoadConfigured := 0;\n\t            #statInternal.diagnostics.status := #ERROR_RTINFO_RESET_STATISTICS;\n\t            #statInternal.diagnostics.subfunctionStatus := #tempResultValue;\n\t          ELSE\n\t            ; // ELSE not used\n\t          END_IF;\n\t        END_REGION\n\t        \n\t        #statMainState := #FB_STATE_PROCESSING;\n\t      END_REGION Enabling\n\t      \n\t    #FB_STATE_PROCESSING: // Processing active\n\t      REGION Processing\n\t        REGION Runtime measuring\n\t        END_REGION Runtime measuring\n\t        \n\t        REGION Reset edge\n\t          // in case of reset the block we just jump back to enabling to init the tags\n\t          IF #reset AND NOT #statInternal.resetPrevious THEN\n\t            #statMainState := #FB_STATE_ENABLING;\n\t          END_IF;\n\t          #statInternal.resetPrevious := #reset;\n\t        END_REGION\n\t        \n\t        REGION Read actual cycle time\n\t          #tempResultValue := INT_TO_WORD(RT_INFO(MODE := #RT_INFO_CYCLETIME, OB := 1, INFO := #statCycleTimeActual));\n\t          IF TRUE // Only if no error is present\n\t            AND #tempResultValue.%X15\n\t            AND NOT #statInternal.errorAutoCleared\n\t          THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERROR_RTINFO_ACTUAL_CYCLETIME;\n\t            #statInternal.diagnostics.subfunctionStatus := #tempResultValue;\n\t          END_IF;\n\t          \n\t          REGION Averaging if configured\n\t            IF #configuration.averagingValues > 1 THEN\n\t              // Actual NEW = (previous * (averageNumber - 1) + actual) / averageNumber;\n\t              #statCycleTimeActual := 1000 * ULINT_TO_LTIME((LTIME_TO_ULINT(#statPrevious.cycleTimeActual) / 1000 * (#configuration.averagingValues - 1) + LTIME_TO_ULINT(#statCycleTimeActual) / 1000) / #configuration.averagingValues);\n\t            END_IF;\n\t          END_REGION\n\t        END_REGION\n\t        \n\t        REGION Read min cycle time\n\t          #tempResultValue := INT_TO_WORD(RT_INFO(MODE := #RT_INFO_READ_SHORTEST_CYCLE_TIME, OB := 1, INFO := #statCycleTimeMin));\n\t          IF TRUE // Only if no error is present\n\t            AND #tempResultValue.%X15\n\t            AND NOT #statInternal.errorAutoCleared\n\t          THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERROR_RTINFO_ACTUAL_MIN_CYCLETIME;\n\t            #statInternal.diagnostics.subfunctionStatus := #tempResultValue;\n\t          END_IF;\n\t        END_REGION\n\t        \n\t        REGION Read max cycle time\n\t          #tempResultValue := INT_TO_WORD(RT_INFO(MODE := #RT_INFO_READ_LONGEST_CYCLE_TIME, OB := 1, INFO := #statCycleTimeMax));\n\t          IF TRUE // Only if no error is present\n\t            AND #tempResultValue.%X15\n\t            AND NOT #statInternal.errorAutoCleared\n\t          THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERROR_RTINFO_ACTUAL_MAX_CYCLETIME;\n\t            #statInternal.diagnostics.subfunctionStatus := #tempResultValue;\n\t          END_IF;\n\t        END_REGION\n\t        \n\t        REGION Read actual communication load\n\t          #tempResultValue := INT_TO_WORD(RT_INFO(MODE := #RT_INFO_COM_LOAD, OB := 1, INFO := #tempComLoadActual));\n\t          #statComLoadActual := UINT_TO_REAL(#tempComLoadActual);\n\t          IF TRUE // Only if no error is present\n\t            AND #tempResultValue.%X15\n\t            AND NOT #statInternal.errorAutoCleared\n\t          THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERROR_RTINFO_ACTUAL_COM_LOAD;\n\t            #statInternal.diagnostics.subfunctionStatus := #tempResultValue;\n\t          END_IF;\n\t          \n\t          REGION Averaging if configured\n\t            IF #configuration.averagingValues > 1 THEN\n\t              // Actual NEW = (previous * (averageNumber - 1) + actual) / averageNumber;\n\t              #statComLoadActual := 1000.0 * (#statPrevious.comLoadActual / 1000.0 * (#configuration.averagingValues - 1) + #statComLoadActual / 1000.0) / #configuration.averagingValues;\n\t            END_IF;\n\t          END_REGION\n\t        END_REGION\n\t        \n\t        REGION Read actual runtimes of Cyclic Organisation Block\n\t          FOR #tempIndex := 0 TO #LAST_CYCLIC_BLOCK_INDEX DO\n\t            // If measurment is disabled, jump to next iteration\n\t            IF FALSE\n\t              OR #configuration.organizationBlocksCyclic[#tempIndex].enableMeasurement = FALSE\n\t              OR #configuration.organizationBlocksCyclic[#tempIndex].obNumber = 0\n\t            THEN\n\t              CONTINUE;\n\t            END_IF;\n\t            \n\t            // Read array index into temp\n\t            #tempResult := #statResultsCyclic[#tempIndex];\n\t            \n\t            // Read actual OB Runtime\n\t            #tempResultValue := INT_TO_WORD(RT_INFO(MODE := #RT_INFO_RUNTIME, OB := #tempResult.obNumber, INFO := #tempResult.runtime));\n\t            IF TRUE\n\t              AND #tempResultValue.%X15\n\t            THEN\n\t              #tempResult.runtime := t#0ms;\n\t              #tempResult.cycleLoad := 0.0;\n\t              #tempResult.error := TRUE;\n\t              #tempResult.status := #tempResultValue;\n\t              CONTINUE;\n\t            ELSE\n\t              #tempResult.error := FALSE;\n\t              #tempResult.status := #NO_ERROR;\n\t            END_IF;\n\t            \n\t            IF TRUE // Only if no error is present we write the main diag state\n\t              AND #tempResultValue.%X15\n\t              AND NOT #statInternal.errorAutoCleared\n\t            THEN\n\t              #statInternal.errorAutoCleared := TRUE;\n\t              #statInternal.diagnostics.status := #ERROR_RTINFO_RUNTIME_OB OR DINT_TO_WORD(#tempIndex);\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResultValue;\n\t            END_IF;\n\t            \n\t            REGION Averaging if configured\n\t              IF #configuration.averagingValues > 1 THEN\n\t                // Actual NEW = (previous * (averageNumber - 1) + actual) / averageNumber;\n\t                #tempResult.runtime := 1000 * ULINT_TO_LTIME((LTIME_TO_ULINT(#statPrevious.runtimesCyclic[#tempIndex]) / 1000 * (#configuration.averagingValues - 1) + LTIME_TO_ULINT(#tempResult.runtime) / 1000) / #configuration.averagingValues);\n\t              END_IF;\n\t            END_REGION\n\t            \n\t            REGION OB Load calculation\n\t              #tempResult.cycleLoad := UDINT_TO_REAL(LTIME_TO_UDINT(#tempResult.runtime)) / UDINT_TO_REAL(LTIME_TO_UDINT(#statCycleTimeActual)) * 100.0;\n\t              #tempResult.maxCycleLoad := UDINT_TO_REAL(LTIME_TO_UDINT(#tempResult.runtime)) / UDINT_TO_REAL(LTIME_TO_UDINT(#statCycleTimeMaxConfigured)) * 100.0;\n\t            END_REGION\n\t            \n\t            // Write result back to array index\n\t            #statResultsCyclic[#tempIndex] := #tempResult;\n\t          END_FOR;\n\t        END_REGION\n\t        \n\t        REGION Read actual runtimes of Organisation Block\n\t          FOR #tempIndex := 0 TO #LAST_BLOCK_INDEX DO\n\t            // If measurment is disabled, jump to next iteration\n\t            IF FALSE\n\t              OR #configuration.organizationBlocks[#tempIndex].enableMeasurement = FALSE\n\t              OR #configuration.organizationBlocks[#tempIndex].obNumber = 0\n\t            THEN\n\t              CONTINUE;\n\t            END_IF;\n\t            \n\t            // Read array index into temp\n\t            #tempResult := #statResults[#tempIndex];\n\t            \n\t            // Read actual OB Runtime\n\t            #tempResultValue := INT_TO_WORD(RT_INFO(MODE := #RT_INFO_RUNTIME, OB := #tempResult.obNumber, INFO := #tempResult.runtime));\n\t            IF TRUE\n\t              AND #tempResultValue.%X15\n\t            THEN\n\t              #tempResult.runtime := t#0ms;\n\t              #tempResult.cycleLoad := 0.0;\n\t              #tempResult.error := TRUE;\n\t              #tempResult.status := #tempResultValue;\n\t              CONTINUE;\n\t            ELSE\n\t              #tempResult.error := FALSE;\n\t              #tempResult.status := #NO_ERROR;\n\t            END_IF;\n\t            \n\t            IF TRUE // Only if no error is present we write the main diag state\n\t              AND #tempResultValue.%X15\n\t              AND NOT #statInternal.errorAutoCleared\n\t            THEN\n\t              #statInternal.errorAutoCleared := TRUE;\n\t              #statInternal.diagnostics.status := #ERROR_RTINFO_RUNTIME_OB OR DINT_TO_WORD(#tempIndex);\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResultValue;\n\t            END_IF;\n\t            \n\t            REGION Averaging if configured\n\t              IF #configuration.averagingValues > 1 THEN\n\t                // Actual NEW = (previous * (averageNumber - 1) + actual) / averageNumber;\n\t                #tempResult.runtime := 1000 * ULINT_TO_LTIME((LTIME_TO_ULINT(#statPrevious.runtimes[#tempIndex]) / 1000 * (#configuration.averagingValues - 1) + LTIME_TO_ULINT(#tempResult.runtime) / 1000) / #configuration.averagingValues);\n\t              END_IF;\n\t            END_REGION\n\t            \n\t            REGION OB Load calculation\n\t              #tempResult.cycleLoad := UDINT_TO_REAL(LTIME_TO_UDINT(#tempResult.runtime)) / UDINT_TO_REAL(LTIME_TO_UDINT(#statCycleTimeActual)) * 100.0;\n\t              #tempResult.maxCycleLoad := UDINT_TO_REAL(LTIME_TO_UDINT(#tempResult.runtime)) / UDINT_TO_REAL(LTIME_TO_UDINT(#statCycleTimeMaxConfigured)) * 100.0;\n\t            END_REGION\n\t            \n\t            // Write result back to array index\n\t            #statResults[#tempIndex] := #tempResult;\n\t          END_FOR;\n\t        END_REGION\n\t        \n\t        REGION Communication load calculation\n\t          IF NOT #statInternal.diagnostics.status.%X15 THEN\n\t            // Total Load calculation of cyclic OBs\n\t            #statCpuLoadPerc := #loadCascade;\n\t            FOR #tempIndex := 0 TO #LAST_CYCLIC_BLOCK_INDEX DO\n\t              // If measurment is disabled, jump to next iteration\n\t              IF FALSE\n\t                OR #configuration.organizationBlocksCyclic[#tempIndex].enableMeasurement = FALSE\n\t                OR #configuration.organizationBlocksCyclic[#tempIndex].obNumber = 0\n\t              THEN\n\t                CONTINUE;\n\t              ELSE\n\t                #statCpuLoadPerc += #statResultsCyclic[#tempIndex].maxCycleLoad;\n\t              END_IF;\n\t            END_FOR;\n\t            \n\t            // Load Calculation\n\t            // If load sim is disabled, take the actual value read from PLC\n\t            IF #configuration.comLoadSim <= 0 THEN\n\t              #tempComLoadPercent := #statComLoadActual;\n\t            ELSE\n\t              #tempComLoadPercent := UINT_TO_REAL(#configuration.comLoadSim);\n\t            END_IF;\n\t            \n\t            #tempRuntimePercentage := 100.0 * (ULINT_TO_REAL(LTIME_TO_ULINT(#statCycleTimeActual)) / ULINT_TO_REAL(LTIME_TO_ULINT(#statCycleTimeMaxConfigured)));\n\t            #statComLoadActual := #tempRuntimePercentage * ((100.0 - #tempComLoadPercent) / 100.0) * ((100.0 - #statCpuLoadPerc) / 100.0);\n\t            #statCpuLoadPerc += #statComLoadActual;\n\t          ELSE\n\t            ;\n\t          END_IF;\n\t        END_REGION\n\t        \n\t        REGION Store previous values if averaging is configured\n\t          IF #configuration.averagingValues > 1 THEN\n\t            #statPrevious.cycleTimeActual := #statCycleTimeActual;\n\t            #statPrevious.comLoadActual := #statComLoadActual;\n\t            \n\t            FOR #tempIndex := 0 TO #LAST_CYCLIC_BLOCK_INDEX DO\n\t              #statPrevious.runtimesCyclic[#tempIndex] := #statResultsCyclic[#tempIndex].runtime;\n\t            END_FOR;\n\t            \n\t            FOR #tempIndex := 0 TO #LAST_BLOCK_INDEX DO\n\t              #statPrevious.runtimes[#tempIndex] := #statResults[#tempIndex].runtime;\n\t            END_FOR;\n\t          END_IF;\n\t        END_REGION\n\t      END_REGION Processing\n\t      \n\t    #FB_STATE_DISABLING: // Disabling active\n\t      REGION Disabling\n\t        // Disabling\n\t        FOR #tempIndex := 0 TO #LAST_CYCLIC_BLOCK_INDEX DO\n\t          #statResultsCyclic[#tempIndex] := #tempResult;\n\t        END_FOR;\n\t        FOR #tempIndex := 0 TO #LAST_BLOCK_INDEX DO\n\t          #statResults[#tempIndex] := #tempResult;\n\t        END_FOR;\n\t        \n\t        #statCycleTimeMin :=\n\t        #statCycleTimeActual :=\n\t        #statCycleTimeMax := t#0ms;\n\t        #statCycleTimeMaxConfigured := t#0ms;\n\t        #statComLoadActual := 0;\n\t        #statCpuLoadPerc := 0.0;\n\t        #statComLoadActual := 0;\n\t        #statComLoadConfigured := 0;\n\t        #tempRuntime := 0.0;\n\t        // When disabling is complete the bit #statDisablingCompleted must be set\n\t        #statInternal.disablingCompleted := TRUE;\n\t      END_REGION Disabling\n\t      \n\t    ELSE // Undefined state in state machine reached\n\t      REGION Undefined state\n\t        #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;\n\t        #statInternal.diagnostics.subfunctionStatus := 16#00;\n\t        #statInternal.diagnostics.stateNumber := #statMainState;\n\t        #statInternal.errorUserCleared := TRUE;\n\t      END_REGION Undefined state\n\t  END_CASE;\n\tEND_REGION STATE MACHINE\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  IF (#statInternal.disablingCompleted = TRUE) THEN\n\t    REGION Disabling\n\t      // Reset outputs if disabling completed\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := FALSE;\n\t      #statInternal.errorUserCleared := FALSE;\n\t      #statInternal.errorAutoCleared := FALSE;\n\t      #statInternal.diagnostics.status := #STATUS_NO_CALL;\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION Disabling\n\t    \n\t  ELSIF (#statInternal.errorUserCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION Error user cleared\n\t      // Error can only be cleared by user; rising edge at enable input is needed to continue \n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      // #diagnostics := #statDiagnostic;\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // execution aborted --> set state no processing\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION Error user cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION Error auto cleared\n\t      // Error can be reset by FB automatically\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #diagnostics := #statInternal.diagnostics;\n\t    END_REGION Error auto cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = FALSE) AND (#statInternal.errorUserCleared = FALSE) AND (#statInternal.error = TRUE) THEN\n\t    REGION After user/auto cleared or command aborted\n\t      // If autocleared error is acknowledged\n\t      #statInternal.valid := TRUE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := FALSE;\n\t      // TODO: remove this line if more detailed status information is used instead of \"#STATUS_SUBSEQUENT_CALL\"\n\t      #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t    END_REGION After user/auto cleared or command aborted\n\t  END_IF;\n\t  \n\t  REGION Write static values to outputs\n\t    #valid := #statInternal.valid;\n\t    #busy := #statInternal.busy;\n\t    #error := #statInternal.error;\n\t    #status := #statInternal.diagnostics.status;\n\t    // ENO mechanism is not used / not wanted replace the following line by --> ENO := TRUE;\n\t    ENO := NOT #statInternal.error;\n\t    \n\t    // Write application specific static values to outputs\n\t    #averagingActive := (#configuration.averagingValues > 1) AND (#statMainState <> #FB_STATE_NO_PROCESSING);\n\t    #loadCascadeActive := (#loadCascade > 0.0) AND (#statMainState <> #FB_STATE_NO_PROCESSING);\n\t    \n\t    #cycleTimeMin := #statCycleTimeMin;\n\t    #cycleTimeActual := #statCycleTimeActual;\n\t    #cycleTimeMax := #statCycleTimeMax;\n\t    #cycleTimeMaxConfigured := #statCycleTimeMaxConfigured;\n\t    #runtime := #tempRuntime;\n\t    #cpuLoad := #statCpuLoadPerc;\n\t    #comLoad := #statComLoadActual;\n\t    #comLoadConfigured := #statComLoadConfigured;\n\t    #limitWarning := #statCpuLoadPerc > #configuration.limitWarning;\n\t    #limitAlarm := #statCpuLoadPerc > #configuration.limitAlarm;\n\t    \n\t    FOR #tempIndex := 0 TO #LAST_CYCLIC_BLOCK_INDEX DO\n\t      #resultsCyclic[#tempIndex] := #statResultsCyclic[#tempIndex];\n\t    END_FOR;\n\t    FOR #tempIndex := 0 TO #LAST_BLOCK_INDEX DO\n\t      #results[#tempIndex] := #statResults[#tempIndex];\n\t    END_FOR;\n\t  END_REGION Write static values to outputs\n\tEND_REGION OUTPUTS\n\t\n\t#statModuleRunTime := RUNTIME(#statInternal.runTimeInternalMem) * 1000;\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "ReadPnInterfaceParameter", "description": "The function block provides Interface parameter like the IP Address settings, MAC Address and the PN Name.", "type": "FUNCTION_BLOCK", "name": "LGF_ReadPnInterfaceParameter", "vars": [{"name": "execute", "type": "Bool", "description": "Rising edge starts action once"}, {"name": "hardwareId", "type": "HW_ANY", "description": "Hardware ID of the Interface where the parameter\nshould be read"}, {"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished, new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "DWord", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "address", "type": "IP_V4", "description": "IP Address from interface"}, {"name": "subnetMask", "type": "IP_V4", "description": "Subnet mask from interface"}, {"name": "standardGateway", "type": "IP_V4", "description": "Standard gateway address from interface"}, {"name": "macAddress", "type": "Array[0..5] of\nByte", "description": "MAC Address from interface"}, {"name": "pnName", "type": "String", "description": "Profinet name from interface"}], "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts action once"}, {"name": "hardwareId", "type": "HW_ANY", "description": "Hardware ID of the Interface where the parameter\nshould be read"}], "output": [{"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished, new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "DWord", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "address", "type": "IP_V4", "description": "IP Address from interface"}, {"name": "subnetMask", "type": "IP_V4", "description": "Subnet mask from interface"}, {"name": "standardGateway", "type": "IP_V4", "description": "Standard gateway address from interface"}, {"name": "macAddress", "type": "Array[0..5] of\nByte", "description": "MAC Address from interface"}, {"name": "pnName", "type": "String", "description": "Profinet name from interface"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_ReadPnInterfaceParameter\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Industry Support'\nFAMILY : LGF\nNAME : LGF_ReadPnInterfaceParameter\n   VAR_INPUT \n      execute : Bool;\n      hardwareId : HW_ANY;\n   END_VAR\n\n   VAR_OUTPUT \n      done { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : DWord := #STATUS_NO_CALL;\n      address {InstructionName := 'IP_V4'; LibVersion := '1.0'; ExternalWritable := 'False'} : IP_V4;\n      subnetMask {InstructionName := 'IP_V4'; LibVersion := '1.0'; ExternalWritable := 'False'} : IP_V4;\n      standardGateway {InstructionName := 'IP_V4'; LibVersion := '1.0'; ExternalWritable := 'False'} : IP_V4;\n      macAddress { ExternalWritable := 'False'} : Array[0..5] of Byte;\n      pnName { ExternalWritable := 'False'} : String;\n   END_VAR\n\n   VAR \n      statExecuteOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statBusy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord := #STATUS_NO_CALL;\n      statFBState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;\n      statHardwareId { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : HW_ANY;\n      instRedRec {InstructionName := 'RDREC'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : RDREC;\n      statPdInterfaceData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         BlockType { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;\n         BlockLength { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;\n         BlockVersionHigh { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;\n         BlockVersionLow { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;\n         Data { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..301] of Byte;\n      END_STRUCT;\n   END_VAR\n\n   VAR_TEMP \n      tempExecute : Bool;\n      tempIndex : USInt;\n   END_VAR\n\n   VAR CONSTANT \n      REC_PDINTERFACE_REAL : DInt := 16#8080;\n      REC_PDINTERFACE_LENGHT : UInt := 300;\n      FB_STATE_NO_PROCESSING : DInt := 0;\n      FB_STATE_READ_RECORD : DInt := 1;\n      FB_STATE_PROCESS_RECORD : DInt := 2;\n      STATUS_EXECUTION_FINISHED : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      ERR_UNDEFINED_STATE : Word := 16#9000;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS / (c)Copyright 2021\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ReadPnInterfaceParameter\n\t  // Function:         The function block provides Interface parameter like the IP Address settings, MAC Address and the PN Name.\n\t  // Library:          LGF\n\t  // Author:           Siemens Industry Support\n\t  // Tested with:      CPU 1516-3 PN/DP\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     --\n\t  // Requirements:     S7-1200/1500\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 2022-12-16 | Siemens Online Support | First released version\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t(/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION TRIGGERING\n\t  #tempExecute := #execute; // Work with temporary value / create process image\n\t  IF (#tempExecute = TRUE) AND (#statExecuteOld = FALSE) // Check if FB is triggered\n\t    // TODO(optional): delete next line and comment line if FB shall finish current job before new job can be started with rising edge of execute\n\t    AND (#statStatus = #STATUS_NO_CALL)\n\t  THEN // First call; initialize FB\n\t    #statDone := FALSE;\n\t    #statBusy := TRUE;\n\t    #statError := FALSE;\n\t    #statStatus := #STATUS_FIRST_CALL;\n\t    // State machine - start processing\n\t    #statFBState := #FB_STATE_READ_RECORD;\n\t    \n\t    // Init ariables\n\t    #statHardwareId := #hardwareId;\n\t    // PNN Name\n\t    #pnName := '';\n\t    // MAC-Address data\n\t    #macAddress[0] := 16#00;\n\t    #macAddress[1] := 16#00;\n\t    #macAddress[2] := 16#00;\n\t    #macAddress[3] := 16#00;\n\t    #macAddress[4] := 16#00;\n\t    #macAddress[5] := 16#00;\n\t    // IP-Address data\n\t    #address.ADDR[1] := 16#00;\n\t    #address.ADDR[2] := 16#00;\n\t    #address.ADDR[3] := 16#00;\n\t    #address.ADDR[4] := 16#00;\n\t    // Subnetmask data\n\t    #subnetMask.ADDR[1] := 16#00;\n\t    #subnetMask.ADDR[2] := 16#00;\n\t    #subnetMask.ADDR[3] := 16#00;\n\t    #subnetMask.ADDR[4] := 16#00;\n\t    // Copy Standard Gateway data\n\t    #standardGateway.ADDR[1] := 16#00;\n\t    #standardGateway.ADDR[2] := 16#00;\n\t    #standardGateway.ADDR[3] := 16#00;\n\t    #standardGateway.ADDR[4] := 16#00;\n\t    \n\t    // Initialize functionality: call subsidiary FBs with FALSE\n\t    #instRedRec(REQ    := FALSE,\n\t                ID     := #statHardwareId, //Interface to be questioned [HW_ID]\n\t                INDEX  := #REC_PDINTERFACE_REAL,\n\t                MLEN   := #REC_PDINTERFACE_LENGHT,\n\t                RECORD := #statPdInterfaceData);\n\t    \n\t  ELSIF (#statStatus = #STATUS_FIRST_CALL) THEN\n\t    #statStatus := #STATUS_SUBSEQUENT_CALL;\n\t  END_IF;\n\t  \n\t  // Edge detection 'execute' input\n\t  #statExecuteOld := #tempExecute;\n\tEND_REGION TRIGGERING\n\t\n\tIF (#statStatus = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION STATE MACHINE\n\t  CASE #statFBState OF // State machine of FB\n\t    #FB_STATE_NO_PROCESSING:\n\t      REGION No Processing\n\t        ; // No processing active (Note: this state must always be present and left empty)\n\t      END_REGION No Processing\n\t      \n\t    #FB_STATE_READ_RECORD:\n\t      REGION Processing Read Record\n\t        #instRedRec(REQ    := TRUE,\n\t                    ID     := #statHardwareId, //Interface to be questioned [HW_ID]\n\t                    INDEX  := #REC_PDINTERFACE_REAL,\n\t                    MLEN   := #REC_PDINTERFACE_LENGHT,\n\t                    RECORD := #statPdInterfaceData);\n\t        \n\t        IF (#instRedRec.VALID = TRUE) THEN\n\t          #statFBState := #FB_STATE_PROCESS_RECORD;\n\t          \n\t        ELSIF (#instRedRec.ERROR = TRUE) THEN // Error occurred in subsidiary FB\n\t          #statStatus := #instRedRec.STATUS; // Set status of read record\n\t        END_IF;\n\t      END_REGION Processing Read Record\n\t      \n\t    #FB_STATE_PROCESS_RECORD:\n\t      REGION Processing Process the DataRecord\n\t        // Get PN-interface Name. String starts at an odd address within the array\n\t        Chars_TO_Strg(Chars  := #statPdInterfaceData.Data,\n\t                      pChars := 1,\n\t                      Cnt    := BYTE_TO_UINT(#statPdInterfaceData.Data[0]),\n\t                      Strg   => #pnName);\n\t        \n\t        // Calculate start address of IP-address data. Blockdata is padded to make it Unsigned32 aligned!\n\t        // When reading is valid, then calculate the offset of the MAC address inside the array\n\t        #tempIndex := BYTE_TO_USINT(#statPdInterfaceData.Data[0]) + (4 - ((BYTE_TO_USINT(#statPdInterfaceData.Data[0]) + 2) MOD 4));\n\t        \n\t        // Copy MAC-Address data\n\t        #macAddress[0] := #statPdInterfaceData.Data[#tempIndex + 0];\n\t        #macAddress[1] := #statPdInterfaceData.Data[#tempIndex + 1];\n\t        #macAddress[2] := #statPdInterfaceData.Data[#tempIndex + 2];\n\t        #macAddress[3] := #statPdInterfaceData.Data[#tempIndex + 3];\n\t        #macAddress[4] := #statPdInterfaceData.Data[#tempIndex + 4];\n\t        #macAddress[5] := #statPdInterfaceData.Data[#tempIndex + 5];\n\t        \n\t        // Copy IP-Address data\n\t        #address.ADDR[1] := #statPdInterfaceData.Data[#tempIndex + 8 + 0];\n\t        #address.ADDR[2] := #statPdInterfaceData.Data[#tempIndex + 8 + 1];\n\t        #address.ADDR[3] := #statPdInterfaceData.Data[#tempIndex + 8 + 2];\n\t        #address.ADDR[4] := #statPdInterfaceData.Data[#tempIndex + 8 + 3];\n\t        \n\t        // Copy Subnetmask data\n\t        #subnetMask.ADDR[1] := #statPdInterfaceData.Data[#tempIndex + 12 + 0];\n\t        #subnetMask.ADDR[2] := #statPdInterfaceData.Data[#tempIndex + 12 + 1];\n\t        #subnetMask.ADDR[3] := #statPdInterfaceData.Data[#tempIndex + 12 + 2];\n\t        #subnetMask.ADDR[4] := #statPdInterfaceData.Data[#tempIndex + 12 + 3];\n\t        \n\t        // Copy Standard Gateway data\n\t        #standardGateway.ADDR[1] := #statPdInterfaceData.Data[#tempIndex + 16 + 0];\n\t        #standardGateway.ADDR[2] := #statPdInterfaceData.Data[#tempIndex + 16 + 1];\n\t        #standardGateway.ADDR[3] := #statPdInterfaceData.Data[#tempIndex + 16 + 2];\n\t        #standardGateway.ADDR[4] := #statPdInterfaceData.Data[#tempIndex + 16 + 3];\n\t        \n\t        // Reset Read record\n\t        #instRedRec(REQ    := FALSE,\n\t                    ID     := #statHardwareId, //Interface to be questioned [HW_ID]\n\t                    INDEX  := #REC_PDINTERFACE_REAL,\n\t                    MLEN   := #REC_PDINTERFACE_LENGHT,\n\t                    RECORD := #statPdInterfaceData);\n\t        \n\t        #statStatus := #STATUS_EXECUTION_FINISHED;\n\t      END_REGION Processing Process the DataRecord\n\t      \n\t    ELSE // Undefined state in state machine reached\n\t      REGION Undefined state\n\t        #statStatus := #ERR_UNDEFINED_STATE;\n\t      END_REGION Undefined state\n\t  END_CASE;\n\tEND_REGION STATE MACHINE\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  IF (#statStatus = #STATUS_EXECUTION_FINISHED) AND (#statDone = FALSE) THEN // Execution finished without errors\n\t    REGION Execution finished\n\t      #statDone := TRUE;\n\t      #statBusy := FALSE;\n\t      #statError := FALSE;\n\t      // execution aborted --> set state no processing\n\t      #statFBState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION Execution finished\n\t    \n\t  ELSIF (#statStatus.%X15 = TRUE) AND (#statError = FALSE) THEN // Error occurred (#statStatus is 16#8000 to 16#FFFF)\n\t    REGION Error occured\n\t      #statDone := FALSE;\n\t      #statBusy := FALSE;\n\t      #statError := TRUE;\n\t      // execution aborted --> set state no processing\n\t      #statFBState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION Error occured\n\t    \n\t  ELSIF (#tempExecute = FALSE) AND ((#statDone = TRUE) OR (#statError = TRUE)) THEN // Reset outputs\n\t    REGION Execute reseted\n\t      #statDone := FALSE;\n\t      #statBusy := FALSE;\n\t      #statError := FALSE;\n\t      #statStatus := #STATUS_NO_CALL;\n\t    END_REGION Execute reseted\n\t  END_IF;\n\t  \n\t  REGION Write static values to outputs\n\t    #done := #statDone;\n\t    #busy := #statBusy;\n\t    #error := #statError;\n\t    #status := #statStatus;\n\t    // if ENO mechanism is not used / not wanted replace the following line by --> ENO := TRUE;\n\t    ENO := NOT #statError;\n\t  END_REGION Write static values to outputs\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
