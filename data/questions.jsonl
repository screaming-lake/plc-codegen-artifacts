{"title": "Double Word Edge Detection", "description": "Write a function block (FB) that checks each cycle for rising and falling edges in each bit of a double word (DWord) input value. The function block should be able to detect and report changes, rising edges, and falling edges in the input value.\n\nExample:\nAssume the input value changes from 2#101 to 2#11011. The number of rising edges is 3, and the bit stream of rising edges is 2#11010. The number of falling edges is 1, and the bit stream of falling edges is 2#100.", "type": "FUNCTION_BLOCK", "name": "GetBitStates", "input": [{"name": "value", "type": "DWord", "description": "Input value to be checked for changes and edge triggers"}], "output": [{"name": "hasChanged", "type": "Bool", "description": "True indicates that the input value has changed"}, {"name": "hasRisingEdges", "type": "Bool", "description": "True indicates that a rising edge has occurred in the input value"}, {"name": "risingBits", "type": "DWord", "description": "Bit stream of rising edges, where each bit indicates whether a rising edge occurred at the corresponding position in the input value (1 for rising edge, 0 for no rising edge)"}, {"name": "noOfRisingBits", "type": "USInt", "description": "Number of rising edges in the input value"}, {"name": "hasFallingEdges", "type": "Bool", "description": "True indicates that a falling edge has occurred in the input value"}, {"name": "fallingBits", "type": "DWord", "description": "Bit stream of falling edges, where each bit indicates whether a falling edge occurred at the corresponding position in the input value (1 for falling edge, 0 for no falling edge)"}, {"name": "noOfFallingBits", "type": "USInt", "description": "Number of falling edges in the input value"}], "answer": "FUNCTION_BLOCK \"GetBitStates\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      value : DWord;\n   END_VAR\n\n   VAR_OUTPUT \n      hasChanged  : Bool;\n      hasRisingEdges : Bool;\n      risingBits  : DWord;\n      noOfRisingBits  : USInt;\n      hasFallingEdges  : Bool;\n      fallingBits  : DWord;\n      noOfFallingBits  : USInt;\n   END_VAR\n\n   VAR \n      statPreviousValue  : DWord;\n   END_VAR\n\n   VAR_TEMP \n      tempRisingResult : DWord;\n      tempNoRisingBits : DWord;\n      tempFallingResult : DWord;\n      tempNoFallingBits : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_EDGES : DWord;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //============================================================================\n\t  // Title:            GetBitStates\n\t  // Comment/Function: Check DWord for edges, falling as well as rising.  \n\t  //                   Returns the number of edges, DWords with edge bits and a bool if edge(s) exists.\n\t  //                   https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n\t\n\t  //=============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION PROGRAM LOGIC\n\t  // Get edges from input DWord and DWord from previous cycle\n\t  #tempRisingResult := #value AND NOT #statPreviousValue;\n\t  #tempFallingResult := NOT #value AND #statPreviousValue;\n\t  \n\t  // Store value for next cycle\n\t  #statPreviousValue := #value;\n\t  \n\t  // Copy edge result into work variable for counting the number of rising edges\n\t  #tempNoRisingBits := #tempRisingResult;\n\t  // Count number of rising edges, algorythm descriped from: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n\t  #tempNoRisingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoRisingBits) - DWORD_TO_UDINT(SHR(IN := #tempNoRisingBits, N := 1) AND 16#55555555));\n\t  #tempNoRisingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoRisingBits & 16#33333333) + DWORD_TO_UDINT(SHR(IN := #tempNoRisingBits, N := 2) AND 16#33333333));\n\t  #tempNoRisingBits := SHR(IN := UDINT_TO_DWORD(DWORD_TO_UDINT(UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoRisingBits) + DWORD_TO_UDINT(SHR(IN := #tempNoRisingBits, N := 4))) AND 16#0F0F0F0F) * DWORD_TO_UDINT(16#01010101)), N := 24);\n\t  \n\t  // Copy edges result into work variable for counting the number of falling edges\n\t  #tempNoFallingBits := #tempFallingResult;\n\t  // Count number of falling edges, algorythm descriped from: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n\t  #tempNoFallingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoFallingBits) - DWORD_TO_UDINT(SHR(IN := #tempNoFallingBits, N := 1) AND 16#55555555));\n\t  #tempNoFallingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoFallingBits & 16#33333333) + DWORD_TO_UDINT(SHR(IN := #tempNoFallingBits, N := 2) AND 16#33333333));\n\t  #tempNoFallingBits := SHR(IN := UDINT_TO_DWORD(DWORD_TO_UDINT(UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoFallingBits) + DWORD_TO_UDINT(SHR(IN := #tempNoFallingBits, N := 4))) AND 16#0F0F0F0F) * DWORD_TO_UDINT(16#01010101)), N := 24);\n\tEND_REGION PROGRAM LOGIC\n\t\n\tREGION OUTPUTS\n\t  #hasChanged := (#tempRisingResult > #ZERO_EDGES) OR (#tempFallingResult > #ZERO_EDGES);\n\t  #hasRisingEdges := #tempRisingResult > #ZERO_EDGES;\n\t  #risingBits := #tempRisingResult;\n\t  #noOfRisingBits := DWORD_TO_USINT(#tempNoRisingBits);\n\t  \n\t  #hasFallingEdges := #tempFallingResult > #ZERO_EDGES;\n\t  #fallingBits := #tempFallingResult;\n\t  #noOfFallingBits := DWORD_TO_USINT(#tempNoFallingBits);\n\t  \n\t  // ENO not needed, no error evaluation needed\n\t  ENO := FALSE;\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK\n\n", "in/out": [], "return_value": []}
{"title": "Convert DTL DateTime to String", "description": "Write a function (FC) that converts a date-time value of type DTL to a string and outputs it using a custom separator. The converted string format should be YYYY<separator>MM<separator>DD<separator>HH:mm:ss.nnnnnnnn, where <separator> is the character specified by the function parameter. Note that the separator should not be applied between hours, minutes, seconds, and nanoseconds.\n\nExample:\nAssume the input DTL date-time is 2023-09-17 12:34:56.123456789 and the custom separator is '-'.\nThe function should return the string \"2023-09-17 12:34:56.123456789\" as the conversion result.", "type": "FUNCTION", "name": "DTLToString_ISO", "input": [{"name": "date", "type": "DTL", "description": "Date of type DTL"}, {"name": "separator", "type": "Char", "description": "Separator used between year and month, and month and day in the converted date"}], "return_value": [{"type": "String", "description": "Converted date string"}], "answer": "FUNCTION \"DTLToString_ISO\" : String\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      \"date\"  : DTL;\n      separator : Char;\n   END_VAR\n\n   VAR_TEMP \n      tempString : String;\n      tempIndex : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      CONVERT_SIZE_YEAR : USInt := 4;\n      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;\n      CONVERT_SIZE_NANOSECOND : USInt := 9;\n      CONVERT_PRECISION : USInt := 0;\n      CONVERT_FORMAT_TO_STRING : Word := 16#0000;\n      CONVERT_START_POSITION_YEAR : UInt := 1;\n      CONVERT_START_POSITION_MONTH : UInt := 6;\n      CONVERT_START_POSITION_DAY : UInt := 9;\n      CONVERT_START_POSITION_HOUR : UInt := 12;\n      CONVERT_START_POSITION_MINUTE : UInt := 15;\n      CONVERT_START_POSITION_SECOND : UInt := 18;\n      CONVERT_START_POSITION_NANOSECOND : UInt := 21;\n      SEPARATOR_POSITION_YEAR_MONTH : UInt := 5;\n      SEPARATOR_POSITION_MONTH_DAY : UInt := 8;\n      SEPARATOR_POSITION_HOUR_MINUTE : UInt := 14;\n      SEPARATOR_POSITION_MINUTE_SECOND : UInt := 17;\n      SEPARATOR_POSITION_SECOND_NANOSECOND : UInt := 20;\n      SEPARATOR_NANOSECOND : Char := '.';\n      SEPARATOR_TIME : Char := ':';\n      SEPARATOR_DATE : Char := '-';\n      REPLACE_NANOSECOND_COUNT : DInt := 8;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Title:            DTLtoString_ISO\n\t  // Comment/Function: This function converts a date of data type DTL into a character string of data type STRING in international format (YYYY MM DD…).\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION\n\t  #tempString := '';\n\tEND_REGION\n\t\n\tREGION CONVERTER\n\t  // Set format parameters for output string\n\t  // International ISO 8601\n\t  // DTL  | Y| Y| Y| Y| -| M| M| -| D| D|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS\n\t  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--\n\t  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29\n\t  \n\t  // Convert \"Value\" into \"String\" and place at the right position\n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.YEAR,\n\t           P      := #CONVERT_START_POSITION_YEAR,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_YEAR,\n\t           OUT    => #tempString);    // DTL YEAR --> String --> #tempPosYear\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.MONTH,\n\t           P      := #CONVERT_START_POSITION_MONTH,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL MONTH --> String --> #tempPosMonth\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.DAY,\n\t           P      := #CONVERT_START_POSITION_DAY,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL DAY --> String --> #tempPosDay\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.HOUR,\n\t           P      := #CONVERT_START_POSITION_HOUR,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL HOUR --> String --> #tempPosHour\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.MINUTE,\n\t           P      := #CONVERT_START_POSITION_MINUTE,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL MINUTE --> String --> #tempPosMinute\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.SECOND,\n\t           P      := #CONVERT_START_POSITION_SECOND,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL SECOND --> String --> #tempPosSecond\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.NANOSECOND,\n\t           P      := #CONVERT_START_POSITION_NANOSECOND,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_NANOSECOND,\n\t           OUT    => #tempString);     // DTL NANOSECOND --> String --> #tempPosNanosecond\n\t  \n\t  // Place separators at the right position in the string\n\t  IF #separator = '' THEN\n\t    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #SEPARATOR_DATE;\n\t    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #SEPARATOR_DATE;\n\t  ELSE\n\t    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #separator;\n\t    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #separator;\n\t  END_IF;\n\t  #tempString[#SEPARATOR_POSITION_HOUR_MINUTE] := #SEPARATOR_TIME;\n\t  #tempString[#SEPARATOR_POSITION_MINUTE_SECOND] := #SEPARATOR_TIME;\n\t  #tempString[#SEPARATOR_POSITION_SECOND_NANOSECOND] := #SEPARATOR_NANOSECOND;\n\t  \n\t  // Correcting the string, due to the conversion of a leading \"0\" value into a \"blank\".\n\t  // Replacing of \"blank\" by \"0\"\n\t  IF (#tempString[#CONVERT_START_POSITION_MONTH] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_MONTH] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_DAY] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_DAY] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_HOUR] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_HOUR] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_MINUTE] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_MINUTE] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_SECOND] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_SECOND] := '0';\n\t  END_IF;\n\t  \n\t  FOR #tempIndex := 0 TO #REPLACE_NANOSECOND_COUNT DO\n\t    IF (#tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] = ' ') THEN\n\t      #tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] := '0';\n\t    ELSE\n\t      EXIT;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #DTLToString_ISO := #tempString;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n", "output": [], "in/out": []}
{"title": "Extract Substring from Character Array", "description": "Write a function (FC) that extracts a substring from a character array based on a given starting string and ending string.\n\n1. The function should traverse searchIn to find the first occurrence of textBefore, then find the subsequent occurrence of textAfter.\n2. If both textBefore and textAfter are found, the function should extract the string between these two boundaries (excluding the boundary strings themselves) and return this substring.\n3. If textBefore or textAfter does not exist in searchIn, the function should return a specific status code.\n\nThe status parameter indicates the execution status of the program:\n- 16#0000: Execution successful\n- 16#8200: Input parameter searchIn is not a character array or byte array\n\nThe return value indicates the result of the search:\n- 16#0000: Search successful, both start and end boundaries found\n- 16#9001: Search unsuccessful, only start boundary found, end boundary not found\n- 16#9002: Search unsuccessful, start boundary not found.\n\nExample:\nAssume searchIn is \"This is a [sample] string with [multiple] boundaries.\", textBefore is \"[\", and textAfter is \"]\". The function should return \"sample\" as the extracted substring.", "type": "FUNCTION", "name": "ExtractStringFromCharArray", "input": [{"name": "textBefore", "type": "String", "description": "Starting boundary of the substring to extract"}, {"name": "textAfter", "type": "String", "description": "Ending boundary of the substring to extract"}], "output": [{"name": "extractedString", "type": "String", "description": "Extracted substring"}, {"name": "status", "type": "Word", "description": "Status code, see description"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Character or byte array to search in"}], "return_value": [{"type": "Word", "description": "Status code, see description"}], "answer": "FUNCTION \"ExtractStringFromCharArray\" : Word\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      textBefore : String;\n      textAfter : String;\n   END_VAR\n\n   VAR_OUTPUT \n      extractedString : String;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      searchIn : Variant;\n   END_VAR\n\n   VAR_TEMP \n      tempNumElements : UDInt;\n      tempPosInArray : DInt;\n      tempLenTextBefore : Int;\n      tempPosTextBefore : DInt;\n      tempLenTextAfter : Int;\n      tempPosTextAfter : Int;\n      tempString : String;\n   END_VAR\n\n   VAR CONSTANT \n      LEN_STRING : UInt := 254;\n      STATUS_TEXT_FOUND : Word := 16#0000;\n      WARNING_ONLY_START : Word := 16#9001;\n      WARNING_NOTHING_FOUND : Word := 16#9002;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Title:            ExtractStringFromCharArray\n\t  // Function:         The function extracts a String specified by a text before and after\n\t  //                   from an array of characters.\n\t \n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Initialization\n\t  #tempPosTextBefore := 0;\n\t  #tempPosTextAfter := 0;\n\t  #tempPosInArray := 0;\n\t  #tempLenTextBefore := LEN(#textBefore);\n\t  #tempLenTextAfter := LEN(#textAfter);\n\t  #extractedString := '';\n\t  #status := #STATUS_NO_ERROR;\n\t  #ExtractStringFromCharArray := #WARNING_NOTHING_FOUND;\n\t  \n\t  REGION Validation of inputs\n\t    // check whether the input is an ARRAY and TYPE of elements is CHAR or BYTE\n\t    // IF so, the number OF the ARRAY elements is read out.\n\t    // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t    IF TRUE\n\t      AND IS_ARRAY(#searchIn)\n\t      AND ((TypeOfElements(#searchIn) = Char) OR (TypeOfElements(#searchIn) = Byte))\n\t    THEN\n\t      // Get number of elements\n\t      #tempNumElements := CountOfElements(#searchIn);\n\t    ELSE\n\t      #status := #ERR_NO_ARRAY;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION Validation of inputs\n\tEND_REGION Initialization\n\t\n\tREGION Process\n\t  REPEAT // Search for text before until something was found\n\t    // Convert Chars to String\n\t    Chars_TO_Strg(Chars  := #searchIn,\n\t                  pChars := #tempPosInArray, // Subtract offset since pChars is zero based\n\t                  Cnt    := UDINT_TO_UINT(MIN(IN1 := #LEN_STRING, IN2 := #tempNumElements)),\n\t                  Strg   => #tempString);\n\t    \n\t    // Search for text before\n\t    #tempPosTextBefore := FIND(IN1 := #tempString, IN2 := #textBefore);\n\t    \n\t    // Text before was found\n\t    IF #tempPosTextBefore > 0 THEN\n\t      // Set position in array to end of text before\n\t      #tempPosInArray += #tempPosTextBefore + #tempLenTextBefore - 1;\n\t      \n\t      // Create new string from end of text before\n\t      Chars_TO_Strg(Chars  := #searchIn,\n\t                    pChars := #tempPosInArray, // Subtract offset since pChars is zero based\n\t                    Cnt    := UDINT_TO_UINT(MIN(IN1 := #LEN_STRING, IN2 := #tempNumElements)),\n\t                    Strg   => #tempString);\n\t      \n\t      // Find end of string to be extracted\n\t      #tempPosTextAfter := FIND(IN1 := #tempString, IN2 := #textAfter);\n\t      \n\t      IF #tempPosTextAfter > 0 THEN // Shorten string if text after was found\n\t        #extractedString := LEFT(IN := #tempString, L := #tempPosTextAfter - 1);\n\t        #ExtractStringFromCharArray := #STATUS_TEXT_FOUND;\n\t        EXIT;\n\t        \n\t      ELSE // Output whole string if text after was not found\n\t        #extractedString := #tempString;\n\t        #ExtractStringFromCharArray := #WARNING_ONLY_START;\n\t        EXIT;\n\t      END_IF;\n\t      \n\t    ELSE\n\t      // Otherwise continue search in next string minus length of text before to ensure\n\t      // keywords are not broken up at the end of a string and thus missed\n\t      #tempPosInArray += UINT_TO_INT(#LEN_STRING) - #tempLenTextBefore;\n\t    END_IF;\n\t    \n\t    // Repeat until end of array is reached\n\t  UNTIL (#tempPosInArray > #tempNumElements) END_REPEAT;\n\tEND_REGION Process\n\t\nEND_FUNCTION\n\n"}
{"title": "FIFO First-In-First-Out Queue", "description": "Write a function block (FB) that implements a first-in-first-out (FIFO) circular queue, where both the maximum length and data type of the queue are variable. The circular queue should support the following operations:\n\n1. Enqueue: Add an element to the tail of the queue if the queue is not full.\n2. Dequeue: Remove an element from the head of the queue if the queue is not empty, and return its value.\n3. Check if the queue is empty: Determine whether the queue has no elements.\n4. Check if the queue is full: Determine whether the queue has reached its maximum capacity.\n5. Get the number of elements: Return the current number of elements in the queue.\n\nStatus codes:\n16#0000: FB executed without errors\n16#8001: Queue is empty\n16#8002: Queue is full", "type": "FUNCTION_BLOCK", "name": "FIFO", "input": [{"name": "enqueue", "type": "Bool", "description": "Enqueue operation: Add an element to the tail of the queue if it is not full"}, {"name": "dequeue", "type": "Bool", "description": "Dequeue operation: Remove an element from the head of the queue if it is not empty, and return its value"}, {"name": "reset", "type": "Bool", "description": "Reset operation: Reset head and tail pointers, set elementCount output to zero, and set isEmpty output to TRUE"}, {"name": "clear", "type": "Bool", "description": "Clear operation: Reset head and tail pointers, empty the queue, and initialize it with the initialItem value. Set elementCount output to zero and isEmpty output to TRUE"}, {"name": "initialItem", "type": "Variant", "description": "Value used to initialize the queue"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: no error occurred TRUE: error occurred during FB execution"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the queue"}, {"name": "isEmpty", "type": "Bool", "description": "TRUE indicates the queue is empty"}], "in/out": [{"name": "item", "type": "Variant", "description": "Value used to add to the queue or returned from the queue"}, {"name": "buffer", "type": "Variant", "description": "Array used as the queue"}], "answer": "FUNCTION_BLOCK \"FIFO\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      enqueue : Bool := FALSE;\n      dequeue : Bool := FALSE;\n      reset : Bool;\n      clear : Bool;\n      initialItem : Variant;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n      elementCount : DInt := 0;\n      isEmpty : Bool := FALSE;\n   END_VAR\n\n   VAR_IN_OUT \n      item : Variant;\n      buffer : Variant;\n   END_VAR\n\n   VAR \n      statEdgesMem : Struct\n         enqueue : Bool;\n         dequeue : Bool;\n         clear : Bool;\n      END_STRUCT;\n      statFirstItemIndex : Int := -1;\n      statNextEmptyItemIndex : Int := 0;\n      statElementCount : DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempEdges : Struct\n         enqueue : Bool;\n         dequeue : Bool;\n         clear : Bool;\n      END_STRUCT;\n      tempInternalError : Int;\n      tempNewFirstItemIndex : Int;\n      tempNewNextEmptyItemIndex : Int;\n      tempBufferSize : UDInt;\n      tempCounter : Int;\n   END_VAR\n\n   VAR CONSTANT \n      BUFFER_IS_EMPTY : Int := -1;\n      NO_INTERNAL_ERROR : Int := 0;\n      BUFFER_INITIALIZED : Int := -1;\n      EMPTY_INITIALIZED : Int := 0;\n      INDEX_BEGINNING : Int := 0;\n      COUNT_ELEMENTS : UDInt := 1;\n      INCREMENT : Int := 1;\n      BUFFER_SIZE_CORRECTION : UDInt := 1;\n      COUNTER_LOWER_LIMIT : Int := 0;\n      ZERO_ELEMENTS : DInt := 0;\n      STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_NO_CURRENT_JOBS : Word := 16#7000;\n      ERR_BUFFER_EMPTY : Word := 16#8001;\n      ERR_BUFFER_FULL : Word := 16#8002;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_WRONG_TYPE_ITEM : Word := 16#8201;\n      ERR_WRONG_TYPE_INITIAL_ITEM : Word := 16#8202;\n      ERR_INDEX_IN_ARRAY_LIMITS_1 : Word := 16#8601;\n      ERR_INDEX_IN_ARRAY_LIMITS_2 : Word := 16#8602;\n      ERR_CLEAR_BUFFER : Word := 16#8610;\n      ERR_RETURN_FIRST_ENTRY : Word := 16#8611;\n      ERR_REPLACE_ITEM_BY_INIT_VALUE : Word := 16#8612;\n      ERR_WRITE_ENTRY : Word := 16#8613;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t    //===============================================================================\n\t    // Title:           FIFO\n\t    // Comment/Function: FIFO (First In First Out)\n\t    //                   Queue / ring buffer memory\n\t    \n\t    //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Block execution control\n\t    // collect edges\n\t    #tempEdges.enqueue := #enqueue AND NOT #statEdgesMem.enqueue;\n\t    #tempEdges.dequeue := #dequeue AND NOT #statEdgesMem.dequeue;\n\t    #tempEdges.clear := #clear AND NOT #statEdgesMem.clear;\n\t    // store values for edge detection\n\t    #statEdgesMem.enqueue := #enqueue;\n\t    #statEdgesMem.dequeue := #dequeue;\n\t    #statEdgesMem.clear := #clear;\n\t    \n\t    // This program code section is only executed if no trigger input is active\n\t    IF NOT (#enqueue OR #dequeue OR #reset OR #clear) THEN\n\t        // If an error occurred during program execution,\n\t        // the status \"No Current Job\" is used 16#7000 afterwarts when the triggers are reseted\n\t        #error := false;\n\t        #status := #STATUS_NO_CURRENT_JOBS;\n\t        \n\t        // the program processing OF the FB is terminated\n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Validation of inputs\n\t    // check whether the ring #buffer is an ARRAY.\n\t    // IF so, the number OF the ARRAY elements is read out.\n\t    // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t    IF IS_ARRAY(#buffer) THEN\n\t        #tempBufferSize := CountOfElements(#buffer);\n\t    ELSE\n\t        #error := true;\n\t        #status := #ERR_NO_ARRAY;\n\t        \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // check whether the data type OF the ARRAY elements matches\n\t    // the data type OF the entry (#item). IF the data types DO NOT match,\n\t    // the program execution is terminated at this point\n\t    IF (TypeOf(#item) <> TypeOfElements(#buffer)) THEN\n\t        #error := true;\n\t        #status := #ERR_WRONG_TYPE_ITEM;\n\t       \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // check whether the initial value OF the ring #buffer\n\t    // matches the entry (tag #item). IF the data types DO NOT match,\n\t    // the program execution is terminated at this point\n\t    IF (TypeOf(#item) <> TypeOf(#initialItem)) THEN\n\t        #error := true;\n\t        #status := #ERR_WRONG_TYPE_INITIAL_ITEM;\n\t       \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // check whether the variable indices are within the ARRAY limits.\n\t    // IF they are NOT, the program execution is terminated at this point\n\t    IF (#statNextEmptyItemIndex >= #tempBufferSize) THEN\n\t        #error := true;\n\t        #status := #ERR_INDEX_IN_ARRAY_LIMITS_1;\n\t        \n\t        RETURN;\n\t    ELSIF (#statFirstItemIndex >= #tempBufferSize) THEN\n\t        #error := true;\n\t        #status := #ERR_INDEX_IN_ARRAY_LIMITS_2;\n\t       \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // If resetBuffer is \"TRUE\", the buffer counters are reset\n\t    IF #reset THEN\n\t        #statFirstItemIndex := #BUFFER_INITIALIZED;\n\t        #statNextEmptyItemIndex := #EMPTY_INITIALIZED;\n\t        #statElementCount := #EMPTY_INITIALIZED;\n\t        #elementCount := #EMPTY_INITIALIZED;\n\t        #isEmpty := true;\n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // If clearBuffer has rising edge, the buffer is initialized by initial values\n\t    IF #tempEdges.clear THEN\n\t        FOR #tempCounter := #COUNTER_LOWER_LIMIT TO UDINT_TO_INT(#tempBufferSize - #BUFFER_SIZE_CORRECTION) DO\n\t            \n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #tempCounter,\n\t                                                   DEST => #buffer);\n\t        END_FOR;\n\t        \n\t        // checks whether a local error has occurred.\n\t        IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t            #error := true;\n\t            #status := #ERR_CLEAR_BUFFER;\n\t           \n\t        END_IF;\n\t        \n\t        // reset counters\n\t        #statFirstItemIndex := #BUFFER_INITIALIZED;\n\t        #statNextEmptyItemIndex := #EMPTY_INITIALIZED;\n\t        #statElementCount := #EMPTY_INITIALIZED;\n\t        #elementCount := #EMPTY_INITIALIZED;\n\t        #isEmpty := true;\n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION FIFO algorithm  \n\t    IF #tempEdges.dequeue THEN\n\t        REGION dequeue\n\t            // check whether the ring #buffer is empty\n\t            // IF this is the CASE, program execution is terminated at this point\n\t            IF (#statFirstItemIndex = #BUFFER_IS_EMPTY) THEN\n\t                #error := true;\n\t                #status := #ERR_BUFFER_EMPTY;\n\t               \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // return the first entry of the ring buffer\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #buffer,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #statFirstItemIndex,\n\t                                                   DEST_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST => #item);\n\t            \n\t            // check whether a local error has occurred\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                #error := true;\n\t                #status := #ERR_RETURN_FIRST_ENTRY;\n\t               \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // check whether the ring #buffer contains ARRAY elements\n\t            // IF it does, the first entry is passed further on and the index is incremented BY 1\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #statFirstItemIndex,\n\t                                                   DEST => #buffer);\n\t            \n\t            // check whether a local error has occurred\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                #error := true;\n\t                #status := #ERR_REPLACE_ITEM_BY_INIT_VALUE;\n\t                \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // calculate the new index of the first entry\n\t            #tempNewFirstItemIndex := #statFirstItemIndex + #INCREMENT;\n\t            #tempNewFirstItemIndex := #tempNewFirstItemIndex MOD UDINT_TO_INT(#tempBufferSize);\n\t            \n\t            // check whether the ring buffer is empty\n\t            IF (#statNextEmptyItemIndex = #tempNewFirstItemIndex) THEN\n\t                // If the ring buffer is empty, the index is set to 0\n\t                #statFirstItemIndex := #BUFFER_INITIALIZED;\n\t                #statNextEmptyItemIndex := #EMPTY_INITIALIZED;\n\t            ELSE\n\t                // The index of the first entry is changed\n\t                #statFirstItemIndex := #tempNewFirstItemIndex;\n\t            END_IF;\n\t            \n\t            // Evaluation of the number of elements in the stack\n\t            #statElementCount -= #INCREMENT;\n\t            \n\t        END_REGION dequeue\n\t        \n\t    ELSIF #tempEdges.enqueue THEN\n\t        REGION enqueue\n\t            // check whether the ring #buffer is full\n\t            // IF this is the CASE, program execution is terminated at this point\n\t            IF (#statNextEmptyItemIndex = #statFirstItemIndex) THEN\n\t                #error := true;\n\t                #status := #ERR_BUFFER_FULL;\n\t             \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // write the entry to the ring buffer\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #item,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #statNextEmptyItemIndex,\n\t                                                   DEST => #buffer);\n\t            \n\t            // check whether a local error has occurred\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                #error := true;\n\t                #status := #ERR_WRITE_ENTRY;\n\t             \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // increment the index by 1 and calculates the new empty entry index\n\t            #tempNewNextEmptyItemIndex := (#statNextEmptyItemIndex + #INCREMENT) MOD UDINT_TO_INT(#tempBufferSize);\n\t            #statNextEmptyItemIndex := #tempNewNextEmptyItemIndex;\n\t            \n\t            // check which index the \"#firstItemIndex\" tag has\n\t            // IF the number = -1, the ring buffer is initialized\n\t            // AND the entry is written TO the ring #buffer\n\t            // Therefore, \"0\" must be assigned TO the tag\n\t            IF (#statFirstItemIndex = #BUFFER_INITIALIZED) THEN\n\t                #statFirstItemIndex := #INDEX_BEGINNING;\n\t            END_IF;\n\t            \n\t            // Evaluation of the number of elements in the stack\n\t            #statElementCount += #INCREMENT;\n\t        END_REGION enqueue\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t    #elementCount := #statElementCount;\n\t    #isEmpty := #statElementCount <= #ZERO_ELEMENTS;\n\t    \n\t    #error := false;\n\t    #status := #STATUS_NO_ERROR;\n\t \n\t    // no error handling by ENO needed\n\t    ENO := TRUE;\n\tEND_REGION\n\t\n\t\nEND_FUNCTION_BLOCK\n\n", "return_value": []}
{"title": "Calculate Moving Average", "description": "Write a function block (FB) that calculates and updates a moving arithmetic average. A moving arithmetic average computes the average over consecutive data points, where each new data point replaces the oldest one, and the average is recalculated.\n\n1. When cyclicExecution is TRUE, a new value is read and the moving average is updated automatically every scan cycle.\n2. An external trigger signal is provided. When a rising edge occurs on trigger, a new value is immediately read and the moving average is updated.\n3. A reset function is provided. When the reset signal is TRUE, the moving average calculation is reset. If the window size is less than 1 or greater than 100, an error status and status code are output.\n\nThe status parameter indicates the execution status of the program:\n- 16#0000: Execution successful\n- 16#8200: Window length error, please set a value between 1 and 100.", "type": "FUNCTION_BLOCK", "name": "FloatingAverage", "input": [{"name": "cyclicExecution", "type": "Bool", "description": "When TRUE, reads values periodically; trigger has no effect"}, {"name": "trigger", "type": "Bool", "description": "External trigger signal; reads value on each rising edge"}, {"name": "value", "type": "LReal", "description": "New data value to read"}, {"name": "windowSize", "type": "Int", "description": "Window size of the moving average; must be between 1 and 100"}, {"name": "reset", "type": "Bool", "description": "Reset signal; when TRUE, resets the moving average calculation"}], "output": [{"name": "average", "type": "LReal", "description": "Moving average"}, {"name": "windowSizeReached", "type": "Bool", "description": "FALSE: maximum window width not yet reached TRUE: maximum window width reached"}, {"name": "error", "type": "Bool", "description": "FALSE: no error occurred TRUE: error occurred during FB execution"}, {"name": "status", "type": "Word", "description": "Status code"}], "answer": "FUNCTION_BLOCK \"FloatingAverage\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      cyclicExecution : Bool := false;\n      trigger : Bool;\n      value : LReal;\n      windowSize : Int := 100;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      average  : LReal;\n      windowSizeReached  : Bool;\n      error  : Bool;\n      status  : Word;\n   END_VAR\n\n   VAR \n      statValues  : Array[#ZERO_INT..#MAX_WINDOW_SIZE] of LReal;\n      statValuesSum  : LReal := 0.0;\n      statArithmeticAverage  : LReal := 0.0;\n      statWindowSizeOld  : Int := 0;\n      statCounter  : Int := 0;\n      statwindowSizeReached  : Bool;\n      statTriggerOld  : Bool := false;\n   END_VAR\n\n   VAR_TEMP \n      tempValue : LReal;\n      tempIndex : Int;\n      tempTriggerEdge : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_INT : Int := 0;\n      ZERO_LREAL : LReal := 0.0;\n      MAX_WINDOW_SIZE : Int := 100;\n      INCREMENT : Int := 1;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_WRONG_WINDOW_SIZE : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // Title:            FloatingAverage\n\t  // Comment/Function: This function block calculates the floating arithmetic average\n\t  //                   of incoming REAL values each cycle or each trigger impulse.\n\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and input data processing\n\t  // Copy commonly used data to temp variables\n\t  #tempValue := #value;\n\t  \n\t  // Positive edge detection for triggering of calculation\n\t  #tempTriggerEdge := #trigger AND NOT #statTriggerOld;\n\t  #statTriggerOld := #trigger;\n\t  \n\t  // Reset OR if window size changes the calculation\n\t  IF #reset OR (#windowSize <> #statWindowSizeOld) THEN\n\t    #statWindowSizeOld := #windowSize;\n\t    #statCounter := #ZERO_INT;\n\t    #statValuesSum := #ZERO_LREAL;\n\t    #statArithmeticAverage := #ZERO_LREAL;\n\t    #average := #ZERO_LREAL;\n\t    #windowSizeReached := FALSE;\n\t    #statwindowSizeReached := FALSE;\n\t    #error := false;\n\t    #status := #STATUS_FINISHED_NO_ERROR;\n\t    RETURN;\n\t    \n\t    // Check window size, in case of incorrect window size setup an error\n\t  ELSIF (#windowSize <= #ZERO_INT) OR (#windowSize > #MAX_WINDOW_SIZE) THEN\n\t    #statWindowSizeOld := #windowSize;\n\t    #statCounter := #ZERO_INT;\n\t    #statValuesSum := #ZERO_LREAL;\n\t    #statArithmeticAverage := #ZERO_LREAL;\n\t    #average := #ZERO_LREAL;\n\t    #statwindowSizeReached := FALSE;\n\t    #windowSizeReached := FALSE;\n\t    #error := TRUE;\n\t    #status := #ERR_WRONG_WINDOW_SIZE; // Info \"No correct set of window size\"\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Floating average calculation\n\t  // Triggered calculation OR cyclicly operation\n\t  IF #cyclicExecution OR #tempTriggerEdge THEN\n\t    \n\t    //Calculate array counter by using modulo\n\t    #tempIndex := #statCounter MOD #windowSize;\n\t    \n\t    // First step - fill the Array with values\n\t    // as long as desired window size is not reached\n\t    // counter and array starts with zero\n\t    IF (#statCounter < #windowSize) THEN\n\t      // Add value to sum\n\t      #statValuesSum += #tempValue;\n\t      // Add value to window\n\t      #statValues[#tempIndex] := #tempValue;\n\t      // Increment counter\n\t      #statCounter += #INCREMENT;\n\t      // Calculate avarage value\n\t      #statArithmeticAverage := #statValuesSum / #statCounter;\n\t      \n\t    ELSE\n\t      // wuindow size is reached, set output\n\t      #statwindowSizeReached := TRUE;\n\t      // Add value to sum\n\t      #statValuesSum += #tempValue - #statValues[#tempIndex];\n\t      // Add value to window\n\t      #statValues[#tempIndex] := #tempValue;\n\t      // Calculate avarage value\n\t      #statArithmeticAverage := #statValuesSum / #windowSize;\n\t      \n\t      // Manipulate counter value of window if modulo calc result is zero\n\t      IF (#tempIndex = #ZERO_INT) THEN\n\t        #statCounter := #windowSize + #INCREMENT;\n\t      ELSE\n\t        // Increment counter\n\t        #statCounter += #INCREMENT;\n\t      END_IF;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Outputs\n\t  #average := #statArithmeticAverage;\n\t  #windowSizeReached := #statwindowSizeReached;\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  \n\t  // ENO mechanism is not used - forced to true\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n\n", "in/out": [], "return_value": []}
{"title": "Integration Function", "description": "Write a function block (FB) that performs integration of an input signal, with start and reset functionalities. Integration accumulates the input signal over time, typically used to calculate cumulative quantities such as flow or displacement. The start function begins the integration calculation, while the reset function sets the integral value back to zero.\nIf reading the system time fails, an error status and error code are output.\nStatus codes:\n16#0000: FB executed without errors\n16#8600: Error reading system time", "type": "FUNCTION_BLOCK", "name": "Integration", "input": [{"name": "enable", "type": "Bool", "description": "Start signal; when TRUE, integration calculation is enabled. If FALSE, integration stops, and the integral output retains the last computed value"}, {"name": "value", "type": "LReal", "description": "Input signal value to integrate"}, {"name": "reset", "type": "Bool", "description": "Reset signal; when TRUE, resets the integral value to zero"}], "output": [{"name": "integral", "type": "LReal", "description": "Integral value"}, {"name": "error", "type": "Bool", "description": "FALSE: no error occurred; TRUE: error occurred during FB execution"}, {"name": "status", "type": "Word", "description": "Status code"}], "answer": "FUNCTION_BLOCK \"Integration\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      enable : Bool;\n      value : LReal;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      integral : LReal;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR \n      statLastTime  : DTL;\n      statInputOldValue : LReal;\n      statIntegral : LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempSysTime  : DTL;\n      tempTimeDiffrence : LReal;\n      tempCalculation : LReal;\n      tempRetval : Word;\n   END_VAR\n\n   VAR CONSTANT \n      CLEAR_TIME  : DTL;\n      SECOND_IN_MS : LReal := 1000.0;\n      DIVIDE_BY_TWO : LReal := 2.0;\n      ZERO : LReal := 0.0;\n      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      ERR_READ_SYS_TIME : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t    //============================================================================\n\t    // Title:            Integration\n\t    // Comment/Function: Integrates the input value\n\t    //                   integration by trapezoidal rule\n\t    \n\t    //=============================================================================\n\tEND_REGION Block info header\n\t\n\t//Reset region must be before the enable region so that even if the function disabled, the user can reset the values.\n\tREGION Reset the function\n\t    IF #reset THEN\n\t        #statInputOldValue := #ZERO;\n\t        #statIntegral := #ZERO;\n\t        \n\t        // Clear LastTime value.\n\t        // Initial condition - first Delta time will be 0.\n\t        #statLastTime := #CLEAR_TIME;\n\t        \n\t        #integral := #ZERO;\n\t        #error := false;\n\t        #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t        \n\t        RETURN;\n\t    END_IF;\n\tEND_REGION Reset the function\n\t\n\tREGION Enable/Disable integral calculation\n\t    IF NOT #enable THEN\n\t        #statInputOldValue := #ZERO;\n\t        \n\t        // Clear LastTime value.\n\t        // If it is not cleared when the function is enabled again,\n\t        // the first value will be multiplied with the time difference of the whole disable time\n\t        // Initial condition - first Delta time will be 0.\n\t        #statLastTime := #CLEAR_TIME;\n\t        \n\t        #integral := #statIntegral;\n\t        #error := false;\n\t        #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t        \n\t        RETURN;\n\t    END_IF;\n\tEND_REGION Enable/Disable integral calculation\n\t\n\tREGION Get system time\n\t    // Read system time\n\t    #tempRetval := INT_TO_WORD(RD_SYS_T(OUT => #tempSysTime));\n\t    \n\t    // Error Handling read system time\n\t    IF (#tempRetval > #SUB_STATUS_NO_ERROR) THEN\n\t        #integral := #statIntegral;\n\t        #error := TRUE;\n\t        #status := #ERR_READ_SYS_TIME;\n\t       \n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating the integral\n\t    // Calculate time difference between last and actual time\n\t    // coverting from DTL via time and DInt to Real\n\t    // scale from millisecond to second\n\t    #tempTimeDiffrence := DINT_TO_REAL(TIME_TO_DINT(T_DIFF(IN1 := #tempSysTime, IN2 := #statLastTime))) / #SECOND_IN_MS;\n\t    \n\t    // Write actual to last time\n\t    #statLastTime := #tempSysTime;\n\t    \n\t    // integration by trapezoidal rule\n\t    // add LastScalIn to ScalIn\n\t    // divide by two --> avarage of both - old and actual value\n\t    // multiply with time delta --> area unterneath the both borders\n\t    #tempCalculation := (#value + #statInputOldValue) * #tempTimeDiffrence / #DIVIDE_BY_TWO;\n\t    \n\t    // Calculate new integral\n\t    #statIntegral += #tempCalculation;\n\t    \n\t    // Save last input\n\t    #statInputOldValue := #value;\n\tEND_REGION Calculating the integral\n\t\n\tREGION Write outputs\n\t    #integral := #statIntegral;\n\t    #error := false;\n\t    #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t    \n\t    \n\t    //ENO mechanism is not used\n\t    ENO := TRUE;\n\tEND_REGION Write outputs\n\t\nEND_FUNCTION_BLOCK\n\n", "in/out": [], "return_value": []}
{"title": "Lamp Control Program", "description": "Write a function block (FB) that implements a lamp control function.\nA control panel has three indicator lamps, controlled by three button switches.\n\n1. Input parameters #button1 to #button3 represent the three buttons; output parameters #greenLight, #redLight, and #yellowLight represent the indicator lamps.\n2. When #button1=0 (manual mode), the indicator lamps display different states based on the combination of #button2 and #button3:\n - When #button2 and #button3 are both 0, all indicator lamps are off (#greenLight, #redLight, #yellowLight all 0).\n - When #button2=1 and #button3=0, #greenLight is on continuously, and #redLight flashes at 0.5 Hz (1 second off, 1 second on).\n - When #button2=0 and #button3=1, #redLight is on continuously, and #yellowLight flashes at 1 Hz (1 second off, 1 second on).\n - When #button2 and #button3 are both 1, #yellowLight is on continuously, and #greenLight flashes at 1 Hz (1 second off, 1 second on).\n3. When #button1=1 (automatic mode), the indicator lamps cycle automatically as follows:\n - First, #greenLight is on for 1 second.\n - Then #greenLight off, #redLight on for 1 second.\n - Then #redLight off, #yellowLight on for 1 second.\n - Then return to the initial state (#greenLight on for 1 second), and repeat the cycle.", "type": "FUNCTION_BLOCK", "name": "LightsControl", "input": [{"name": "button1", "type": "Bool", "description": "Button 1"}, {"name": "button2", "type": "Bool", "description": "Button 2"}, {"name": "button3", "type": "Bool", "description": "Button 3"}], "output": [{"name": "greenLight", "type": "Bool", "description": "Green light"}, {"name": "redLight", "type": "Bool", "description": "Red light"}, {"name": "yellowLight", "type": "Bool", "description": "Yellow light"}], "answer": "FUNCTION_BLOCK \"LightsControl\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      button1 : Bool;\n      button2 : Bool;\n      button3 : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      greenLight : Bool;\n      redLight : Bool;\n      yellowLight : Bool;\n   END_VAR\n\n   VAR \n      CycleStep : Int := 0;\n      ManModeTimer1 : TON_TIME;\n      ManModeTimer2 : TON_TIME;\n      AutoModeTimer : TON_TIME;\n   END_VAR\n\n\nBEGIN\n\t    IF #button1 = FALSE THEN\n\t        #ManModeTimer1(IN := #ManModeTimer2.Q,\n\t                       PT := t#1s);\n\t        #ManModeTimer2(IN := NOT #ManModeTimer1.Q,\n\t                       PT := t#1s);\n\t        IF #button2 AND NOT #button3 THEN\n\t            #greenLight := TRUE;\n\t            #redLight := #ManModeTimer2.Q;\n\t            #yellowLight := FALSE;\n\t        ELSIF NOT #button2 AND #button3 THEN\n\t            #redLight := TRUE;\n\t            #yellowLight := #ManModeTimer2.Q;\n\t            #greenLight := FALSE;\n\t        ELSIF #button2 AND #button3 THEN\n\t            #yellowLight := TRUE;\n\t            #greenLight := #ManModeTimer2.Q;\n\t            #redLight := FALSE;\n\t        ELSE\n\t            #greenLight := FALSE;\n\t            #redLight := FALSE;\n\t            #yellowLight := FALSE;\n\t        END_IF;\n\t        \n\t    ELSE\n\t        #AutoModeTimer(IN := TRUE,\n\t                       PT := T#1s);\n\t        CASE #CycleStep OF\n\t            0:\n\t                #greenLight := TRUE;\n\t                #redLight := FALSE;\n\t                #yellowLight := FALSE;\n\t                IF #AutoModeTimer.Q THEN\n\t                    #CycleStep := 1;\n\t                    #AutoModeTimer(IN := FALSE,\n\t                                   PT := T#1s);\n\t                END_IF;\n\t            1:\n\t                #greenLight := FALSE;\n\t                #redLight := TRUE;\n\t                #yellowLight := FALSE;\n\t                \n\t                IF #AutoModeTimer.Q THEN\n\t                    #CycleStep := 2;\n\t                    #AutoModeTimer(IN := FALSE,\n\t                                   PT := T#1s);\n\t                END_IF;\n\t            2:\n\t                #greenLight := FALSE;\n\t                #redLight := FALSE;\n\t                #yellowLight := TRUE;\n\t                \n\t                IF #AutoModeTimer.Q THEN\n\t                    #CycleStep := 0;\n\t                    #AutoModeTimer(IN := FALSE,\n\t                                   PT := T#1s);\n\t                END_IF;\n\t        END_CASE;\n\t    END_IF;\nEND_FUNCTION_BLOCK\n\n", "in/out": [], "return_value": []}
{"title": "Matrix Addition", "description": "Write a function (FC) that performs addition of two matrices.\n\nThe function accepts two variable-sized two-dimensional floating-point arrays, matrix1 and matrix2, as input parameters. The function should check whether the two input matrices and the output matrix used to return the result have the same number of rows and columns. If they do not match, the function should return an error status and a specific error code.\n\nStatus codes:\n16#0000: FB executed without errors\n16#8200: Lower bound of matrix1 rows differs from matrix2 rows\n16#8201: Lower bound of matrix1 rows differs from result matrix rows\n16#8202: Lower bound of matrix1 columns differs from matrix2 columns\n16#8203: Lower bound of matrix1 columns differs from result matrix columns\n16#8204: Upper bound of matrix1 rows differs from matrix2 rows\n16#8205: Upper bound of matrix1 rows differs from result matrix rows\n16#8206: Upper bound of matrix1 columns differs from matrix2 columns\n16#8207: Upper bound of matrix1 columns differs from result matrix columns", "type": "FUNCTION", "name": "MatrixAddition", "input": [{"name": "matrix1", "type": "Array[*, ] of LReal", "description": "First matrix"}, {"name": "matrix2", "type": "Array[, ] of LReal", "description": "Second matrix"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: no error occurred; TRUE: error occurred during FB execution"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrixResult", "type": "Array[, *] of LReal", "description": "Matrix to store the result of the calculation"}], "answer": "FUNCTION \"MatrixAddition\" : Void\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      matrix1 : Array[*, *] of LReal;\n      matrix2 : Array[*, *] of LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      matrixResult : Array[*, *] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempMatrix1LowerBoundRows : DInt;\n      tempMatrix1LowerBoundColumns : DInt;\n      tempMatrix1UpperBoundRows : DInt;\n      tempMatrix1UpperBoundColumns : DInt;\n      tempMatrix2LowerBoundRows : DInt;\n      tempMatrix2LowerBoundColumns : DInt;\n      tempMatrix2UpperBoundRows : DInt;\n      tempMatrix2UpperBoundColumns : DInt;\n      tempResultMatrixLowerBoundRows : DInt;\n      tempResultMatrixLowerBoundColumns : DInt;\n      tempResultMatrixUpperBoundRows : DInt;\n      tempResultMatrixUpperBoundColumns : DInt;\n      tempCounterRows : DInt;\n      tempCounterColumns : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ROWS : UInt := 1;\n      COLUMNS : UInt := 2;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS : Word := 16#8200;\n      ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS : Word := 16#8201;\n      ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS : Word := 16#8202;\n      ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS : Word := 16#8203;\n      ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS : Word := 16#8204;\n      ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS : Word := 16#8205;\n      ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS : Word := 16#8206;\n      ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS : Word := 16#8207;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            MatrixAddition\n\t  // Comment/Function: Caluclates the sum of two matrices\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Getting matrices size\n\t  //Determine the size of the matrices\n\t  // Lower bound rows\n\t  #tempMatrix1LowerBoundRows := LOWER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2LowerBoundRows := LOWER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  #tempResultMatrixLowerBoundRows := LOWER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Lower bound columns\n\t  #tempMatrix1LowerBoundColumns := LOWER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2LowerBoundColumns := LOWER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\t  #tempResultMatrixLowerBoundColumns := LOWER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\t  \n\t  // Upper bound rows\n\t  #tempMatrix1UpperBoundRows := UPPER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2UpperBoundRows := UPPER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  #tempResultMatrixUpperBoundRows := UPPER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Upper bound columns\n\t  #tempMatrix1UpperBoundColumns := UPPER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2UpperBoundColumns := UPPER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\t  #tempResultMatrixUpperBoundColumns := UPPER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\tEND_REGION\n\t\n\tREGION Error evaluation of matrixes dimentions\n\t  //Check the lower bound of all matrices\n\t  IF (#tempMatrix1LowerBoundRows <> #tempMatrix2LowerBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundRows <> #tempResultMatrixLowerBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundColumns <> #tempMatrix2LowerBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundColumns <> #tempResultMatrixLowerBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS;\n\t    RETURN;\n\t  END_IF;\n\t  //Check the upper bound of all matrices\n\t  IF (#tempMatrix1UpperBoundRows <> #tempMatrix2UpperBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundRows <> #tempResultMatrixUpperBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundColumns <> #tempMatrix2UpperBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundColumns <> #tempResultMatrixUpperBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Addition of the matrices and writting to output\n\t  FOR #tempCounterRows := #tempMatrix1LowerBoundRows TO #tempMatrix1UpperBoundRows DO\n\t    FOR #tempCounterColumns := #tempMatrix1LowerBoundColumns TO #tempMatrix1UpperBoundColumns DO\n\t      #matrixResult[#tempCounterRows, #tempCounterColumns] := #matrix1[#tempCounterRows, #tempCounterColumns] + #matrix2[#tempCounterRows, #tempCounterColumns];\n\t    END_FOR;\n\t  END_FOR;\n\t  \n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n", "return_value": []}
{"title": "Random Number", "description": "Write a function (FC) that generates a random integer within a specified range using the PLC's clock value.\nIf the specified range is invalid or reading the system time fails, an error status and error code are output.\n\nStatus codes:\n16#0000: FB executed without errors\n16#8200: Invalid range: minValue greater than maxValue\n16#8600: Error reading system time", "type": "FUNCTION", "name": "RandomRange_DInt", "input": [{"name": "minValue", "type": "DInt", "description": "Minimum value of the random number range"}, {"name": "maxValue", "type": "DInt", "description": "Maximum value of the random number range"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: no error occurred; TRUE: error occurred during FB execution"}, {"name": "status", "type": "Word", "description": "Status code"}], "return_value": [{"type": "DInt", "description": "Generated random number"}], "answer": "FUNCTION \"RandomRange_DInt\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      minValue : DInt;\n      maxValue : DInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTime  : DTL;\n      tempNanoSecondInDWord : DWord;\n      tempTimeStatus : Word;\n      tempRandomValue : DWord;\n      tempNormReal : Real;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : DInt := 0;\n      MAX_UDINT : UDInt := 4_294_967_295;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_MAX_LESS_MIN : Word := 16#8200;\n      ERR_RD_SYS_T : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t    //=============================================================================\n\t    // Title:            RandomRange_DInt\n\t    // Comment/Function: This function generates random numbers in defined limits (Datatype DInt)\n\t    \n\t    //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Validation\n\t    // Check if the maximal Value is less than the minimal value\n\t    IF (#minValue > #maxValue) THEN\n\t        #error := true;\n\t        #status := #ERR_MAX_LESS_MIN;\n\t        \n\t        #RandomRange_DInt := #ZERO;\n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // Read system time\n\t    #tempTimeStatus := INT_TO_WORD(RD_SYS_T(#tempTime));\n\t    \n\t    // Check return variable for error\n\t    IF (#tempTimeStatus <> #SUB_STATUS_NO_ERROR) THEN\n\t        #error := true;\n\t        #status := #ERR_RD_SYS_T;\n\t        \n\t        #RandomRange_DInt := #ZERO;\n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating random number\n\t    // Converting to double word so individual bytes can be addressed\n\t    #tempNanoSecondInDWord := UDINT_TO_DWORD(#tempTime.NANOSECOND);\n\t    \n\t    // Callculate a random-start-value depending on the time\n\t    #tempRandomValue.%B3 := #tempNanoSecondInDWord.%B0;\n\t    #tempRandomValue.%B2 := #tempNanoSecondInDWord.%B1;\n\t    #tempRandomValue.%B1 := #tempNanoSecondInDWord.%B2;\n\t    #tempRandomValue.%B0 := #tempNanoSecondInDWord.%B3;\n\t    \n\t    // Norm the calculated random number: 0.0 <= #tempNormReal <= 1.0\n\t    #tempNormReal := UDINT_TO_REAL(DWORD_TO_UDINT(#tempRandomValue)) / UDINT_TO_REAL(#MAX_UDINT);\n\t    \n\t    // Scale the tempNormReal to be in the range of maxValue and minValue\n\t    #RandomRange_DInt := REAL_TO_DINT((#tempNormReal * DINT_TO_REAL(#maxValue - #minValue) + DINT_TO_REAL(#minValue)));\n\t    \n\t    #error := false;\n\t    #status := #STATUS_FINISHED_NO_ERROR;\n\t    \n\t    // ENO mechanism is not used\n\t    ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n", "in/out": []}
{"title": "Find Maximum and Minimum Values", "description": "Write a function (FC) that receives a variable-length integer array as input and returns the maximum and minimum values in the array, as well as their positions in the array.\n\nExample:\nAssume the input array is array[1..5]=[5, 10, 2, 25, 1]. The function should return maximum value 25, minimum value 1, maximum value position 4, and minimum value position 5.", "type": "FUNCTION", "name": "SearchMinMax_DInt", "input": [{"name": "values", "type": "Array[*] of DInt", "description": "Array to search"}], "output": [{"name": "minValue", "type": "DInt", "description": "Minimum value in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Position of the minimum value in the array"}, {"name": "maxValue", "type": "DInt", "description": "Maximum value in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Position of the maximum value in the array"}], "answer": "FUNCTION \"SearchMinMax_DInt\" : Void\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      values : Array[*] of DInt;\n   END_VAR\n\n   VAR_OUTPUT \n      minValue : DInt;\n      minValueIndex : DInt;\n      maxValue : DInt;\n      maxValueIndex : DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempArrayLowerBound : DInt;\n      tempArrayUpperBound : DInt;\n      tempCounter : DInt;\n      tempArrayIndexMax : DInt;\n      tempArrayIndexMin : DInt;\n      tempActValue : DInt;\n      tempMinValue : DInt;\n      tempMaxValue : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      START_FROM_SECOND_ELEMENT : Int := 1;\n      DIMENSION_ONE : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            SearchMinMax_DInt\n\t  // Comment/Function: Searches an array for the minimum and maximum number and\n\t  //                   outputs the position and values of those numbers for\n\t  //                   array of double integers\n\t \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Validation of inputs and outputs \n\t  // Lower bound\n\t  #tempArrayLowerBound := LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t  // Upper bound \n\t  #tempArrayUpperBound := UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\tEND_REGION\n\t\n\tREGION Searching the array \n\t  // Assign first value as min / max\n\t  #tempMinValue := #tempMaxValue := #values[#tempArrayLowerBound];\n\t  #tempArrayIndexMin := #tempArrayIndexMax := #tempArrayLowerBound;\n\t  \n\t  // Search the Array for min/max values\n\t  FOR #tempCounter := (#tempArrayLowerBound + #START_FROM_SECOND_ELEMENT) TO #tempArrayUpperBound DO\n\t    \n\t    #tempActValue := #values[#tempCounter];\n\t    \n\t    // check for min\n\t    IF #tempActValue < #tempMinValue THEN\n\t      #tempMinValue := #tempActValue;\n\t      #tempArrayIndexMin := #tempCounter;\n\t      // check for max\n\t    ELSIF #tempActValue > #tempMaxValue THEN\n\t      #tempMaxValue := #tempActValue;\n\t      #tempArrayIndexMax := #tempCounter;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  // Copy found values to outputs\n\t  // Copy Minimum value\n\t  #minValue := #values[#tempArrayIndexMin];\n\t  // Copy Maximum value\n\t  #maxValue := #values[#tempArrayIndexMax];\n\t  \n\t  // Write found indexes to outputs\n\t  #minValueIndex := #tempArrayIndexMin;\n\t  #maxValueIndex := #tempArrayIndexMax;\n\t  \n\t  // ENO mechanism is not used, no error possible\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n", "in/out": [], "return_value": []}
{"title": "Generate Pulse Signal", "description": "Write a function block (FB) that generates a periodic signal that alternates between FALSE and TRUE. In each cycle, the duration of the TRUE state and the FALSE state is determined by the specified frequency and pulse-to-pause ratio. The pulse-to-pause ratio defines the ratio of the TRUE duration to the FALSE duration within each cycle.\n\nExample:\nAssume frequency is 0.5 Hz and pulsePauseRatio is 3. This means each cycle is 2 seconds long, with the TRUE state lasting 1.5 seconds and the FALSE state lasting 0.5 seconds.", "type": "FUNCTION_BLOCK", "name": "Frequency", "input": [{"name": "frequency", "type": "Real", "description": "Clock frequency in Hz"}, {"name": "pulsePauseRatio", "type": "Real", "description": "Pulse-to-pause ratio, defined as the duration of the TRUE state divided by the duration of the FALSE state in each cycle. For example, if pulsePauseRatio is 2, the TRUE duration is twice the FALSE duration."}], "output": [{"name": "clock", "type": "Bool", "description": "Pulse output"}, {"name": "countdown", "type": "Time", "description": "Remaining time of the current state"}], "answer": "FUNCTION_BLOCK \"Frequency\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      frequency : Real := 0.0;\n      pulsePauseRatio : Real := 1.0;\n   END_VAR\n\n   VAR_OUTPUT \n      clock  : Bool;\n      countdown  : Time;\n   END_VAR\n\n   VAR \n      instTofTimePulse  : TOF_TIME;\n      instTofTimePause  : TOF_TIME;\n      statFrequencyOld  : Real;\n      statPulsePauseRatioOld : Real;\n      statTimePulse  : Time;\n      statTimePause  : Time;\n   END_VAR\n\n   VAR_TEMP \n      tempPulseRate : Real;\n      tempPauseRate : Real;\n      tempCountdown : Time;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : Real := 0.0;\n      ZERO_TIME : Time := T#0ms;\n      SECOND_IN_MS : Real := 1000.0;\n      ONE : Real := 1.0;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            Frequency\n\t  // Comment/Function: This function generates a signal that changes between the values `FALSE` and `TRUE` depending on a defined frequency and a pulse pause ratio.\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Calculation of settings and program execution\n\t  // If input <= 0.0 the block is disabled\n\t  IF (#frequency <= #ZERO) OR (#pulsePauseRatio <= #ZERO) THEN\n\t    #clock := FALSE;\n\t    #tempCountdown := #ZERO_TIME;\n\t  ELSE\n\t    \n\t    //Calculating function frequency and pulse pause ratio only when an input is changed\n\t    IF #statFrequencyOld <> #frequency OR #statPulsePauseRatioOld <> #pulsePauseRatio THEN\n\t      RESET_TIMER(TIMER := #instTofTimePause);\n\t      RESET_TIMER(TIMER := #instTofTimePulse);\n\t      \n\t      #tempPulseRate := #pulsePauseRatio / (#pulsePauseRatio + #ONE); // Calculate pulse rate   \n\t      #tempPauseRate := #ONE - #tempPulseRate;                      // Calculate pause rate   \n\t      #statTimePulse := UDINT_TO_TIME(REAL_TO_UDINT((#SECOND_IN_MS * #tempPulseRate / #frequency))); // Calculate pulse time   \n\t      #statTimePause := UDINT_TO_TIME(REAL_TO_UDINT((#SECOND_IN_MS * #tempPauseRate / #frequency))); // Calculate pause time\n\t      #statFrequencyOld := #frequency;\n\t      #statPulsePauseRatioOld := #pulsePauseRatio;\n\t    END_IF;\n\t    \n\t    //Two time off-delay timers that are resetting each other on expiration\n\t    #instTofTimePulse(IN := NOT #instTofTimePause.Q,\n\t                      PT := #statTimePulse);\n\t    \n\t    //If timer for pulse is running, remaining time of the PULSE is calculated\n\t    #tempCountdown := #statTimePulse - #instTofTimePulse.ET;\n\t    \n\t    #instTofTimePause(IN := #instTofTimePulse.Q,\n\t                      PT := #statTimePause);\n\t    \n\t    //If timer for pulse is NOT running, remaining time of the PAUSE is calculated\n\t    IF #tempCountdown = #ZERO_TIME THEN\n\t      #tempCountdown := #statTimePause - #instTofTimePause.ET;\n\t    END_IF;\n\t    \n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t  // Assigning value of the pulse timer to the clock output\n\t  #clock := #instTofTimePulse.Q;\n\t  #countdown := #tempCountdown;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n\n", "in/out": [], "return_value": []}
{"title": "Sorting", "description": "Write a function block (FB) that performs optional ascending or descending sorting. The FB should accept a variable-length integer array (maximum length 1000 elements) and a parameter indicating the sort direction (ascending or descending), and write the sorted result back to the original array. If the array has more than 1000 elements or 1 or fewer elements, the FB should output an error status and an error code.\n\nStatus codes:\n16#0000: FB executed without errors\n16#8200: Array has 1 or fewer elements\n16#8201: Array has more than 1000 elements", "type": "FUNCTION_BLOCK", "name": "ShellSort_DInt", "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE for ascending order, TRUE for descending order"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: no error occurred; TRUE: error occurred during FB execution"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of DInt", "description": "Array to be sorted"}], "answer": "FUNCTION_BLOCK \"ShellSort_DInt\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      sortDirection : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status  : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of DInt;\n   END_VAR\n\n   VAR \n      tempArray : Array[1..#MAX_ARRAY_ELEMENTS] of DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempNoOfElements : DInt;\n      tempGap : DInt;\n      tempLoopIndex : DInt;\n      tempExchangeIndex : DInt;\n      tempExchangeVariable : DInt;\n      tempArrayOffset : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      ARRAY_START_INDEX : UInt := 1;\n      SINGLE_ARRAY_ELEMENT : DInt := 1;\n      GAP_INIT : Int := 1;\n      GAP_THRESHOLD : Int := 1;\n      GAP_RATIO : DInt := 3;\n      INCREMENT : Int := 1;\n      ELEMENTS_COUNT_CORRECTION : DInt := 1;\n      MAX_ARRAY_ELEMENTS : Int := 1000;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_TOO_MANY_ELEMENTS : Word := 16#8201;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // Title:            ShellSort_DInt\n\t  // Comment/Function: This block sorts an array with any number of elements (max. 1000)\n\t  //                   in ascending or descending order and returns the sorted version of the array in the same variable.\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Special description\n\t  // Space note: If you wish to reduce the space of this block, you may reduce the\n\t  // size OF the tempArray<Type> TO one just big enough FOR your specific purpose\n\t  // It is not recommended to increase the size significantly.\n\tEND_REGION\n\t\n\tREGION Initialization and input data processing\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // Array elements calculation\n\t  // (for example: 6 - 2 = 4; but real number of elements is 5)\n\t  #tempNoOfElements := #tempUpperLimit - #tempLowerLimit + #ELEMENTS_COUNT_CORRECTION;\n\t  \n\t  // Shift array index to range 1..MAX_ARRAY_ELEMENTS\n\t  #tempArrayOffset := - #tempLowerLimit + #ARRAY_START_INDEX;\n\t  \n\t  // Check whether the array contains less than the maximum possible amount of elements\n\t  IF #tempNoOfElements > #MAX_ARRAY_ELEMENTS THEN\n\t    #error := true;\n\t    #status := #ERR_TOO_MANY_ELEMENTS;\n\t    RETURN;\n\t  ELSIF #tempNoOfElements <= #SINGLE_ARRAY_ELEMENT THEN\n\t    // If there are 0 elements in the array, set status to \"Error: Parameter is an empty array\"\n\t    #error := true;\n\t    #status := #ERR_NO_ARRAY;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Sorting\n\t  // Read the elements of the incoming array and write into the local array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #tempArray[#tempLoopIndex + #tempArrayOffset] := #array[#tempLoopIndex];\n\t  END_FOR;\n\t  \n\t  REGION Shell sort algorithm\n\t    #tempGap := #GAP_INIT;\n\t    \n\t    // Evaluation of the maximal gap size\n\t    REPEAT\n\t      #tempGap := (#GAP_RATIO * #tempGap) + #INCREMENT;\n\t    UNTIL #tempGap > #tempNoOfElements END_REPEAT;\n\t    \n\t    REPEAT\n\t      #tempGap := #tempGap / #GAP_RATIO;\n\t      \n\t      FOR #tempLoopIndex := #tempGap + #INCREMENT TO #tempNoOfElements DO\n\t        #tempExchangeVariable := #tempArray[#tempLoopIndex];\n\t        #tempExchangeIndex := #tempLoopIndex;\n\t        \n\t        // sort descending \n\t        IF #sortDirection THEN\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] < #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t          \n\t          // sort ascending\n\t        ELSE\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] > #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t        END_IF;\n\t        \n\t        #tempArray[#tempExchangeIndex] := #tempExchangeVariable;\n\t      END_FOR;\n\t      \n\t    UNTIL #tempGap <= #GAP_THRESHOLD END_REPEAT;\n\t  END_REGION\n\t  \n\t  // Write the elements of the local array back to the inOut array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #array[#tempLoopIndex] := #tempArray[#tempLoopIndex + #tempArrayOffset];\n\t  END_FOR;\n\t  \n\t  // Set \"No error\" status\n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n\n", "return_value": []}
{"title": "Special Stack", "description": "Write a function block (FB) that implements a special stack where the minimum value is removed during a pop operation.\n1. Push operation: When a new element is pushed, first check if the stack is full. If full, do nothing. Otherwise, add it to the top of the array and update the top position.\n2. Pop operation: When popping, first check if the stack is empty. If empty, do nothing. Otherwise, remove the minimum value from the stack, return its value, and update the top position.\nStatus codes:\n16#0000: FB executed without errors\n16#8A04: Stack is full\n16#8A05: Stack is empty", "type": "FUNCTION_BLOCK", "name": "StackMin", "input": [{"name": "push", "type": "Bool", "description": "Push operation; adds an element to the stack if not full"}, {"name": "pop", "type": "Bool", "description": "Pop operation; removes the minimum value from the stack and returns it if stack is not empty"}, {"name": "reset", "type": "Bool", "description": "Reset operation; resets the top position of the stack"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: no error occurred; TRUE: error occurred during FB execution"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "item", "type": "Int", "description": "Value to push onto the stack or return from the stack"}, {"name": "stack", "type": "Array[0..3] of Int", "description": "Array used as the stack"}], "answer": "FUNCTION_BLOCK \"StackMin\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      push : Bool;   // 入栈\n      pop : Bool;   // 出栈\n      reset : Bool;   // 复位\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;   // 故障状态\n      status : Word;   // 状态代码\n   END_VAR\n\n   VAR_IN_OUT \n      item : Int;   // 入栈或出栈的元素\n      stack : Array[0..3] of Int;   // 堆栈空间\n   END_VAR\n\n   VAR \n      statStackIndex : Int;   // 堆栈指针\n      statMin : Int;\n   END_VAR\n\n   VAR_TEMP \n      tempStackSize : DInt;\n      tempCount : Int;\n   END_VAR\n\n   VAR CONSTANT \n      STACK_FULL : Word := 16#8A04;   // 堆栈已满\n      STACK_EMPTY : Word := 16#8A05;   // 堆栈已空\n      NO_ERROR : Word := 16#0000;\n   END_VAR\n\n\nBEGIN\n\t//设置堆栈长度\n\tREGION StackSize\n\t    #tempStackSize := 4;\n\tEND_REGION\n\t\n\t//入栈\n\tREGION Push\n\t    IF #push = TRUE THEN\n\t        IF #statStackIndex >= #tempStackSize THEN             //判断是否满栈，如果已经满栈,则不执行入栈,并报错\n\t            #error := TRUE;\n\t            #status := #STACK_FULL;\n\t            RETURN;\n\t        END_IF;\n\t        #stack[#statStackIndex] := #item;                    //否则放入元素\n\t        #statStackIndex += 1;                                //堆栈指针上移\n\t    END_IF;\n\tEND_REGION\n\t\n\t//出栈\n\tREGION Pop\n\t    IF #pop = TRUE THEN\n\t        \n\t        //判断空栈，如果已经空栈,则不执行出栈,并报错\n\t        IF #statStackIndex <= 0 THEN                          \n\t            #error := TRUE;\n\t            #status := #STACK_EMPTY;\n\t            RETURN;\n\t        END_IF;\n\t        \n\t        //查找最小值所在位置\n\t        #statMin := 0;\n\t        IF #statStackIndex>1 THEN\n\t            FOR #tempCount := 1 TO #statStackIndex - 1 DO\n\t                IF #stack[#tempCount] < #stack[#statMin] THEN\n\t                    #statMin := #tempCount;\n\t                END_IF;\n\t            END_FOR;\n\t        END_IF;\n\t        \n\t        //取出元素，上面元素往下顺移\n\t        #item := #stack[#statMin];               \n\t        IF #statMin<>#statStackIndex-1 THEN\n\t            FOR #tempCount := #statMin TO #statStackIndex - 2 DO\n\t                #stack[#tempCount] := #stack[#tempCount + 1];\n\t            END_FOR;\n\t        END_IF;\n\t        #stack[#statStackIndex - 1] := 0;\n\t        #statStackIndex -= 1;                               //堆栈指针下移\n\t    END_IF;\n\tEND_REGION\n\t\n\t//复位\n\tREGION Reset\n\t    IF #reset = TRUE THEN\n\t        #statStackIndex := 0;\n\t    END_IF;\n\tEND_REGION\n\t\n\t#error := FALSE;\n\t#status := #NO_ERROR;\n\t\nEND_FUNCTION_BLOCK\n\n", "return_value": []}
{"title": "Convert String to IP Address and Port", "description": "In Siemens PLC programming, it is often necessary to receive strings containing an IP address and port number from user input or external devices and parse them into integer formats for network communication.\nWrite a function (FC) to convert a string containing an IP address and an optional port number into integer IP address and port number values. The string format should be \"xxx.xxx.xxx.xxx[:port]\", where xxx represents a number between 0-255, and port represents an optional number between 0-65535. If the string contains a port number, return it; otherwise, return a default port number (e.g., 0). The parsed IP address and port number should be returned in the appropriate fields of the TADDR_Param system data structure.\nThe function should validate that the input string matches the \"IP_ADDRESS:PORT\" format, with the IP address consisting of four dot-separated integers between 0 and 255, and the port number being an integer between 0 and 65535.\nIf the string format is correct, the function should parse it into a four-byte integer array representing the IP address and an integer representing the port number, and return these values.\nIf the string format is incorrect, the function should output an error status and an error code.\nStatus codes:\n16#0000: FB executed without errors\n16#811x: Too many characters in the IP address, where x indicates the lowest byte number with error (e.g., if the 2nd byte has an error, x=2)\n16#812x: IP address string is empty, x has the same meaning as above\n16#813x: IP address exceeds maximum value (255), x has the same meaning as above\n16#8150: Port number has too many characters\n16#8151: Port string is empty\n16#8152: Port number exceeds maximum value (65535)", "type": "FUNCTION", "name": "StringToTaddr", "input": [{"name": "ipAddressString", "type": "String", "description": "Input string"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: no error occurred; TRUE: error occurred during FB execution"}, {"name": "status", "type": "Word", "description": "Status code"}], "return_value": [{"type": "TADDR_Param", "description": "Converted IP address and port number"}], "answer": "FUNCTION \"StringToTaddr\" : TADDR_Param\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      ipAddressString : String;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempOctetIndex : Int;\n      tempCharPosition : Int;\n      tempAddressString : String;\n      tempOctetString : String[#MAX_CHAR_FOR_IP_OCTET_NUMBER];\n      tempNumber : UDInt;\n      tempPortNumberIsSpecified : Bool;\n      tempIpAdressTaddr  : TADDR_Param;\n   END_VAR\n\n   VAR CONSTANT \n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_OCTET_WRONG_NUMBER_OF_CHAR : Word := 16#8110;\n      ERR_OCTET_STRING_IS_EMPTY : Word := 16#8120;\n      ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS : Word := 16#8130;\n      ERR_PORT_WRONG_NUMBER_OF_CHAR : Word := 16#8150;\n      ERR_PORT_STRING_IS_EMPTY : Word := 16#8151;\n      ERR_PORT_EXCEEDS_MAX_PORT : Word := 16#8152;\n      MAX_IP_ADDRESS_OCTET_NUMBER : USInt := 255;\n      MAX_PORT_NUMBER : UInt := 65535;\n      EMPTY_STRING : Int := 0;\n      MAX_CHAR_FOR_IP_OCTET_NUMBER : Int := 4;\n      MAX_CHAR_FOR_PORT_NUMBER : Int := 5;\n      INIT_VAL : USInt := 0;\n      NUMBER_OF_IP_OCTETS : Int := 4;\n      CHAR_DOT : Char := '.';\n      CHAR_COLON : Char := ':';\n      CONVERT_FORMAT_TO_INTEGER : Word := 16#0000;\n      CONVERT_START_POSITION : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Title:            StringToTaddr\n\t  // Comment/Function: This function converts a string IP Address into TADDR Parameter format.\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Initialization\n\t  #tempAddressString := #ipAddressString;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[1] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[2] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[3] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[4] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_PORT_NR := #INIT_VAL;\n\t  #StringToTaddr := #tempIpAdressTaddr;\n\tEND_REGION\n\t\n\tREGION Process Address String  \n\t  REGION Process octests 1-4\n\t    FOR #tempOctetIndex := 1 TO #NUMBER_OF_IP_OCTETS BY 1 DO\n\t      // check if loop has not reached the last octet\n\t      IF #tempOctetIndex < #NUMBER_OF_IP_OCTETS THEN\n\t        // search for dot as octet seperator\n\t        // there has to be a dot present between the octets\n\t        #tempCharPosition := FIND(IN1 := #tempAddressString, IN2 := #CHAR_DOT);\n\t        \n\t      ELSE\n\t        // search for colon as port seperator after the last Octet\n\t        #tempCharPosition := FIND(IN1 := #tempAddressString, IN2 := #CHAR_COLON);\n\t        \n\t        // if colon is present, there is a port number specified / check if Port number added\n\t        #tempPortNumberIsSpecified := (#tempCharPosition > 0);\n\t        \n\t        // if no port is spezified, its just the last octet\n\t        IF NOT #tempPortNumberIsSpecified THEN\n\t          // need to set the char position to the end of string + one for later cobesion and checks\n\t          #tempCharPosition := LEN(#tempAddressString) + 1;\n\t        END_IF;\n\t      END_IF;\n\t      \n\t      REGION Octet conversion\n\t        // check if IP Octet contains more then three digits --> Error\n\t        IF #tempCharPosition > #MAX_CHAR_FOR_IP_OCTET_NUMBER THEN\n\t          #error := TRUE;\n\t          #status := #ERR_OCTET_WRONG_NUMBER_OF_CHAR OR INT_TO_WORD(#tempOctetIndex);\n\t          #StringToTaddr := #tempIpAdressTaddr;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        // extract octet string\n\t        #tempOctetString := LEFT(IN := #tempAddressString, L := #tempCharPosition - 1);\n\t        // Check if Octet string is empty --> Error\n\t        IF LEN(#tempOctetString) = #EMPTY_STRING THEN\n\t          #error := TRUE;\n\t          #status := #ERR_OCTET_STRING_IS_EMPTY OR INT_TO_WORD(#tempOctetIndex);\n\t          #StringToTaddr := #tempIpAdressTaddr;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        // Convert the octet string to numerical value\n\t        STRG_VAL(IN     := #tempOctetString,\n\t                 FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t                 P      := #CONVERT_START_POSITION,\n\t                 OUT    => #tempNumber);\n\t        \n\t        // check if the octet number exeeds the maximum possible range of 255 of USInt --> Error\n\t        IF #tempNumber > #MAX_IP_ADDRESS_OCTET_NUMBER THEN\n\t          #error := TRUE;\n\t          #status := #ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS OR INT_TO_WORD(#tempOctetIndex);\n\t          #StringToTaddr := #tempIpAdressTaddr;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        // add address octet to temp address tag\n\t        #tempIpAdressTaddr.REM_IP_ADDR[#tempOctetIndex] := UDINT_TO_USINT(#tempNumber);\n\t        \n\t        // delete octet string from address string\n\t        #tempAddressString := DELETE(IN := #tempAddressString, P := 1, L := #tempCharPosition);\n\t      END_REGION Octet conversion\n\t    END_FOR;\n\t  END_REGION Process octests 1-4\n\t  \n\t  REGION PORT number conversion\n\t    // If the string contains a port number too, parse it\n\t    IF #tempPortNumberIsSpecified THEN\n\t      // lenght of string exceeds length of port string --> Error\n\t      IF LEN(#tempAddressString) > #MAX_CHAR_FOR_PORT_NUMBER THEN\n\t        #error := TRUE;\n\t        #status := #ERR_PORT_WRONG_NUMBER_OF_CHAR;\n\t        #StringToTaddr := #tempIpAdressTaddr;\n\t        RETURN;\n\t        \n\t        // Check if string is empty --> Error\n\t      ELSIF LEN(#tempAddressString) = #EMPTY_STRING THEN\n\t        #error := TRUE;\n\t        #status := #ERR_PORT_STRING_IS_EMPTY;\n\t        #StringToTaddr := #tempIpAdressTaddr;\n\t        RETURN;\n\t      END_IF;\n\t      \n\t      // Convert the port number string to numerical value\n\t      STRG_VAL(IN     := #tempAddressString,\n\t               FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t               P      := #CONVERT_START_POSITION,\n\t               OUT    => #tempNumber);\n\t      \n\t      // check if the Port number exeeds the maximum possible range of 65535 of UInt --> Error\n\t      IF #tempNumber > #MAX_PORT_NUMBER THEN\n\t        #error := TRUE;\n\t        #status := #ERR_PORT_EXCEEDS_MAX_PORT;\n\t        #StringToTaddr := #tempIpAdressTaddr;\n\t        RETURN;\n\t      END_IF;\n\t      \n\t      // add port number to temp address tag\n\t      #tempIpAdressTaddr.REM_PORT_NR := UDINT_TO_UINT(#tempNumber);\n\t    END_IF;\n\t  END_REGION PORT number conversion\n\t  \n\tEND_REGION\n\t\n\tREGION Outputs\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #StringToTaddr := #tempIpAdressTaddr;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n", "in/out": []}
{"title": "Temperature Logic Control", "description": "Write a function block (FB) that implements a temperature control logic. The program should include the following functions:\n1. Read the temperature sensor value through an analog input module.\n2. Compare the read temperature value TemperatureSensorInput with the set temperature SetTemperature.\n3. If the actual temperature is below the set temperature, turn on the heater HeaterOutput.\n4. If the actual temperature is above the set temperature, turn off the heater HeaterOutput.\n5. If the heater operates continuously for a certain time (for testing, 5s), trigger overheat protection, automatically turn off the heater, and overheat protection can only be cleared after a certain time (for testing, 3s).\n6. Provide status indication showing current temperature, set temperature, heater status, and whether overheat protection is active.\n7. Provide temperature sensor fault detection: if TemperatureSensorInput is less than 0 or greater than 100, consider the sensor faulty and turn off the heater.", "type": "FUNCTION_BLOCK", "name": "TempCtrl", "input": [{"name": "TemperatureSensorInput", "type": "Real", "description": "Temperature sensor input value, i.e., actual temperature"}, {"name": "SetTemperature", "type": "Real", "description": "Set temperature value"}], "output": [{"name": "CurrentTemperature", "type": "Real", "description": "Current temperature display"}, {"name": "SetTempDisplay", "type": "Real", "description": "Set temperature display"}, {"name": "HeaterStatus", "type": "Bool", "description": "Heater status display"}, {"name": "OverheatProtection", "type": "Bool", "description": "Overheat protection status display"}], "in/out": [{"name": "HeaterOutput", "type": "Bool", "description": "Heater control output"}], "answer": "FUNCTION_BLOCK \"TempCtrl\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      TemperatureSensorInput : Real;   // 温度传感器输入值\n      SetTemperature : Real;   // 设定温度值\n   END_VAR\n\n   VAR_OUTPUT \n      CurrentTemperature : Real;   // 当前温度显示\n      SetTempDisplay : Real;   // 设定温度显示\n      HeaterStatus : Bool;   // 加热器状态显示\n      OverheatProtection : Bool;   // 过热保护状态显示\n   END_VAR\n\n   VAR_IN_OUT \n      HeaterOutput : Bool;   // 加热器控制输出\n   END_VAR\n\n   VAR \n      HeaterState : Struct\n         IsEnabled : Bool;\n         OverheatProtectionTriggered : Bool;\n      END_STRUCT;\n      OverheatTimer  : TON_TIME;   // 过热保护定时器\n      SensorError : Bool;   // 传感器错误标志\n      CoolTimer  : TON_TIME;\n      OverheatTimerOutput  : Bool;\n      CoolTimerOutput  : Bool;\n   END_VAR\n\n\nBEGIN\n\t// 显示当前温度和设定温度 \n\t#CurrentTemperature := #TemperatureSensorInput;\n\t#SetTempDisplay := #SetTemperature;\n\t\n\t// 检查传感器是否失效 \n\tIF #TemperatureSensorInput < 0 OR #TemperatureSensorInput > 100 THEN\n\t    #SensorError := TRUE;\n\tELSE\n\t    #SensorError := FALSE;\n\tEND_IF;\n\t\n\t// 温度控制逻辑 \n\t// 过热保护逻辑 \n\t#OverheatTimer(IN := #HeaterOutput,\n\t               PT := T#5S,\n\t               Q => #OverheatTimerOutput);\n\tIF #HeaterState.IsEnabled AND #OverheatTimerOutput THEN\n\t    #HeaterState.OverheatProtectionTriggered := TRUE;\n\t    #HeaterState.IsEnabled := FALSE;\n\t    #HeaterOutput := FALSE;\n\tEND_IF;\n\t#CoolTimer(IN := #HeaterState.OverheatProtectionTriggered,\n\t           PT := t#3S,\n\t           Q => #CoolTimerOutput);\n\tIF #CoolTimerOutput THEN\n\t    #HeaterState.OverheatProtectionTriggered := FALSE ;\n\tEND_IF;\n\t\n\tIF NOT #SensorError THEN\n\t    IF #CurrentTemperature < #SetTemperature AND NOT #HeaterState.OverheatProtectionTriggered THEN\n\t        IF NOT #HeaterState.IsEnabled THEN\n\t            #HeaterState.IsEnabled := TRUE;\n\t            #HeaterOutput := TRUE;\n\t        END_IF;\n\t    ELSIF #CurrentTemperature > #SetTemperature THEN\n\t        IF #HeaterState.IsEnabled THEN\n\t            #HeaterState.IsEnabled := FALSE;\n\t            #HeaterOutput := FALSE;\n\t        END_IF;\n\t    END_IF;\n\t    \n\tELSE\n\t    // 传感器错误处理 \n\t    #HeaterOutput := FALSE;\n\t    #HeaterState.IsEnabled := FALSE;\n\tEND_IF;\n\t\n\t// 显示加热器状态和过热保护状态 \n\t#HeaterStatus := #HeaterState.IsEnabled;\n\t#OverheatProtection := #HeaterState.OverheatProtectionTriggered;\nEND_FUNCTION_BLOCK\n\n", "return_value": []}
{"title": "SawTooth", "description": "This function generates a sawtooth-shaped signal profile. Each sawtooth consists of a defined number of steps (increments). Note LEGACY FUNCTION Please update and use the FB with the same name LGF_CountRisInDWord in the future! This function is no longer maintained!", "type": "FUNCTION_BLOCK", "name": "LGF_SawTooth", "vars": [{"name": "startValue", "type": "Int", "description": "Start value at which the signal begins."}, {"name": "timeRange", "type": "Time", "description": "Time after which the output parameter `value` is\nincremented"}, {"name": "incrementRange", "type": "Int", "description": "Size of the jump from one increment to the next."}, {"name": "numberSteps", "type": "Int", "description": "Number of increments per sawtooth. (In the case of an\nendless sawtooth signal, this information is not\nnecessary)."}, {"name": "endlessSteps", "type": "Bool", "description": "Specifies whether an endless sawtooth signal will be\ngenerated.\n`TRUE` - Activated, `FALSE` - Disabled"}, {"name": "reset", "type": "Bool", "description": "Sawtooth starts again at the start value, `startValue`."}, {"name": "value", "type": "Int", "description": "Current value of the sawtooth signal."}], "input": [{"name": "startValue", "type": "Int", "description": "Start value at which the signal begins."}, {"name": "timeRange", "type": "Time", "description": "Time after which the output parameter `value` is\nincremented"}, {"name": "incrementRange", "type": "Int", "description": "Size of the jump from one increment to the next."}, {"name": "numberSteps", "type": "Int", "description": "Number of increments per sawtooth. (In the case of an\nendless sawtooth signal, this information is not\nnecessary)."}, {"name": "endlessSteps", "type": "Bool", "description": "Specifies whether an endless sawtooth signal will be\ngenerated.\n`TRUE` - Activated, `FALSE` - Disabled"}, {"name": "reset", "type": "Bool", "description": "Sawtooth starts again at the start value, `startValue`."}], "output": [{"name": "value", "type": "Int", "description": "Current value of the sawtooth signal."}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_SawTooth\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LFG\nNAME : LGF_SawTooth\n   VAR_INPUT \n      startValue : Int;\n      timeRange : Time;\n      incrementRange : Int;\n      numberSteps : Int;\n      endlessSteps : Bool;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      value { ExternalWritable := 'False'} : Int;\n   END_VAR\n\n   VAR \n      statStartValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statEndlessSteps { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statTimeRange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;\n      statIncrementRange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statNumberSteps { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statCurrentStep { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statFirstRun { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;\n      statStartTimer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statTimerFinished { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      instTimer {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;\n      statActValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : Int;\n      INCREMENT_WITH_ONE : Int := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Library:          LGF_SawTooth\n\t  // Comment/Function: This function generates a sawtooth-shaped signal profile. Each sawtooth consists of a defined number of steps (increments).\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible.\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.11.2015  Siemens Industry Online Support\n\t  //                      Bug fix\n\t  // 01.00.02 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.03 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.04 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.10 23.09.2019  Simatic Systems Support\n\t  //                      Code refactoring, regions and more comments added\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization\n\t  // Initialization for the first call or reset complete function\n\t  IF #statFirstRun OR #reset THEN\n\t    // Copy all input parameter to static values\n\t    #statStartValue := #startValue;\n\t    #statTimeRange := #timeRange;\n\t    #statIncrementRange := #incrementRange;\n\t    #statNumberSteps := #numberSteps;\n\t    #statEndlessSteps := #endlessSteps;\n\t    \n\t    // Reset static values\n\t    #statActValue := #statStartValue;\n\t    #statStartTimer := TRUE;\n\t    #statCurrentStep := #ZERO;\n\t    #statFirstRun := FALSE;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution\n\t  // Calculation of a new values if the time base is up\n\t  IF (#statTimerFinished AND NOT #reset) THEN\n\t    \n\t    #statActValue := #statActValue + #statIncrementRange;\n\t    #statCurrentStep := #statCurrentStep + #INCREMENT_WITH_ONE;\n\t    \n\t    // If a defined number of steps must be performed \n\t    IF (#statEndlessSteps = FALSE) THEN\n\t      // Restart with start value if number of steps is reached\n\t      IF #statCurrentStep > #statNumberSteps THEN\n\t        #statCurrentStep := #ZERO;\n\t        #statActValue := #statStartValue;\n\t      END_IF;\n\t      // If endless is on the step counter is resetted  \n\t    ELSE\n\t      #statCurrentStep := #ZERO;\n\t    END_IF;\n\t    #statStartTimer := FALSE; // Reset the time base\n\t  END_IF;\n\t  \n\t  // Call a times as basis of the step range\n\t  #instTimer(IN := #statStartTimer,\n\t             PT := #statTimeRange,\n\t             Q  => #statTimerFinished);\n\t  \n\t  // Start the timer\n\t  #statStartTimer := TRUE;\n\t  \n\t  // Write Output, if restart is active output value = 0\n\t  IF (#reset = TRUE) THEN\n\t    #statActValue := #startValue;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Writing to output\n\t  #value := #statActValue;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "ShellSort", "description": "This block sorts an array of type LReal with any number of elements (max. 1000) in ascending or descending order and returns the sorted version of the array in the same variable.", "type": "FUNCTION_BLOCK", "name": "LGF_ShellSort_LReal", "vars": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "array", "type": "Array[*] of LReal", "description": "Array to be sorted"}], "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "array", "type": "Array[*] of LReal", "description": "Array to be sorted"}], "answer": "FUNCTION_BLOCK \"LGF_ShellSort_LReal\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_ShellSort_LReal\n   VAR_INPUT \n      sortDirection : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of LReal;\n   END_VAR\n\n   VAR \n      tempArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..#MAX_ARRAY_ELEMENTS] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempNoOfElements : DInt;\n      tempGap : DInt;\n      tempLoopIndex : DInt;\n      tempExchangeIndex : DInt;\n      tempExchangeVariable : LReal;\n      tempArrayOffset : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      ARRAY_START_INDEX : UInt := 1;\n      SINGLE_ARRAY_ELEMENT : DInt := 1;\n      GAP_INIT : Int := 1;\n      GAP_THRESHOLD : Int := 1;\n      GAP_RATIO : DInt := 3;\n      INCREMENT : Int := 1;\n      ELEMENTS_COUNT_CORRECTION : DInt := 1;\n      MAX_ARRAY_ELEMENTS : Int := 1000;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_TOO_MANY_ELEMENTS : Word := 16#8201;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ShellSort_DInt\n\t  // Comment/Function: This block sorts an array with any number of elements (max. 1000)\n\t  //                   in ascending or descending order and returns the sorted version of the array in the same variable.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.01.00 19.05.2016  Siemens Industry Online Support\n\t  //                      New function: reverse sort\n\t  // 01.01.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.01.02 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.01.03 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 02.00.00 29.01.2019  Siemens Industry Online Support\n\t  //                      Output \"done\" removed (not necessary, because only one cycle)\n\t  // 02.00.01 15.10.2019  Simatic Systems Support\n\t  //                      Code refactoring, comments added,\n\t  //                      change data type from Real to LReal\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Special description\n\t  // Space note: If you wish to reduce the space of this block, you may reduce the\n\t  // size OF the tempArray<Type> TO one just big enough FOR your specific purpose\n\t  // It is not recommended to increase the size significantly.\n\tEND_REGION\n\t\n\tREGION Initialization and input data processing\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // Array elements calculation\n\t  // (for example: 6 - 2 = 4; but real number of elements is 5)\n\t  #tempNoOfElements := #tempUpperLimit - #tempLowerLimit + #ELEMENTS_COUNT_CORRECTION;\n\t  \n\t  // Shift array index to range 1..MAX_ARRAY_ELEMENTS\n\t  #tempArrayOffset := - #tempLowerLimit + #ARRAY_START_INDEX;\n\t  \n\t  // Check whether the array contains less than the maximum possible amount of elements\n\t  IF #tempNoOfElements > #MAX_ARRAY_ELEMENTS THEN\n\t    #error := true;\n\t    #status := #ERR_TOO_MANY_ELEMENTS;\n\t    RETURN;\n\t  ELSIF #tempNoOfElements <= #SINGLE_ARRAY_ELEMENT THEN\n\t    // If there are 0 elements in the array, set status to \"Error: Parameter is an empty array\"\n\t    #error := true;\n\t    #status := #ERR_NO_ARRAY;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Sorting\n\t  // Read the elements of the incoming array and write into the local array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #tempArray[#tempLoopIndex + #tempArrayOffset] := #array[#tempLoopIndex];\n\t  END_FOR;\n\t  \n\t  REGION Shell sort algorithm\n\t    #tempGap := #GAP_INIT;\n\t    \n\t    // Evaluation of the maximal gap size\n\t    REPEAT\n\t      #tempGap := (#GAP_RATIO * #tempGap) + #INCREMENT;\n\t    UNTIL #tempGap > #tempNoOfElements END_REPEAT;\n\t    \n\t    REPEAT\n\t      #tempGap := #tempGap / #GAP_RATIO;\n\t      \n\t      FOR #tempLoopIndex := #tempGap + #INCREMENT TO #tempNoOfElements DO\n\t        #tempExchangeVariable := #tempArray[#tempLoopIndex];\n\t        #tempExchangeIndex := #tempLoopIndex;\n\t        \n\t        // sort descending \n\t        IF #sortDirection THEN\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] < #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t          \n\t          // sort ascending\n\t        ELSE\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] > #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t        END_IF;\n\t        \n\t        #tempArray[#tempExchangeIndex] := #tempExchangeVariable;\n\t      END_FOR;\n\t      \n\t    UNTIL #tempGap <= #GAP_THRESHOLD END_REPEAT;\n\t  END_REGION\n\t  \n\t  // Write the elements of the local array back to the inOut array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #array[#tempLoopIndex] := #tempArray[#tempLoopIndex + #tempArrayOffset];\n\t  END_FOR;\n\t  \n\t  // Set \"No error\" status\n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "BitCount", "description": "This block counts in a variable of type DWord how many bits are set (TRUE) and how many are not set (FALSE) and outputs the number at the outputs. Instead of DWord, Word and Byte can also be used by converting the past parameter with e.g. BYTE_TO_DWORD and connecting the corresponding bit length of the data type at the parameter “numberOfBits”. Byte=8, Word=16, DWord=32", "type": "FUNCTION", "name": "LGF_BitCount", "vars": [{"name": "value", "type": "DWord", "description": "Tag where the bit states has to be counted"}, {"name": "numberOfBits", "type": "USInt", "description": "Number of bits in input tag \"value\" (bit size of Datatype), in case of\nByte=8, Word=16, DWord=32"}, {"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "countBitsFalse", "type": "USInt", "description": "Number of bits are FALSE in input tag \"value\""}, {"name": "countBitsTrue", "type": "USInt", "description": "Number of bits are TRUE in input tag \"value\""}], "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit states has to be counted"}, {"name": "numberOfBits", "type": "USInt", "description": "Number of bits in input tag \"value\" (bit size of Datatype), in case of\nByte=8, Word=16, DWord=32"}], "output": [{"name": "countBitsFalse", "type": "USInt", "description": "Number of bits are FALSE in input tag \"value\""}, {"name": "countBitsTrue", "type": "USInt", "description": "Number of bits are TRUE in input tag \"value\""}], "in/out": [], "answer": "FUNCTION \"LGF_BitCount\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : SiemensSIMATICSystemsSupport\nFAMILY : LGF\nNAME : LGF_BitCount\n   VAR_INPUT \n      value : DWord;\n      numberOfBits : USInt;\n   END_VAR\n\n   VAR_OUTPUT \n      countBitsFalse : USInt;\n      countBitsTrue : USInt;\n   END_VAR\n\n   VAR_TEMP \n      tempBinaryValues : DWord;\n      tempLoopIndex : DInt;\n      tempCountBitsTrue : USInt;\n      tempCountBitsFalse : USInt;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : USInt := 0;\n      INCREMENT : USInt := 1;\n      SHIFT_ON_BIT_RIGHT : USInt := 1;\n      START_INDEX : DInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_BitCount\n\t  // Comment/Function: Count bits in elementary datatype - DWord\n\t  //                   count the set (TRUE) and not set (FALSE) bits in a binary datatype \n\t  //                   can be used for Word and Byte as well, by convert\n\t  //                   the past paramter and the result using for e.g. Dword_to_Byte\n\t  //                   \"numberOfBits\" number of bits in input tag \"value\",\n\t  //                   in case of Byte=8, Word=16, Dword=32\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO not in use, set to true, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge         | Changes applied\n\t  // 01.00.00 | 06.06.2015 | Siemens Industry Support | first release\n\t  // 03.00.00 | 23.04.2020 | Siemens Industry Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.02 | 19.01.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Logic\n\t  // init counter tags\n\t  #tempCountBitsFalse := #ZERO;\n\t  #tempCountBitsTrue := #ZERO;\n\t  #tempBinaryValues := #value;\n\t  \n\t  // iterate over input tag\n\t  FOR #tempLoopIndex := #START_INDEX TO USINT_TO_DINT(#numberOfBits) DO\n\t    // check if bit is true or false\n\t    IF #tempBinaryValues.%X0 THEN\n\t      #tempCountBitsTrue += #INCREMENT;\n\t    ELSE\n\t      #tempCountBitsFalse += #INCREMENT;\n\t    END_IF;\n\t    \n\t    // shift input tag one to the right\n\t    #tempBinaryValues := SHR(IN := #tempBinaryValues, N := #SHIFT_ON_BIT_RIGHT);\n\t  END_FOR;\n\t  \n\t  // set output values\n\t  #countBitsFalse := #tempCountBitsFalse;\n\t  #countBitsTrue := #tempCountBitsTrue;\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "DelayProgram", "description": "Blocking delay to increase/extent PLC Load to simulate program load.", "type": "FUNCTION_BLOCK", "name": "LGF_DelayProgram", "vars": [{"name": "delay", "type": "Time", "description": "Time by which the program is delayed"}], "input": [{"name": "delay", "type": "Time", "description": "Time by which the program is delayed"}], "output": [], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_DelayProgram\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Simatic Systems Support'\nFAMILY : LGF\nNAME : LGF_DelayProgram\n   VAR_INPUT \n      delay { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#1MS;\n   END_VAR\n\n   VAR \n      instDelay {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Siemens AG / (c)Copyright 2020\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_DelayProgram\n\t  // Comment/Function: Blocking delay to increase/extent PLC Load to simulate program load.\n\t  // Library/Family:   LGF - Library of general functions\n\t  // Author:           Simatic Systems Support\n\t  // Tested with:      S7-1500\n\t  // Engineering:      TIA Portal V19\n\t  // Restrictions:     ENO mechanism is NOT used - forced TO true.\n\t  // Requirements:     PLC S7-1500 / S7-1200\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge | Changes applied\n\t  //----------|------------|------------------|------------------------------------\n\t  // 01.00.00 | 19.05.2024 | SAG BG           | First Release\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t(/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Processing\n\t  // Call timer with false to ensure a rising edge in operation\n\t  #instDelay.TON(IN := FALSE,\n\t                 PT := #delay);\n\t  \n\t  // Call timer iin Loop to Block Programm\n\t  WHILE NOT #instDelay.Q DO\n\t    #instDelay.TON(IN := TRUE,\n\t                   PT := #delay);\n\t  END_WHILE;\n\t  \n\t  // Call timer with false to reset\n\t  #instDelay.TON(IN := FALSE,\n\t                 PT := #delay);\n\t  \n\t  // ENO NOT IN USE HERE\n\t  ENO := FALSE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "TimeToString", "description": "This function converts a variable of the system data type Time into a variable of the data type String.", "type": "FUNCTION", "name": "LGF_TimeToString", "vars": [{"name": "timeValue", "type": "Time", "description": "Time value to convert\nExample: `T#1D_3H_45M_6S`"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output string"}, {"name": "Ret_Val", "type": "String", "description": "Converted time as string.Example: `1D3H45M6S0MS`"}, {"name": "stringDay", "type": "String", "description": "Converted day as string"}, {"name": "stringHour", "type": "String", "description": "Converted hour as string"}, {"name": "stringMinute", "type": "String", "description": "Converted minute as string"}, {"name": "stringSecond", "type": "String", "description": "Converted second as string"}, {"name": "stringMilliSecond", "type": "String", "description": "Converted millisecond as string"}], "input": [{"name": "timeValue", "type": "Time", "description": "Time value to convert\nExample: `T#1D_3H_45M_6S`"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output string"}], "output": [{"name": "stringDay", "type": "String", "description": "Converted day as string"}, {"name": "stringHour", "type": "String", "description": "Converted hour as string"}, {"name": "stringMinute", "type": "String", "description": "Converted minute as string"}, {"name": "stringSecond", "type": "String", "description": "Converted second as string"}, {"name": "stringMilliSecond", "type": "String", "description": "Converted millisecond as string"}], "in/out": [], "answer": "FUNCTION \"LGF_TimeToString\" : String\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_TimeToString\n   VAR_INPUT \n      timeValue : Time;\n      separator { S7_HiddenAssignment := 'Hide'; S7_PredefinedAssignment := '$'-$''; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : Char;\n   END_VAR\n\n   VAR_OUTPUT \n      stringDay : String;\n      stringHour : String;\n      stringMinute : String;\n      stringSecond : String;\n      stringMilliSecond : String;\n   END_VAR\n\n   VAR_TEMP \n      tempTimeResult : String;\n      tempTimeMilliseconds : DInt;\n      tempDays : DInt;\n      tempHours : DInt;\n      tempMinutes : DInt;\n      tempSecond : DInt;\n      tempMillisecond : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      MS_PER_DAY : DInt := 86400000;\n      MS_PER_HOUR : DInt := 3600000;\n      MS_PER_MINUTE : DInt := 60000;\n      MS_PER_SECOND : DInt := 1000;\n      NUMBER_OF_CHAR_TO_DEL : Int := 1;\n      FIRST_POSITION : Int := 1;\n      NO_REMAINDER : Int := 0;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_TimeToString\n\t  // Comment/Function: This function converts a time value to a string\n\t  //                   When more than one time unit is specified, the value must not exceed 24 days, 23 hours, 59 minutes, 59 seconds or 999 milliseconds.\n\t  //                   Output format is the folowing := '10D20H30M20S630MS', just existing parts would be added to the string\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V4.0\n\t  // Engineering:      TIA Portal V17 \n\t  // Restrictions:     ENO mechanism is not used, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 03.07.2018 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 17.08.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15 Update 2\n\t  // 01.00.02 | 23.11.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15.1\n\t  // 01.00.03 | 02.07.2019 | Simatic Systems Support\n\t  //                         Standard header and block parameters update, status parameter added\n\t  // 01.00.05 | 09.07.2019 | Simatic Systems Support\n\t  //                         Further improvements minimization and commends added\n\t  // 01.00.06 | 30.07.2019 | Simatic Systems Support\n\t  //                         Add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  // 03.01.00 | 17.07.2025 | Simatic Systems Support\n\t  //                         Implemented separator input and functionality\n\t  //===============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION INITIALISATION\n\t  #tempTimeResult := '';\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t    // convert from time to millisecond\n\t    #tempTimeMilliseconds := TIME_TO_DINT(#timeValue);\n\t    \n\t    // calculate the days and remaining hours\n\t    #tempDays := #tempTimeMilliseconds / #MS_PER_DAY;\n\t    #tempTimeMilliseconds := #tempTimeMilliseconds MOD #MS_PER_DAY;\n\t    \n\t    // calculate the hours and remaining minutes\n\t    #tempHours := #tempTimeMilliseconds / #MS_PER_HOUR;\n\t    #tempTimeMilliseconds := #tempTimeMilliseconds MOD #MS_PER_HOUR;\n\t    \n\t    // calculate the minutes and remaining seconds\n\t    #tempMinutes := #tempTimeMilliseconds / #MS_PER_MINUTE;\n\t    #tempTimeMilliseconds := #tempTimeMilliseconds MOD #MS_PER_MINUTE;\n\t    \n\t    // calculate the seconds and remaining milliseconds\n\t    #tempSecond := #tempTimeMilliseconds / #MS_PER_SECOND;\n\t    #tempMillisecond := #tempTimeMilliseconds MOD #MS_PER_SECOND;\n\t    \n\t    // check if value is greater then zero and add to result string without leading \"+\"\n\t    IF (#tempMillisecond > #NO_REMAINDER) THEN\n\t        #stringMilliSecond := DELETE(IN := DINT_TO_STRING(#tempMillisecond), L := #NUMBER_OF_CHAR_TO_DEL, P := #FIRST_POSITION);\n\t        #tempTimeResult := CONCAT(IN1 := #separator, IN2 := #stringMilliSecond, IN3 := 'MS');\n\t    END_IF;\n\t    \n\t    // check if value is greater then zero and add to result string without leading \"+\"\n\t    IF (#tempSecond > #NO_REMAINDER) THEN\n\t        #stringSecond := DELETE(IN := DINT_TO_STRING(#tempSecond), L := #NUMBER_OF_CHAR_TO_DEL, P := #FIRST_POSITION);\n\t        #tempTimeResult := CONCAT(IN1 := #separator, IN2 := #stringSecond, IN3 := 'S', IN4 := #tempTimeResult);\n\t    END_IF;\n\t    \n\t    // check if value is greater then zero and add to result string without leading \"+\"\n\t    IF (#tempMinutes > #NO_REMAINDER) THEN\n\t        #stringMinute := DELETE(IN := DINT_TO_STRING(#tempMinutes), L := #NUMBER_OF_CHAR_TO_DEL, P := #FIRST_POSITION);\n\t        #tempTimeResult := CONCAT(IN1 := #separator, IN2 := #stringMinute, IN3 := 'M', IN4 := #tempTimeResult);\n\t    END_IF;\n\t    \n\t    // check if value is greater then zero and add to result string without leading \"+\"\n\t    IF (#tempHours > #NO_REMAINDER) THEN\n\t        #stringHour := DELETE(IN := DINT_TO_STRING(#tempHours), L := #NUMBER_OF_CHAR_TO_DEL, P := #FIRST_POSITION);\n\t        #tempTimeResult := CONCAT(IN1 := #separator, IN2 := #stringHour, IN3 := 'H', IN4 := #tempTimeResult);\n\t    END_IF;\n\t    \n\t    // check if value is greater then zero and add to result string without leading \"+\"\n\t    IF (#tempDays > #NO_REMAINDER) THEN\n\t        #stringDay := DELETE(IN := DINT_TO_STRING(#tempDays), L := #NUMBER_OF_CHAR_TO_DEL, P := #FIRST_POSITION);\n\t        #tempTimeResult := CONCAT(IN1 := #stringDay, IN2 := 'D', IN3 := #tempTimeResult);\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_TimeToString := #tempTimeResult;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "String"}]}
{"title": "ShellSort", "description": "This block sorts an array of type DInt with any number of elements (max. 1000) in ascending or descending order and returns the sorted version of the array in the same variable.", "type": "FUNCTION_BLOCK", "name": "LGF_ShellSort_DInt", "vars": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "array", "type": "Array[*] of DInt", "description": "Array to be sorted"}], "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "array", "type": "Array[*] of DInt", "description": "Array to be sorted"}], "answer": "FUNCTION_BLOCK \"LGF_ShellSort_DInt\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_ShellSort_DInt\n   VAR_INPUT \n      sortDirection : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of DInt;\n   END_VAR\n\n   VAR \n      tempArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..#MAX_ARRAY_ELEMENTS] of DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempNoOfElements : DInt;\n      tempGap : DInt;\n      tempLoopIndex : DInt;\n      tempExchangeIndex : DInt;\n      tempExchangeVariable : DInt;\n      tempArrayOffset : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      ARRAY_START_INDEX : UInt := 1;\n      SINGLE_ARRAY_ELEMENT : DInt := 1;\n      GAP_INIT : Int := 1;\n      GAP_THRESHOLD : Int := 1;\n      GAP_RATIO : DInt := 3;\n      INCREMENT : Int := 1;\n      ELEMENTS_COUNT_CORRECTION : DInt := 1;\n      MAX_ARRAY_ELEMENTS : Int := 1000;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_TOO_MANY_ELEMENTS : Word := 16#8201;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ShellSort_DInt\n\t  // Comment/Function: This block sorts an array with any number of elements (max. 1000)\n\t  //                   in ascending or descending order and returns the sorted version of the array in the same variable.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.01.00 19.05.2016  Siemens Industry Online Support\n\t  //                      New function: reverse sort\n\t  // 01.01.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.01.02 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.01.03 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 02.00.00 29.01.2019  Siemens Industry Online Support\n\t  //                      Output \"done\" removed (not necessary, because only one cycle)\n\t  // 02.00.01 15.10.2019  Simatic Systems Support\n\t  //                      Code refactoring, comments added,\n\t  //                      change data type from Int to DInt\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Special description\n\t  // Space note: If you wish to reduce the space of this block, you may reduce the\n\t  // size OF the tempArray<Type> TO one just big enough FOR your specific purpose\n\t  // It is not recommended to increase the size significantly.\n\tEND_REGION\n\t\n\tREGION Initialization and input data processing\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // Array elements calculation\n\t  // (for example: 6 - 2 = 4; but real number of elements is 5)\n\t  #tempNoOfElements := #tempUpperLimit - #tempLowerLimit + #ELEMENTS_COUNT_CORRECTION;\n\t  \n\t  // Shift array index to range 1..MAX_ARRAY_ELEMENTS\n\t  #tempArrayOffset := - #tempLowerLimit + #ARRAY_START_INDEX;\n\t  \n\t  // Check whether the array contains less than the maximum possible amount of elements\n\t  IF #tempNoOfElements > #MAX_ARRAY_ELEMENTS THEN\n\t    #error := true;\n\t    #status := #ERR_TOO_MANY_ELEMENTS;\n\t    RETURN;\n\t  ELSIF #tempNoOfElements <= #SINGLE_ARRAY_ELEMENT THEN\n\t    // If there are 0 elements in the array, set status to \"Error: Parameter is an empty array\"\n\t    #error := true;\n\t    #status := #ERR_NO_ARRAY;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Sorting\n\t  // Read the elements of the incoming array and write into the local array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #tempArray[#tempLoopIndex + #tempArrayOffset] := #array[#tempLoopIndex];\n\t  END_FOR;\n\t  \n\t  REGION Shell sort algorithm\n\t    #tempGap := #GAP_INIT;\n\t    \n\t    // Evaluation of the maximal gap size\n\t    REPEAT\n\t      #tempGap := (#GAP_RATIO * #tempGap) + #INCREMENT;\n\t    UNTIL #tempGap > #tempNoOfElements END_REPEAT;\n\t    \n\t    REPEAT\n\t      #tempGap := #tempGap / #GAP_RATIO;\n\t      \n\t      FOR #tempLoopIndex := #tempGap + #INCREMENT TO #tempNoOfElements DO\n\t        #tempExchangeVariable := #tempArray[#tempLoopIndex];\n\t        #tempExchangeIndex := #tempLoopIndex;\n\t        \n\t        // sort descending \n\t        IF #sortDirection THEN\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] < #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t          \n\t          // sort ascending\n\t        ELSE\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] > #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t        END_IF;\n\t        \n\t        #tempArray[#tempExchangeIndex] := #tempExchangeVariable;\n\t      END_FOR;\n\t      \n\t    UNTIL #tempGap <= #GAP_THRESHOLD END_REPEAT;\n\t  END_REGION\n\t  \n\t  // Write the elements of the local array back to the inOut array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #array[#tempLoopIndex] := #tempArray[#tempLoopIndex + #tempArrayOffset];\n\t  END_FOR;\n\t  \n\t  // Set \"No error\" status\n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "IsValueInToleranceByTime", "description": "Checks if a given value is within a specified tolerance in percent of a given set point. The block has a configurable timing for set point change hiding, lower limit and as well for upper limit violation hiding.", "type": "FUNCTION_BLOCK", "name": "LGF_IsValueInToleranceByTime", "vars": [{"name": "value", "type": "Real", "description": "Value to check if in range of setpoint"}, {"name": "setpoint", "type": "Real", "description": "Setpoint"}, {"name": "lowerMinimum", "type": "Real", "description": "[% or ABS] Lower limit/tolerance of the setpoint in\npercent or absolut"}, {"name": "upperMaximum", "type": "Real", "description": "[% or ABS] Upper limit/tolerance of the setpoint in\npercent or absolut"}, {"name": "reset", "type": "Bool", "description": "Reset Block"}, {"name": "configuration", "type": "LGF_typeIsValueI\nn\nToleranceByTime\nConfiguration", "description": "Module related configuration parameters"}, {"name": "overHighLimit", "type": "Bool", "description": "TRUE: if value is above high limit"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE: if value is below low limit"}, {"name": "inLimits", "type": "Bool", "description": "TRUE: if value is in between the limits"}, {"name": "setpointChange", "type": "Bool", "description": "TRUE: when a setpoint change has been detected"}, {"name": "error", "type": "Bool", "description": "Error occured"}, {"name": "status", "type": "Word", "description": "Status of the function"}, {"name": "disableLimits", "type": "Bool", "description": "TRUE: Disable the monitoring timer. Leaving the\ntolerance triggers immediately"}, {"name": "limitsAsAbsolut\nValues", "type": "Bool", "description": "TRUE: Limit given as absolut value / FALSE: Limits\ngiven as tolerance from setpoint - absolut or perecent\nvalue"}, {"name": "toleranzAs\nAbsoluteValues", "type": "Bool", "description": "TRUE: Toleranze given as absolut value / FALSE:\nToleranze in percent from Setpoint"}, {"name": "upperLimit\nMonitoringTime", "type": "Time", "description": "Monitoring time for the upper limit violation"}, {"name": "lowerLimit\nMonitoringTime", "type": "Time", "description": "Monitoring time for the lower limit violation"}, {"name": "setpointChange\nMonitingTime", "type": "Time", "description": "Monitoring time for setpoint changes"}], "input": [{"name": "value", "type": "Real", "description": "Value to check if in range of setpoint"}, {"name": "setpoint", "type": "Real", "description": "Setpoint"}, {"name": "lowerMinimum", "type": "Real", "description": "[% or ABS] Lower limit/tolerance of the setpoint in\npercent or absolut"}, {"name": "upperMaximum", "type": "Real", "description": "[% or ABS] Upper limit/tolerance of the setpoint in\npercent or absolut"}, {"name": "reset", "type": "Bool", "description": "Reset Block"}, {"name": "configuration", "type": "LGF_typeIsValueI\nn\nToleranceByTime\nConfiguration", "description": "Module related configuration parameters"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE: if value is above high limit"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE: if value is below low limit"}, {"name": "inLimits", "type": "Bool", "description": "TRUE: if value is in between the limits"}, {"name": "setpointChange", "type": "Bool", "description": "TRUE: when a setpoint change has been detected"}, {"name": "error", "type": "Bool", "description": "Error occured"}, {"name": "status", "type": "Word", "description": "Status of the function"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_IsValueInToleranceByTime\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_IsValueInToleranceByTime\n   VAR_INPUT \n      value : Real;\n      setpoint : Real;\n      lowerMinimum : Real;\n      upperMaximum : Real;\n      reset : Bool;\n      configuration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : \"LGF_typeIsValueInToleranceByTimeConfiguration\";\n   END_VAR\n\n   VAR_OUTPUT \n      overHighLimit { ExternalWritable := 'False'} : Bool;\n      belowLowLimit { ExternalWritable := 'False'} : Bool;\n      inLimits { ExternalWritable := 'False'} : Bool;\n      setpointChange { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR \n      instMonitorUpper {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;\n      instMonitorLower {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;\n      instMonitorChange {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;\n      statSetpointPrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;\n      statResetPrev { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statSetpointChange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statWasWithinTolerance { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR_TEMP \n      tempValueOverHighLimit : Bool;\n      tempValueUnderLowLimit : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      ONE : Real := 1.0;\n      ONEHUNDRED_PERCENT : Real := 100.0;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_RANGE_LIMIT_VALUE_CALC : Word := 16#8401;\n      ERR_SETPOINT_ABOVE_HIGH_LIMIT : Word := 16#8402;\n      ERR_SETPOINT_BELOW_LOW_LIMIT : Word := 16#8403;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_IsValueInTolerance\n\t  // Comment/Function: Checks if a given value is within a specified tolerance in percent of a given set point.\n\t  //                   The block has a configurable timing FOR set point change hiding,\n\t  //                   lower limit AND as well FOR upper limit violation hiding.\n\t  // Library/Family:   LGF(Library of general Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V5.0\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 21.12.2023 | Siemens Industry Support\n\t  //                         First released version\n\t  //                         Copied snd extended from \"IsValueInRange\"\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and limits check\n\t  // Calculation of limits\n\t  IF #configuration.limitsAsAbsolutValues THEN\n\t    #tempValueOverHighLimit := #value > #upperMaximum;\n\t    #tempValueUnderLowLimit := #value < #lowerMinimum;\n\t  ELSE\n\t    IF #configuration.toleranzAsAbsoluteValues THEN\n\t      #tempValueOverHighLimit := #value > #setpoint + #upperMaximum;\n\t      #tempValueUnderLowLimit := #value < #setpoint - #lowerMinimum;\n\t    ELSE\n\t      #tempValueOverHighLimit := #value > (#setpoint * (#ONE + (ABS(#upperMaximum) / #ONEHUNDRED_PERCENT)));\n\t      #tempValueUnderLowLimit := #value < (#setpoint * (#ONE - (ABS(#lowerMinimum) / #ONEHUNDRED_PERCENT)));\n\t    END_IF;\n\t  END_IF;\n\t  \n\t  \n\t  // Detecting a change in the setpoint, thus resetting the was in tolerance flag\n\t  IF (#statSetpointPrevious <> #setpoint) THEN\n\t    #statWasWithinTolerance := FALSE;\n\t    #statSetpointChange := TRUE;\n\t  END_IF;\n\t  #statSetpointPrevious := #setpoint;\n\t  \n\t  IF FALSE\n\t    OR #configuration.disableLimits\n\t    OR (#reset AND NOT #statResetPrev)\n\t  THEN\n\t    #statWasWithinTolerance := FALSE;\n\t    #statSetpointChange := FALSE;\n\t  END_IF;\n\t  #statResetPrev := #reset;\n\t  \n\t  IF TRUE\n\t    AND NOT (#tempValueUnderLowLimit OR #tempValueOverHighLimit)\n\t    AND NOT #statWasWithinTolerance\n\t  THEN\n\t    #statWasWithinTolerance := TRUE;\n\t  END_IF;\n\t  \n\t  //Outside of data tolerance\n\t  IF ENO = false THEN\n\t    #error := true;\n\t    #status := #ERR_RANGE_LIMIT_VALUE_CALC;\n\t    #overHighLimit := false;\n\t    #belowLowLimit := false;\n\t    #inLimits := false;\n\t    RETURN;\n\t  ELSIF TRUE\n\t    AND #configuration.limitsAsAbsolutValues\n\t    AND #setpoint > #upperMaximum\n\t  THEN\n\t    #error := true;\n\t    #status := #ERR_SETPOINT_ABOVE_HIGH_LIMIT;\n\t    #overHighLimit := false;\n\t    #belowLowLimit := false;\n\t    #inLimits := false;\n\t    RETURN;\n\t  ELSIF TRUE\n\t    AND #configuration.limitsAsAbsolutValues\n\t    AND #setpoint < #lowerMinimum\n\t  THEN\n\t    #error := true;\n\t    #status := #ERR_SETPOINT_BELOW_LOW_LIMIT;\n\t    #overHighLimit := false;\n\t    #belowLowLimit := false;\n\t    #inLimits := false;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Limits evaluation\n\t  // Check if the value is above the high limit\n\t  // In here the upper limit monitor timer will be started once the upper limit is exceeded.\n\t  // The signal is triggered once the timer expired and the process value is still not within the limit.\n\t  // This requires that the process value was at least once within the limits\n\t  #instMonitorUpper.TON(IN := TRUE\n\t                        AND #tempValueOverHighLimit\n\t                        AND (#statWasWithinTolerance OR #instMonitorChange.Q)\n\t                        AND NOT #configuration.disableLimits\n\t                        ,\n\t                        PT := #configuration.upperLimitMonitoringTime);\n\t  \n\t  // Check if the value is below the low limit\n\t  // As above the signal is triggered, when the lower limit is not reached within a certain time\n\t  #instMonitorLower.TON(IN := TRUE\n\t                        AND #tempValueUnderLowLimit\n\t                        AND (#statWasWithinTolerance OR #instMonitorChange.Q)\n\t                        AND NOT #configuration.disableLimits\n\t                        ,\n\t                        PT := #configuration.lowerLimitMonitoringTime);\n\t  \n\t  #instMonitorChange.TON(IN := TRUE\n\t                         AND #statSetpointChange\n\t                         AND NOT #statWasWithinTolerance\n\t                         AND NOT #configuration.disableLimits\n\t                         ,\n\t                         PT := #configuration.setpointChangeMonitingTime);\n\t  \n\t  IF TRUE\n\t    //AND #instMonitorChange.Q\n\t    AND #statSetpointChange\n\t    AND #statWasWithinTolerance\n\t  THEN\n\t    #statSetpointChange := FALSE;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t  // Check if the value is in range and write outputs\n\t  #inLimits := TRUE\n\t  AND NOT (#instMonitorLower.Q OR #instMonitorUpper.Q)\n\t  AND NOT (#statSetpointChange AND NOT #instMonitorChange.Q)\n\t  AND #statWasWithinTolerance;\n\t  \n\t  #overHighLimit := #instMonitorUpper.Q;\n\t  #belowLowLimit := #instMonitorLower.Q;\n\t  #setpointChange := #statSetpointChange AND NOT #statWasWithinTolerance;\n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "DataLogC", "description": "LGF_DataLogC (C -> Compact) function integrates all the datalog system functions and can be used as standalone data logger.", "type": "FUNCTION_BLOCK", "name": "LGF_DataLogC", "vars": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "name", "type": "String", "description": "Name of datalog, also used as file name"}, {"name": "triggerLogEntry", "type": "Bool", "description": "Rising edge trigger one entry in data log (only if\n`parameter.isLoggingByInterval` := FALSE)"}, {"name": "clearLog", "type": "Bool", "description": "Rising edge triggering clearing of datalog file"}, {"name": "deleteLog", "type": "Bool", "description": "Rising edge triggering deletion of datalog file if exist"}, {"name": "parameter", "type": "LGF_typeDataLog\nParameter", "description": "This UDT belongs to the Module `LGF_DataLogC` and\nlists all possible parameter to configure its behaviour."}, {"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "writeEntryDone", "type": "Bool", "description": "TRUE: DataLog write done successfully"}, {"name": "clearLogDone", "type": "Bool", "description": "TRUE: DataLog clear done successfully"}, {"name": "deleteLogDone", "type": "Bool", "description": "TRUE: DataLog delete done successfully"}, {"name": "lastEntryReached", "type": "Bool", "description": "TRUE: Last entry of datalog reached, if `enableRingBuffer` is set,\nstart from beginning, otherwise block ends here"}, {"name": "noOfEntries", "type": "UDInt", "description": "Number of entries in datalog"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}, {"name": "data", "type": "Variant", "description": "Data structure to log in datalog file"}, {"name": "statNoOfEntries", "type": "UDInt", "description": "Number of entries in datalog"}, {"name": "statLlastEntry\nReached", "type": "Bool", "description": "TRUE: Last entry of datalog reached, if `enableRingBuffer` is\nset, start from beginning, otherwise block ends here"}, {"name": "header", "type": "String", "description": "Headline of datalog, string of all data fields, separated\nby a comma: \"field1,field2,field3,...\""}, {"name": "maxNumberOf\nEntries", "type": "UDInt", "description": "Maximum number of entries in datalog"}, {"name": "timestampFormat", "type": "USInt", "description": "Timestamp format - see manual in \"DataLogCreate\" for\nused PLC Type (S7-1200 or S7-1500)"}, {"name": "clearOnOpen", "type": "Bool", "description": "Clear datalog during opening datalog while enabling\nblock"}, {"name": "deleteFile", "type": "Bool", "description": "Delete as well datalog file during datalog delete"}, {"name": "enableRingBuffer", "type": "Bool", "description": "TRUE: Overwrite old values and start from the\nbeginning if datalog reaches its maximum entries\nFALSE: Stop logging if `maxNumberOfEntries` entries\nreached"}, {"name": "loggingBy\nInterval", "type": "Bool", "description": "TRUE: Log on interval time parameter\nFALSE: log on \"triggerEntry\""}, {"name": "loggingInterval", "type": "Time", "description": "Time for automatic logging interval"}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "name", "type": "String", "description": "Name of datalog, also used as file name"}, {"name": "triggerLogEntry", "type": "Bool", "description": "Rising edge trigger one entry in data log (only if\n`parameter.isLoggingByInterval` := FALSE)"}, {"name": "clearLog", "type": "Bool", "description": "Rising edge triggering clearing of datalog file"}, {"name": "deleteLog", "type": "Bool", "description": "Rising edge triggering deletion of datalog file if exist"}, {"name": "parameter", "type": "LGF_typeDataLog\nParameter", "description": "This UDT belongs to the Module `LGF_DataLogC` and\nlists all possible parameter to configure its behaviour."}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "writeEntryDone", "type": "Bool", "description": "TRUE: DataLog write done successfully"}, {"name": "clearLogDone", "type": "Bool", "description": "TRUE: DataLog clear done successfully"}, {"name": "deleteLogDone", "type": "Bool", "description": "TRUE: DataLog delete done successfully"}, {"name": "lastEntryReached", "type": "Bool", "description": "TRUE: Last entry of datalog reached, if `enableRingBuffer` is set,\nstart from beginning, otherwise block ends here"}, {"name": "noOfEntries", "type": "UDInt", "description": "Number of entries in datalog"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}], "in/out": [{"name": "data", "type": "Variant", "description": "Data structure to log in datalog file"}], "answer": "FUNCTION_BLOCK \"LGF_DataLogC\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_DataLogC\n   VAR_INPUT \n      enable : Bool;\n      \"name\" : String := 'DefaultDataLog';\n      triggerLogEntry : Bool;\n      clearLog : Bool;\n      deleteLog : Bool;\n      parameter { S7_HiddenAssignment := 'Hide'} : \"LGF_typeDataLogParameter\";\n   END_VAR\n\n   VAR_OUTPUT \n      valid { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      writeEntryDone { ExternalWritable := 'False'} : Bool;\n      clearLogDone { ExternalWritable := 'False'} : Bool;\n      deleteLogDone { ExternalWritable := 'False'} : Bool;\n      lastEntryReached { ExternalWritable := 'False'} : Bool;\n      noOfEntries { ExternalWritable := 'False'} : UDInt;\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR_IN_OUT \n      data : Variant;\n   END_VAR\n\n   VAR \n      statDataLogCommands { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         \"name\" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;\n         header { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;\n         id { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;\n         noOfRecords { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         timestampFormat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;\n         loggingInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;\n         clearOnOpen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;\n         enableRingBuffer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         isLoggingByInterval { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         edgeOnTriggerLogEntry { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         clearLogPrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         deleteLogPrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      END_STRUCT;\n      instIntervalTimer {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : IEC_TIMER;\n      instDataLogCreate {InstructionName := 'DataLogCreate'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : DataLogCreate;\n      instDataLogOpen {InstructionName := 'DataLogOpen'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : DataLogOpen;\n      instDataLogClose {InstructionName := 'DataLogClose'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : DataLogClose;\n      instDataLogWrite {InstructionName := 'DataLogWrite'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : DataLogWrite;\n      instDataLogClear {InstructionName := 'DataLogClear'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : DataLogClear;\n      instDataLogDelete {InstructionName := 'DataLogDelete'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : DataLogDelete;\n      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         enablePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         valid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorUserCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorAutoCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         disablingCompleted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\";\n      END_STRUCT;\n      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;\n   END_VAR\n   VAR RETAIN\n      statNoOfEntries { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt := 0;\n      statLlastEntryReached { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n   END_VAR\n   VAR \n      statWriteEntryDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR_TEMP \n      tempEnable : Bool;\n      tempExitStateLoop : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      FB_STATE_NO_PROCESSING : DInt := 0;\n      FB_STATE_DL_OPEN : DInt := 20;\n      FB_STATE_DL_CREATE : DInt := 21;\n      FB_STATE_DL_NEW : DInt := 22;\n      FB_STATE_DL_WAIT_FOR_TRIGGER : DInt := 30;\n      FB_STATE_DL_WAIT_FOR_WRITE_CYCLE : DInt := 31;\n      FB_STATE_DL_WRITE : DInt := 40;\n      FB_STATE_DL_CLEAR : DInt := 51;\n      FB_STATE_DL_CLEAR_DONE : DInt := 52;\n      FB_STATE_DL_DELETE : DInt := 53;\n      FB_STATE_DL_DELETE_DONE : DInt := 54;\n      FB_STATE_DISABLING : DInt := 90;\n      FB_STATE_DISABLING_COMPLETED : DInt := 91;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      STATUS_MAX_ENTRIES_REACHED : Word := 16#7010;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n      ERR_WRONG_COMMAND_CALL_ORDER : Word := 16#8401;\n      ERR_DATALOG_OPEN : Word := 16#8601;\n      ERR_DATALOG_CREATE : Word := 16#8602;\n      ERR_DATALOG_CLOSE : Word := 16#8603;\n      ERR_DATALOG_WRITE : Word := 16#8604;\n      ERR_DATALOG_CLEAR : Word := 16#8605;\n      ERR_DATALOG_DELETE : Word := 16#8605;\n      \"//- internal Error codes from sub functions\" : Word;\n      SUB_ERR_DATALOG_DOSE_NOT_EXIST : Word := 16#8092;\n      \"//- internal constants\" : Word;\n      DATALOG_DEFAULT_ID : Word := 16#0000;\n      DATALOG_NO_TIMESTAMP_FORMAT : USInt := 0;\n      DATALOG_LAST_ENTRY_WRITTEN : Word := 16#0001;\n      DATALOG_DELETE_OLD_ENTRIES : UInt := 1;\n      DATALOG_KEEP_OLD_ENTRIES : UInt := 0;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Siemens / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_DataLogC\n\t  // Comment/Function: LGF_DataLogC function integrates all the datalog system functions and can be used as standalone data logger (C -> Compact). \n\t  // Library/Family:   LGF - library of general functions\n\t  // Author:           Simatic Systems Support\n\t  // Tested with:      S7-1200 V4.3 / S7-1500 V2.8\n\t  // Engineering:      TIA Portal (V16)\n\t  // Restrictions:     Just one datalog is possible, after the log is full, a new one has to be created\n\t  //                   or using the log as ringbuffer and overwrite the oldest entries\n\t  //                   ENO not active because of Error and Status output\n\t  // Requirements:     -\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  //----------|------------|-------------------------|------------------------------\n\t  // 01.00.00 | 19.02.2022 | Simatic Systems Support | First released version\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION ENABLING/DISABLING\n\t  #tempEnable := #enable; // Work with temporary value / create process image\n\t  IF TRUE // wrong command call order during enabled\n\t    AND #tempEnable\n\t    AND (#statInternal.diagnostics.status = #STATUS_NO_CALL)\n\t    AND (#deleteLog OR #clearLog)\n\t  THEN\n\t    // set error in case of wrong command call order....\n\t    #statInternal.diagnostics.status := #ERR_WRONG_COMMAND_CALL_ORDER;\n\t    #statInternal.diagnostics.subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t    #statInternal.diagnostics.stateNumber := #statMainState;\n\t    #statInternal.errorAutoCleared := TRUE;\n\t    #statInternal.disablingCompleted := FALSE;\n\t    \n\t  ELSIF #tempEnable AND NOT #statInternal.enablePrevious AND (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Enable FB\n\t    // First call; initialize FB\n\t    #statInternal.valid := TRUE;\n\t    #statInternal.busy := TRUE;\n\t    #statInternal.error := FALSE;\n\t    #statInternal.errorUserCleared := FALSE;\n\t    #statInternal.errorAutoCleared := FALSE;\n\t    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;\n\t    #statInternal.diagnostics.subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t    #statInternal.diagnostics.stateNumber := 0;\n\t    #diagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.disablingCompleted := FALSE;\n\t    // State machine - start functionality\n\t    #statMainState := #FB_STATE_DL_OPEN;\n\t    \n\t    REGION Init block parameter\n\t      // Initialize functionality: reset of variables, diagnostics, etc.\n\t      // check all parameter if valid or not\n\t      #statWriteEntryDone := FALSE;\n\t      #statDataLogCommands.name := #name;\n\t      #statDataLogCommands.header := #parameter.header;\n\t      #statDataLogCommands.noOfRecords := #parameter.maxNumberOfEntries;\n\t      #statDataLogCommands.loggingInterval := #parameter.loggingInterval;\n\t      #statDataLogCommands.isLoggingByInterval := #parameter.loggingByInterval;\n\t      \n\t      // reset internal parameter\n\t      #statDataLogCommands.id := #DATALOG_DEFAULT_ID;\n\t      \n\t      #statDataLogCommands.timestampFormat := #parameter.timestampFormat;\n\t      //#statDataLogCommands.timestampFormat := #DATALOG_NO_TIMESTAMP_FORMAT;\n\t      \n\t      // check if datalog entries should be deleted on open file\n\t      IF #parameter.clearOnOpen THEN\n\t        #statDataLogCommands.clearOnOpen := #DATALOG_DELETE_OLD_ENTRIES;\n\t        // if Datalog has to be cleared, DataLogFull has to be reset as well\n\t        #statLlastEntryReached := FALSE;\n\t        #statNoOfEntries := 0;\n\t      ELSE\n\t        #statDataLogCommands.clearOnOpen := #DATALOG_KEEP_OLD_ENTRIES;\n\t      END_IF;\n\t      \n\t      #statDataLogCommands.enableRingBuffer := #parameter.enableRingBuffer;\n\t      // check if ringbuffer is deactivated and buffer is full\n\t      // if that is the case, do not overwrite and leave function here...\n\t      IF NOT #parameter.enableRingBuffer AND #statLlastEntryReached THEN\n\t        // set flag\n\t        #statInternal.diagnostics.status := #STATUS_MAX_ENTRIES_REACHED;\n\t        #statMainState := #FB_STATE_NO_PROCESSING;\n\t      END_IF;\n\t    END_REGION Init block parameter\n\t    \n\t    REGION Init subFunction calls\n\t      // just if previous parameter-check was successful\n\t      IF (#statMainState <> #FB_STATE_NO_PROCESSING) THEN\n\t        #instDataLogCreate(REQ := FALSE);\n\t        #instDataLogOpen(REQ := FALSE);\n\t        #instDataLogClose(REQ := FALSE);\n\t        #instDataLogWrite(REQ := FALSE);\n\t        #instDataLogClear(REQ := FALSE);\n\t        #instDataLogDelete(REQ := FALSE);\n\t      END_IF;\n\t    END_REGION Init subFunction calls\n\t    \n\t  ELSIF (#tempEnable = FALSE) AND (#statInternal.enablePrevious = TRUE) THEN // Disable FB \n\t    #statMainState := #FB_STATE_DISABLING;\n\t    \n\t  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN // Set status identifier of subsequent call\n\t    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t  END_IF;\n\t  \n\t  // Edge detection 'enable' input\n\t  #statInternal.enablePrevious := #tempEnable;\n\tEND_REGION ENABLING/DISABLING\n\t\n\tIF (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION Command evaluation\n\t  IF FALSE\n\t    OR #statMainState = #FB_STATE_NO_PROCESSING\n\t    OR (TRUE\n\t    AND #statMainState > #FB_STATE_DL_CREATE\n\t    AND #statMainState < #FB_STATE_DL_DELETE\n\t    )\n\t  THEN\n\t    // clear datalog requested\n\t    IF #clearLog AND NOT #statDataLogCommands.clearLogPrevious THEN\n\t      #statMainState := #FB_STATE_DL_CLEAR;\n\t      #statInternal.errorUserCleared := FALSE;\n\t      // delete datalog requested\n\t    ELSIF #deleteLog AND NOT #statDataLogCommands.deleteLogPrevious THEN\n\t      #statMainState := #FB_STATE_DL_DELETE;\n\t      #statInternal.errorAutoCleared := FALSE;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION STATE_MACHINE\n\t  \n\t  // if one ore more runs in the same cycle are necessary, set #tempStateChangeActive := TRUE;\n\t  REPEAT\n\t    // reset #tempExitStateLoop := TRUE; as its defined state to prevent endless loop\n\t    #tempExitStateLoop := TRUE;\n\t    \n\t    CASE #statMainState OF // State machine of FB\n\t      #FB_STATE_NO_PROCESSING:\n\t        REGION NO Processing\n\t          ; // No processing active (Note: this state must always be present and left empty)\n\t        END_REGION NO Processing\n\t        \n\t      #FB_STATE_DL_OPEN:\n\t        REGION DataLog open\n\t          #instDataLogOpen(REQ  := TRUE,\n\t                           MODE := #statDataLogCommands.clearOnOpen,\n\t                           NAME := #statDataLogCommands.name,\n\t                           ID   := #statDataLogCommands.id);\n\t          \n\t          // check if open DL is done successfully - goto write\n\t          IF #instDataLogOpen.DONE THEN\n\t            IF #statDataLogCommands.isLoggingByInterval THEN\n\t              #statMainState := #FB_STATE_DL_WRITE;\n\t            ELSE // is logging by trigger\n\t              #statMainState := #FB_STATE_DL_WAIT_FOR_TRIGGER;\n\t            END_IF;\n\t            // reset instance\n\t            #instDataLogOpen(REQ := FALSE);\n\t            \n\t            // check if error occurred\n\t          ELSIF #instDataLogOpen.ERROR THEN\n\t            // datalog do not exist --> Create\n\t            IF (#instDataLogOpen.STATUS = #SUB_ERR_DATALOG_DOSE_NOT_EXIST) THEN\n\t              #statMainState := #FB_STATE_DL_CREATE;\n\t              \n\t            ELSE // error not known, user have to act - leave block\n\t              #statInternal.diagnostics.status := #ERR_DATALOG_OPEN;\n\t              #statInternal.diagnostics.subfunctionStatus := #instDataLogOpen.STATUS;\n\t              #statInternal.diagnostics.stateNumber := #FB_STATE_DL_OPEN;\n\t              #statInternal.errorUserCleared := TRUE;\n\t            END_IF;\n\t            // reset instance\n\t            #instDataLogOpen(REQ := FALSE);\n\t          END_IF;\n\t        END_REGION DataLog open\n\t        \n\t      #FB_STATE_DL_CREATE:\n\t        REGION DataLog create\n\t          #instDataLogCreate(REQ       := TRUE,\n\t                             RECORDS   := #statDataLogCommands.noOfRecords,\n\t                             TIMESTAMP := #statDataLogCommands.timestampFormat,\n\t                             NAME      := #statDataLogCommands.name,\n\t                             ID        := #statDataLogCommands.id,\n\t                             HEADER    := #statDataLogCommands.header,\n\t                             DATA      := #data);\n\t          \n\t          // check if creating and opening DL is done successfully - goto write\n\t          IF #instDataLogCreate.DONE THEN\n\t            IF (#statDataLogCommands.isLoggingByInterval = TRUE) THEN\n\t              #statMainState := #FB_STATE_DL_WRITE;\n\t            ELSE // is logging by trigger\n\t              #statMainState := #FB_STATE_DL_WAIT_FOR_TRIGGER;\n\t            END_IF;\n\t            // reset instance\n\t            #instDataLogCreate(REQ := FALSE);\n\t            \n\t            // check if error occurred\n\t          ELSIF #instDataLogCreate.ERROR THEN\n\t            // error not known, user have to act\n\t            #statInternal.diagnostics.status := #ERR_DATALOG_CREATE;\n\t            #statInternal.diagnostics.subfunctionStatus := #instDataLogCreate.STATUS;\n\t            #statInternal.diagnostics.stateNumber := #FB_STATE_DL_OPEN;\n\t            #statInternal.errorUserCleared := TRUE;\n\t            // reset instance\n\t            #instDataLogCreate(REQ := FALSE);\n\t          END_IF;\n\t        END_REGION DataLog create\n\t        \n\t      #FB_STATE_DL_WAIT_FOR_TRIGGER,\n\t      #FB_STATE_DL_WAIT_FOR_WRITE_CYCLE:\n\t        REGION Wait for trigger\n\t          // reset flags\n\t          #statLlastEntryReached := FALSE;\n\t          #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t          \n\t          IF TRUE // if trigger has a rising edge\n\t            AND (#triggerLogEntry AND NOT #statDataLogCommands.edgeOnTriggerLogEntry)\n\t            AND (#statMainState = #FB_STATE_DL_WAIT_FOR_TRIGGER)\n\t          THEN\n\t            #statMainState := #FB_STATE_DL_WRITE;\n\t            \n\t          ELSIF TRUE // if interval is over\n\t            AND #instIntervalTimer.Q\n\t            AND (#statMainState = #FB_STATE_DL_WAIT_FOR_WRITE_CYCLE)\n\t          THEN\n\t            #statMainState := #FB_STATE_DL_WRITE;\n\t          END_IF;\n\t        END_REGION Wait for trigger \n\t        \n\t      #FB_STATE_DL_WRITE:\n\t        REGION DataLog write\n\t          #instDataLogWrite(REQ := TRUE,\n\t                            ID  := #statDataLogCommands.id);\n\t          \n\t          // check if datalog is at its last entry\n\t          IF (#instDataLogWrite.STATUS = #DATALOG_LAST_ENTRY_WRITTEN) THEN\n\t            // set flag\n\t            #statLlastEntryReached := TRUE;\n\t            #statInternal.diagnostics.status := #STATUS_MAX_ENTRIES_REACHED;\n\t            // increment counter\n\t            #statNoOfEntries += 1;\n\t            #statWriteEntryDone := TRUE;\n\t            \n\t            // check if datalog should be overwritten or not\n\t            IF #statDataLogCommands.enableRingBuffer THEN\n\t              // is logging by interval\n\t              IF #statDataLogCommands.isLoggingByInterval THEN\n\t                #statMainState := #FB_STATE_DL_WAIT_FOR_WRITE_CYCLE;\n\t                \n\t              ELSE // is logging by trigger\n\t                #statMainState := #FB_STATE_DL_WAIT_FOR_TRIGGER;\n\t              END_IF;\n\t              \n\t            ELSE // do not overwrite - disable and leave block\n\t              #statMainState := #FB_STATE_NO_PROCESSING;\n\t            END_IF;\n\t            // reset instance\n\t            #instDataLogWrite(REQ := FALSE);\n\t            #tempExitStateLoop := FALSE;\n\t            \n\t            // check if open DL is done successfully - goto write\n\t          ELSIF #instDataLogWrite.DONE THEN\n\t            // increment counter\n\t            #statNoOfEntries += 1;\n\t            #statWriteEntryDone := TRUE;\n\t            \n\t            IF #statDataLogCommands.isLoggingByInterval = TRUE THEN\n\t              #statMainState := #FB_STATE_DL_WAIT_FOR_WRITE_CYCLE;\n\t            ELSE // is logging by trigger\n\t              #statMainState := #FB_STATE_DL_WAIT_FOR_TRIGGER;\n\t            END_IF;\n\t            // reset instance\n\t            #instDataLogWrite(REQ := FALSE);\n\t            #tempExitStateLoop := FALSE;\n\t            \n\t            // check if error occurred\n\t          ELSIF #instDataLogWrite.ERROR THEN\n\t            // error not known, user have to act\n\t            #statInternal.diagnostics.status := #ERR_DATALOG_WRITE;\n\t            #statInternal.diagnostics.subfunctionStatus := #instDataLogWrite.STATUS;\n\t            #statInternal.diagnostics.stateNumber := #FB_STATE_DL_WRITE;\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statMainState := #FB_STATE_NO_PROCESSING;\n\t            // reset instance\n\t            #instDataLogWrite(REQ := FALSE);\n\t          END_IF;\n\t        END_REGION DataLog write\n\t        \n\t      #FB_STATE_DL_CLEAR:\n\t        REGION DataLog clear\n\t          #instDataLogClear(REQ := TRUE,\n\t                            ID  := #statDataLogCommands.id);\n\t          \n\t          // check if open DL is done successfully - goto write\n\t          IF #instDataLogClear.DONE THEN\n\t            #statMainState := #FB_STATE_DL_CLEAR_DONE;\n\t            // reset flag\n\t            #statLlastEntryReached := FALSE;\n\t            #statNoOfEntries := 0;\n\t            // reset instance\n\t            #instDataLogClear(REQ := FALSE);\n\t            \n\t            // check if error occurred\n\t          ELSIF #instDataLogClear.ERROR THEN\n\t            // error not known, user have to act\n\t            #statInternal.diagnostics.status := #ERR_DATALOG_CLEAR;\n\t            #statInternal.diagnostics.subfunctionStatus := #instDataLogClear.STATUS;\n\t            #statInternal.diagnostics.stateNumber := #FB_STATE_DL_CLEAR;\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statMainState := #FB_STATE_NO_PROCESSING;\n\t            // reset instance\n\t            #instDataLogWrite(REQ := FALSE);\n\t          END_IF;\n\t        END_REGION DataLog clear\n\t        \n\t      #FB_STATE_DL_CLEAR_DONE:\n\t        REGION DataLog clear done\n\t          IF NOT #clearLog THEN\n\t            IF #statDataLogCommands.isLoggingByInterval THEN\n\t              #statMainState := #FB_STATE_DL_WRITE;\n\t            ELSE\n\t              #statMainState := #FB_STATE_DL_WAIT_FOR_TRIGGER;\n\t            END_IF;\n\t          END_IF;\n\t        END_REGION DataLog clear\n\t        \n\t      #FB_STATE_DL_DELETE:\n\t        REGION DataLog delete\n\t          #instDataLogDelete(REQ     := TRUE,\n\t                             NAME    := #statDataLogCommands.name,\n\t                             DelFile := #parameter.deleteFile,\n\t                             ID      := #statDataLogCommands.id);\n\t          \n\t          // check if delete DL is done successfully - goto disable completed\n\t          IF #instDataLogDelete.DONE THEN\n\t            #statMainState := #FB_STATE_DL_DELETE_DONE;\n\t            // reset flag\n\t            #statLlastEntryReached := FALSE;\n\t            #statNoOfEntries := 0;\n\t            // reset instance\n\t            #instDataLogDelete(REQ := FALSE);\n\t            \n\t            // check if error occurred\n\t          ELSIF #instDataLogDelete.ERROR THEN\n\t            // error not known, user have to act\n\t            #statInternal.diagnostics.status := #ERR_DATALOG_DELETE;\n\t            #statInternal.diagnostics.subfunctionStatus := #instDataLogDelete.STATUS;\n\t            #statInternal.diagnostics.stateNumber := #FB_STATE_DL_DELETE;\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statMainState := #FB_STATE_NO_PROCESSING;\n\t            // reset instance\n\t            #instDataLogDelete(REQ := FALSE);\n\t          END_IF;\n\t        END_REGION DataLog delete\n\t        \n\t      #FB_STATE_DL_DELETE_DONE:\n\t        REGION DataLog delete done\n\t          IF NOT #deleteLog THEN\n\t            #statMainState := #FB_STATE_DISABLING_COMPLETED;\n\t          END_IF;\n\t        END_REGION DataLog delete\n\t        \n\t      #FB_STATE_DISABLING: // Disabling active\n\t        REGION Disabling\n\t          // closing DataLog\n\t          #instDataLogClose(REQ := TRUE,\n\t                            ID  := #statDataLogCommands.id);\n\t          \n\t          // check if datalog is closed\n\t          IF FALSE\n\t            OR #instDataLogClose.DONE\n\t            OR #instDataLogClose.STATUS = #SUB_ERR_DATALOG_DOSE_NOT_EXIST\n\t          THEN\n\t            #statMainState := #FB_STATE_DISABLING_COMPLETED;\n\t            #statInternal.diagnostics.status := #STATUS_FINISHED_NO_ERROR;\n\t            \n\t            // if closing ends with error - report this as well\n\t          ELSIF #instDataLogClose.ERROR THEN\n\t            // error occurred - copy to outputs\n\t            #statInternal.diagnostics.status := #ERR_DATALOG_CLOSE;\n\t            #statInternal.diagnostics.subfunctionStatus := #instDataLogClose.STATUS;\n\t            #statInternal.diagnostics.stateNumber := #FB_STATE_DISABLING;\n\t            #statInternal.errorAutoCleared := TRUE;// next state\n\t            #statMainState := #FB_STATE_DISABLING_COMPLETED;\n\t          END_IF;\n\t        END_REGION Disabling\n\t        \n\t      #FB_STATE_DISABLING_COMPLETED:\n\t        REGION Disabling completed\n\t          // reset instance\n\t          #instDataLogClose(REQ := FALSE);\n\t          // When disabling is complete the bit #statDisablingCompleted must be set\n\t          #statInternal.disablingCompleted := TRUE;\n\t        END_REGION Disabling completed\n\t        \n\t      ELSE // Undefined state in state machine reached\n\t        REGION Undefined state        \n\t          #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;\n\t          #statInternal.diagnostics.subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t          #statInternal.diagnostics.stateNumber := #statMainState;\n\t          #statInternal.errorUserCleared := TRUE;\n\t        END_REGION Undefined state\n\t    END_CASE;\n\t    \n\t    // call interval timer\n\t    #instIntervalTimer.TON(IN := (#statMainState = #FB_STATE_DL_WAIT_FOR_WRITE_CYCLE),\n\t                           PT := #statDataLogCommands.loggingInterval);    // if one ore more runs in the same cycle are necessary, set #tempExitStateLoop := FALSE;\n\t    // check state, if condition = TRUE --> #tempExitStateLoop = TRUE --> LEAVE LOOP\n\t  UNTIL (TRUE = #tempExitStateLoop)\n\t  END_REPEAT;\n\tEND_REGION STATE_MACHINE\n\t\n\tREGION Edge memory\n\t  // store/ reset edge memory\n\t  #statDataLogCommands.edgeOnTriggerLogEntry := #triggerLogEntry;\n\t  #statDataLogCommands.clearLogPrevious := #clearLog;\n\t  #statDataLogCommands.deleteLogPrevious := #deleteLog;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  IF (#statInternal.disablingCompleted = TRUE) THEN\n\t    REGION disabling\n\t      // Reset outputs if disabling completed\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := FALSE;\n\t      #statInternal.errorUserCleared := FALSE;\n\t      #statInternal.errorAutoCleared := FALSE;\n\t      #statInternal.diagnostics.status := #STATUS_NO_CALL;\n\t      // Reset application specific outputs\n\t      #statWriteEntryDone := FALSE;\n\t    END_REGION disabling\n\t    \n\t  ELSIF (#statInternal.errorUserCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION error user cleared\n\t      // Error can only be cleared by user; rising edge at enable input is needed to continue \n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // Reset application specific outputs\n\t      #statWriteEntryDone := FALSE;\n\t      // execution aborted --> set state no processing\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION error user cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION error auto cleared\n\t      // Error can be reset by FB automatically\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // Reset application specific outputs\n\t      #statWriteEntryDone := FALSE;\n\t    END_REGION error auto cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = FALSE) AND (#statInternal.errorUserCleared = FALSE) AND (#statInternal.error = TRUE) THEN\n\t    REGION after user/auto cleared\n\t      // If autocleared error is acknowledged\n\t      #statInternal.valid := TRUE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := FALSE;\n\t      // remove this line if more detailed status information is used instead of \"#STATUS_SUBSEQUENT_CALL\"\n\t      #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t    END_REGION after user/auto cleared\n\t  END_IF;\n\t  \n\t  REGION Write static values to outputs\n\t    #valid := #statInternal.valid;\n\t    #busy := #statInternal.busy;\n\t    #error := #statInternal.error;\n\t    #status := #statInternal.diagnostics.status;\n\t    // if ENO mechanism is not used / not wanted replace the following line by --> ENO := TRUE;\n\t    ENO := NOT #statInternal.error;\n\t    // Write application specific static values to outputs\n\t    #lastEntryReached := #statLlastEntryReached;\n\t    #noOfEntries := #statNoOfEntries;\n\t    \n\t    #writeEntryDone := #statWriteEntryDone;\n\t    #statWriteEntryDone := FALSE;\n\t    \n\t    #clearLogDone := #statMainState = #FB_STATE_DL_CLEAR_DONE;\n\t    #deleteLogDone := #statMainState = #FB_STATE_DL_DELETE_DONE;\n\t  END_REGION Write static values to outputs\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "BinaryToGray", "description": "This function converts a binary coded value into a Gray-coded value.", "type": "FUNCTION", "name": "LGF_BinaryToGray", "vars": [{"name": "variableBinary", "type": "DWord", "description": "Binary coded value to convert to Gray code"}, {"name": "Ret_Val", "type": "DWord", "description": "Gray-coded value"}], "input": [{"name": "variableBinary", "type": "DWord", "description": "Binary coded value to convert to Gray code"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_BinaryToGray\" : DWord\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_BinaryToGray\n   VAR_INPUT \n      variableBinary : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      BIT_SHIFT_1 : USInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_BinaryToGray\n\t  // Comment/Function: This function converts a binary value to a gray coded value\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V14 Update 1\n\t  // Restrictions:     ENO disabled - no error handling needed\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 19.08.2015 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 28.10.2015 | Siemens Industry Online Support\n\t  //                         Name changed\n\t  // 01.00.02 | 02.01.2017 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.03 | 17.08.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15 Update 2\n\t  // 01.00.04 | 23.11.2018 | Siemens Industry Online Support\n\t  //                         Upgrade: TIA V15.1\n\t  // 01.00.05 | 11.06.2019 | Simatic Systems Support\n\t  //                         Standard header and block parameters update\n\t  //                         Add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION OUTPUTS\n\t  #LGF_BinaryToGray := #variableBinary XOR SHR(IN := #variableBinary, N := #BIT_SHIFT_1);\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DWord"}]}
{"title": "AstroClock", "description": "This function calculates the times of sunrise and sunset based on the local time for a specific place on Earth. The exact position is transferred in the form of geographical GPS coordinates (longitude and latitude).", "type": "FUNCTION_BLOCK", "name": "LGF_AstroClock", "vars": [{"name": "enable", "type": "Bool", "description": "TRUE: Activates the functionality of the FB"}, {"name": "positionGps", "type": "LGF_typeGPS_DD", "description": "GPS position to calculate the time of sunrise and\nsunset"}, {"name": "offsetSunrise", "type": "Time", "description": "Offset to sunrise (added to sunrise time, considered at\n`isDaytime`, negative time allowed)"}, {"name": "offsetSunset", "type": "Time", "description": "Offset to sunset (added to sunset time, considered at\n`isDaytime`, negative time allowed)"}, {"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "actualLocalTime", "type": "DTL", "description": "Current time (local time)"}, {"name": "sunriseTime", "type": "DTL", "description": "Sunrise time (localtime)"}, {"name": "sunsetTime", "type": "DTL", "description": "Sunset time (localtime)"}, {"name": "isDaytime", "type": "Bool", "description": "TRUE: If the local time of the controller is between “sunrise” and\n“sunset”."}, {"name": "latitude", "type": "Real", "description": "Degrees latitude with decimal places\n(Unit: degree decimal), North = positive; South =\nnegative)\nvalid value range [-90.00000..90.00000]"}, {"name": "longitude", "type": "Real", "description": "Degrees longitude in degrees with decimal places\n(Unit: degree decimal), East = positive; West =\nnegative)\nvalid range [-180.0000..180.0000]"}], "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Activates the functionality of the FB"}, {"name": "positionGps", "type": "LGF_typeGPS_DD", "description": "GPS position to calculate the time of sunrise and\nsunset"}, {"name": "offsetSunrise", "type": "Time", "description": "Offset to sunrise (added to sunrise time, considered at\n`isDaytime`, negative time allowed)"}, {"name": "offsetSunset", "type": "Time", "description": "Offset to sunset (added to sunset time, considered at\n`isDaytime`, negative time allowed)"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "actualLocalTime", "type": "DTL", "description": "Current time (local time)"}, {"name": "sunriseTime", "type": "DTL", "description": "Sunrise time (localtime)"}, {"name": "sunsetTime", "type": "DTL", "description": "Sunset time (localtime)"}, {"name": "isDaytime", "type": "Bool", "description": "TRUE: If the local time of the controller is between “sunrise” and\n“sunset”."}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_AstroClock\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_AstroClock\n   VAR_INPUT \n      enable : Bool;\n      positionGps : \"LGF_typeGPS_DD\";\n      offsetSunrise : Time;\n      offsetSunset : Time;\n   END_VAR\n\n   VAR_OUTPUT \n      valid { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      subFunctionStatus { ExternalWritable := 'False'} : Word;\n      actualLocalTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;\n      sunriseTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;\n      sunsetTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;\n      isDaytime { ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR \n      statEnableOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statBusy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      statSubfunctionStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statLongitudeHour { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;\n      statLatitudeRadiant { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;\n   END_VAR\n\n   VAR_TEMP \n      tempRetval : Word;\n      tempSysTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempOfficLocTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempDate1Jan {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempSunrise {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempSunset {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempTimeZone : Real;\n      tempDayOfYear : Real;\n      tempAproximateTime : Real;\n      tempSunMeanAnomaly : Real;\n      tempSunLongitude : Real;\n      tempSunMeanRad : Real;\n      tempSunLongitudeRadiant : Real;\n      tempSunAscension : Real;\n      tempSunAscensRad : Real;\n      tempSinDeclination : Real;\n      tempCosDeclination : Real;\n      tempCosLocHourAngle : Real;\n      tempLocalHourAngle : Real;\n      tempLocalMeanTime : Real;\n      tempUTC : Real;\n      tempLocalTime : Real;\n   END_VAR\n\n   VAR CONSTANT \n      SUBSTATUS_DAYLIGHT_SAVING_TIME : Word := 16#0001;\n      NO_ERROR : Word := 16#0000;\n      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_IN_OPERATION : Word := 16#7001;\n      ERR_LATITUDE_VALUE : Word := 16#8204;\n      ERR_LONGITUDE_VALUE : Word := 16#8205;\n      ERR_RD_SYS_T : Word := 16#8601;\n      ERR_RD_LOC_T : Word := 16#8602;\n      DEGREE_0 : Real := 0.0;\n      DEGREE_15 : Real := 15.0;\n      DEGREE_90 : Real := 90.0;\n      DEGREE_180 : Real := 180.0;\n      DEGREE_360 : Real := 360.0;\n      PI : Real := 3.141593;\n      DEGREE_TO_RADIANT : Real := 0.01745329;\n      RADIANT_TO_DEGREE : Real := 57.29578;\n      SUN_ZENIT : LReal := 1.58534073722818;\n      MAX_MIN_OR_SEC_59 : UInt := 59;\n      SECONDS_PER_HOUR : Real := 3600.0;\n      MINUTES_PER_HOUR : Real := 60.0;\n      HOURS_PER_DAY : Real := 24.0;\n      MS_PER_HOUR : Real := 3600000.0;\n      TIME_ZERO {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      FIRST_MONTH_AND_DAY : USInt := 1;\n      APPROXIMATE_TIME_6 : Int := 6;\n      APPROXIMATE_TIME_18 : Int := 18;\n      SUN_MEAN_ANOMALY_0_9856 : Real := 0.9856;\n      SUN_MEAN_ANOMALY_3_289 : Real := 3.289;\n      SUN_TRUE_LONGITUDE_0_02 : Real := 0.02;\n      SUN_TRUE_LONGITUDE_1_916 : Real := 1.916;\n      SUN_TRUE_LONGITUDE_2_0 : Real := 2.0;\n      SUN_TRUE_LONGITUDE_282_634 : Real := 282.634;\n      SUN_RIGHT_ASCENSION_0_91764 : Real := 0.91764;\n      SUN_RIGHT_ASCENSION_2_0 : Real := 2.0;\n      SUN_RIGHT_ASCENSION_2_PI : Real := 6.283185;\n      SUN_DECLINATION_0_39782 : Real := 0.39782;\n      SUM_LOCAL_HOUR_ANGLE : Real := 1.0;\n      LOCAL_MEAN_TIME_0_06571 : Real := 0.06571;\n      LOCAL_MEAN_TIME_6_622 : Real := 6.622;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_AstroClock\n\t  // Comment/Function: Astronomical clock, optional offset, input format DD\n\t  //                   \"LGF_typeGPS_DD\" - GPS position as decimal degree\n\t  // Library/Family:   LGF\n\t  // Author:           Siemens Industry Online Support\n\t  // Tested with:      CPU1214C DC/DC/DC FW:V4.3\n\t  // Engineering:      TIA Portal (V15.1)\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 01.10.2015  Siemens Industry Online Support\n\t  //                      T_ADD instruction is replaced with \"+\"\n\t  // 01.00.02 16.11.2015  Siemens Industry Online Support\n\t  //                      \"offsetSunrise\", \"offsetSunset\" is calculated in\n\t  //                      \"daytime\"\n\t  //                      Bug fix at \"Adjust back TO UTC\"\n\t  // 01.01.00 07.06.2015  Siemens Industry Online Support\n\t  //                      Add output actSystemTime and actLocalTime\n\t  // 01.01.01 15.06.2015  Siemens Industry Online Support\n\t  //                      Add comments\n\t  // 01.01.02 04.01.2017  Siemens Industry Online Support\n\t  //                      Bug fix at calculation sunrise and sunset\n\t  // 01.01.03 20.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V14 Update 1\n\t  // 01.01.04 22.02.2017  Siemens Industry Online Support\n\t  //                      Code optimization\n\t  // 01.01.05 09.07.2018  Siemens Industry Online Support\n\t  //                      Initialize #tempIntSunrise, #tempIntSunset,#tempDate1Jan \n\t  // 01.01.06 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.01.07 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.08 30.08.2019  Simatic Systems Support\n\t  //                      Rename from Astro to AstroClock\n\t  //                      Update Type name to positionGps - \"LGF_typeGPS_DD\" - GPS position as decimal degree\n\t  //                      Refactoring of interface\n\t  //                      - one input type for GPS data\n\t  //                      - refactored for better usability\n\t  //                      - refactoring of whole block to \"ENABLE\" behavior\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Bug fix - not enabled - block still running\n\t  //                      Insert documentation\n\t  //===============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Extended description\n\t  // Function:\n\t  // Your position may be entered at LatitudeDD/LongitudeDD\n\t  // Format signed degree(decimal)\n\t  // \n\t  // OffsetSunrise is added to Latitude and output at Sunrise\n\t  // OffsetSunset is added to Longitude and output at Sunset\n\t  // \n\t  // daytime is set when the actual time is inbetween Sunrise and Sunset\n\t  // ============================================================================\n\t  // Advice:\n\t  // please take care that the system time is permanently synchronizes anyhow\n\t  // ============================================================================\n\t  // Abbreviations\n\t  // lon: Longitude\n\t  // lat: Latitude\n\t  // dir: direction (valid characters: n, N, s, S, e, E, w, W)\n\t  // DD: decimal degrees (type Real)\n\t  //=============================================================================\n\t  // If a faulty value is entered at LatitudeDD\n\t  // then the value of Sunrise is set to zero\n\t  // and the value of Sunset is set to zero\n\t  // and daytime is set to zero\n\tEND_REGION\n\t\n\tREGION Block processing\n\t  // rising edge at enable\n\t  IF (#enable AND NOT #statEnableOld) AND (#statStatus = #STATUS_NO_CALL) THEN // Enable FB\n\t    // First call; initialize FB - set BUSY to TRUE\n\t    #statBusy := TRUE;\n\t    #statStatus := #STATUS_IN_OPERATION;\n\t    #statSubfunctionStatus := #NO_ERROR;\n\t    \n\t    // falling edge at enable\n\t  ELSIF (NOT #enable AND #statEnableOld) THEN  // Disable FB \n\t    // disbaling FB; set BUSY to FALSE\n\t    #statBusy := FALSE;\n\t    #statStatus := #STATUS_NO_CALL;\n\t    #statSubfunctionStatus := #NO_ERROR;\n\t    \n\t    // just if block is in operation,\n\t    // otherwise jump over region -> End here to reduce \"system load\"\n\t  ELSIF (#enable AND #statEnableOld) THEN\n\t    REGION Process astro clock calculation\n\t      // reset internal status storage\n\t      #statStatus := #STATUS_IN_OPERATION;\n\t      #statSubfunctionStatus := #NO_ERROR;\n\t      \n\t      REGION System time, local time, time zone\n\t        // Reading system time UTC\n\t        #tempRetval := INT_TO_WORD(RD_SYS_T(#tempSysTime));\n\t        \n\t        IF (#tempRetval <> #NO_ERROR) THEN\n\t          #statStatus := #ERR_RD_SYS_T;\n\t          #statSubfunctionStatus := #tempRetval;\n\t        END_IF;\n\t        \n\t        // Reading official actual local time\n\t        #tempRetval := INT_TO_WORD(RD_LOC_T(#tempOfficLocTime));\n\t        \n\t        IF (#tempRetval <> #NO_ERROR) AND (#tempRetval <> #SUBSTATUS_DAYLIGHT_SAVING_TIME) THEN\n\t          #statStatus := #ERR_RD_LOC_T;\n\t          #statSubfunctionStatus := #tempRetval;\n\t        END_IF;\n\t        \n\t        // Calculation of time difference #tempSysTime - #tempOfficLocTime\n\t        #tempTimeZone := DINT_TO_REAL(TIME_TO_DINT(T_DIFF(IN1 := #tempSysTime, IN2 := #tempOfficLocTime))) / #MS_PER_HOUR;\n\t      END_REGION System time, local time, time zone\n\t      \n\t      REGION Day of the year\n\t        #tempDate1Jan.YEAR := #tempOfficLocTime.YEAR;\n\t        #tempDate1Jan.MONTH := #FIRST_MONTH_AND_DAY;\n\t        #tempDate1Jan.DAY := #FIRST_MONTH_AND_DAY;\n\t        #tempDayOfYear := UDINT_TO_REAL(DATE_TO_UDINT(DTL_TO_DATE(#tempOfficLocTime)) - DATE_TO_UDINT(DTL_TO_DATE(#tempDate1Jan)) + 1);\n\t      END_REGION Day of the year\n\t      \n\t      REGION input value check\n\t        // input latitude DD > 90°, set fault\n\t        IF (ABS(#positionGps.latitude) > #DEGREE_90) THEN\n\t          #statStatus := #ERR_LATITUDE_VALUE;\n\t        END_IF;\n\t        \n\t        // input longitude DD > 180°, set fault\n\t        IF (ABS(#positionGps.longitude) > #DEGREE_180) THEN\n\t          #statStatus := #ERR_LONGITUDE_VALUE;\n\t        END_IF;\n\t        \n\t        // Copy GPS DD values to work variables and the convert to work units\n\t        #statLatitudeRadiant := #positionGps.latitude * #DEGREE_TO_RADIANT;\n\t        #statLongitudeHour := #positionGps.longitude / #DEGREE_15;\n\t      END_REGION input value check      \n\t      \n\t      REGION Calculate Sunrise\n\t        // Aproximate time \n\t        #tempAproximateTime := #tempDayOfYear + (#APPROXIMATE_TIME_6 - #statLongitudeHour) / #HOURS_PER_DAY;\n\t        \n\t        // Sun's mean anomaly\n\t        #tempSunMeanAnomaly := #SUN_MEAN_ANOMALY_0_9856 * #tempAproximateTime - #SUN_MEAN_ANOMALY_3_289;\n\t        #tempSunMeanRad := #tempSunMeanAnomaly * #DEGREE_TO_RADIANT;\n\t        \n\t        // Sun's true longitude\n\t        #tempSunLongitude := #tempSunMeanAnomaly + #SUN_TRUE_LONGITUDE_282_634\n\t        + #SUN_TRUE_LONGITUDE_1_916 * SIN(#tempSunMeanRad)\n\t        + #SUN_TRUE_LONGITUDE_0_02 * SIN(#SUN_TRUE_LONGITUDE_2_0 * #tempSunMeanRad);\n\t        \n\t        WHILE #tempSunLongitude > #DEGREE_360 DO\n\t          #tempSunLongitude -= #DEGREE_360;\n\t        END_WHILE;\n\t        \n\t        WHILE #tempSunLongitude < #DEGREE_0 DO\n\t          #tempSunLongitude += #DEGREE_360;\n\t        END_WHILE;\n\t        \n\t        #tempSunLongitudeRadiant := #tempSunLongitude * #DEGREE_TO_RADIANT;\n\t        \n\t        // Sun's right ascension\n\t        #tempSunAscensRad := ATAN(#SUN_RIGHT_ASCENSION_0_91764 * TAN(#tempSunLongitudeRadiant));\n\t        \n\t        WHILE #tempSunAscensRad > #SUN_RIGHT_ASCENSION_2_PI DO\n\t          #tempSunAscensRad -= #SUN_RIGHT_ASCENSION_2_PI;\n\t        END_WHILE;\n\t        \n\t        WHILE #tempSunAscensRad < #DEGREE_0 DO\n\t          #tempSunAscensRad += #SUN_RIGHT_ASCENSION_2_PI;\n\t        END_WHILE;\n\t        \n\t        #tempSunAscension := #tempSunAscensRad * #RADIANT_TO_DEGREE;\n\t        #tempSunAscension := (#tempSunAscension\n\t        + DINT_TO_REAL(FLOOR(#tempSunLongitude / #DEGREE_90)) * #DEGREE_90\n\t        - DINT_TO_REAL(FLOOR(#tempSunAscension / #DEGREE_90)) * #DEGREE_90)\n\t        / #DEGREE_15;\n\t        \n\t        // Sun's declination\n\t        #tempSinDeclination := #SUN_DECLINATION_0_39782 * SIN(#tempSunLongitudeRadiant);\n\t        #tempCosDeclination := COS(ASIN(#tempSinDeclination));\n\t        \n\t        // Sun's local hour angle angle\n\t        #tempCosLocHourAngle := LREAL_TO_REAL(\n\t                                              (COS(#SUN_ZENIT) - REAL_TO_LREAL(#tempSinDeclination * SIN(#statLatitudeRadiant)))\n\t                                              / (#tempCosDeclination * COS(#statLatitudeRadiant))\n\t        );\n\t        \n\t        IF (#tempCosLocHourAngle > #SUM_LOCAL_HOUR_ANGLE) THEN\n\t          #tempCosLocHourAngle := #SUM_LOCAL_HOUR_ANGLE;\n\t        ELSIF (#tempCosLocHourAngle < - #SUM_LOCAL_HOUR_ANGLE) THEN\n\t          #tempCosLocHourAngle := - #SUM_LOCAL_HOUR_ANGLE;\n\t        END_IF;\n\t        \n\t        // Calculate local hour angle for sunrise\n\t        #tempLocalHourAngle := (#DEGREE_360 - ACOS(#tempCosLocHourAngle) * #RADIANT_TO_DEGREE) / #DEGREE_15;\n\t        \n\t        // Local mean time of rising/setting\n\t        #tempLocalMeanTime := #tempLocalHourAngle + #tempSunAscension - (#LOCAL_MEAN_TIME_0_06571 * #tempAproximateTime) - #LOCAL_MEAN_TIME_6_622;\n\t        \n\t        // Adjust back TO UTC\n\t        #tempUTC := #tempLocalMeanTime - #statLongitudeHour;\n\t        \n\t        IF (#tempUTC > #HOURS_PER_DAY) THEN\n\t          #tempUTC -= #HOURS_PER_DAY;\n\t        ELSIF (#tempUTC < 0) THEN\n\t          #tempUTC += #HOURS_PER_DAY;\n\t        END_IF;\n\t        \n\t        #tempLocalTime := #tempUTC - #tempTimeZone;\n\t        \n\t        IF (#tempLocalTime >= #HOURS_PER_DAY) THEN\n\t          #tempLocalTime -= DINT_TO_REAL(TRUNC(#tempLocalTime / #HOURS_PER_DAY)) * #HOURS_PER_DAY;\n\t        ELSIF (#tempLocalTime < 0) THEN\n\t          #tempLocalTime += #HOURS_PER_DAY;\n\t        END_IF;\n\t        \n\t        // Convert #tempLocalTime to DTL (#tempIntSunrise) and add offset\n\t        #tempSunrise.YEAR := #tempOfficLocTime.YEAR;\n\t        #tempSunrise.MONTH := #tempOfficLocTime.MONTH;\n\t        #tempSunrise.DAY := #tempOfficLocTime.DAY;\n\t        #tempSunrise := #tempSunrise + UDINT_TO_TIME(REAL_TO_UDINT(#tempLocalTime * #MS_PER_HOUR));\n\t        #tempSunrise.NANOSECOND := 0;\n\t        #tempSunrise += #offsetSunrise;\n\t      END_REGION Calculate Sunrise\n\t      \n\t      REGION Calculate Sunset\n\t        // Aproximate time \n\t        #tempAproximateTime := #tempDayOfYear + (#APPROXIMATE_TIME_18 - #statLongitudeHour) / #HOURS_PER_DAY;\n\t        \n\t        // Sun's mean anomaly\n\t        #tempSunMeanAnomaly := #SUN_MEAN_ANOMALY_0_9856 * #tempAproximateTime - #SUN_MEAN_ANOMALY_3_289;\n\t        #tempSunMeanRad := #tempSunMeanAnomaly * #DEGREE_TO_RADIANT;\n\t        \n\t        // Sun's true longitude\n\t        #tempSunLongitude := #tempSunMeanAnomaly + #SUN_TRUE_LONGITUDE_282_634\n\t        + #SUN_TRUE_LONGITUDE_1_916 * SIN(#tempSunMeanRad)\n\t        + #SUN_TRUE_LONGITUDE_0_02 * SIN(#SUN_TRUE_LONGITUDE_2_0 * #tempSunMeanRad);\n\t        \n\t        WHILE #tempSunLongitude > #DEGREE_360 DO\n\t          #tempSunLongitude -= #DEGREE_360;\n\t        END_WHILE;\n\t        \n\t        WHILE #tempSunLongitude < #DEGREE_0 DO\n\t          #tempSunLongitude += #DEGREE_360;\n\t        END_WHILE;\n\t        \n\t        #tempSunLongitudeRadiant := #tempSunLongitude * #DEGREE_TO_RADIANT;\n\t        \n\t        // Sun's right ascension\n\t        #tempSunAscensRad := ATAN(#SUN_RIGHT_ASCENSION_0_91764 * TAN(#tempSunLongitudeRadiant));\n\t        \n\t        WHILE #tempSunAscensRad > #SUN_RIGHT_ASCENSION_2_PI DO\n\t          #tempSunAscensRad -= #SUN_RIGHT_ASCENSION_2_PI;\n\t        END_WHILE;\n\t        \n\t        WHILE #tempSunAscensRad < #DEGREE_0 DO\n\t          #tempSunAscensRad += #SUN_RIGHT_ASCENSION_2_PI;\n\t        END_WHILE;\n\t        \n\t        #tempSunAscension := #tempSunAscensRad * #RADIANT_TO_DEGREE;\n\t        #tempSunAscension := (#tempSunAscension\n\t        + DINT_TO_REAL(FLOOR(#tempSunLongitude / #DEGREE_90)) * #DEGREE_90\n\t        - DINT_TO_REAL(FLOOR(#tempSunAscension / #DEGREE_90)) * #DEGREE_90)\n\t        / #DEGREE_15;\n\t        \n\t        // Sun's declination\n\t        #tempSinDeclination := #SUN_DECLINATION_0_39782 * SIN(#tempSunLongitudeRadiant);\n\t        #tempCosDeclination := COS(ASIN(#tempSinDeclination));\n\t        \n\t        // Sun's local hour angle\n\t        #tempCosLocHourAngle := LREAL_TO_REAL(\n\t                                              (COS(#SUN_ZENIT) - REAL_TO_LREAL(#tempSinDeclination * SIN(#statLatitudeRadiant)))\n\t                                              / (#tempCosDeclination * COS(#statLatitudeRadiant))\n\t        );\n\t        \n\t        IF (#tempCosLocHourAngle > #SUM_LOCAL_HOUR_ANGLE) THEN\n\t          #tempCosLocHourAngle := #SUM_LOCAL_HOUR_ANGLE;\n\t        ELSIF (#tempCosLocHourAngle < - #SUM_LOCAL_HOUR_ANGLE) THEN\n\t          #tempCosLocHourAngle := - #SUM_LOCAL_HOUR_ANGLE;\n\t        END_IF;\n\t        \n\t        // Calculation local hour angle for sunset\n\t        #tempLocalHourAngle := ACOS(#tempCosLocHourAngle) * #RADIANT_TO_DEGREE / #DEGREE_15;\n\t        \n\t        // Local mean time of rising/setting\n\t        #tempLocalMeanTime := #tempLocalHourAngle + #tempSunAscension - (#LOCAL_MEAN_TIME_0_06571 * #tempAproximateTime) - #LOCAL_MEAN_TIME_6_622;\n\t        \n\t        // Adjust back TO UTC\n\t        #tempUTC := #tempLocalMeanTime - #statLongitudeHour;\n\t        \n\t        IF (#tempUTC > #HOURS_PER_DAY) THEN\n\t          #tempUTC -= #HOURS_PER_DAY;\n\t        ELSIF (#tempUTC < 0) THEN\n\t          #tempUTC += #HOURS_PER_DAY;\n\t        END_IF;\n\t        \n\t        #tempLocalTime := #tempUTC - #tempTimeZone;\n\t        \n\t        IF (#tempLocalTime >= #HOURS_PER_DAY) THEN\n\t          #tempLocalTime -= DINT_TO_REAL(TRUNC(#tempLocalTime / #HOURS_PER_DAY)) * #HOURS_PER_DAY;\n\t        ELSIF (#tempLocalTime < 0) THEN\n\t          #tempLocalTime += #HOURS_PER_DAY;\n\t        END_IF;\n\t        \n\t        // Convert #tempLocalTime to DTL (#tempIntSunset) and add offset\n\t        #tempSunset.YEAR := #tempOfficLocTime.YEAR;\n\t        #tempSunset.MONTH := #tempOfficLocTime.MONTH;\n\t        #tempSunset.DAY := #tempOfficLocTime.DAY;\n\t        #tempSunset := #tempSunset + UDINT_TO_TIME(REAL_TO_UDINT(#tempLocalTime * #MS_PER_HOUR));\n\t        #tempSunset.NANOSECOND := 0;\n\t        #tempSunset += #offsetSunset;\n\t      END_REGION Calculate Sunset\n\t      \n\t    END_REGION Process astro clock calculation\n\t  END_IF;\n\t  \n\t  // Edge detection store 'enable' input to memory\n\t  #statEnableOld := #enable;\n\tEND_REGION Block processing\n\t\n\tREGION OUTPUTS\n\t  // Write application specific values to outputs\n\t  #actualLocalTime := #tempOfficLocTime;\n\t  #sunriseTime := #tempSunrise;\n\t  #sunsetTime := #tempSunset;\n\t  // Evaluate Day (between Sunrise and Sunset)\n\t  #isDaytime := (#tempOfficLocTime >= #tempSunrise) AND (#tempOfficLocTime <= #tempSunset);\n\t  \n\t  // Write static values to outputs\n\t  #valid := NOT #statStatus.%X15 AND #statBusy;\n\t  #busy := #statBusy;\n\t  #error := #statStatus.%X15;\n\t  #status := #statStatus;\n\t  #subFunctionStatus := #statSubfunctionStatus;\n\t  \n\t  // ENO is not used, forced to TRUE\n\t  ENO := TRUE;\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "FahrenheitToKelvin", "description": "This function converts a temperature value - from °Fahrenheit to °Kelvin.", "type": "FUNCTION", "name": "LGF_FahrenheitToKelvin", "vars": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Fahrenheit"}, {"name": "Ret_Val", "type": "Real", "description": "Converted temperature in °Kelvin"}], "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Fahrenheit"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_FahrenheitToKelvin\" : Real\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry_Support\nFAMILY : LGF\nNAME : LGF_FahrenheitToKelvin\n   VAR_INPUT \n      value : Real;\n   END_VAR\n\n   VAR_TEMP \n      tempKelvinTemperature : Real;\n   END_VAR\n\n   VAR CONSTANT \n      TEMPERATURE_GAIN : Real := 1.8;\n      TEMPERATURE_OFFSET_FAHRENHEIT : Real := 273.15;\n      TEMPERATURE_OFFSET : Real := 32.0;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_FahrenheitToKelvin\n\t  // Comment/Function: This function converts the Fahrenheit to Kelvin temperature\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO disabled - no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t  #tempKelvinTemperature := ((#value - #TEMPERATURE_OFFSET) / #TEMPERATURE_GAIN) + #TEMPERATURE_OFFSET_FAHRENHEIT;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_FahrenheitToKelvin := #tempKelvinTemperature;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Real"}]}
{"title": "ShiftRegister", "description": "The Function represents a shift register for any kind of Datatype (using variant). It is possible to shift the elements in the array at bufferRegister to the left (index array[n]:=array[n+1]) or right (index array[n]:=array[n-1]). It could be used for material tracking trough a machine or a process, e.g. for a rotary indexing table. Note As this is a real shift operation, it may cause some runtime effects while using big array sizes to move at the input bufferRegister. Please consider that a FIFO or LIFO storage, based on indexes, could be used as well for most applications.", "type": "FUNCTION_BLOCK", "name": "LGF_ShiftRegister", "vars": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "shiftLeft", "type": "Bool", "description": "Rising edge: Elements in the array `bufferRegister`\nshifted left.\nElements moved from index `N` to `N - 1`.\nThe element at index `N = 0`is overwritten"}, {"name": "shiftRight", "type": "Bool", "description": "Rising edge: Elements in the array `bufferRegister`\nshifted right.\nElements moved from index `N` to `N + 1`.\nThe element at index `N = lastIndex` is overwritten"}, {"name": "shiftRange", "type": "UInt", "description": "Number of places to be shifted in the `bufferRegister`\ninput array"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clear buffer elements in `bufferRegister` with\n`initalItem`"}, {"name": "fill", "type": "Bool", "description": "Overwrite buffer elements after shift operation.\n* `shiftLeft` - the most right element/s\n* `shiftRight` - the most left element/s\noverwritten by `initalItem`."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized\n(usually: `0` / default value)"}, {"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "leftShiftCount", "type": "DInt", "description": "Number of left shift operations since clearing"}, {"name": "rightShiftCount", "type": "DInt", "description": "Number of right shift operations since clearing"}, {"name": "shiftOffsetCounter", "type": "DInt", "description": "Offset of shift operations.\n`rightShift` - `leftShift`"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}, {"name": "bufferRegister", "type": "Variant", "description": "Buffer / Register memory as ARRAY, which keeps the data.\nThe data in the register is shifted left or right depending on the\ncommand."}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "shiftLeft", "type": "Bool", "description": "Rising edge: Elements in the array `bufferRegister`\nshifted left.\nElements moved from index `N` to `N - 1`.\nThe element at index `N = 0`is overwritten"}, {"name": "shiftRight", "type": "Bool", "description": "Rising edge: Elements in the array `bufferRegister`\nshifted right.\nElements moved from index `N` to `N + 1`.\nThe element at index `N = lastIndex` is overwritten"}, {"name": "shiftRange", "type": "UInt", "description": "Number of places to be shifted in the `bufferRegister`\ninput array"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clear buffer elements in `bufferRegister` with\n`initalItem`"}, {"name": "fill", "type": "Bool", "description": "Overwrite buffer elements after shift operation.\n* `shiftLeft` - the most right element/s\n* `shiftRight` - the most left element/s\noverwritten by `initalItem`."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized\n(usually: `0` / default value)"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "leftShiftCount", "type": "DInt", "description": "Number of left shift operations since clearing"}, {"name": "rightShiftCount", "type": "DInt", "description": "Number of right shift operations since clearing"}, {"name": "shiftOffsetCounter", "type": "DInt", "description": "Offset of shift operations.\n`rightShift` - `leftShift`"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}], "in/out": [{"name": "bufferRegister", "type": "Variant", "description": "Buffer / Register memory as ARRAY, which keeps the data.\nThe data in the register is shifted left or right depending on the\ncommand."}], "answer": "FUNCTION_BLOCK \"LGF_ShiftRegister\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry_Support\nFAMILY : LGF\nNAME : LGF_ShiftRegister\n   VAR_INPUT \n      enable : Bool;\n      shiftLeft : Bool;\n      shiftRight : Bool;\n      shiftRange { S7_PredefinedAssignment := '1'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : UInt := 1;\n      reset : Bool;\n      clear : Bool;\n      fill : Bool;\n      initialItem { S7_PredefinedAssignment := 'NULL'} : Variant;\n   END_VAR\n\n   VAR_OUTPUT \n      valid { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      leftShiftCount { ExternalWritable := 'False'} : DInt;\n      rightShiftCount { ExternalWritable := 'False'} : DInt;\n      shiftOffsetCounter { ExternalWritable := 'False'} : DInt;\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR_IN_OUT \n      bufferRegister : Variant;\n   END_VAR\n\n   VAR \n      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         enablePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         valid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorUserCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorAutoCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         disablingCompleted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\";\n         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\";\n      END_STRUCT;\n      statEdgesMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         shiftRight { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         shiftLeft { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         clear { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      END_STRUCT;\n      statBufferSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n      statLeftShiftCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 0;\n      statRightShiftCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 0;\n      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;\n   END_VAR\n\n   VAR_TEMP \n      tempEnable : Bool;\n      tempEdges : Struct\n         shiftLeft : Bool;\n         shiftRight : Bool;\n         reset : Bool;\n         clear : Bool;\n      END_STRUCT;\n      tempInternalError : Int;\n      tempCounter : DInt;\n      tempRepeatStateMaschine : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      NO_INTERNAL_ERROR : Int := 16#0000;\n      EMPTY_INITIALIZED : Int := 0;\n      INDEX_BEGINNING : Int := 0;\n      COUNT_ELEMENTS : UDInt := 1;\n      INCREMENT : Int := 1;\n      BUFFER_SIZE_CORRECTION : UDInt := 1;\n      COUNTER_LOWER_LIMIT : DInt := 0;\n      ZERO_ELEMENTS : DInt := 0;\n      FB_STATE_NO_PROCESSING : DInt := 0;\n      FB_STATE_ENABLING : DInt := 1;\n      FB_STATE_IDLE : DInt := 10;\n      FB_STATE_RESET : DInt := 11;\n      FB_STATE_CLEAR : DInt := 12;\n      FB_STATE_SHIFT_LEFT : DInt := 20;\n      FB_STATE_SHIFT_RIGHT : DInt := 30;\n      FB_STATE_DISABLING : DInt := 90;\n      STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_NO_CURRENT_JOBS : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      ERR_BUFFER_FULL : Word := 16#8002;\n      ERR_BUFFER_EMPTY : Word := 16#8001;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_CLEARING_WITHOUT_INITIAL_ITEM : Word := 16#8201;\n      ERR_FILL_WITHOUT_INITIAL_ITEM : Word := 16#8202;\n      ERR_WRONG_TYPE_INITIAL_ITEM : Word := 16#8203;\n      ERR_BOOL_NOT_SUPPORTED : Word := 16#8204;\n      ERR_MULTIPLE_COMMANDS_DEDECTED : Word := 16#8401;\n      ERR_IN_SHIFT_RANGE : Word := 16#8402;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n      ERR_CLEAR_BUFFER : Word := 16#8610;\n      ERR_SHIFT_BUFFER_LEFT : Word := 16#8611;\n      ERR_SHIFT_BUFFER_LEFT_FILL : Word := 16#8612;\n      ERR_SHIFT_BUFFER_RIGHT : Word := 16#8621;\n      ERR_SHIFT_BUFFER_RIGHT_FILL : Word := 16#8622;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ShiftRegister\n\t  // Comment/Function: The Function represnts a shift register for any kind of Datatype (using `variant`) - it can be used as a kind of a ring buffer.\n\t  //                   It is possible to shift the register array left (index `array[n]:=array[n+1]`) or right (index a`array[n]:=array[n-1]`).\n\t  //                   As this is a real shift operation, it may causes some runtime effects while using big array sizes to move.\n\t  //                   It could be used for pusing the material traking UDT trouf the maschin, e.g. a rotary indexing table\n\t  //                   Please consider that a FIFO  or LIFO storage, based on indexes, could be used as well for most applications.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V16 Update 4\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  //                   Bool array is not supported by `MOVE_BLK_VARIANT`\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 03.00.00 09.04.2021  Simatic Systems Support\n\t  //                      Refactoring and alignment to Datatype Variant\n\t  //                      Insert documentation\n\t  // 04.00.00 04.09.2024  Simatic Systems Support\n\t  //                      Rework to PLC Open `Enable` behavior\n\t  //                      Add `reset` input / counter outputs\n\t  //                      Fix Bug while filling after left shift operation\n\t  //                      Rework to diagnostic output datatype\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\t\n\tREGION ENABLING/DISABLING\n\t  #tempEnable := #enable; // Work with temporary value / create process image\n\t  IF (#tempEnable = TRUE) AND (#statInternal.diagnostics.status = #STATUS_NO_CURRENT_JOBS) THEN // Enable FB\n\t    // First call; initialize FB\n\t    #statInternal.valid := TRUE;\n\t    #statInternal.busy := TRUE;\n\t    #statInternal.error := FALSE;\n\t    #statInternal.errorUserCleared := FALSE;\n\t    #statInternal.errorAutoCleared := FALSE;\n\t    #statInternal.disablingCompleted := FALSE;\n\t    #statInternal.diagnostics := #statInternal.emptyDiagnostics;\n\t    #diagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;\n\t    // State machine - start processing\n\t    #statMainState := #FB_STATE_ENABLING;\n\t    \n\t  ELSIF (#tempEnable = FALSE) AND (#statInternal.enablePrevious = TRUE) THEN // Disable FB \n\t    #statMainState := #FB_STATE_DISABLING;\n\t    \n\t  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN // Set status identifier of subsequent call\n\t    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t  END_IF;\n\t  \n\t  // Edge detection 'enable' input\n\t  #statInternal.enablePrevious := #tempEnable;\n\tEND_REGION ENABLING/DISABLING\n\t\n\tIF (#statInternal.diagnostics.status = #STATUS_NO_CURRENT_JOBS) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION STATE MACHINE\n\t  REPEAT\n\t    #tempRepeatStateMaschine := FALSE;\n\t    \n\t    CASE #statMainState OF // State machine of FB\n\t      #FB_STATE_NO_PROCESSING:\n\t        REGION No Processing\n\t          ; // No processing active (Note: this state must always be present and left empty)\n\t        END_REGION No Processing\n\t        \n\t      #FB_STATE_ENABLING: // Enabling active\n\t        REGION Enabling\n\t          // check whether the item type is BOOL\n\t          // Bool is not supported by Systemfunction MOVE BLOCK VARIANT\n\t          IF FALSE\n\t            OR TypeOf(#initialItem) = Bool\n\t            OR TypeOfElements(#bufferRegister) = Bool\n\t          THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_BOOL_NOT_SUPPORTED;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          // check whether the ring #buffer is an ARRAY.\n\t          // IF so, the number OF the ARRAY elements is read out.\n\t          // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t          IF IS_ARRAY(#bufferRegister) THEN\n\t            #statBufferSize := CountOfElements(#bufferRegister);\n\t          ELSE\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_NO_ARRAY;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // check whether the initial value OF the ring #buffer\n\t          // matches the entry (tag #item). IF the data types DO NOT match,\n\t          // the program execution is terminated at this point\n\t          IF TRUE\n\t            AND (#initialItem <> NULL)\n\t            AND (TypeOfElements(#bufferRegister) <> TypeOf(#initialItem))\n\t          THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_WRONG_TYPE_INITIAL_ITEM;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // Store values for edge detection\n\t          #statEdgesMem.shiftLeft := #shiftLeft;\n\t          #statEdgesMem.shiftRight := #shiftRight;\n\t          #statEdgesMem.reset := #reset;\n\t          #statEdgesMem.clear := #clear;\n\t          \n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION Enabling\n\t        \n\t      #FB_STATE_IDLE:\n\t        REGION IDLE\n\t          // Collect edges\n\t          #tempEdges.shiftRight := #shiftRight AND NOT #statEdgesMem.shiftRight;\n\t          #tempEdges.shiftLeft := #shiftLeft AND NOT #statEdgesMem.shiftLeft;\n\t          #tempEdges.reset := #reset AND NOT #statEdgesMem.reset;\n\t          #tempEdges.clear := #clear AND NOT #statEdgesMem.clear;\n\t          // Store values for edge detection\n\t          #statEdgesMem.shiftRight := #shiftRight;\n\t          #statEdgesMem.shiftLeft := #shiftLeft;\n\t          #statEdgesMem.reset := #reset;\n\t          #statEdgesMem.clear := #clear;\n\t          \n\t          // Reset is allways possible\n\t          IF #tempEdges.reset THEN\n\t            #statMainState := #FB_STATE_RESET;\n\t            #tempRepeatStateMaschine := TRUE;\n\t            \n\t            // If error Pending - do nothing until error was reseted\n\t          ELSIF #statInternal.diagnostics.status.%X15 THEN\n\t            ;// Stay here and no further operation possible\n\t            \n\t            // Check if number of movements is in a plausible and valid range\n\t            // -> Has to be lees than the buffer size\n\t          ELSIF #shiftRange >= #statBufferSize THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_IN_SHIFT_RANGE;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // If Fill is activated, an inital item has to be present\n\t          ELSIF (#fill AND #initialItem = NULL) THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_FILL_WITHOUT_INITIAL_ITEM;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // If clearBuffer has rising edge, the buffer is initialized by initial values\n\t            // Check whether the initial value OF the ring #buffer\n\t            // matches the entry (tag #item). IF the data types DO NOT match,\n\t            // the program execution is terminated at this point\n\t          ELSIF (#tempEdges.clear AND #initialItem = NULL) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_CLEARING_WITHOUT_INITIAL_ITEM;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // If Fill is activated, an inital item has to be present\n\t          ELSIF (#fill AND #initialItem = NULL) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_FILL_WITHOUT_INITIAL_ITEM;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // Multiple commands dedected\n\t          ELSIF (BOOL_TO_INT(#tempEdges.clear) + BOOL_TO_INT(#tempEdges.shiftRight) + BOOL_TO_INT(#tempEdges.shiftLeft)) > 1 THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_MULTIPLE_COMMANDS_DEDECTED;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // Commands\n\t          ELSIF #tempEdges.clear THEN\n\t            #statMainState := #FB_STATE_CLEAR;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSIF #tempEdges.shiftRight THEN\n\t            #statMainState := #FB_STATE_SHIFT_RIGHT;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSIF #tempEdges.shiftLeft THEN\n\t            #statMainState := #FB_STATE_SHIFT_LEFT;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSE\n\t            #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t          END_IF;\n\t        END_REGION IDLE\n\t        \n\t      #FB_STATE_CLEAR:\n\t        REGION CLEARING\n\t          // Reset status\n\t          #statInternal.errorAutoCleared := FALSE;\n\t          \n\t          FOR #tempCounter := #COUNTER_LOWER_LIMIT TO UDINT_TO_DINT(#statBufferSize - #BUFFER_SIZE_CORRECTION) DO\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #tempCounter,\n\t                                                   DEST => #bufferRegister);\n\t            \n\t            // Checks whether a local error has occurred.\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t              #statInternal.errorAutoCleared := TRUE;\n\t              #statInternal.diagnostics.status := #ERR_CLEAR_BUFFER;\n\t              #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t              EXIT;\n\t            END_IF;\n\t          END_FOR;\n\t          IF #statInternal.errorAutoCleared THEN\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // Reset counters\n\t          #statLeftShiftCount :=\n\t          #statRightShiftCount := #EMPTY_INITIALIZED;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_RESET:\n\t        REGION RESET\n\t          // Reset Error Auto Cleared\n\t          #statInternal.errorAutoCleared := FALSE;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_SHIFT_LEFT:\n\t        REGION SHIFT_LEFT\n\t          // Shift whole array elemnts from N --> N-1\n\t          #tempInternalError := MOVE_BLK_VARIANT(SRC := #bufferRegister,\n\t                                                 COUNT := #statBufferSize - #shiftRange,\n\t                                                 SRC_INDEX := #shiftRange,\n\t                                                 DEST_INDEX := 0,\n\t                                                 DEST => #bufferRegister);\n\t          \n\t          // Check whether a local error has occurred\n\t          IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_SHIFT_BUFFER_LEFT;\n\t            #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          REGION Fill after shift left\n\t            IF #fill THEN\n\t              // Run through buffer and overwrite all elements with its initial item element\n\t              FOR #tempCounter := UDINT_TO_DINT(#statBufferSize - #shiftRange) TO UDINT_TO_DINT(#statBufferSize - #BUFFER_SIZE_CORRECTION) DO\n\t                // Overwrite the \"old\" values after shift\n\t                #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                       COUNT := #COUNT_ELEMENTS,\n\t                                                       SRC_INDEX := #INDEX_BEGINNING,\n\t                                                       DEST_INDEX := #tempCounter,\n\t                                                       DEST => #bufferRegister);\n\t                \n\t                // Check whether a local error has occurred\n\t                IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                  #statInternal.errorAutoCleared := TRUE;\n\t                  #statInternal.diagnostics.status := #ERR_SHIFT_BUFFER_LEFT_FILL;\n\t                  #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t                  EXIT;\n\t                END_IF;\n\t              END_FOR;\n\t              IF #statInternal.errorAutoCleared THEN\n\t                EXIT;\n\t              END_IF;\n\t            END_IF;\n\t          END_REGION Fill after shift left\n\t          \n\t          // This program code section increments the index by 1 for shifting.    \n\t          #statLeftShiftCount += #INCREMENT;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_SHIFT_RIGHT:\n\t        REGION SHIFT_RIGHT\n\t          // Shift whole array elemnsts from N --> N+1\n\t          #tempInternalError := MOVE_BLK_VARIANT(SRC := #bufferRegister,\n\t                                                 COUNT := #statBufferSize - #shiftRange,\n\t                                                 SRC_INDEX := #INDEX_BEGINNING,\n\t                                                 DEST_INDEX := #shiftRange,\n\t                                                 DEST => #bufferRegister);\n\t          \n\t          // Check whether a local error has occurred\n\t          IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_SHIFT_BUFFER_RIGHT;\n\t            #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t            RETURN;\n\t          END_IF;\n\t          \n\t          REGION Fill after shift right\n\t            IF #fill THEN\n\t              // Run through buffer and overwrite all elements with its initial item element\n\t              FOR #tempCounter := #INDEX_BEGINNING TO UDINT_TO_DINT(#shiftRange - #BUFFER_SIZE_CORRECTION) DO\n\t                // Overwrite the \"old\" values after shift\n\t                #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                       COUNT := #COUNT_ELEMENTS,\n\t                                                       SRC_INDEX := #INDEX_BEGINNING,\n\t                                                       DEST_INDEX := #tempCounter,\n\t                                                       DEST => #bufferRegister);\n\t                \n\t                // Check whether a local error has occurred\n\t                IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                  #statInternal.errorAutoCleared := TRUE;\n\t                  #statInternal.diagnostics.status := #ERR_SHIFT_BUFFER_RIGHT_FILL;\n\t                  #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t                  EXIT;\n\t                END_IF;\n\t              END_FOR;\n\t              IF #statInternal.errorAutoCleared THEN\n\t                EXIT;\n\t              END_IF;\n\t            END_IF;\n\t          END_REGION Fill after shift right\n\t          \n\t          // This program code section increments the index by 1 for shifting.    \n\t          #statRightShiftCount += #INCREMENT;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_DISABLING: // Disabling active\n\t        REGION Disabling\n\t          // Disabling is complete the bit #statDisablingCompleted must be set\n\t          #statInternal.disablingCompleted := TRUE;\n\t        END_REGION Disabling\n\t        \n\t      ELSE // Undefined state in state machine reached\n\t        REGION Undefined state\n\t          #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;\n\t          #statInternal.diagnostics.subfunctionStatus := 16#00;\n\t          #statInternal.diagnostics.stateNumber := #statMainState;\n\t          #statInternal.errorUserCleared := TRUE;\n\t        END_REGION Undefined state\n\t    END_CASE;\n\t  UNTIL #tempRepeatStateMaschine = false END_REPEAT;\n\tEND_REGION STATE MACHINE\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  IF (#statInternal.disablingCompleted = TRUE) THEN\n\t    REGION Disabling\n\t      // Reset outputs if disabling completed\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := FALSE;\n\t      #statInternal.errorUserCleared := FALSE;\n\t      #statInternal.errorAutoCleared := FALSE;\n\t      #statInternal.diagnostics.status := #STATUS_NO_CURRENT_JOBS;\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION Disabling\n\t    \n\t  ELSIF (#statInternal.errorUserCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION Error user cleared\n\t      // Error can only be cleared by user; rising edge at enable input is needed to continue \n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // Execution aborted --> set state no processing\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION Error user cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION Error auto cleared\n\t      // Error can be reset by FB automatically\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // Handling of autocleared error\n\t      #statMainState := #FB_STATE_IDLE;\n\t      #tempRepeatStateMaschine := TRUE;\n\t    END_REGION Error auto cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = FALSE) AND (#statInternal.errorUserCleared = FALSE) AND (#statInternal.error = TRUE) THEN\n\t    REGION After user/auto cleared or command aborted\n\t      // If autocleared error is acknowledged\n\t      #statInternal.valid := TRUE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := FALSE;\n\t      #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t    END_REGION After user/auto cleared or command aborted\n\t  END_IF;\n\t  \n\t  REGION Write static values to outputs\n\t    #valid := #statInternal.valid;\n\t    #busy := #statInternal.busy;\n\t    #error := #statInternal.error;\n\t    #status := #statInternal.diagnostics.status;\n\t    // if ENO mechanism is not used / error /& Status output present\n\t    ENO := TRUE;\n\t    // Write application specific static values to outputs\n\t    #leftShiftCount := #statLeftShiftCount;\n\t    #rightShiftCount := #statRightShiftCount;\n\t    #shiftOffsetCounter := #rightShiftCount - #leftShiftCount;\n\t  END_REGION Write static values to outputs\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "GetCalendarWeek", "description": "This function uses the specified date to calculate the calendar week and the number of days that have passed since the beginning of the year for the USA and many other countries.", "type": "FUNCTION", "name": "LGF_GetCalendarWeek_US", "vars": [{"name": "date", "type": "DTL", "description": "Date used to calculate the calendar week and days since 1 January"}, {"name": "Ret_Val", "type": "DInt", "description": "Number of the calendar week."}, {"name": "calendarDay", "type": "DInt", "description": "Days past since January 1st on given date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}], "input": [{"name": "date", "type": "DTL", "description": "Date used to calculate the calendar week and days since 1 January"}], "output": [{"name": "calendarDay", "type": "DInt", "description": "Days past since January 1st on given date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_GetCalendarWeek_US\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_GetCalendarWeek_US\n   VAR_INPUT \n      \"date\" {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n   END_VAR\n\n   VAR_OUTPUT \n      calendarDay : DInt;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempDate {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempCurrentYearWeekday1Jan : UDInt;\n      tempNextYearWeekday1Jan : UDInt;\n      tempCurrentYearWeekday31Dec : UDInt;\n      tempPrevYearWeekday1Jan : UDInt;\n      tempPrevYearWeekday31Dec : UDInt;\n      tempDaysCorr : DInt;\n      tempWeek : DInt;\n      tempDays : DInt;\n      tempCurrentYearIsLeapyear : Bool;\n      tempPrevYearIsLeapyear : Bool;\n      tempYearCurrentYear : UInt;\n      tempYearPrevYear : UInt;\n      tempYearNextYear : UInt;\n      tempIsCurrentYearWith53Weeks : Bool;\n      tempIsPrevYearWith53Weeks : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      SUNDAY : UDInt := 1;\n      MONDAY : UDInt := 2;\n      TUESDAY : UDInt := 3;\n      WEDNESDAY : UDInt := 4;\n      THURSDAY : UDInt := 5;\n      FRIDAY : UDInt := 6;\n      SATURDAY : UDInt := 7;\n      FIRST_DAY : USInt := 1;\n      LAST_DAY : USInt := 31;\n      JANUARY : USInt := 1;\n      DECEMBER : USInt := 12;\n      ONE_YEAR : UInt := 1;\n      ONE_DAY : DInt := 1;\n      TWO_DAYS : DInt := 2;\n      THREE_DAYS : DInt := 3;\n      FOUR_DAYS : DInt := 4;\n      FIVE_DAYS : DInt := 5;\n      SEVEN_DAYS : DInt := 7;\n      ONE_WEEK : DInt := 1;\n      WEEK_1 : DInt := 1;\n      WEEK_52 : DInt := 52;\n      WEEK_53 : DInt := 53;\n      WEEK_54 : DInt := 54;\n      LEAP_YEAR_CHECK_4 : UInt := 4;\n      LEAP_YEAR_CHECK_100 : UInt := 100;\n      LEAP_YEAR_CHECK_400 : UInt := 400;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_LIM_DATE : Word := 16#8201;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_GetCalendarWeek_US\n\t  // Comment/Function: This function calculates the week number for USA and other countries.\n\t  //                   - new week starts with Sunday\n\t  //                   - the week wich contains the 1st January is always week number 1\n\t  //                   - a year has 52 or 53 weeks\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V14 Upd 1\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 13.11.2019  Simatic Systems Support\n\t  //                      First release\n\t  //                      based on spli from  LGF_CalenderWeek (previously LGF_CalenderWeek_ISO)\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 19.01.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION\n\t  #tempDays := 0;\n\t  #tempWeek := 0;\n\tEND_REGION\n\t\n\tREGION COUNT DAYS\n\t  // Days passed in the year since 1st January, \"date\" included\n\t  #tempDays := \"LGF_GetCalendarDay\"(\"date\" := #date, error => #error, status => #status);\n\t  IF #error THEN\n\t    #LGF_GetCalendarWeek_US := #tempWeek;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION COUNT WEEKS\n\t  // Year of actual year, previous year and next year\n\t  #tempYearCurrentYear := #date.YEAR;\n\t  #tempYearPrevYear := #date.YEAR - #ONE_YEAR;\n\t  #tempYearNextYear := #date.YEAR + #ONE_YEAR;\n\t  \n\t  // Check if current year is a leap year (29. February/366 days)\n\t  #tempCurrentYearIsLeapyear := (((#tempYearCurrentYear MOD #LEAP_YEAR_CHECK_4 = 0) AND NOT (#tempYearCurrentYear MOD #LEAP_YEAR_CHECK_100 = 0)) OR (#tempYearCurrentYear MOD #LEAP_YEAR_CHECK_400 = 0));\n\t  // Check if previous year is a leap year (29. February/366 days)\n\t  #tempPrevYearIsLeapyear := (((#tempYearPrevYear MOD #LEAP_YEAR_CHECK_4 = 0) AND NOT (#tempYearPrevYear MOD #LEAP_YEAR_CHECK_100 = 0)) OR (#tempYearPrevYear MOD #LEAP_YEAR_CHECK_400 = 0));\n\t  \n\t  // Weekday of 1st January in the current year\n\t  #tempDate := #date;\n\t  #tempDate.MONTH := #JANUARY;\n\t  #tempDate.DAY := #FIRST_DAY;\n\t  #tempDate := #tempDate + T#0ms;\n\t  #tempCurrentYearWeekday1Jan := #tempDate.WEEKDAY;\n\t  \n\t  // Weekday of 1st January in the next year\n\t  #tempDate.YEAR := #tempYearNextYear;\n\t  #tempDate.MONTH := #JANUARY;\n\t  #tempDate.DAY := #FIRST_DAY;\n\t  #tempDate := #tempDate + T#0ms;\n\t  #tempNextYearWeekday1Jan := #tempDate.WEEKDAY;\n\t  \n\t  // Weekday of 31st December in the current year\n\t  #tempDate := #date;\n\t  #tempDate.MONTH := #DECEMBER;\n\t  #tempDate.DAY := #LAST_DAY;\n\t  #tempDate := #tempDate + T#0ms;\n\t  #tempCurrentYearWeekday31Dec := #tempDate.WEEKDAY;\n\t  \n\t  // Weekday of 1st January in the previous year\n\t  #tempDate.YEAR := #tempYearPrevYear;\n\t  #tempDate.MONTH := #JANUARY;\n\t  #tempDate.DAY := #FIRST_DAY;\n\t  #tempDate := #tempDate + T#0ms;\n\t  #tempPrevYearWeekday1Jan := #tempDate.WEEKDAY;\n\t  \n\t  // Weekday of 31st December in the previous year\n\t  #tempDate.YEAR := #tempYearPrevYear;\n\t  #tempDate.MONTH := #DECEMBER;\n\t  #tempDate.DAY := #LAST_DAY;\n\t  #tempDate := #tempDate + T#0ms;\n\t  #tempPrevYearWeekday31Dec := #tempDate.WEEKDAY;\n\t  \n\t  // Calculate the week number for USA and other countries\n\t  // - new week begins whith Sunday\n\t  // - the week wich contains the 1st January is allways week number 1\n\t  // - a year has 52 or 53 weeks\n\t  \n\t  // Correction of the number of #tempDays depending on the weekday of 1st January\n\t  CASE #tempCurrentYearWeekday1Jan OF\n\t    #SUNDAY:\n\t      #tempDaysCorr := #tempDays - #ONE_DAY;\n\t    #MONDAY:\n\t      #tempDaysCorr := #tempDays;\n\t    #TUESDAY:\n\t      #tempDaysCorr := #tempDays + #ONE_DAY;\n\t    #WEDNESDAY:\n\t      #tempDaysCorr := #tempDays + #TWO_DAYS;\n\t    #THURSDAY:\n\t      #tempDaysCorr := #tempDays + #THREE_DAYS;\n\t    #FRIDAY:\n\t      #tempDaysCorr := #tempDays + #FOUR_DAYS;\n\t    #SATURDAY:\n\t      #tempDaysCorr := #tempDays + #FIVE_DAYS;\n\t  END_CASE;\n\t  // calculate the number of the week\n\t  #tempWeek := #tempDaysCorr / #SEVEN_DAYS + #ONE_WEEK;\n\t  \n\t  // Check if current year has 53 weeks\n\t  #tempIsCurrentYearWith53Weeks := (NOT #tempCurrentYearIsLeapyear AND (#tempCurrentYearWeekday1Jan = #SATURDAY AND #tempCurrentYearWeekday31Dec = #SATURDAY)) OR\n\t  (#tempCurrentYearIsLeapyear AND ((#tempCurrentYearWeekday1Jan = #SATURDAY AND #tempCurrentYearWeekday31Dec = #SUNDAY) OR (#tempCurrentYearWeekday1Jan = #FRIDAY AND #tempCurrentYearWeekday31Dec = #SATURDAY)));\n\t  \n\t  // Correct the week number depending on wheter the current year has 53 weeks\n\t  IF #tempWeek = #WEEK_53 THEN\n\t    IF #tempIsCurrentYearWith53Weeks THEN\n\t      #tempWeek := #WEEK_53;\n\t    ELSE\n\t      #tempWeek := #WEEK_1;\n\t    END_IF;\n\t  END_IF;\n\t  \n\t  IF #tempWeek = #WEEK_54 THEN\n\t    #tempWeek := #WEEK_1;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #calendarDay := #tempDays;\n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERROR;\n\t  #LGF_GetCalendarWeek_US := #tempWeek;\n\t  \n\t  // ENO is not used, forced to TRUE\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DInt"}]}
{"title": "Random", "description": "This function generates a random value with each call. The random number has the data type DInt.", "type": "FUNCTION", "name": "LGF_Random_DInt", "vars": [{"name": "Ret_Val", "type": "DInt", "description": "Random number in the DInt range"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION \"LGF_Random_DInt\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_Random_DInt\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n      subfunctionStatus : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempNanoSecondInDWord : DWord;\n      tempTimeStatus : Word;\n      tempRandomValue : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : DInt;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_RD_SYS_T : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_Random_DInt\n\t  // Comment/Function: Generates a random number in the DInt Range\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 13.11.2019  Siemens Industry Presales Support\n\t  //                      First release\n\t  //                      copied from \"LGF_Random_Real\"\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 04.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Validation\n\t  // Read system time\n\t  #tempTimeStatus := INT_TO_WORD(RD_SYS_T(#tempTime));\n\t  \n\t  // Check return variable for error\n\t  IF (#tempTimeStatus <> #SUB_STATUS_NO_ERROR) THEN\n\t    #error := true;\n\t    #status := #ERR_RD_SYS_T;\n\t    #subfunctionStatus := #tempTimeStatus;\n\t    #LGF_Random_DInt := #ZERO;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating random number\n\t  // Converting to double word so individual bytes can be addressed\n\t  #tempNanoSecondInDWord := UDINT_TO_DWORD(#tempTime.NANOSECOND);\n\t  \n\t  // Calculate a random-start-value depending on the time\n\t  #tempRandomValue.%B3 := #tempNanoSecondInDWord.%B0;\n\t  #tempRandomValue.%B2 := #tempNanoSecondInDWord.%B1;\n\t  #tempRandomValue.%B1 := #tempNanoSecondInDWord.%B2;\n\t  #tempRandomValue.%B0 := #tempNanoSecondInDWord.%B3;\n\t  \n\t  #LGF_Random_DInt := DWORD_TO_DINT(#tempRandomValue);\n\t  \n\t  #error := false;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DInt"}]}
{"title": "CalcCRC32Advanced", "description": "The CRC calculation is used for error detection at data transmission. The result of a calculation returns a CRC value via the data sent. The receiver detects a faulty transmission due to the unequal CRC value. The function LGF_CalcCRC32Advanced uses 32 bits as the generator polynomial (mask) and the parameters finalXorValue, reflectInput, and reflectResult.", "type": "FUNCTION", "name": "LGF_CalcCRC32Advanced", "vars": [{"name": "initValue", "type": "DWord", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "DWord", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "finalXorValue", "type": "DWord", "description": "Value with which another XOR operation is performed at the end"}, {"name": "reflectInput", "type": "Bool", "description": "TRUE: the sequence of the bits within the input byte is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "reflectResult", "type": "Bool", "description": "TRUE: the order of the bits within the result is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation\n0 = all elements / the whole array"}, {"name": "Ret_Val", "type": "DWord", "description": "Calculated CRC value (return value of the function)."}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated."}], "input": [{"name": "initValue", "type": "DWord", "description": "Start value with which the calculation is executed.\nIf there is no need for start value - assign 16#00"}, {"name": "mask", "type": "DWord", "description": "Generator polynomial with which the calculation is executed.\n(Mask / CRC polynomial)"}, {"name": "finalXorValue", "type": "DWord", "description": "Value with which another XOR operation is performed at the end"}, {"name": "reflectInput", "type": "Bool", "description": "TRUE: the sequence of the bits within the input byte is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "reflectResult", "type": "Bool", "description": "TRUE: the order of the bits within the result is mirrored. The\nsequence 0...7 becomes 7...0."}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation\n0 = all elements / the whole array"}], "output": [{"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated."}], "answer": "FUNCTION \"LGF_CalcCRC32Advanced\" : DWord\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_CRC32Advanced\n   VAR_INPUT \n      initValue { S7_PredefinedAssignment := '16#00'} : DWord;\n      mask { S7_PredefinedAssignment := '16#00'} : DWord;\n      finalXorValue { S7_PredefinedAssignment := '16#00'} : DWord;\n      reflectInput { S7_PredefinedAssignment := 'FALSE'} : Bool;\n      reflectResult { S7_PredefinedAssignment := 'FALSE'} : Bool;\n      noOfElements { S7_PredefinedAssignment := '0'} : UInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of Byte;\n   END_VAR\n\n   VAR_TEMP \n      tempInput : Byte;\n      tempCRC : DWord;\n      tempInvCRC : DWord;\n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempIndexArray : DInt;\n      tempIndexCRC : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      SHIFT_ONE_BIT : UInt := 1;\n      SHIFT_THREE_BYTE : UInt := 24;\n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      CRC_LOOP_LOWER_LIMIT : DInt := 0;\n      CRC_LOOP_UPPER_LIMIT : DInt := 7;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_OF_ELEMENTS : Word := 16#8400;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_CRC32Advanced\n\t  // Comment/Function: This function makes a CRC calculation according\n\t  //                   to the CRC-32 algorithm\n\t  //                   advanced because of reflect In/Out and final XOR combination\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - no error handling, no failure possible\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.03 09.10.2019  Simatic Systems Support\n\t  //                      Code refactoring, comments added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //                      Assign default start values to optional inputs - `initValue`, `mask`, `finalXorValue`, `reflectInput`, `reflectResult`\n\t  // 03.01.00 14.04.2023  Simatic Systems Support\n\t  //                      Add input `noOfElements` to assign length to be converted different from array size \n\t  //                      Add outputs `error` and `status` display a wrong assignment to `noOfElements`\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and input data processing\n\t  // Defining initial value for algorithm\n\t  #tempCRC := #initValue;\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // check paramter `noOfELements`, if gretaer than zero check if fits to array size\n\t  IF #noOfElements > 0 THEN\n\t    IF #noOfElements > (#tempUpperLimit - #tempLowerLimit + 1) THEN\n\t      #status := #ERR_NO_OF_ELEMENTS;\n\t      #error := TRUE;\n\t      ENO := FALSE;\n\t      #LGF_CalcCRC32Advanced := #tempCRC;\n\t      RETURN;\n\t    ELSE\n\t      #tempUpperLimit := #tempLowerLimit + #noOfElements - 1;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION CRC calculation\n\t  FOR #tempIndexArray := #tempLowerLimit TO #tempUpperLimit DO\n\t    \n\t    IF #reflectInput THEN\n\t      // Reverse bit order in input byte\n\t      #tempInput.%X7 := #array[#tempIndexArray].%X0;\n\t      #tempInput.%X6 := #array[#tempIndexArray].%X1;\n\t      #tempInput.%X5 := #array[#tempIndexArray].%X2;\n\t      #tempInput.%X4 := #array[#tempIndexArray].%X3;\n\t      #tempInput.%X3 := #array[#tempIndexArray].%X4;\n\t      #tempInput.%X2 := #array[#tempIndexArray].%X5;\n\t      #tempInput.%X1 := #array[#tempIndexArray].%X6;\n\t      #tempInput.%X0 := #array[#tempIndexArray].%X7;\n\t    ELSE\n\t      #tempInput := #array[#tempIndexArray];\n\t    END_IF;\n\t    \n\t    // Perform division using XOR function for appropriate DWord in array (with shift byte into MSB of 32bit CRC)\n\t    #tempCRC := #tempCRC XOR SHL(IN := BYTE_TO_DWORD(#tempInput), N := #SHIFT_THREE_BYTE);\n\t    \n\t    FOR #tempIndexCRC := #CRC_LOOP_LOWER_LIMIT TO #CRC_LOOP_UPPER_LIMIT DO\n\t      // Check if MSB is set\n\t      IF #tempCRC.%X31 THEN\n\t        // Shift left and perform division by mask polynomial using XOR function\n\t        #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT) XOR #mask;\n\t      ELSE\n\t        // Shift left without division\n\t        #tempCRC := SHL(IN := #tempCRC, N := #SHIFT_ONE_BIT);\n\t      END_IF;\n\t    END_FOR;\n\t    \n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Outputs assignment\n\t  IF #reflectResult THEN\n\t    // Reverse bit order in CRC checksum\n\t    #tempInvCRC.%X31 := #tempCRC.%X0;\n\t    #tempInvCRC.%X30 := #tempCRC.%X1;\n\t    #tempInvCRC.%X29 := #tempCRC.%X2;\n\t    #tempInvCRC.%X28 := #tempCRC.%X3;\n\t    #tempInvCRC.%X27 := #tempCRC.%X4;\n\t    #tempInvCRC.%X26 := #tempCRC.%X5;\n\t    #tempInvCRC.%X25 := #tempCRC.%X6;\n\t    #tempInvCRC.%X24 := #tempCRC.%X7;\n\t    #tempInvCRC.%X23 := #tempCRC.%X8;\n\t    #tempInvCRC.%X22 := #tempCRC.%X9;\n\t    #tempInvCRC.%X21 := #tempCRC.%X10;\n\t    #tempInvCRC.%X20 := #tempCRC.%X11;\n\t    #tempInvCRC.%X19 := #tempCRC.%X12;\n\t    #tempInvCRC.%X18 := #tempCRC.%X13;\n\t    #tempInvCRC.%X17 := #tempCRC.%X14;\n\t    #tempInvCRC.%X16 := #tempCRC.%X15;\n\t    #tempInvCRC.%X15 := #tempCRC.%X16;\n\t    #tempInvCRC.%X14 := #tempCRC.%X17;\n\t    #tempInvCRC.%X13 := #tempCRC.%X18;\n\t    #tempInvCRC.%X12 := #tempCRC.%X19;\n\t    #tempInvCRC.%X11 := #tempCRC.%X20;\n\t    #tempInvCRC.%X10 := #tempCRC.%X21;\n\t    #tempInvCRC.%X9 := #tempCRC.%X22;\n\t    #tempInvCRC.%X8 := #tempCRC.%X23;\n\t    #tempInvCRC.%X7 := #tempCRC.%X24;\n\t    #tempInvCRC.%X6 := #tempCRC.%X25;\n\t    #tempInvCRC.%X5 := #tempCRC.%X26;\n\t    #tempInvCRC.%X4 := #tempCRC.%X27;\n\t    #tempInvCRC.%X3 := #tempCRC.%X28;\n\t    #tempInvCRC.%X2 := #tempCRC.%X29;\n\t    #tempInvCRC.%X1 := #tempCRC.%X30;\n\t    #tempInvCRC.%X0 := #tempCRC.%X31;\n\t    \n\t    #LGF_CalcCRC32Advanced := #tempInvCRC XOR #finalXorValue;\n\t  ELSE\n\t    #LGF_CalcCRC32Advanced := #tempCRC XOR #finalXorValue;\n\t  END_IF;\n\t  \n\t  #status := #STATUS_NO_ERROR;\n\t  #error := FALSE;\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DWord"}]}
{"title": "StoreMinMax", "description": "This function reads-in a value of a variable at each call and outputs the maximum and minimum value that has been read in since the first call. The evaluation can be reset if necessary. The block supports the data type LReal.", "type": "FUNCTION_BLOCK", "name": "LGF_StoreMinMax", "vars": [{"name": "value", "type": "LReal", "description": "Value to be compared with min/max"}, {"name": "reset", "type": "Bool", "description": "TRUE: The min/max history is reset and the evaluation\nstarts over again."}, {"name": "minValue", "type": "LReal", "description": "Minimum value since first call or `reset`."}, {"name": "maxValue", "type": "LReal", "description": "Maximum values since first call or `reset`."}], "input": [{"name": "value", "type": "LReal", "description": "Value to be compared with min/max"}, {"name": "reset", "type": "Bool", "description": "TRUE: The min/max history is reset and the evaluation\nstarts over again."}], "output": [{"name": "minValue", "type": "LReal", "description": "Minimum value since first call or `reset`."}, {"name": "maxValue", "type": "LReal", "description": "Maximum values since first call or `reset`."}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_StoreMinMax\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_MinMaxHistory\n   VAR_INPUT \n      value : LReal := 0.0;\n      reset : Bool := false;\n   END_VAR\n\n   VAR_OUTPUT \n      minValue { ExternalWritable := 'False'} : LReal := 0.0;\n      maxValue { ExternalWritable := 'False'} : LReal := 0.0;\n   END_VAR\n\n   VAR \n      statStoreMinValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := #LREAL_MAX;\n      statStoreMaxValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := #LREAL_MIN;\n   END_VAR\n\n   VAR CONSTANT \n      LREAL_MAX : LReal := 1.7976931348623157e+308;\n      LREAL_MIN : LReal := -1.7976931348623157e+308;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_MinMaxHistory\n\t  // Comment/Function: This function block saves the minimum and maximum value,\n\t  //                   since the start of the block.\n\t  //                   ENO disabled - no error handling, no failure possible\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     -\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  //                      Code optimization\n\t  // 01.00.02 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.03 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.04 09.10.2019  Simatic Systems Support\n\t  //                      Regions, comments and constants are added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 04.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION\n\t\n\tREGION Compare values\n\t  // Save min value\n\t  IF (#value < #statStoreMinValue) THEN\n\t    #statStoreMinValue := #value;\n\t  END_IF;\n\t  \n\t  // Save max value\n\t  IF (#value > #statStoreMaxValue) THEN\n\t    #statStoreMaxValue := #value;\n\t  END_IF;\n\t  \n\t  // If reset is TRUE, min and max value are set to #LREAL_MAX and #LREAL_MIN respectively\n\t  IF #reset THEN\n\t    #statStoreMinValue := #LREAL_MAX;\n\t    #statStoreMaxValue := #LREAL_MIN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  #minValue := #statStoreMinValue;\n\t  #maxValue := #statStoreMaxValue;\n\t  \n\t  //ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "LIFO", "description": "LIFO (Last-In First-Out / Stack buffer memory) This function stores incoming data and outputs the latest/most recent not-yet-processed data.", "type": "FUNCTION_BLOCK", "name": "LGF_LIFO", "vars": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "push", "type": "Bool", "description": "Push item to the buffer"}, {"name": "pop", "type": "Bool", "description": "Pop item from the buffer"}, {"name": "peek", "type": "Bool", "description": "Peek item from the buffer (buffer not changed/modified)"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value\n`initialItem` (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized\n(usually: `0` / default value)"}, {"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "TRUE: Buffer is empty"}, {"name": "isFull", "type": "Bool", "description": "TRUE: Buffer is full"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}, {"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the\nbuffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer. (Array of…)"}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "push", "type": "Bool", "description": "Push item to the buffer"}, {"name": "pop", "type": "Bool", "description": "Pop item from the buffer"}, {"name": "peek", "type": "Bool", "description": "Peek item from the buffer (buffer not changed/modified)"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value\n`initialItem` (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized\n(usually: `0` / default value)"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "TRUE: Buffer is empty"}, {"name": "isFull", "type": "Bool", "description": "TRUE: Buffer is full"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}], "in/out": [{"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the\nbuffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer. (Array of…)"}], "answer": "FUNCTION_BLOCK \"LGF_LIFO\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_LIFO\n   VAR_INPUT \n      enable : Bool;\n      push : Bool := false;\n      pop : Bool := false;\n      peek : Bool := false;\n      reset : Bool;\n      clear : Bool;\n      initialItem : Variant;\n   END_VAR\n\n   VAR_OUTPUT \n      valid { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      elementCount { ExternalWritable := 'False'} : DInt;\n      isEmpty { ExternalWritable := 'False'} : Bool;\n      isFull { ExternalWritable := 'False'} : Bool;\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR_IN_OUT \n      item : Variant;\n      buffer : Variant;\n   END_VAR\n\n   VAR \n      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         enablePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         valid { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorUserCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         errorAutoCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         disablingCompleted { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\";\n         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\";\n      END_STRUCT;\n      statEdgesMem { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         push { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         pop { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         peek { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         clear { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      END_STRUCT;\n      statBufferSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n      statLastItemIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := -1;\n      statElementCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;\n   END_VAR\n\n   VAR_TEMP \n      tempEnable : Bool;\n      tempEdges : Struct\n         push : Bool;\n         pop : Bool;\n         peek : Bool;\n         clear : Bool;\n         reset : Bool;\n      END_STRUCT;\n      tempInternalError : Int;\n      tempNewFirstItemIndex : Int;\n      tempNewNextEmptyItemIndex : Int;\n      tempCounter : Int;\n      tempRepeatStateMaschine : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      BUFFER_IS_EMPTY : Int := -1;\n      NO_INTERNAL_ERROR : Int := 0;\n      BUFFER_INITIALIZED : Int := -1;\n      EMPTY_INITIALIZED : Int := 0;\n      INDEX_BEGINNING : Int := 0;\n      COUNT_ELEMENTS : UDInt := 1;\n      INCREMENT : Int := 1;\n      BUFFER_SIZE_CORRECTION : UDInt := 1;\n      COUNTER_LOWER_LIMIT : Int := 0;\n      ZERO_ELEMENTS : DInt := 0;\n      FB_STATE_NO_PROCESSING : DInt := 0;\n      FB_STATE_ENABLING : DInt := 1;\n      FB_STATE_IDLE : DInt := 10;\n      FB_STATE_RESET : DInt := 11;\n      FB_STATE_CLEAR : DInt := 12;\n      FB_STATE_PUSH : DInt := 20;\n      FB_STATE_PEEK : DInt := 30;\n      FB_STATE_POP : DInt := 31;\n      FB_STATE_DISABLING : DInt := 90;\n      STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_NO_CURRENT_JOBS : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      ERR_BUFFER_EMPTY : Word := 16#8001;\n      ERR_BUFFER_FULL : Word := 16#8002;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_WRONG_TYPE_ITEM : Word := 16#8201;\n      ERR_WRONG_TYPE_INITIAL_ITEM : Word := 16#8202;\n      ERR_BOOL_NOT_SUPPORTED : Word := 16#8203;\n      ERR_MULTIPLE_COMMANDS_DEDECTED : Word := 16#8204;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n      ERR_INDEX_IN_ARRAY_LIMITS_1 : Word := 16#8601;\n      ERR_INDEX_IN_ARRAY_LIMITS_2 : Word := 16#8602;\n      ERR_CLEAR_BUFFER : Word := 16#8610;\n      ERR_RETURN_LAST_ENTRY : Word := 16#8611;\n      ERR_POP_REPLACE_ITEM_BY_INIT_VALUE : Word := 16#8612;\n      ERR_WRITE_ENTRY : Word := 16#8613;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_LIFO\n\t  // Comment/Function: LIFO (Last-In First-Out / Stack buffer memory)  \n\t  //                   The function stores incoming data and outputs\n\t  //                   the latest/most recent NOT-yet-processed data.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  //                   Bool array is not supported by `MOVE_BLK_VARIANT`\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 10.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 02.00.00 29.01.2019  Siemens Industry Online Support\n\t  //                      Output \"done\" removed (not necessary, because block works synchronous)\n\t  // 03.00.00 22.10.2019  Simatic Systems Support\n\t  //                      Code refactoring, comments added\n\t  //                      Interface change (push, pop, peek etc.)\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  // 04.00.00 04.09.2024  Simatic Systems Support\n\t  //                      Rework to PLC Open `Enable` behavior\n\t  //                      Add `isFull` outputs\n\t  //                      Rework to diagnostic output datatype\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION ENABLING/DISABLING\n\t  #tempEnable := #enable; // Work with temporary value / create process image\n\t  IF (#tempEnable = TRUE) AND (#statInternal.diagnostics.status = #STATUS_NO_CURRENT_JOBS) THEN // Enable FB\n\t    // First call; initialize FB\n\t    #statInternal.valid := TRUE;\n\t    #statInternal.busy := TRUE;\n\t    #statInternal.error := FALSE;\n\t    #statInternal.errorUserCleared := FALSE;\n\t    #statInternal.errorAutoCleared := FALSE;\n\t    #statInternal.disablingCompleted := FALSE;\n\t    #statInternal.diagnostics := #statInternal.emptyDiagnostics;\n\t    #diagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;\n\t    // State machine - start processing\n\t    #statMainState := #FB_STATE_ENABLING;\n\t    \n\t  ELSIF (#tempEnable = FALSE) AND (#statInternal.enablePrevious = TRUE) THEN // Disable FB \n\t    #statMainState := #FB_STATE_DISABLING;\n\t    \n\t  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN // Set status identifier of subsequent call\n\t    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t  END_IF;\n\t  \n\t  // Edge detection 'enable' input\n\t  #statInternal.enablePrevious := #tempEnable;\n\tEND_REGION ENABLING/DISABLING\n\t\n\tIF (#statInternal.diagnostics.status = #STATUS_NO_CURRENT_JOBS) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION STATE MACHINE\n\t  REPEAT\n\t    #tempRepeatStateMaschine := FALSE;\n\t    \n\t    CASE #statMainState OF // State machine of FB\n\t      #FB_STATE_NO_PROCESSING:\n\t        REGION No Processing\n\t          ; // No processing active (Note: this state must always be present and left empty)\n\t        END_REGION No Processing\n\t        \n\t      #FB_STATE_ENABLING: // Enabling active\n\t        REGION Enabling\n\t          // check whether the item type is BOOL\n\t          // Bool is not supported by Systemfunction MOVE BLOCK VARIANT\n\t          IF FALSE\n\t            OR TypeOf(#item) = Bool\n\t            OR TypeOf(#initialItem) = Bool\n\t            OR TypeOfElements(#buffer) = Bool\n\t          THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_BOOL_NOT_SUPPORTED;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          // check whether the ring #buffer is an ARRAY.\n\t          // IF so, the number OF the ARRAY elements is read out.\n\t          // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t          IF IS_ARRAY(#buffer) THEN\n\t            #statBufferSize := CountOfElements(#buffer);\n\t          ELSE\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_NO_ARRAY;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // check whether the data type OF the ARRAY elements matches\n\t          // the data type OF the entry (#item). IF the data types DO NOT match,\n\t          // the program execution is terminated at this point\n\t          IF (TypeOf(#item) <> TypeOfElements(#buffer)) THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_WRONG_TYPE_ITEM;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // check whether the initial value OF the ring #buffer\n\t          // matches the entry (tag #item). IF the data types DO NOT match,\n\t          // the program execution is terminated at this point\n\t          IF (TypeOf(#item) <> TypeOf(#initialItem)) THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_WRONG_TYPE_INITIAL_ITEM;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // Store values for edge detection\n\t          #statEdgesMem.push := #push;\n\t          #statEdgesMem.pop := #pop;\n\t          #statEdgesMem.peek := #peek;\n\t          #statEdgesMem.reset := #reset;\n\t          #statEdgesMem.clear := #clear;\n\t          \n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION Enabling\n\t        \n\t      #FB_STATE_IDLE:\n\t        REGION IDLE\n\t          // Collect edges\n\t          #tempEdges.push := #push AND NOT #statEdgesMem.push;\n\t          #tempEdges.pop := #pop AND NOT #statEdgesMem.pop;\n\t          #tempEdges.peek := #peek AND NOT #statEdgesMem.peek;\n\t          #tempEdges.reset := #reset AND NOT #statEdgesMem.reset;\n\t          #tempEdges.clear := #clear AND NOT #statEdgesMem.clear;\n\t          // Store values for edge detection\n\t          #statEdgesMem.push := #push;\n\t          #statEdgesMem.pop := #pop;\n\t          #statEdgesMem.peek := #peek;\n\t          #statEdgesMem.reset := #reset;\n\t          #statEdgesMem.clear := #clear;\n\t          \n\t          // Reset is allways possible\n\t          IF #tempEdges.reset THEN\n\t            #statMainState := #FB_STATE_RESET;\n\t            #tempRepeatStateMaschine := TRUE;\n\t            \n\t            // If error Pending - do nothing until error was reseted\n\t          ELSIF #statInternal.diagnostics.status.%X15 THEN\n\t            ;// Stay here and no further operation possible\n\t            \n\t            // Check whether the variable indices are within the ARRAY limits.\n\t            // IF they are NOT, the program execution is terminated at this point\n\t          ELSIF (#statLastItemIndex >= #statBufferSize) THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_INDEX_IN_ARRAY_LIMITS_1;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t          ELSIF (#statElementCount > #statBufferSize) THEN\n\t            #statInternal.errorUserCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_INDEX_IN_ARRAY_LIMITS_2;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // Multiple commands dedected\n\t          ELSIF (BOOL_TO_INT(#tempEdges.clear) + BOOL_TO_INT(#tempEdges.pop) + BOOL_TO_INT(#tempEdges.push) + BOOL_TO_INT(#tempEdges.peek)) > 1 THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_MULTIPLE_COMMANDS_DEDECTED;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            \n\t            // Commands\n\t          ELSIF #tempEdges.clear THEN\n\t            #statMainState := #FB_STATE_CLEAR;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSIF #tempEdges.push THEN\n\t            #statMainState := #FB_STATE_PUSH;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSIF #tempEdges.peek THEN\n\t            #statMainState := #FB_STATE_PEEK;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSIF #tempEdges.pop THEN\n\t            #statMainState := #FB_STATE_POP;\n\t            #tempRepeatStateMaschine := TRUE;\n\t          ELSE\n\t            #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t          END_IF;\n\t        END_REGION IDLE\n\t        \n\t      #FB_STATE_CLEAR:\n\t        REGION CLEARING\n\t          // Reset status\n\t          #statInternal.errorAutoCleared := FALSE;\n\t          \n\t          FOR #tempCounter := #COUNTER_LOWER_LIMIT TO UDINT_TO_INT(#statBufferSize - #BUFFER_SIZE_CORRECTION) DO\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #tempCounter,\n\t                                                   DEST => #buffer);\n\t            \n\t            // Checks whether a local error has occurred.\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t              #statInternal.errorAutoCleared := TRUE;\n\t              #statInternal.diagnostics.status := #ERR_CLEAR_BUFFER;\n\t              #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t              EXIT;\n\t            END_IF;\n\t          END_FOR;\n\t          IF #statInternal.errorAutoCleared THEN\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // Reset counters\n\t          #statLastItemIndex := #BUFFER_INITIALIZED;\n\t          #statElementCount := #EMPTY_INITIALIZED;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_RESET:\n\t        REGION RESET\n\t          // Reset Error Auto Cleared\n\t          #statInternal.errorAutoCleared := FALSE;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_PUSH:\n\t        REGION Push\n\t          // this program code section checks whether the ring #buffer is full.\n\t          // IF this is the CASE, program execution is terminated at this point\n\t          IF ((#statLastItemIndex + #INCREMENT) >= #statBufferSize) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_BUFFER_FULL;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // This program code section writes the entry to the ring buffer.   \n\t          #tempInternalError := MOVE_BLK_VARIANT(SRC := #item,\n\t                                                 COUNT := #COUNT_ELEMENTS,\n\t                                                 SRC_INDEX := #INDEX_BEGINNING,\n\t                                                 DEST_INDEX := #statLastItemIndex + #INCREMENT,\n\t                                                 DEST => #buffer);\n\t          \n\t          // Check whether a local error has occurred\n\t          IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_WRITE_ENTRY;\n\t            #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // This program code section increments the index by 1 for reading and writing.        \n\t          #statLastItemIndex += #INCREMENT;\n\t          // Evaluation of the number of elements in the stack\n\t          #statElementCount += #INCREMENT;\n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_PEEK,\n\t      #FB_STATE_POP:\n\t        REGION PEEK_POP\n\t          // checks whether the ring #buffer is empty.\n\t          // IF this is the CASE, program execution is terminated at this point\n\t          IF (#statLastItemIndex <= #BUFFER_IS_EMPTY) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_BUFFER_EMPTY;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_NO_ERROR;\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          // returning the last entry of the ring buffer\n\t          #tempInternalError := MOVE_BLK_VARIANT(SRC := #buffer,\n\t                                                 COUNT := #COUNT_ELEMENTS,\n\t                                                 SRC_INDEX := #statLastItemIndex,\n\t                                                 DEST_INDEX := #INDEX_BEGINNING,\n\t                                                 DEST => #item);\n\t          \n\t          // check whether a local error has occurred\n\t          IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t            #statInternal.errorAutoCleared := TRUE;\n\t            #statInternal.diagnostics.status := #ERR_RETURN_LAST_ENTRY;\n\t            #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t            EXIT;\n\t          END_IF;\n\t          \n\t          REGION Pop\n\t            // is POP - delete element in buffer\n\t            // The value is initialized just if the \"pop\" input is triggered\n\t            // If the \"peek\" input is triggered, stack is not changed\n\t            IF #statMainState = #FB_STATE_POP THEN\n\t              #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                     COUNT := #COUNT_ELEMENTS,\n\t                                                     SRC_INDEX := #INDEX_BEGINNING,\n\t                                                     DEST_INDEX := #statLastItemIndex,\n\t                                                     DEST => #buffer);\n\t              \n\t              // This program code section checks whether a local error has occurred.\n\t              IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                #statInternal.errorAutoCleared := TRUE;\n\t                #statInternal.diagnostics.status := #ERR_POP_REPLACE_ITEM_BY_INIT_VALUE;\n\t                #statInternal.diagnostics.subfunctionStatus := INT_TO_WORD(#tempInternalError);\n\t                EXIT;\n\t              END_IF;\n\t              \n\t              // This program code section decrements the index by 1 for reading and writing.\n\t              #statLastItemIndex -= #INCREMENT;\n\t              // Evaluation of the number of elements in the stack\n\t              #statElementCount -= #INCREMENT;\n\t            END_IF;\n\t          END_REGION Pop\n\t          \n\t          // Set next state\n\t          #statMainState := #FB_STATE_IDLE;\n\t          #tempRepeatStateMaschine := TRUE;\n\t        END_REGION\n\t        \n\t      #FB_STATE_DISABLING: // Disabling active\n\t        REGION Disabling\n\t          // Disabling is complete the bit #statDisablingCompleted must be set\n\t          #statInternal.disablingCompleted := TRUE;\n\t        END_REGION Disabling\n\t        \n\t      ELSE // Undefined state in state machine reached\n\t        REGION Undefined state\n\t          #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;\n\t          #statInternal.diagnostics.subfunctionStatus := 16#00;\n\t          #statInternal.diagnostics.stateNumber := #statMainState;\n\t          #statInternal.errorUserCleared := TRUE;\n\t        END_REGION Undefined state\n\t    END_CASE;\n\t  UNTIL #tempRepeatStateMaschine = false END_REPEAT;\n\tEND_REGION STATE MACHINE\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  IF (#statInternal.disablingCompleted = TRUE) THEN\n\t    REGION Disabling\n\t      // Reset outputs if disabling completed\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := FALSE;\n\t      #statInternal.errorUserCleared := FALSE;\n\t      #statInternal.errorAutoCleared := FALSE;\n\t      #statInternal.diagnostics.status := #STATUS_NO_CURRENT_JOBS;\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION Disabling\n\t    \n\t  ELSIF (#statInternal.errorUserCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION Error user cleared\n\t      // Error can only be cleared by user; rising edge at enable input is needed to continue \n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := FALSE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // Execution aborted --> set state no processing\n\t      #statMainState := #FB_STATE_NO_PROCESSING;\n\t    END_REGION Error user cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = TRUE) AND (#statInternal.error = FALSE) THEN\n\t    REGION Error auto cleared\n\t      // Error can be reset by FB automatically\n\t      #statInternal.valid := FALSE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := TRUE;\n\t      // Write diagnostics\n\t      #diagnostics := #statInternal.diagnostics;\n\t      // Handling of autocleared error\n\t      #statMainState := #FB_STATE_IDLE;\n\t      #tempRepeatStateMaschine := TRUE;\n\t    END_REGION Error auto cleared\n\t    \n\t  ELSIF (#statInternal.errorAutoCleared = FALSE) AND (#statInternal.errorUserCleared = FALSE) AND (#statInternal.error = TRUE) THEN\n\t    REGION After user/auto cleared or command aborted\n\t      // If autocleared error is acknowledged\n\t      #statInternal.valid := TRUE;\n\t      #statInternal.busy := TRUE;\n\t      #statInternal.error := FALSE;\n\t      #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t    END_REGION After user/auto cleared or command aborted\n\t  END_IF;\n\t  \n\t  REGION Write static values to outputs\n\t    #valid := #statInternal.valid;\n\t    #busy := #statInternal.busy;\n\t    #error := #statInternal.error;\n\t    #status := #statInternal.diagnostics.status;\n\t    // if ENO mechanism is not used / error /& Status output present\n\t    ENO := TRUE;\n\t    // Write application specific static values to outputs\n\t    #elementCount := #statElementCount;\n\t    #isEmpty := #statElementCount <= #ZERO_ELEMENTS;\n\t    #isFull := #statElementCount >= #statBufferSize;\n\t  END_REGION Write static values to outputs\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "FahrenheitToCelsius", "description": "This function converts a temperature value - from °Fahrenheit to °Celsius.", "type": "FUNCTION", "name": "LGF_FahrenheitToCelsius", "vars": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Fahrenheit"}, {"name": "Ret_Val", "type": "Real", "description": "Converted temperature in °Celsius"}], "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Fahrenheit"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_FahrenheitToCelsius\" : Real\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry_Support\nFAMILY : LGF\nNAME : LGF_FahrenheitToCelsius\n   VAR_INPUT \n      value : Real;\n   END_VAR\n\n   VAR_TEMP \n      tempCelsiusTemperature : Real;\n   END_VAR\n\n   VAR CONSTANT \n      TEMPERATURE_GAIN : Real := 1.8;\n      TEMPERATURE_OFFSET : Real := 32.0;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_FahrenheitToCelsius\n\t  // Comment/Function: This function converts a temperature value - from °Fahrenheit to °Celsius\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO disabled - no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t  #tempCelsiusTemperature := (#value - #TEMPERATURE_OFFSET) / #TEMPERATURE_GAIN;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_FahrenheitToCelsius := #tempCelsiusTemperature;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Real"}]}
{"title": "UnixTimeToDTL", "description": "This function converts the Unix time of data type DInt to a date and time of data type DTL. The timestamp is calculated in UTC. This means that the time zone is not considered. Only times after 01/01/1990 are permitted.", "type": "FUNCTION", "name": "LGF_UnixTimeToDTL", "vars": [{"name": "timeUnix", "type": "DInt", "description": "UNIX time to convert"}, {"name": "Ret_Val", "type": "DTL", "description": "Converted time (Date and time).In case of Error: 0 (error = true)"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "timeUnix", "type": "DInt", "description": "UNIX time to convert"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_UnixTimeToDTL\" : DTL\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_UnixTimeToDTL\n   VAR_INPUT \n      timeUnix : DInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempDate : DInt;\n      tempTime : DInt;\n      tempDTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n   END_VAR\n\n   VAR CONSTANT \n      DELTA_1970_1990 : DInt := 631_152_000;\n      SEC_PER_DAY : DInt := 86400;\n      SEC_PER_HOUR : DInt := 3600;\n      SEC_PER_MINUTE : DInt := 60;\n      STATUS_NO_ERRROR : Word := 16#0000;\n      ERR_TIME_BEFORE_1990 : Word := 16#8000;\n      WARN_CONVERSION_LIMIT : Word := 16#6001;\n      CONVERSION_LIMIT {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1990-01-01-00:00:00;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_UnixTimeToDTL\n\t  // Comment/Function: This function converts a Unix time of data type DInt to a date and time of data type DTL.\n\t  //                   The timestamp is calculated in UTC. This means that the time zone is not taken into account.\n\t  //                   Only times after 01/01/1990 are permitted.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15\n\t  // Restrictions:     ENO mechanism is not used, Error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 16.10.2018 | Siemens Industry Online Support\n\t  //                         First released version\n\t  // 01.00.01 | 18.06.2019 | Simatic Systems Support\n\t  //                         Standard header and block parameters update, status parameter added\n\t  // 01.00.02 | 10.07.2019 | Simatic Systems Support\n\t  //                         Commends added and code intention adjusted\n\t  //                         Add ENO handling\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         Harmonize the version of the whole library\n\t  // 03.00.01 | 23.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION CONVERT\n\t  // Check if timeUnix less than 01.01.1990\n\t  IF (#timeUnix < #DELTA_1970_1990) THEN\n\t    #LGF_UnixTimeToDTL := #CONVERSION_LIMIT;\n\t    #error := TRUE;\n\t    #status := #ERR_TIME_BEFORE_1990;\n\t    RETURN;\n\t    \n\t    // Check if timeUnix is exactly on lower limitation of 01.01.1990\n\t  ELSIF (#timeUnix = #DELTA_1970_1990) THEN\n\t    #LGF_UnixTimeToDTL := #CONVERSION_LIMIT;\n\t    #error := FALSE;\n\t    #status := #WARN_CONVERSION_LIMIT;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Convert date\n\t  #tempDate := (#timeUnix - #DELTA_1970_1990) / #SEC_PER_DAY;\n\t  #tempDTL := DATE_TO_DTL(DINT_TO_DATE(#tempDate));\n\t  \n\t  // Convert time\n\t  #tempTime := #timeUnix - #DELTA_1970_1990 - (#tempDate * #SEC_PER_DAY);\n\t  #tempDTL.HOUR := DINT_TO_USINT(#tempTime / #SEC_PER_HOUR);\n\t  #tempDTL.MINUTE := DINT_TO_USINT(#tempTime MOD #SEC_PER_HOUR / #SEC_PER_MINUTE);\n\t  #tempDTL.SECOND := DINT_TO_USINT(#tempTime MOD #SEC_PER_MINUTE);\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_UnixTimeToDTL := #tempDTL;\n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERRROR;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DTL"}]}
{"title": "Random", "description": "This function generates a random value with each call. The random number has the data type UDInt.", "type": "FUNCTION", "name": "LGF_Random_UDInt", "vars": [{"name": "Ret_Val", "type": "UDInt", "description": "Random number in the UDInt range"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION \"LGF_Random_UDInt\" : UDInt\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_Random_UDInt\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n      subfunctionStatus : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempNanoSecondInDWord : DWord;\n      tempTimeStatus : Word;\n      tempRandomValue : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : UDInt := 0;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_RD_SYS_T : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_Random_UDInt\n\t  // Comment/Function: Generates a random number in the UDInt Range\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 11.12.2019  Simatic Systems Support\n\t  //                      First release\n\t  //                      copied from \"LGF_Random_Real\"\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 04.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Validation\n\t  // Read system time\n\t  #tempTimeStatus := INT_TO_WORD(RD_SYS_T(#tempTime));\n\t  \n\t  // Check return variable for error\n\t  IF (#tempTimeStatus <> #SUB_STATUS_NO_ERROR) THEN\n\t    #error := true;\n\t    #status := #ERR_RD_SYS_T;\n\t    #subfunctionStatus := #tempTimeStatus;\n\t    #LGF_Random_UDInt := #ZERO;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating random number\n\t  // Converting to double word so individual bytes can be addressed\n\t  #tempNanoSecondInDWord := UDINT_TO_DWORD(#tempTime.NANOSECOND);\n\t  \n\t  // Calculate a random-start-value depending on the time\n\t  #tempRandomValue.%B3 := #tempNanoSecondInDWord.%B0;\n\t  #tempRandomValue.%B2 := #tempNanoSecondInDWord.%B1;\n\t  #tempRandomValue.%B1 := #tempNanoSecondInDWord.%B2;\n\t  #tempRandomValue.%B0 := #tempNanoSecondInDWord.%B3;\n\t  \n\t  #LGF_Random_UDInt := DWORD_TO_UDINT(#tempRandomValue);\n\t  \n\t  #error := false;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "UDInt"}]}
{"title": "Boxplot_DInt", "description": "If you want to get an overview of existing data, you can use a Boxplot diagram. A Boxplot shows you in which area the data is located and how it is distributed over this area. A Boxplot consists of the following parameters: • Minimum (smallest occurring value of the sample) • Lower or first quartile (below this value are 25% of the sample values) • Median or second quartile (below this value are 50% of the sample values) • Upper or third quartile (below this value are 75% of the sample values) • Maximum (largest occurring value of the sample) Figure: Boxplot WinCC-Control To visualize the Boxplot, the Siemens Industry Online Support offers you a Net-Control, which you can use in conjunction with WinCC Runtime Professional. You can find the controls in the UserFiles folder of this library. Figure: .Net Control “Boxplot” Entry ID: 109479728 | V5.2.0 | 08/2025 Generated with Code2Docu © Siemens 2025 | 312 Program blocks", "type": "FUNCTION_BLOCK", "name": "LGF_Boxplot_DInt", "vars": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection:\n* 0: Outlier detection is deactivated\n* 0-1: Invalid value\n* >1: Outlier detection is activated."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %."}, {"name": "max", "type": "DInt", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "DInt", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %."}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}, {"name": "values", "type": "Array[*] of DInt", "description": "The array containing the data series that is to be used for the\ncalculation"}], "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection:\n* 0: Outlier detection is deactivated\n* 0-1: Invalid value\n* >1: Outlier detection is activated."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %."}, {"name": "max", "type": "DInt", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "DInt", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %."}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "The array containing the data series that is to be used for the\ncalculation"}], "answer": "FUNCTION_BLOCK \"LGF_Boxplot_DInt\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_Boxplot_DInt\n   VAR_INPUT \n      execute : Bool;\n      rangeOutlier : LReal := 1.5;\n   END_VAR\n\n   VAR_OUTPUT \n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      subfunctionStatus { ExternalWritable := 'False'} : Word;\n      outlierMax { ExternalWritable := 'False'} : LReal;\n      max { ExternalWritable := 'False'} : DInt;\n      q75 { ExternalWritable := 'False'} : LReal;\n      median { ExternalWritable := 'False'} : LReal;\n      q25 { ExternalWritable := 'False'} : LReal;\n      min { ExternalWritable := 'False'} : DInt;\n      outlierMin { ExternalWritable := 'False'} : LReal;\n      skewness { ExternalWritable := 'False'} : LReal;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of DInt;\n   END_VAR\n\n   VAR \n      statMaxNew { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statMinNew { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statSubfuncStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statExecuteOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      instShellSort { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_ShellSort_DInt\";\n      statMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statQuartil25 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statQuartil75 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statNumberOfElements { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statMedian { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statDeltaQuartil { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statOutlierMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statOutlierMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statSkewness { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statBorderOutlier { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempK : LReal;\n      tempValueDInt : DInt;\n      tempValueDInt1 : DInt;\n      tempArrLowBound : DInt;\n      tempArrUppBound : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_LREAL : LReal := 0.0;\n      ZERO_DINT : DInt := 0;\n      RANGE_OUTLIER_LOWER_BORDER : LReal := 1.0;\n      ELEMENTS_COUNT_CORRECTION : Int := 1;\n      CONVERT_TO_PERCENT : Int := 100;\n      DIMENSION_ONE : UDInt := 1;\n      NO_REMAINDER : Int := 0;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_EXECUTION_FINISHED : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      ERR_NEG_ARR_BOUND : Word := 16#8200;\n      ERR_SHELL_SORT : Word := 16#8600;\n      ERR_RANGE_NOT_OK : Word := 16#9101;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_Boxplot_Dint\n\t  // Comment/Function: The function block sorts the data row and calculates\n\t  //                   the so-called \"five point summary\" for an array of double integers\n\t  //                   Auto ENO disabled, forced to true - error handling done by error and status\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V5.0 \n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO disabled, forced to true - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //----------|------------|------------------------|----------------------------\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|----------------------------\n\t  // 01.00.00 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 01.00.01 | 05.11.2019 | Simatic Systems Support\n\t  //                       | Code reworked, regions, comments and constants are added\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  // 03.00.02 | 05.09.2024 | Simatic Systems Support\n\t  //                       | Fixed bug for array starting index\n\t  // 03.00.03 | 16.07.2025 | Simatic Systems Support\n\t  //                       | Fixed comments and block info header                    \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t    (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Dectect execution bit\n\t    //Positive edge detection\n\t    IF #execute AND NOT #statExecuteOld THEN\n\t        //count array elements\n\t        #tempArrLowBound := LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t        #tempArrUppBound := UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t        \n\t        //Reset outputs and statics\n\t        #statStatus := #STATUS_FIRST_CALL;\n\t        #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t        #statQuartil25 := #ZERO_LREAL;\n\t        #statMedian := #ZERO_LREAL;\n\t        #statQuartil75 := #ZERO_LREAL;\n\t        #statOutlierMax := #ZERO_LREAL;\n\t        #statOutlierMin := #ZERO_LREAL;\n\t        #statSkewness := #ZERO_LREAL;\n\t        #statMaxNew := #ZERO_DINT;\n\t        #statMinNew := #ZERO_DINT;\n\t        #statMin := #ZERO_DINT;\n\t        #statMax := #ZERO_DINT;\n\t        \n\t        //FB is currently inactive\n\t    ELSIF NOT #execute THEN\n\t        #statStatus := #STATUS_NO_CALL;\n\t        #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t    END_IF;\n\t    #statExecuteOld := #execute;\n\tEND_REGION\n\t\n\tREGION Validation\n\t    //Check rangeOutlier\n\t    IF #statStatus = #STATUS_FIRST_CALL THEN\n\t        //Value is not ok. Range have to be > 1.0 or 0.0\n\t        IF #rangeOutlier <> #ZERO_LREAL AND #rangeOutlier <= #RANGE_OUTLIER_LOWER_BORDER THEN\n\t            #statStatus := #ERR_RANGE_NOT_OK;\n\t            \n\t            //Check array boundry\n\t        ELSIF #tempArrLowBound < 0 THEN\n\t            #statStatus := #ERR_NEG_ARR_BOUND;\n\t        END_IF;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Boxplot calculation\n\t    IF #statStatus = #STATUS_FIRST_CALL THEN\n\t        //Get number of elents of the array\n\t        #statNumberOfElements := (#tempArrUppBound - #tempArrLowBound + #ELEMENTS_COUNT_CORRECTION);\n\t        \n\t        //Sort array\n\t        #instShellSort(array := #values);\n\t        \n\t        IF #instShellSort.error THEN\n\t            #statStatus := #ERR_SHELL_SORT;\n\t            #statSubfuncStatus := #instShellSort.status;\n\t        ELSE\n\t            #statMin := #values[#tempArrLowBound];\n\t            #statMax := #values[#tempArrUppBound];\n\t            //calculate median (Q50) - different calculation if the Number of Elements is even or odd \n\t            IF (#statNumberOfElements MOD 2) = #NO_REMAINDER THEN\n\t                // if n is even -> calculate MEDIAN = (x(n/2)+x(n/2+1))/2 \n\t                #tempValueDInt := #values[((#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION) / 2) + #tempArrLowBound];\n\t                #tempValueDInt1 := #values[(((#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION) / 2) + 1) + #tempArrLowBound];\n\t                #statMedian := DINT_TO_LREAL(((#tempValueDInt1 + #tempValueDInt) / 2));\n\t            ELSE\n\t                // if n is odd -> MEDIAN = x(n+1/2)\n\t                #statMedian := DINT_TO_LREAL(#values[((#statNumberOfElements + 1 - #ELEMENTS_COUNT_CORRECTION) / 2) + #tempArrLowBound]);\n\t            END_IF;\n\t            \n\t            //calculate 1.quartil(Q25)\n\t            // q1 = x(k) with  k=(n+3)/4 \n\t            #tempK := (DINT_TO_LREAL(#statNumberOfElements + 3 - #ELEMENTS_COUNT_CORRECTION) / 4.0) + #tempArrLowBound;\n\t            \n\t            \n\t            \n\t            #tempValueDInt := #values[TRUNC(#tempK)];\n\t            #tempValueDInt1 := #values[TRUNC(#tempK) + 1];\n\t            #statQuartil25 := DINT_TO_LREAL(#tempValueDInt) + (FRAC_LREAL(#tempK) * DINT_TO_LREAL(#tempValueDInt1 - #tempValueDInt));\n\t            \n\t            //calculate 3.quartil(Q75)\n\t            //q3 = x(n+1-k) with k=(3n+1)/4\n\t            #tempK := (3 * DINT_TO_LREAL(#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION + 1) / 4.0) + #tempArrLowBound;\n\t            \n\t            #tempValueDInt := #values[TRUNC(#tempK)];\n\t            #tempValueDInt1 := #values[TRUNC(#tempK) + 1];\n\t            #statQuartil75 := DINT_TO_LREAL(#tempValueDInt) + FRAC_LREAL(#tempK) * DINT_TO_REAL(#tempValueDInt1 - #tempValueDInt);\n\t            \n\t            //only if RANGE_OUTLIER is not zero\n\t            IF #rangeOutlier <> 0 THEN\n\t                //calculate Delta Q75-Q25\n\t                #statDeltaQuartil := #statQuartil75 - #statQuartil25;\n\t                \n\t                //check for min outlier\n\t                //calculate border for outlier\n\t                #statBorderOutlier := #statQuartil25 - #rangeOutlier * #statDeltaQuartil;\n\t                \n\t                //search in array for values outside the border\n\t                FOR #statCounter := 0 TO DINT_TO_INT(#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION) DO\n\t                    #tempValueDInt := #values[#statCounter + #tempArrLowBound];\n\t                    IF #tempValueDInt < LREAL_TO_DINT(#statBorderOutlier) THEN\n\t                        //detected a value as outlier, check next value\n\t                        ;\n\t                    ELSE\n\t                        //all outlier detected. Calulate new Min Value in range and calulate outlier in %\n\t                        #statOutlierMin := DINT_TO_LREAL((#CONVERT_TO_PERCENT * #statCounter)) / DINT_TO_LREAL(#statNumberOfElements);\n\t                        #statMinNew := #tempValueDInt;\n\t                        EXIT;\n\t                    END_IF;\n\t                END_FOR;\n\t                \n\t                //check for max outlier\n\t                //calculate border for outlier\n\t                #statBorderOutlier := #statQuartil75 + #rangeOutlier * #statDeltaQuartil;\n\t                //search in array for values outside the border \n\t                FOR #statCounter := DINT_TO_INT(#statNumberOfElements - #ELEMENTS_COUNT_CORRECTION) TO 0 BY - 1 DO\n\t                    #tempValueDInt := #values[#statCounter + #tempArrLowBound];\n\t                    IF #tempValueDInt > LREAL_TO_DINT(#statBorderOutlier) THEN\n\t                        //detected a value as outlier, check next value\n\t                        ;\n\t                    ELSE\n\t                        //all outlier detected. Calulate new Max Value in range and calulate outliers in %\n\t                        #statOutlierMax := DINT_TO_REAL((#CONVERT_TO_PERCENT * (#statNumberOfElements - INT_TO_DINT(#statCounter) - #ELEMENTS_COUNT_CORRECTION))) / DINT_TO_REAL(#statNumberOfElements);\n\t                        #statMaxNew := #tempValueDInt;\n\t                        EXIT;\n\t                    END_IF;\n\t                END_FOR;\n\t            END_IF;\n\t            \n\t            //calculate Skewness\n\t            //S= ((Q25 + Q75)-2*Q50) / (Q75 - Q25)\n\t            #statSkewness := (#statQuartil75 + #statQuartil25 - 2.0 * #statMedian) / (#statQuartil75 - #statQuartil25);\n\t            \n\t            #statStatus := #STATUS_EXECUTION_FINISHED;\n\t            #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t            \n\t        END_IF;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Write Outputs\n\t    IF #rangeOutlier <> #ZERO_LREAL THEN\n\t        #min := #statMinNew;\n\t        #max := #statMaxNew;\n\t    ELSE\n\t        #min := #statMin;\n\t        #max := #statMax;\n\t    END_IF;\n\t    \n\t    #q25 := #statQuartil25;\n\t    #median := #statMedian;\n\t    #q75 := #statQuartil75;\n\t    #outlierMin := #statOutlierMin;\n\t    #outlierMax := #statOutlierMax;\n\t    #skewness := #statSkewness;\n\t    \n\t    #error := #statStatus.%X15;\n\t    #status := #statStatus;\n\t    #subfunctionStatus := #statSubfuncStatus;\n\t    \n\t    // ENO mechanism is not used - forced to true.\n\t    ENO := TRUE;\n\tEND_REGION\n\t\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "KelvinToCelsius", "description": "This function converts a temperature value - from °Kelvin to °Celsius.", "type": "FUNCTION", "name": "LGF_KelvinToCelsius", "vars": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Kelvin"}, {"name": "Ret_Val", "type": "Real", "description": "Converted temperature in °Celsius"}], "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Kelvin"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_KelvinToCelsius\" : Real\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry_Support\nFAMILY : LGF\nNAME : LGF_KelvinToCelsius\n   VAR_INPUT \n      value : Real;\n   END_VAR\n\n   VAR_TEMP \n      tempCelsiusTemperature : Real;\n   END_VAR\n\n   VAR CONSTANT \n      TEMPERATURE_OFFSET : Real := 273.15;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_KelvinToCelsius\n\t  // Comment/Function: This function converts a temperature value - from °Kelvin to °Celsius\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO disabled - no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 20.06.2019 | Simatic Systems Support\n\t  //                         First release\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 22.02.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION CONVERT\n\t  #tempCelsiusTemperature := #value - #TEMPERATURE_OFFSET;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_KelvinToCelsius := #tempCelsiusTemperature;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Real"}]}
{"title": "ClockGen", "description": "This function generates the same clock signals as the system clock memory.", "type": "FUNCTION_BLOCK", "name": "LGF_ClockGen", "vars": [{"name": "clockDataType", "type": "LGF_typeSystem\nClockGen", "description": "Clock data type"}, {"name": "clockDataTypeRisingEdge", "type": "LGF_typeSystem\nClockGen", "description": "Clock edge data type (rising edges)"}, {"name": "clockDataTypeFallingEdge", "type": "LGF_typeSystem\nClockGen", "description": "Clock edge data type (falling edges)"}, {"name": "clockByte", "type": "Byte", "description": "Clock byte"}, {"name": "clockByteRisingEdge", "type": "Byte", "description": "Clock edge byte (rising edges)"}, {"name": "clockByteFallingEdge", "type": "Byte", "description": "Clock edge byte (falling edges)"}, {"name": "clk10Hz", "type": "Bool", "description": "Clock bit 10Hz"}, {"name": "clk5Hz", "type": "Bool", "description": "Clock bit 5Hz"}, {"name": "clk2Hz5", "type": "Bool", "description": "Clock bit 2.5Hz"}, {"name": "clk2Hz", "type": "Bool", "description": "Clock bit 2Hz"}, {"name": "clk1Hz25", "type": "Bool", "description": "Clock bit 1.25Hz"}, {"name": "clk1Hz", "type": "Bool", "description": "Clock bit 1Hz"}, {"name": "clk0Hz625", "type": "Bool", "description": "Clock bit 0.625Hz"}, {"name": "clk0Hz5", "type": "Bool", "description": "Clock bit 0.5Hz"}, {"name": "clk10Hz", "type": "Bool", "description": "Clock bit 10Hz"}, {"name": "clk5Hz", "type": "Bool", "description": "Clock bit 5Hz"}, {"name": "clk2Hz5", "type": "Bool", "description": "Clock bit 2.5Hz"}, {"name": "clk2Hz", "type": "Bool", "description": "Clock bit 2Hz"}, {"name": "clk1Hz25", "type": "Bool", "description": "Clock bit 1.25Hz"}, {"name": "clk1Hz", "type": "Bool", "description": "Clock bit 1Hz"}, {"name": "clk0Hz625", "type": "Bool", "description": "Clock bit 0.625Hz"}, {"name": "clk0Hz5", "type": "Bool", "description": "Clock bit 0.5Hz"}], "input": [], "output": [{"name": "clockDataType", "type": "LGF_typeSystem\nClockGen", "description": "Clock data type"}, {"name": "clockDataTypeRisingEdge", "type": "LGF_typeSystem\nClockGen", "description": "Clock edge data type (rising edges)"}, {"name": "clockDataTypeFallingEdge", "type": "LGF_typeSystem\nClockGen", "description": "Clock edge data type (falling edges)"}, {"name": "clockByte", "type": "Byte", "description": "Clock byte"}, {"name": "clockByteRisingEdge", "type": "Byte", "description": "Clock edge byte (rising edges)"}, {"name": "clockByteFallingEdge", "type": "Byte", "description": "Clock edge byte (falling edges)"}, {"name": "clk10Hz", "type": "Bool", "description": "Clock bit 10Hz"}, {"name": "clk5Hz", "type": "Bool", "description": "Clock bit 5Hz"}, {"name": "clk2Hz5", "type": "Bool", "description": "Clock bit 2.5Hz"}, {"name": "clk2Hz", "type": "Bool", "description": "Clock bit 2Hz"}, {"name": "clk1Hz25", "type": "Bool", "description": "Clock bit 1.25Hz"}, {"name": "clk1Hz", "type": "Bool", "description": "Clock bit 1Hz"}, {"name": "clk0Hz625", "type": "Bool", "description": "Clock bit 0.625Hz"}, {"name": "clk0Hz5", "type": "Bool", "description": "Clock bit 0.5Hz"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_ClockGen\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Simatic Systems Support (SICAR)'\nFAMILY : LGF\nNAME : LGF_ClockGen\n   VAR_OUTPUT \n      clockDataType { ExternalWritable := 'False'} : \"LGF_typeSystemClockGen\";\n      clockDataTypeRisingEdge { ExternalWritable := 'False'} : \"LGF_typeSystemClockGen\";\n      clockDataTypeFallingEdge { ExternalWritable := 'False'} : \"LGF_typeSystemClockGen\";\n      clockByte { ExternalWritable := 'False'} : Byte;\n      clockByteRisingEdge { ExternalWritable := 'False'} : Byte;\n      clockByteFallingEdge { ExternalWritable := 'False'} : Byte;\n      clk10Hz { ExternalWritable := 'False'} : Bool;\n      clk5Hz { ExternalWritable := 'False'} : Bool;\n      clk2Hz5 { ExternalWritable := 'False'} : Bool;\n      clk2Hz { ExternalWritable := 'False'} : Bool;\n      clk1Hz25 { ExternalWritable := 'False'} : Bool;\n      clk1Hz { ExternalWritable := 'False'} : Bool;\n      clk0Hz625 { ExternalWritable := 'False'} : Bool;\n      clk0Hz5 { ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR \n      statMemRuntime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statClockByte { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;\n      statClockByteFallingEdge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;\n      statClockByteRisingEdge { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;\n      statClockBytePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;\n      statCalcTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         clk10Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         clk5Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         clk2Hz5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         clk2Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         clk1Hz25 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         clk1Hz { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         clk0Hz625 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n         clk0Hz5 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n      END_STRUCT;\n      statStateFlag { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeSystemClockGen\";\n   END_VAR\n\n   VAR_TEMP \n      tempCycleTimeMicroSecond : UDInt;\n   END_VAR\n\n   VAR CONSTANT \n      PULSE_WIDTH_CLK10HZ : UDInt := 50000;\n      PULSE_WIDTH_CLK5HZ : UDInt := 100000;\n      PULSE_WIDTH_CLK2_5HZ : UDInt := 200000;\n      PULSE_WIDTH_CLK2HZ : UDInt := 250000;\n      PULSE_WIDTH_CLK1_25HZ : UDInt := 400000;\n      PULSE_WIDTH_CLK1HZ : UDInt := 500000;\n      PULSE_WIDTH_CLK0_625HZ : UDInt := 800000;\n      PULSE_WIDTH_CLK0_5HZ : UDInt := 1000000;\n      SECOND_TO_MICROSECOND : Real := 1000000.0;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG \n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_SystemClockGen\n\t  // Comment/Function: This function generates the same clocksignals as the system clock memory.\n\t  // Library/Family:   LGF (from SICAR)\n\t  // Author:           Simatic Systems Support (SICAR)\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1 and PLC S7 1516F-3 PN/DP\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO disabled\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge        | Changes applied\n\t  //----------|------------|-------------------------|------------------------------\n\t  // 01.00.00 | 01.10.2023 | SICAR                   | First released version\n\t  // 01.00.01 | 06.05.2025 | Simatic Systems Support | Integration into LGF\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Read current cyletime\n\t  #tempCycleTimeMicroSecond := LREAL_TO_UDINT((RUNTIME(#statMemRuntime)) * #SECOND_TO_MICROSECOND);\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 10Hz\n\t  // Sum up the cycletime\n\t  #statCalcTime.clk10Hz += #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk10Hz AND #statCalcTime.clk10Hz / #PULSE_WIDTH_CLK10HZ >= 1 THEN\n\t    //Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk10Hz := TRUE;\n\t    #statCalcTime.clk10Hz := #statCalcTime.clk10Hz MOD #PULSE_WIDTH_CLK10HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk10Hz AND #statCalcTime.clk10Hz / #PULSE_WIDTH_CLK10HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk10Hz := FALSE;\n\t    #statCalcTime.clk10Hz := #statCalcTime.clk10Hz MOD #PULSE_WIDTH_CLK10HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 5Hz\n\t  // Sum up the cycletime\n\t  #statCalcTime.clk5Hz += #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk5Hz AND #statCalcTime.clk5Hz / #PULSE_WIDTH_CLK5HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk5Hz := TRUE;\n\t    #statCalcTime.clk5Hz := #statCalcTime.clk5Hz MOD #PULSE_WIDTH_CLK5HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk5Hz AND #statCalcTime.clk5Hz / #PULSE_WIDTH_CLK5HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk5Hz := FALSE;\n\t    #statCalcTime.clk5Hz := #statCalcTime.clk5Hz MOD #PULSE_WIDTH_CLK5HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 2_5Hz\n\t  // Sum up the cycletime\n\t  #statCalcTime.clk2Hz5 += #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk2Hz5 AND #statCalcTime.clk2Hz5 / #PULSE_WIDTH_CLK2_5HZ >= 1 THEN\n\t    //Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk2Hz5 := TRUE;\n\t    #statCalcTime.clk2Hz5 := #statCalcTime.clk2Hz5 MOD #PULSE_WIDTH_CLK2_5HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk2Hz5 AND #statCalcTime.clk2Hz5 / #PULSE_WIDTH_CLK2_5HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk2Hz5 := FALSE;\n\t    #statCalcTime.clk2Hz5 := #statCalcTime.clk2Hz5 MOD #PULSE_WIDTH_CLK2_5HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 2Hz\n\t  // Sum up the cycletime\n\t  #statCalcTime.clk2Hz += #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk2Hz AND #statCalcTime.clk2Hz / #PULSE_WIDTH_CLK2HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk2Hz := TRUE;\n\t    #statCalcTime.clk2Hz := #statCalcTime.clk2Hz MOD #PULSE_WIDTH_CLK2HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk2Hz AND #statCalcTime.clk2Hz / #PULSE_WIDTH_CLK2HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk2Hz := FALSE;\n\t    #statCalcTime.clk2Hz := #statCalcTime.clk2Hz MOD #PULSE_WIDTH_CLK2HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 1_25Hz\n\t  // Sum up the cycletime\n\t  #statCalcTime.clk1Hz25 += #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk1Hz25 AND #statCalcTime.clk1Hz25 / #PULSE_WIDTH_CLK1_25HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk1Hz25 := TRUE;\n\t    #statCalcTime.clk1Hz25 := #statCalcTime.clk1Hz25 MOD #PULSE_WIDTH_CLK1_25HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk1Hz25 AND #statCalcTime.clk1Hz25 / #PULSE_WIDTH_CLK1_25HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk1Hz25 := FALSE;\n\t    #statCalcTime.clk1Hz25 := #statCalcTime.clk1Hz25 MOD #PULSE_WIDTH_CLK1_25HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 1Hz\n\t  //Sum up the cycletime\n\t  #statCalcTime.clk1Hz += #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk1Hz AND #statCalcTime.clk1Hz / #PULSE_WIDTH_CLK1HZ >= 1 THEN\n\t    //Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk1Hz := TRUE;\n\t    #statCalcTime.clk1Hz := #statCalcTime.clk1Hz MOD #PULSE_WIDTH_CLK1HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk1Hz AND #statCalcTime.clk1Hz / #PULSE_WIDTH_CLK1HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk1Hz := FALSE;\n\t    #statCalcTime.clk1Hz := #statCalcTime.clk1Hz MOD #PULSE_WIDTH_CLK1HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 0_625Hz\n\t  // Sum up the cycletime\n\t  #statCalcTime.clk0Hz625 += #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk0Hz625 AND #statCalcTime.clk0Hz625 / #PULSE_WIDTH_CLK0_625HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk0Hz625 := TRUE;\n\t    #statCalcTime.clk0Hz625 := #statCalcTime.clk0Hz625 MOD #PULSE_WIDTH_CLK0_625HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk0Hz625 AND #statCalcTime.clk0Hz625 / #PULSE_WIDTH_CLK0_625HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk0Hz625 := FALSE;\n\t    #statCalcTime.clk0Hz625 := #statCalcTime.clk0Hz625 MOD #PULSE_WIDTH_CLK0_625HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of settings and program execution for 0_5Hz\n\t  // Sum up the cycletime\n\t  #statCalcTime.clk0Hz5 += + #tempCycleTimeMicroSecond;\n\t  \n\t  // Calculation if positive flag is active\n\t  IF NOT #statStateFlag.clk0Hz5 AND #statCalcTime.clk0Hz5 / #PULSE_WIDTH_CLK0_5HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function\n\t    #statStateFlag.clk0Hz5 := TRUE;\n\t    #statCalcTime.clk0Hz5 := #statCalcTime.clk0Hz5 MOD #PULSE_WIDTH_CLK0_5HZ;\n\t    \n\t    // Calculation if negative flag is active  \n\t  ELSIF #statStateFlag.clk0Hz5 AND #statCalcTime.clk0Hz5 / #PULSE_WIDTH_CLK0_5HZ >= 1 THEN\n\t    // Set statusflag and write remainder with modulo function \n\t    #statStateFlag.clk0Hz5 := FALSE;\n\t    #statCalcTime.clk0Hz5 := #statCalcTime.clk0Hz5 MOD #PULSE_WIDTH_CLK0_5HZ;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Writing Output\n\t  // Write statusbit to output\n\t  #clk10Hz := #statClockByte.%X0 := NOT #statStateFlag.clk10Hz;\n\t  #clk5Hz := #statClockByte.%X1 := NOT #statStateFlag.clk5Hz;\n\t  #clk2Hz5 := #statClockByte.%X2 := NOT #statStateFlag.clk2Hz5;\n\t  #clk2Hz := #statClockByte.%X3 := NOT #statStateFlag.clk2Hz;\n\t  #clk1Hz25 := #statClockByte.%X4 := NOT #statStateFlag.clk1Hz25;\n\t  #clk1Hz := #statClockByte.%X5 := NOT #statStateFlag.clk1Hz;\n\t  #clk0Hz625 := #statClockByte.%X6 := NOT #statStateFlag.clk0Hz625;\n\t  #clk0Hz5 := #statClockByte.%X7 := NOT #statStateFlag.clk0Hz5;\n\t  \n\t  REGION Generating Edges\n\t    IF #statClockByte = #statClockBytePrevious THEN\n\t      #statClockByteRisingEdge :=\n\t      #statClockByteFallingEdge := 16#00;\n\t    ELSE\n\t      #statClockByteRisingEdge := (#statClockByte XOR #statClockBytePrevious) AND #statClockByte;\n\t      #statClockByteFallingEdge := (#statClockByte XOR #statClockBytePrevious) AND NOT #statClockByte;\n\t    END_IF;\n\t    #statClockBytePrevious := #statClockByte;\n\t  END_REGION\n\t  \n\t  #clockByte := #statClockByte;\n\t  #clockByteRisingEdge := #statClockByteRisingEdge;\n\t  #clockByteFallingEdge := #statClockByteFallingEdge;\n\t  \n\t  SCATTER(IN  := #statClockByte,\n\t          OUT => #clockDataType);\n\t  SCATTER(IN  := #statClockByteRisingEdge,\n\t          OUT => #clockDataTypeRisingEdge);\n\t  SCATTER(IN  := #statClockByteFallingEdge,\n\t          OUT => #clockDataTypeFallingEdge);\n\t  \n\t  // ENO is not needed here, forced to TRUE\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "DifferenceQuotientFC", "description": "This function numerically differentiates a signal sampled equidistantly in time. For example, the velocity can be calculated from a measured locus curve, or the acceleration can be calculated from the measured velocity. In order to minimize the effects of a scattering measurement signal, this algorithm uses a compensating polynomial. The function calculates the differentiated values acyclically. The function reads an array that is differentiated. 𝑁−4 smoothed measured values can be calculated from N measured values. The output array contains the value 0 in the index (0,1,N-1,N). However, replacement values can be calculated.", "type": "FUNCTION", "name": "LGF_DifferenceQuotientFC", "vars": [{"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values. (e.g. 1s)"}, {"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "values", "type": "Array[*] of LReal", "description": "Values that will be included in the differentiation."}, {"name": "derivatedValues", "type": "Array[*] of LReal", "description": "The differentiated value range."}], "input": [{"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values. (e.g. 1s)"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that will be included in the differentiation."}, {"name": "derivatedValues", "type": "Array[*] of LReal", "description": "The differentiated value range."}], "answer": "FUNCTION \"LGF_DifferenceQuotientFC\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_DifferenceQuotientFC\n   VAR_INPUT \n      deltaT : LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of LReal;\n      derivatedValues : Array[*] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempLowerBound : Int;\n      tempUpperBound : Int;\n      tempNumberOfElements : Int;\n      tempLowerBoundOut : Int;\n      tempUpperBoundOut : Int;\n      tempNumberOfElementsOut : Int;\n      tempCount : Int;\n      tempDivision : LReal;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : LReal := 0.0;\n      NUMBER_OF_ELEMENTS_CORRECTION : Int := 1;\n      DIMENSION_ONE : UDInt := 1;\n      MINIMUM_ARRAY_ELEMENTS : UDInt := 4;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_DELTA_T : Word := 16#8200;\n      ERR_ARRAYS_DIFFERENT : Word := 16#8400;\n      ERR_NOT_ENOUGH_VALUES : Word := 16#8401;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_DifferenceQuotientFC\n\t  // Comment/Function: This function differentiates a signal\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //----------|------------|------------------------|----------------------------\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|----------------------------\n\t  // 01.00.00 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 01.00.01 | 15.11.2019 | Simatic Systems Support\n\t  //                       | Regions, comments and constants are added\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Checking number of lower and upper bound  \n\t  #tempLowerBound := DINT_TO_INT(LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE));\n\t  #tempUpperBound := DINT_TO_INT(UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE));\n\t  \n\t  #tempNumberOfElements := #tempUpperBound - #tempLowerBound + #NUMBER_OF_ELEMENTS_CORRECTION;\n\t  \n\t  #tempLowerBoundOut := DINT_TO_INT(LOWER_BOUND(ARR := #derivatedValues, DIM := #DIMENSION_ONE));\n\t  #tempUpperBoundOut := DINT_TO_INT(UPPER_BOUND(ARR := #derivatedValues, DIM := #DIMENSION_ONE));\n\t  \n\t  #tempNumberOfElementsOut := #tempUpperBoundOut - #tempLowerBoundOut + #NUMBER_OF_ELEMENTS_CORRECTION;\n\t  \n\t  //check if size of arrays is ok\n\t  IF #tempNumberOfElementsOut <> #tempNumberOfElements THEN\n\t    #error := true;\n\t    #status := #ERR_ARRAYS_DIFFERENT;\n\t    RETURN;\n\t    // check size of arrays if the are big enough\n\t  ELSIF #tempNumberOfElements <= #MINIMUM_ARRAY_ELEMENTS THEN\n\t    #error := true;\n\t    #status := #ERR_NOT_ENOUGH_VALUES;\n\t    RETURN;\n\t    // DeltaT cannot be zero, devision by zero not possible.\n\t  ELSIF #deltaT = #ZERO THEN\n\t    #error := true;\n\t    #status := #ERR_DELTA_T;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating the derrivate values  \n\t  // calculate derivate value \n\t  // keep the \"Magic Numbers\" as they are part of the Math equation and would extent the formular in a unreadable way\n\t  // ẏ(n)=1/12h*(y(n-2)-8y(n-1)+8y(n+1)-y(n+2))\n\t  // h = deltaT\n\t  #tempDivision := 1.0 / (12.0 * #deltaT);\n\t  FOR #tempCount := #tempLowerBound + 2 TO #tempUpperBound - 2 DO\n\t    #derivatedValues[#tempCount] := #tempDivision * (#values[#tempCount - 2] - 8 * #values[#tempCount - 1] + 8 * #values[#tempCount + 1] - #values[#tempCount + 2]);\n\t  END_FOR;\n\t  \n\t  // ẏ(n-2)=1/84h*(-125y(n-2)+136y(n-1)+48y(n)-88y(n+1)+29y(n+2))\n\t  // h = deltaT\n\t  #tempDivision := 1.0 / (84.0 * #deltaT);\n\t  #derivatedValues[0] := #tempDivision * (-125 * #values[0] + 136 * #values[1] + 48 * #values[2] - 88 * #values[3] + 29 * #values[4]);\n\t  \n\t  // ẏ(n-1)=1/84h*(-38y(n-2)-2y(n-1)+24y(n)+26y(n+1)-10y(n+2))\n\t  // h = deltaT\n\t  #derivatedValues[1] := #tempDivision * (-38 * #values[0] - 2 * #values[1] + 24 * #values[2] + 26 * #values[3] - 10 * #values[4]);\n\t  \n\t  // ẏ(n+1)=1/84h(10y(n-2)-26y(n-1)-24y(n)+2y(n+1)+38y(n+2))\n\t  // h = deltaT\n\t  #derivatedValues[#tempUpperBound - 1] := #tempDivision * (10 * #values[#tempUpperBound - 4] - 26 * #values[#tempUpperBound - 3] - 24 * #values[#tempUpperBound - 2] + 2 * #values[#tempUpperBound - 1] + 38 * #values[#tempUpperBound]);\n\t  \n\t  // y(n-2)=1/84h(-29y(n-2)+88y(n-1)-48y(n)-136y(n+1)+125y(n+2))\n\t  // h = deltaT\n\t  #derivatedValues[#tempUpperBound] := #tempDivision * (-29 * #values[#tempUpperBound - 4] + 88 * #values[#tempUpperBound - 3] - 48 * #values[#tempUpperBound - 2] - 136 * #values[#tempUpperBound - 1] + 125 * #values[#tempUpperBound]);\n\t  \n\t  #error := false;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  // ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "FileReadWriteDelete", "description": "The function LGF_FileReadWriteDelete can be used to read, write or delete a file to/from the SIMATIC Memory Card (SMC). To read or write the data, it is necessary to deserialize/serialize it, which the function already does for the user. For this purpose, an external buffer in the form of a byte array must be connected, which can hold the amount of data; if the buffer is too small, an error is output. The file name must always be specified in full together with the folder name and the file extension in the following format: UserFiles/Test.dat.", "type": "FUNCTION_BLOCK", "name": "LGF_FileReadWriteDelete", "vars": [{"name": "executeRead", "type": "Bool", "description": "Rising edge starts file read once"}, {"name": "executeWrite", "type": "Bool", "description": "Rising edge starts file write once"}, {"name": "executeDelete", "type": "Bool", "description": "Rising edge starts file delete once"}, {"name": "fileName", "type": "String", "description": "Name of file including path: `UserFiles/test.dat`"}, {"name": "parameter", "type": "LGF_typeFileRead\nWriteDelete\nParameter", "description": "This UDT belongs to the Module\n`LGF_FileReadWriteDelete` and lists all possible\nparameters to configure its behavior."}, {"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished; new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the functionality"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "dataLength", "type": "DInt", "description": "Data length read from file (serialized length of `data`)"}, {"name": "fileDoesNotExist", "type": "Bool", "description": "True: The file or the path present at `fileName` does not exist"}, {"name": "timestamps", "type": "LGF_typeFileRead\nWriteDelete\nTimestamps", "description": "Timestamps for commands and file"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}, {"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set read from file / to write to file"}, {"name": "dataLengthMust\nMatch", "type": "Bool", "description": "TRUE: The length of the file data set and the dataset in\nthe PLC must match (File read)"}, {"name": "clearBuffer\nBefore", "type": "Bool", "description": "TRUE: Buffer would be cleared with 16#00 Byte before\nwriting the data (File write)"}, {"name": "includeTimestamp", "type": "Bool", "description": "TRUE: A Timestamp (DTL) is included in front of the\nData.\n`executeWrite` adds the actual time (system- or local\ntime)\n`executeRead` reads back the timestamp"}, {"name": "timeStampIsLocal", "type": "Bool", "description": "TRUE: The timestamp is used in local time.\nFALSE: The timestamp is used in system time / UTC.\nOnly used if `includeTimestamp` is set."}, {"name": "file", "type": "LGF_typeFileRea\nd\nWriteDelete\nTimestamp", "description": "Time stamp of file"}, {"name": "lastCommand", "type": "LGF_typeFileRea\nd\nWriteDelete\nTimestamp", "description": "Time stamp of last command"}, {"name": "executeRead", "type": "LGF_typeFileRea\nd\nWriteDelete\nTimestamp", "description": "Time stamp of command `executeRead`"}, {"name": "executeWrite", "type": "LGF_typeFileRea\nd\nWriteDelete\nTimestamp", "description": "Time stamp of command `executeWrite`"}, {"name": "executeDelete", "type": "LGF_typeFileRea\nd\nWriteDelete\nTimestamp", "description": "Time stamp of command `executeDelete`"}, {"name": "lastError", "type": "LGF_typeFileRea\nd\nWriteDelete\nTimestamp", "description": "Time stamp of the last error that occurred"}, {"name": "status", "type": "Word", "description": "Status of the Block or error identification when error\noccurred"}, {"name": "subfunction\nStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system\nblocks"}, {"name": "stateNumber", "type": "DInt", "description": "State in the state machine of the block where the error\noccurred"}], "input": [{"name": "executeRead", "type": "Bool", "description": "Rising edge starts file read once"}, {"name": "executeWrite", "type": "Bool", "description": "Rising edge starts file write once"}, {"name": "executeDelete", "type": "Bool", "description": "Rising edge starts file delete once"}, {"name": "fileName", "type": "String", "description": "Name of file including path: `UserFiles/test.dat`"}, {"name": "parameter", "type": "LGF_typeFileRead\nWriteDelete\nParameter", "description": "This UDT belongs to the Module\n`LGF_FileReadWriteDelete` and lists all possible\nparameters to configure its behavior."}], "output": [{"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished; new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the functionality"}, {"name": "status", "type": "Word", "description": "16#0000 - 16#7FFF: Status of the FB, 16#8000 - 16#FFFF: Error\nidentification"}, {"name": "dataLength", "type": "DInt", "description": "Data length read from file (serialized length of `data`)"}, {"name": "fileDoesNotExist", "type": "Bool", "description": "True: The file or the path present at `fileName` does not exist"}, {"name": "timestamps", "type": "LGF_typeFileRead\nWriteDelete\nTimestamps", "description": "Timestamps for commands and file"}, {"name": "diagnostics", "type": "LGF_type\nDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from\nblocks through the interface."}], "in/out": [{"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set read from file / to write to file"}], "answer": "FUNCTION_BLOCK \"LGF_FileReadWriteDelete\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Simatic Systems Support'\nFAMILY : LGF\nNAME : LGF_FileReadWriteDelete\n   VAR_INPUT \n      executeRead : Bool;\n      executeWrite : Bool;\n      executeDelete : Bool;\n      fileName : String;\n      parameter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : \"LGF_typeFileReadWriteDeleteParameter\";\n   END_VAR\n\n   VAR_OUTPUT \n      done { ExternalWritable := 'False'} : Bool;\n      busy { ExternalWritable := 'False'} : Bool;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      dataLength { ExternalWritable := 'False'} : DInt;\n      fileDoesNotExist { ExternalWritable := 'False'} : Bool;\n      timestamps { ExternalWritable := 'False'} : \"LGF_typeFileReadWriteDeleteTimestamps\";\n      diagnostics { ExternalWritable := 'False'} : \"LGF_typeDiagnostics\";\n   END_VAR\n\n   VAR_IN_OUT \n      bufferByteArray : Array[*] of Byte;\n      data : Variant;\n   END_VAR\n\n   VAR \n      statInternal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct\n         executePrevious { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         done { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         busy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n         diagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n         emptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeDiagnostics\" := (#STATUS_NO_CALL, (), ());\n      END_STRUCT;\n      instFileRead {InstructionName := 'FileReadC'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : FileReadC;\n      instFileWrite {InstructionName := 'FileWriteC'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : FileWriteC;\n      instFileDelete {InstructionName := 'FileDelete'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : FileDelete;\n      statMainState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #STATE_NO_PROCESSING;\n      statParameterDataIsByteArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statAsynchronusMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      statBufferSize { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statLengthData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statLengthFile { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 0;\n      statLengthTimeStamp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 0;\n      statTimestamps { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeFileReadWriteDeleteTimestamps\";\n      statTimestampDefault { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_typeFileReadWriteDeleteTimestamp\" := (#DEFAULT_DATE, FALSE);\n   END_VAR\n\n   VAR_TEMP \n      tempExecute : Bool;\n      tempExitStateLoop : Bool;\n      tempResult : Word;\n      tempBufferPosition : DInt;\n      tempPathPrefix : String;\n   END_VAR\n\n   VAR CONSTANT \n      DEFAULT_DATE {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1970-01-01-00:00:00;\n      PATH_PREFIX : String := 'UserFiles/';\n      EMPTY_BYTE : Byte := 16#00;\n      FILE_DELETE_PATH_NAME_NOT_EXIST : Word := 16#8091;\n      FILE_DELETE_FILE_NOT_EXIST : Word := 16#8092;\n      STATE_NO_PROCESSING : DInt := 0;\n      STATE_FILE_READ_INIT : DInt := 1;\n      STATE_FILE_WRITE_INIT : DInt := 2;\n      STATE_FILE_DELETE_INIT : DInt := 3;\n      STATE_FILE_READ : DInt := 10;\n      STATE_FILE_READ_PARAMETER_TO_INTERFACE : DInt := 11;\n      STATE_FILE_WRITE_PARAMETER : DInt := 20;\n      STATE_FILE_WRITE : DInt := 21;\n      STATE_FILE_DELETE : DInt := 30;\n      STATUS_EXECUTION_FINISHED : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      STATUS_SUBSEQUENT_CALL : Word := 16#7002;\n      ERR_UNDEFINED_STATE : Word := 16#8600;\n      \"- - - Application Error codes\" : Word;\n      ERR_BUFFER_LOWERBOUND : Word := 16#8201;\n      ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY : Word := 16#8202;\n      ERR_MULTIPLE_COMMANDS : Word := 16#8400;\n      ERR_FILE_PATH : Word := 16#8401;\n      ERR_READ_TIME_LOCAL : Word := 16#8402;\n      ERR_READ_TIME_SYSTEM : Word := 16#8403;\n      ERR_FILE_SIZE_GRATER_THEN_DATA_SIZE : Word := 16#8411;\n      ERR_FILE_SIZE_LESS_THEN_DATA_SIZE : Word := 16#8412;\n      ERR_MOVE_BLK_VARIANT : Word := 16#8601;\n      ERR_SERIALIZE_DATA : Word := 16#8602;\n      ERR_DESERIALIZE_DATA : Word := 16#8603;\n      ERR_SERIALIZE_DATE_TIMESTAMP : Word := 16#8604;\n      ERR_DESERIALIZE_DATE_TIMESTAMP : Word := 16#8605;\n      ERR_FILE_READ_INIT : Word := 16#8610;\n      ERR_FILE_READ : Word := 16#8611;\n      ERR_FILE_WRITE_INIT : Word := 16#8620;\n      ERR_FILE_WRITE : Word := 16#8621;\n      ERR_FILE_DELETE_INIT : Word := 16#8630;\n      ERR_FILE_DELETE : Word := 16#8631;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //================================================================================\n\t  //SIEMENS AG\n\t  //(c)Copyright 2017 All Rights Reserved\n\t  //--------------------------------------------------------------------------------\n\t  //Library:       LGF (Library General Functions) \n\t  //Tested with:   S7-1510SP-F\n\t  //Engineering:   TIA Portal V15\n\t  //Restrictions:  ---\n\t  //Requirements:  S7-1500/S7-1500T FW 2.5\n\t  //Functionality: The function `LGF_FileReadWriteDelete` can be used to read, write or delete a file to/from the SIMATIC Memory Card (SMC).\n\t  //To read or write the data, it is necessary to deserialize/serialize it, which the function already does for the user.\n\t  //For this purpose, an external buffer in the form of a Byte array must be connected, which can hold the amount of data;\n\t  //if the buffer is too small, an error is output.\n\t  //The file name must always be specified in full together with the folder name AND the file extension in the following format: `UserFiles/Test.dat`.\n\t  //--------------------------------------------------------------------------------\n\t  //Change log table:\n\t  //Version  | Date       | Expert in charge        | Changes applied\n\t  //---------|------------|-------------------------|------------------------------\n\t  //01.00.00 | 10.07.2025 | Simatic Systems Support | First released version\n\t  //================================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\t  \n\t  (/**/)\n\t  \n\t  (/**/)\n\t  \n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION TRIGGERING\n\t  #tempExecute := #executeRead OR #executeWrite OR #executeDelete; // Work with temporary value / create process image\n\t  IF (#tempExecute = TRUE) AND (#statInternal.executePrevious = FALSE) // Check if FB is triggered\n\t    // FB shall finish current job before new job can be started with rising edge of execute\n\t    AND (#statInternal.diagnostics.status = #STATUS_NO_CALL)\n\t  THEN // First call; initialize FB\n\t    #statInternal.done := FALSE;\n\t    #statInternal.busy := TRUE;\n\t    #statInternal.error := FALSE;\n\t    \n\t    // Initialize functionality: reset of variables, diagnostics, etc.\n\t    #statInternal.diagnostics := #statInternal.emptyDiagnostics;\n\t    #statInternal.diagnostics.status := #STATUS_FIRST_CALL;\n\t    #diagnostics := #statInternal.emptyDiagnostics;\n\t    \n\t    // Initialize functionality: call subsidiary FBs with FALSE\n\t    #instFileRead(REQ := FALSE);\n\t    #instFileWrite(REQ := FALSE);\n\t    #instFileDelete(REQ := FALSE);\n\t    \n\t    REGION Generate Timestamp of command\n\t      IF #parameter.timeStampIsLocal THEN\n\t        #tempResult := INT_TO_WORD(RD_LOC_T(#statTimestamps.lastCommand.dateAndTime));\n\t      ELSE\n\t        #tempResult := INT_TO_WORD(RD_SYS_T(#statTimestamps.lastCommand.dateAndTime));\n\t      END_IF;\n\t      #statTimestamps.lastCommand.timestampIsLocal := #parameter.timeStampIsLocal;\n\t    END_REGION\n\t    \n\t    IF FALSE // Multiple Commands set?\n\t      OR (#executeRead AND #executeWrite)\n\t      OR (#executeRead AND #executeDelete)\n\t      OR (#executeWrite AND #executeDelete)\n\t    THEN\n\t      #statInternal.diagnostics.status := #ERR_MULTIPLE_COMMANDS;\n\t      #statInternal.diagnostics.stateNumber := #STATE_NO_PROCESSING;\n\t      #statMainState := #STATE_NO_PROCESSING;\n\t      \n\t    ELSIF #tempResult.%X15 THEN // Read time stamp throws an error?\n\t      IF #parameter.timeStampIsLocal THEN\n\t        #statInternal.diagnostics.status := #ERR_READ_TIME_LOCAL;\n\t      ELSE\n\t        #statInternal.diagnostics.status := #ERR_READ_TIME_SYSTEM;\n\t      END_IF;\n\t      \n\t      #statInternal.diagnostics.stateNumber := #STATE_NO_PROCESSING;\n\t      #statMainState := #STATE_NO_PROCESSING;\n\t      \n\t      // State machine - start processing\n\t    ELSIF #executeRead THEN\n\t      #statMainState := #STATE_FILE_READ_INIT;\n\t    ELSIF #executeWrite THEN\n\t      #statMainState := #STATE_FILE_WRITE_INIT;\n\t    ELSIF #executeDelete THEN\n\t      #statMainState := #STATE_FILE_DELETE_INIT;\n\t    END_IF;\n\t    \n\t  ELSIF (#statInternal.diagnostics.status = #STATUS_FIRST_CALL) THEN\n\t    #statInternal.diagnostics.status := #STATUS_SUBSEQUENT_CALL;\n\t  END_IF;\n\t  \n\t  // Edge detection 'execute' input\n\t  #statInternal.executePrevious := #tempExecute;\n\tEND_REGION TRIGGERING\n\t\n\tIF (#statInternal.diagnostics.status = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce \"system load\"\n\t  RETURN;\n\tEND_IF;\n\t\n\tREGION STATE_MACHINE\n\t  // If one ore more runs in the same cycle are necessary, set #tempStateChangeActive := TRUE;\n\t  REPEAT\n\t    // Reset #tempExitStateLoop := TRUE; as its defined state to prevent endless loop\n\t    #tempExitStateLoop := TRUE;\n\t    \n\t    // State machine of FB\n\t    CASE #statMainState OF\n\t      #STATE_NO_PROCESSING: // No processing active (Note: this state must always be present and left empty)\n\t        ;\n\t        \n\t      #STATE_FILE_READ_INIT,\n\t      #STATE_FILE_WRITE_INIT,\n\t      #STATE_FILE_DELETE_INIT:\n\t        REGION Init\n\t          REGION Verify File Path\n\t            #tempPathPrefix := #PATH_PREFIX;\n\t            \n\t            FOR #tempBufferPosition := 1 TO DINT_TO_INT(LEN(#tempPathPrefix)) DO\n\t              IF #fileName[#tempBufferPosition] <> #tempPathPrefix[#tempBufferPosition] THEN\n\t                // Characters arenÄt identiacal\n\t                #statInternal.diagnostics.status := #ERR_FILE_PATH;\n\t                #statInternal.diagnostics.subfunctionStatus := DINT_TO_WORD(#tempBufferPosition);\n\t                EXIT; // Stop execution and leave block\n\t              END_IF;\n\t            END_FOR;\n\t            \n\t            // Leaving the outer loop as well in case of error\n\t            IF #statInternal.diagnostics.status.%X15 THEN\n\t              EXIT; // Stop execution and leave block\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          REGION Proof if delete is called to jump to the next step\n\t            // If delet is called - move on to next state\n\t            // jump over the others by jump over loop iterator with continue\n\t            IF #statMainState = #STATE_FILE_DELETE_INIT THEN\n\t              REGION Delete File handler init\n\t                // Init file read with false\n\t                #instFileDelete(REQ := FALSE);\n\t                \n\t                IF #instFileDelete.Error THEN\n\t                  #statInternal.diagnostics.status := #ERR_FILE_DELETE_INIT;\n\t                  #statInternal.diagnostics.subfunctionStatus := #instFileDelete.Status;\n\t                  EXIT; // Stop execution and leave block\n\t                END_IF;\n\t                \n\t                // Next state\n\t                #statMainState := #STATE_FILE_DELETE;\n\t                // ASYNCRONUS - set to true:\n\t                #tempExitStateLoop := #statAsynchronusMode;\n\t                CONTINUE;\n\t              END_REGION\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          REGION Verify buffer boundary\n\t            // Check buffer size\n\t            // Check lower boundary\n\t            #tempResult := DINT_TO_WORD(LOWER_BOUND(ARR := #bufferByteArray, DIM := 1));\n\t            \n\t            IF 0 <> #tempResult THEN // ERROR: buffer lowerbound has to be 0\n\t              #statInternal.diagnostics.status := #ERR_BUFFER_LOWERBOUND;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              EXIT; // Stop execution and leave block\n\t            END_IF;\n\t            \n\t            // Get upper boundary and calc size of buffer\n\t            #statBufferSize := UPPER_BOUND(ARR := #bufferByteArray, DIM := 1) + 1;\n\t          END_REGION\n\t          \n\t          // Verify parameter data types\n\t          REGION Set TimeStamp length\n\t            IF #parameter.includeTimestamp THEN\n\t              #statLengthTimeStamp := 14;\n\t            ELSE\n\t              #statLengthTimeStamp := 0;\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          REGION Verify parameter data types\n\t            // Check type of Parameter attached to IN/OUT\n\t            // If Array proceed here, Array limits checked by move block variant\n\t            IF IS_ARRAY(#data) AND TypeOfElements(#data) = Byte THEN\n\t              #statParameterDataIsByteArray := TRUE;\n\t              // Get array size\n\t              #statLengthData := UDINT_TO_DINT(CountOfElements(#data));\n\t              \n\t              // Verify if buffer is big enough to store data\n\t              IF #statBufferSize < (#statLengthData + #statLengthTimeStamp) THEN\n\t                // ERROR: buffer array is to small for data array\n\t                #statInternal.diagnostics.status := #ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY;\n\t                #statInternal.diagnostics.subfunctionStatus := 16#0000;\n\t                EXIT; // Stop execution and leave block\n\t              END_IF;\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          REGION Proof if read is called to jump to the next step\n\t            IF #statMainState = #STATE_FILE_READ_INIT THEN\n\t              REGION Check array to see if the length is sufficient to store the read data\n\t                #statParameterDataIsByteArray := FALSE;\n\t                #statLengthData := 0;\n\t                \n\t                #tempResult := INT_TO_WORD(\n\t                                           Serialize(SRC_VARIABLE := #data,\n\t                                                     DEST_ARRAY => #bufferByteArray,\n\t                                                     POS := #statLengthData));\n\t                \n\t                // Check if serialize parameter structure was successful, otherwise set ERROR\n\t                IF #STATUS_EXECUTION_FINISHED <> #tempResult THEN\n\t                  #statInternal.diagnostics.status := #ERR_SERIALIZE_DATA;\n\t                  #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t                  EXIT; // Stop execution and leave block\n\t                END_IF;\n\t              END_REGION\n\t              \n\t              REGION Read File handler init\n\t                // Set length for FileRead call\n\t                IF #parameter.dataLengthMustMatch THEN\n\t                  #instFileRead.Length := 0;\n\t                ELSE\n\t                  #instFileRead.Length := DINT_TO_UDINT(#statLengthData + #statLengthTimeStamp);\n\t                END_IF;\n\t                \n\t                // Init file read with false\n\t                #instFileRead(REQ := FALSE);\n\t                \n\t                IF #instFileRead.Error THEN\n\t                  #statInternal.diagnostics.status := #ERR_FILE_READ_INIT;\n\t                  #statInternal.diagnostics.subfunctionStatus := #instFileRead.Status;\n\t                  EXIT; // Stop execution and leave block\n\t                END_IF;\n\t                \n\t                // Next state\n\t                #statMainState := #STATE_FILE_READ;\n\t                // ASYNCRONUS - set to true:\n\t                #tempExitStateLoop := #statAsynchronusMode;\n\t                CONTINUE;\n\t              END_REGION\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          REGION Proof if write is called to jump to the next step\n\t            IF #statMainState = #STATE_FILE_WRITE_INIT THEN\n\t              REGION File handler init\n\t                // Init file write with false\n\t                #instFileWrite(REQ := FALSE);\n\t                \n\t                IF #instFileWrite.Error THEN\n\t                  #statInternal.diagnostics.status := #ERR_FILE_WRITE_INIT;\n\t                  #statInternal.diagnostics.subfunctionStatus := #instFileWrite.Status;\n\t                  EXIT; // Stop execution and leave block\n\t                END_IF;\n\t                \n\t                // Next state\n\t                #statMainState := #STATE_FILE_WRITE_PARAMETER;\n\t                // ASYNCRONUS - set to true:\n\t                #tempExitStateLoop := #statAsynchronusMode;\n\t                CONTINUE;\n\t              END_REGION\n\t            END_IF;\n\t          END_REGION\n\t        END_REGION\n\t        \n\t      #STATE_FILE_READ:\n\t        REGION File read - File handling\n\t          // Set file handler request to true\n\t          #instFileRead(REQ    := TRUE,\n\t                        Name   := #fileName,\n\t                        Offset := UDINT#0,\n\t                        Data   := #bufferByteArray);\n\t          \n\t          IF #instFileRead.Error THEN\n\t            #statLengthFile := UDINT_TO_DINT(#instFileRead.ResultLength);\n\t            #statInternal.diagnostics.status := #ERR_FILE_READ;\n\t            #statInternal.diagnostics.subfunctionStatus := #instFileRead.Status;\n\t            EXIT; // Stop execution and leave block\n\t            \n\t          ELSIF #instFileRead.Done THEN\n\t            #statLengthFile := UDINT_TO_DINT(#instFileRead.ResultLength);\n\t            // Check file length parameter\n\t            IF TRUE\n\t              AND #parameter.dataLengthMustMatch\n\t              AND (#statLengthFile > (#statLengthData + #statLengthTimeStamp))\n\t            THEN\n\t              #statTimestamps.file := #statTimestampDefault;\n\t              #statInternal.diagnostics.status := #ERR_FILE_SIZE_GRATER_THEN_DATA_SIZE;\n\t              #statInternal.diagnostics.subfunctionStatus := DINT_TO_WORD((#statLengthData + #statLengthTimeStamp));\n\t              EXIT; // Stop execution and leave block\n\t              \n\t            ELSIF TRUE\n\t              AND #parameter.dataLengthMustMatch\n\t              AND (#statLengthFile < (#statLengthData + #statLengthTimeStamp))\n\t            THEN\n\t              #statTimestamps.file := #statTimestampDefault;\n\t              #statInternal.diagnostics.status := #ERR_FILE_SIZE_LESS_THEN_DATA_SIZE;\n\t              #statInternal.diagnostics.subfunctionStatus := DINT_TO_WORD((#statLengthData + #statLengthTimeStamp));\n\t              EXIT; // Stop execution and leave block\n\t              \n\t            ELSE\n\t              // Next state\n\t              #statMainState := #STATE_FILE_READ_PARAMETER_TO_INTERFACE;\n\t              // ASYNCRONUS - set to true:\n\t              #tempExitStateLoop := #statAsynchronusMode;\n\t            END_IF;\n\t          END_IF;\n\t        END_REGION\n\t        \n\t      #STATE_FILE_READ_PARAMETER_TO_INTERFACE:\n\t        REGION File read - Parameter handling\n\t          // Init buffer size/position pointer\n\t          #tempBufferPosition := 0;\n\t          \n\t          REGION Include time stamp\n\t            IF #parameter.includeTimestamp THEN\n\t              // Deserialize Time Stamp into buffer\n\t              // Length of timestamp is 14 byte\n\t              #tempResult := INT_TO_WORD(\n\t                                         Deserialize(SRC_ARRAY := #bufferByteArray,\n\t                                                     DEST_VARIABLE => #statTimestamps.file,\n\t                                                     POS := #tempBufferPosition)\n\t              );\n\t              \n\t              \n\t              // Check if move parameter structure was successful, otherwise set ERROR\n\t              IF #STATUS_EXECUTION_FINISHED <> #tempResult THEN\n\t                #statTimestamps.file := #statTimestampDefault;\n\t                #statInternal.diagnostics.status := #ERR_DESERIALIZE_DATE_TIMESTAMP;\n\t                #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t                EXIT; // Stop execution and leave block\n\t              END_IF;\n\t              \n\t            ELSE\n\t              #statTimestamps.file := #statTimestampDefault;\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          // If parameter is byte array - just copy\n\t          IF #statParameterDataIsByteArray THEN\n\t            // Copy buffer array into parameter array\n\t            #tempResult := INT_TO_WORD(\n\t                                       MOVE_BLK_VARIANT(SRC := #bufferByteArray,\n\t                                                        COUNT := DINT_TO_UDINT(#statLengthData),\n\t                                                        SRC_INDEX := #tempBufferPosition,\n\t                                                        DEST_INDEX := DINT#0,\n\t                                                        DEST => #data)\n\t            );\n\t            \n\t            // Check if move parameter structure was successful, otherwise set ERROR\n\t            IF #STATUS_EXECUTION_FINISHED <> #tempResult THEN\n\t              #statTimestamps.file := #statTimestampDefault;\n\t              #statInternal.diagnostics.status := #ERR_MOVE_BLK_VARIANT;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              EXIT; // Stop execution and leave block\n\t            END_IF;\n\t            \n\t            // Next state switched by status\n\t            #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_EXECUTION_FINISHED;\n\t            \n\t          ELSE // Parameter is NOT byte array - DESERIALZE\n\t            // Deserialize data from buffer\n\t            #tempResult := INT_TO_WORD(\n\t                                       Deserialize(SRC_ARRAY := #bufferByteArray,\n\t                                                   DEST_VARIABLE => #data,\n\t                                                   POS := #tempBufferPosition)\n\t            );\n\t            \n\t            // Check if serialize parameter structure was successful, otherwise set ERROR\n\t            IF #STATUS_EXECUTION_FINISHED <> #tempResult THEN\n\t              #statTimestamps.file := #statTimestampDefault;\n\t              #statInternal.diagnostics.status := #ERR_DESERIALIZE_DATA;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              EXIT; // Stop execution and leave block\n\t            END_IF;\n\t            \n\t            #statTimestamps.executeRead := #statTimestamps.lastCommand;\n\t            // Next state switched by status\n\t            #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED;\n\t            #statInternal.diagnostics.subfunctionStatus := #STATUS_EXECUTION_FINISHED;\n\t          END_IF;\n\t        END_REGION\n\t        \n\t      #STATE_FILE_WRITE_PARAMETER:\n\t        REGION File write - Parameter handling\n\t          // Init buffer size/position pointer\n\t          #tempBufferPosition := 0;\n\t          \n\t          REGION Include time stamp\n\t            IF #parameter.includeTimestamp THEN\n\t              // Serialize Time Stamp into buffer\n\t              // Length of timestamp is 14 byte\n\t              #statTimestamps.file := #statTimestamps.lastCommand;\n\t              \n\t              #tempResult := INT_TO_WORD(\n\t                                         Serialize(SRC_VARIABLE := #statTimestamps.file,\n\t                                                   DEST_ARRAY => #bufferByteArray,\n\t                                                   POS := #tempBufferPosition)\n\t              );\n\t              \n\t              // Check if move parameter structure was successful, otherwise set ERROR\n\t              IF #STATUS_EXECUTION_FINISHED <> #tempResult THEN\n\t                #statTimestamps.file := #statTimestampDefault;\n\t                #statInternal.diagnostics.status := #ERR_SERIALIZE_DATE_TIMESTAMP;\n\t                #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t                EXIT; // Stop execution and leave block\n\t              END_IF;\n\t              \n\t            ELSE\n\t              #statTimestamps.file := #statTimestampDefault;\n\t            END_IF;\n\t          END_REGION\n\t          \n\t          IF #statParameterDataIsByteArray THEN // Parameter is byte array - just copy\n\t            // Copy parameter array into buffer array\n\t            #tempResult := INT_TO_WORD(\n\t                                       MOVE_BLK_VARIANT(SRC := #data,\n\t                                                        COUNT := DINT_TO_UDINT(#statLengthData),\n\t                                                        SRC_INDEX := DINT#0,\n\t                                                        DEST_INDEX := #tempBufferPosition,\n\t                                                        DEST => #bufferByteArray)\n\t            );\n\t            // Set data length\n\t            #statLengthData += #tempBufferPosition;\n\t            \n\t            // Check if move parameter structure was successful, otherwise set ERROR\n\t            IF #STATUS_EXECUTION_FINISHED <> #tempResult THEN\n\t              #statTimestamps.file := #statTimestampDefault;\n\t              #statInternal.diagnostics.status := #ERR_MOVE_BLK_VARIANT;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              EXIT; // Stop execution and leave block\n\t            END_IF;\n\t            \n\t          ELSE // Parameter is NOT byte array - SERIALZE Data\n\t            // Clear buffer before writing the data into the file\n\t            // This avoids unintended content inside the binary file\n\t            IF #parameter.clearBufferBefore THEN\n\t              FILL_BLK(IN    := #EMPTY_BYTE,\n\t                       COUNT := DINT_TO_UDINT(#statBufferSize - #tempBufferPosition - 1),\n\t                       OUT   => #bufferByteArray[#tempBufferPosition]);\n\t            END_IF;\n\t            \n\t            // Serialize data into buffer\n\t            #tempResult := INT_TO_WORD(\n\t                                       Serialize(SRC_VARIABLE := #data,\n\t                                                 DEST_ARRAY => #bufferByteArray,\n\t                                                 POS := #tempBufferPosition)\n\t            );\n\t            \n\t            // After serialize, set array size pointer to numer of serialized elements\n\t            #statLengthData := #tempBufferPosition;\n\t            \n\t            // Check if serialize parameter structure was successful, otherwise set ERROR\n\t            IF #STATUS_EXECUTION_FINISHED <> #tempResult THEN\n\t              #statTimestamps.file := #statTimestampDefault;\n\t              #statInternal.diagnostics.status := #ERR_SERIALIZE_DATA;\n\t              #statInternal.diagnostics.subfunctionStatus := #tempResult;\n\t              EXIT; // Stop execution and leave block\n\t            END_IF;\n\t          END_IF;\n\t          \n\t          // Next state\n\t          #statMainState := #STATE_FILE_WRITE;\n\t          // ASYNCRONUS - set to true:\n\t          #tempExitStateLoop := #statAsynchronusMode;\n\t        END_REGION\n\t        \n\t      #STATE_FILE_WRITE:\n\t        REGION File write - File handling\n\t          // Set file handler request to true\n\t          #instFileWrite(REQ    := TRUE,\n\t                         Name   := #fileName,\n\t                         Offset := UDINT#0,\n\t                         Length := DINT_TO_UDINT(#statLengthData),\n\t                         Data   := #bufferByteArray);\n\t          \n\t          IF #instFileWrite.Error THEN\n\t            #statTimestamps.file := #statTimestampDefault;\n\t            #statTimestamps.executeWrite := #statTimestampDefault;\n\t            #statLengthFile := UDINT_TO_DINT(#instFileWrite.ResultLength);\n\t            #statInternal.diagnostics.status := #ERR_FILE_WRITE;\n\t            #statInternal.diagnostics.subfunctionStatus := #instFileWrite.Status;\n\t            EXIT; // Stop execution and leave block\n\t            \n\t          ELSIF #instFileWrite.Done THEN\n\t            #statTimestamps.executeWrite := #statTimestamps.lastCommand;\n\t            \n\t            #statLengthFile := UDINT_TO_DINT(#instFileWrite.ResultLength);\n\t            // Next state switched by status\n\t            #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED;\n\t            #statInternal.diagnostics.subfunctionStatus := 16#0000;\n\t          END_IF;\n\t        END_REGION\n\t        \n\t      #STATE_FILE_DELETE:\n\t        REGION File delete\n\t          // Set file handler request to true\n\t          #instFileDelete(REQ  := TRUE,\n\t                          Name := #fileName);\n\t          \n\t          IF #instFileDelete.Error THEN\n\t            #statTimestamps.file := #statTimestampDefault;\n\t            #statTimestamps.executeDelete := #statTimestampDefault;\n\t            #statInternal.diagnostics.status := #ERR_FILE_DELETE;\n\t            #statInternal.diagnostics.subfunctionStatus := #instFileDelete.Status;\n\t            EXIT; // Stop execution and leave block\n\t            \n\t          ELSIF #instFileDelete.Done THEN\n\t            #statTimestamps.file := #statTimestampDefault;\n\t            #statTimestamps.executeDelete := #statTimestamps.lastCommand;\n\t            // Next state switched by status\n\t            #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED;\n\t            #statInternal.diagnostics.subfunctionStatus := 16#0000;\n\t          END_IF;\n\t        END_REGION\n\t        \n\t      ELSE // Undefined state in state machine reached\n\t        #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;\n\t    END_CASE;\n\t    // if one ore more runs in the same cycle are necessary, set #tempExitStateLoop := FALSE;\n\t    // Check state, if condition = TRUE --> #tempExitStateLoop = TRUE --> LEAVE LOOP\n\t  UNTIL (TRUE = #tempExitStateLoop)\n\t  END_REPEAT;\n\tEND_REGION STATE_MACHINE\n\t\n\tREGION OUTPUTS\n\t  // Write outputs\n\t  IF (#statInternal.diagnostics.status = #STATUS_EXECUTION_FINISHED) AND (#statInternal.done = FALSE) THEN // Execution finished without errors\n\t    #statInternal.done := TRUE;\n\t    #statInternal.busy := FALSE;\n\t    #statInternal.error := FALSE;\n\t    #statMainState := #STATE_NO_PROCESSING; // Switch state machine to \"no processing\"\n\t    \n\t  ELSIF (#statInternal.diagnostics.status.%X15 = TRUE) AND (#statInternal.error = FALSE) THEN // Error occurred (#statStatus is 16#8000 to 16#FFFF)\n\t    #statInternal.done := FALSE;\n\t    #statInternal.busy := FALSE;\n\t    #statInternal.error := TRUE;\n\t    // Write diagnostics\n\t    #statTimestamps.lastError := #statTimestamps.lastCommand;\n\t    #statInternal.diagnostics.stateNumber := #statMainState;\n\t    #diagnostics := #statInternal.diagnostics;\n\t    #statMainState := #STATE_NO_PROCESSING; // Switch state machine to \"no processing\"\n\t    \n\t  ELSIF (#tempExecute = FALSE) AND ((#statInternal.done = TRUE) OR (#statInternal.error = TRUE)) THEN // Reset outputs\n\t    #statInternal.done := FALSE;\n\t    #statInternal.busy := FALSE;\n\t    #statInternal.error := FALSE;\n\t    #statInternal.diagnostics.status := #STATUS_NO_CALL;\n\t    #statLengthData := 0;\n\t    #statLengthFile := 0;\n\t  END_IF;\n\t  \n\t  // Write static values to outputs\n\t  #done := #statInternal.done;\n\t  #busy := #statInternal.busy;\n\t  #error := #statInternal.error;\n\t  #status := #statInternal.diagnostics.status;\n\t  \n\t  #dataLength := #statLengthData;\n\t  \n\t  #fileDoesNotExist := TRUE\n\t  AND (FALSE\n\t  OR #statInternal.diagnostics.status = #ERR_FILE_READ\n\t  OR #statInternal.diagnostics.status = #ERR_FILE_DELETE\n\t  ) AND (FALSE\n\t  OR #statInternal.diagnostics.subfunctionStatus = #FILE_DELETE_PATH_NAME_NOT_EXIST\n\t  OR #statInternal.diagnostics.subfunctionStatus = #FILE_DELETE_FILE_NOT_EXIST\n\t  );\n\t  \n\t  #timestamps := #statTimestamps;\n\t  \n\t  ENO := #statInternal.error;\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "SearchMinMax", "description": "This function searches, in an array of the data type DInt, for the maximum and minimum value and the respective index in the array. The following data types of the array elements are supported: Int, DInt, UInt, UDInt, USInt, SInt, and Real.", "type": "FUNCTION", "name": "LGF_SearchMinMax", "vars": [{"name": "variableArray", "type": "Variant", "description": "Array in whose fields the maximum and minimum are searched"}, {"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "minValue", "type": "Variant", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array.\nThe start index of the array plus `minValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "maxValue", "type": "Variant", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array.\nThe start index of the array plus `maxValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [{"name": "variableArray", "type": "Variant", "description": "Array in whose fields the maximum and minimum are searched"}], "output": [{"name": "minValue", "type": "Variant", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array.\nThe start index of the array plus `minValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "maxValue", "type": "Variant", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array.\nThe start index of the array plus `maxValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION \"LGF_SearchMinMax\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_SearchMinMax\n   VAR_INPUT \n      variableArray : Variant;\n   END_VAR\n\n   VAR_OUTPUT \n      minValue : Variant;\n      minValueIndex : DInt;\n      maxValue : Variant;\n      maxValueIndex : DInt;\n      error : Bool;\n      status : Word;\n      subfunctionStatus : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempArrayEndIndex : DInt;\n      tempCounter : DInt;\n      tempSubfunctionErr : Int;\n      tempArrayIndexMax : DInt;\n      tempArrayIndexMin : DInt;\n      tempActValueInt : Int;\n      tempMinInt : Int;\n      tempMaxInt : Int;\n      tempActValueUInt : UInt;\n      tempMinUInt : UInt;\n      tempMaxUInt : UInt;\n      tempActValueDInt : DInt;\n      tempMinDInt : DInt;\n      tempMaxDInt : DInt;\n      tempActValueUDInt : UDInt;\n      tempMinUDInt : UDInt;\n      tempMaxUDInt : UDInt;\n      tempActValueUSInt : USInt;\n      tempMinUSInt : USInt;\n      tempMaxUSInt : USInt;\n      tempActValueSInt : SInt;\n      tempMinSInt : SInt;\n      tempMaxSInt : SInt;\n      tempActValueReal : Real;\n      tempMinReal : Real;\n      tempMaxReal : Real;\n      tempActValueLReal : LReal;\n      tempMinLReal : LReal;\n      tempMaxLReal : LReal;\n   END_VAR\n\n   VAR CONSTANT \n      DECREMNT_BY_ONE : DInt := 1;\n      START_FROM_SECOND_ELEMENT : Int := 1;\n      SUBFUNCTION_NO_ERROR : Int := 0;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_WRONG_TYPE : Word := 16#8201;\n      ERR_NOT_EQUAL_TYPES : Word := 16#8202;\n      ERR_MOVE_BLK_VARIANT : Word := 16#8203;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Siemens AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_SearchMinMax\n\t  // Comment/Function: Searches an array for the minimum and maximum number and\n\t  //                   outputs the position and values of those numbers\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - Error handling with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA Portal V14 Update 1\n\t  // 01.00.02 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.03 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.01.00 08.11.2019  Siemens Industry Presales Support\n\t  //                      Code refactoring, regions and more comments added\n\t  // 03.00.00 23.04.2020  Siemens Industry Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 09.02.2021  Simatic Systems Support\n\t  //                      Rework constants and comments\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization\n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  #subfunctionStatus := INT_TO_WORD(#SUBFUNCTION_NO_ERROR);\n\t  #tempSubfunctionErr := #SUBFUNCTION_NO_ERROR;\n\tEND_REGION\n\t\n\tREGION Validation of inputs and outputs \n\t  // Check if the variant-variable is an array if yes cout the elements of the array\n\t  IF NOT (IS_ARRAY(#variableArray)) THEN\n\t    #error := true;\n\t    #status := #ERR_NO_ARRAY;\n\t    RETURN;\n\t    // Check if the elements of the array and the variables min and max have the same datatype.\n\t  ELSIF TypeOfElements(#variableArray) <> TypeOf(#minValue) OR TypeOf(#minValue) <> TypeOf(#maxValue) THEN\n\t    #error := true;\n\t    #status := #ERR_NOT_EQUAL_TYPES;\n\t    RETURN;\n\t  ELSE\n\t    #tempArrayEndIndex := (UDINT_TO_DINT(CountOfElements(#variableArray)) - #DECREMNT_BY_ONE);\n\t  END_IF;\n\t  //No need for validation for array max length. It cannot exceed DInt\n\tEND_REGION\n\t\n\tREGION Searching the array based on data type\n\t  CASE TypeOfElements(#variableArray) OF\n\t    Int:\n\t      REGION Search Array of Integers\n\t        //assign first value as min/max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMaxInt);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMinInt := #tempMaxInt;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          //Read the next element of the array\n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueInt);\n\t          // check for min\n\t          IF #tempActValueInt < #tempMinInt THEN\n\t            #tempMinInt := #tempActValueInt;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueInt > #tempMaxInt THEN\n\t            #tempMaxInt := #tempActValueInt;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    UInt:\n\t      REGION Search Array of Usigned Integers\n\t        //Assign first value as min / max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMaxUInt);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMinUInt := #tempMaxUInt;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          //Read the next element of the array\n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueUInt);\n\t          // check for min\n\t          IF #tempActValueUInt < #tempMinUInt THEN\n\t            #tempMinUInt := #tempActValueUInt;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueUInt > #tempMaxUInt THEN\n\t            #tempMaxUInt := #tempActValueUInt;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    DInt:\n\t      REGION Search Array of Double Integers\n\t        //Assign first value as min / max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMaxDInt);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMinDInt := #tempMaxDInt;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          //Read the next element of the array\n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueDInt);\n\t          // check for min\n\t          IF #tempActValueDInt < #tempMinDInt THEN\n\t            #tempMinDInt := #tempActValueDInt;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueDInt > #tempMaxDInt THEN\n\t            #tempMaxDInt := #tempActValueDInt;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    UDInt:\n\t      REGION Search Array of Unsigned Double Integers\n\t        //Assign first value as min / max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMaxUDInt);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMinUDInt := #tempMaxUDInt;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          //Read the next element of the array\n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueUDInt);\n\t          // check for min\n\t          IF #tempActValueUDInt < #tempMinUDInt THEN\n\t            #tempMinUDInt := #tempActValueUDInt;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueUDInt > #tempMaxUDInt THEN\n\t            #tempMaxUDInt := #tempActValueUDInt;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    USInt:\n\t      REGION Search Array of Unsigned Short Integers\n\t        //Assign first value as min/max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMaxUSInt);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMinUSInt := #tempMaxUSInt;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          //Read the next element of the array\n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueUSInt);\n\t          // check for min\n\t          IF #tempActValueUSInt < #tempMinUSInt THEN\n\t            #tempMinUSInt := #tempActValueUSInt;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueUSInt > #tempMaxUSInt THEN\n\t            #tempMaxUSInt := #tempActValueUSInt;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    SInt:\n\t      REGION Search Array of Signed Integers\n\t        //Assign first value as min / max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMaxSInt);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMinSInt := #tempMaxSInt;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          //Read the next element of the array\n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueSInt);\n\t          // check for min\n\t          IF #tempActValueSInt < #tempMinSInt THEN\n\t            #tempMinSInt := #tempActValueSInt;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueSInt > #tempMaxSInt THEN\n\t            #tempMaxSInt := #tempActValueSInt;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    Real:\n\t      REGION Search Array of Real\n\t        //Assign first value as min / max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMinReal);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMaxReal := #tempMinReal;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          \n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueReal);\n\t          // check for min\n\t          IF #tempActValueReal < #tempMinReal THEN\n\t            #tempMinReal := #tempActValueReal;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueReal > #tempMaxReal THEN\n\t            #tempMaxReal := #tempActValueReal;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    LReal:\n\t      REGION Search Array of LReal\n\t        //Assign first value as min / max\n\t        #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                COUNT := 1,\n\t                                                SRC_INDEX := 0,\n\t                                                DEST_INDEX := 0,\n\t                                                DEST => #tempMinLReal);\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        //Initializa Minimum value\n\t        #tempMaxLReal := #tempMinLReal;\n\t        //Search the Array for min/max values\n\t        FOR #tempCounter := #START_FROM_SECOND_ELEMENT TO #tempArrayEndIndex DO\n\t          \n\t          #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                                  COUNT := 1,\n\t                                                  SRC_INDEX := #tempCounter,\n\t                                                  DEST_INDEX := 0,\n\t                                                  DEST => #tempActValueLReal);\n\t          // check for min\n\t          IF #tempActValueLReal < #tempMinLReal THEN\n\t            #tempMinLReal := #tempActValueLReal;\n\t            #tempArrayIndexMin := #tempCounter;\n\t            // check for max\n\t          ELSIF #tempActValueLReal > #tempMaxLReal THEN\n\t            #tempMaxLReal := #tempActValueLReal;\n\t            #tempArrayIndexMax := #tempCounter;\n\t          END_IF;\n\t        END_FOR;\n\t        //Checking return value of subfunction\n\t        IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t          #error := true;\n\t          #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t          #status := #ERR_MOVE_BLK_VARIANT;\n\t          RETURN;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    ELSE\n\t      #error := true;\n\t      #subfunctionStatus := INT_TO_WORD(#SUBFUNCTION_NO_ERROR);\n\t      #status := #ERR_WRONG_TYPE;\n\t      RETURN;\n\t  END_CASE;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t  //Copy found values to outputs\n\t  //Copy Minimum value\n\t  #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                          COUNT := 1,\n\t                                          SRC_INDEX := #tempArrayIndexMin,\n\t                                          DEST_INDEX := 0,\n\t                                          DEST => #minValue);\n\t  //Copy Maximum value\n\t  #tempSubfunctionErr := MOVE_BLK_VARIANT(SRC := #variableArray,\n\t                                          COUNT := 1,\n\t                                          SRC_INDEX := #tempArrayIndexMax,\n\t                                          DEST_INDEX := 0,\n\t                                          DEST => #maxValue);\n\t  \n\t  //Checking return value of subfunction\n\t  IF #tempSubfunctionErr <> #SUBFUNCTION_NO_ERROR THEN\n\t    #error := true;\n\t    #subfunctionStatus := INT_TO_WORD(#tempSubfunctionErr);\n\t    #status := #ERR_MOVE_BLK_VARIANT;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  //Write found indexes to outputs\n\t  #minValueIndex := #tempArrayIndexMin;\n\t  #maxValueIndex := #tempArrayIndexMax;\n\t  \n\t  //ENO mechanism is not used, nerror handling via error & status\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
{"title": "SinusCI", "description": "This function generates a sinusoidal signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.", "type": "FUNCTION_BLOCK", "name": "LGF_SinusCI", "vars": [{"name": "amplitude", "type": "Real", "description": "Amplitude of the signal profile."}, {"name": "offset", "type": "Real", "description": "Offset of the signal profile in the Y-direction."}, {"name": "periode", "type": "UDInt", "description": "Period duration of the signal profile in [ms]"}, {"name": "phaseShift", "type": "Real", "description": "Phase offset in [ms]"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling cyclic interrupt OB"}, {"name": "reset", "type": "Bool", "description": "Reset of the signal profile."}, {"name": "value", "type": "Real", "description": "Current value of the sinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [{"name": "amplitude", "type": "Real", "description": "Amplitude of the signal profile."}, {"name": "offset", "type": "Real", "description": "Offset of the signal profile in the Y-direction."}, {"name": "periode", "type": "UDInt", "description": "Period duration of the signal profile in [ms]"}, {"name": "phaseShift", "type": "Real", "description": "Phase offset in [ms]"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling cyclic interrupt OB"}, {"name": "reset", "type": "Bool", "description": "Reset of the signal profile."}], "output": [{"name": "value", "type": "Real", "description": "Current value of the sinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_SinusCI\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Industry_Support\nFAMILY : LGF\nNAME : LGF_SinusCI\n   VAR_INPUT \n      amplitude : Real := 1.0;\n      offset : Real;\n      periode : UDInt := 1000;\n      phaseShift : Real;\n      callOB : OB_CYCLIC;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      value { ExternalWritable := 'False'} : Real;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      subFunctionStatus { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR \n      statRad { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;\n      statPhaseShift { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real := 0.0;\n      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;\n   END_VAR\n\n   VAR_TEMP \n      tempCycleTime : UDInt;\n      tempCyclePhase : UDInt;\n      tempCycleStatus : Word;\n      tempReadTimeStatus : Int;\n   END_VAR\n\n   VAR CONSTANT \n      SECOND_IN_MS : UDInt := 1000;\n      ZERO : Int := 0;\n      SLOPE : Int := 2;\n      TWO_PI : Real := 6.283185;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      QRY_CINT_OB_UNAVAILABLE : Word := 16#0000;\n      ERR_OB_UNAVAILABLE : Word := 16#8600;\n      ERR_QRY_CINT : Word := 16#8601;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_SinusCI\n\t  // Comment/Function: This function generates a sinusoidal signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V15.1 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 03.07.2018  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.00.03 26.09.2019  Simatic Systems Support\n\t  //                      Code refactoring, regions and more comments added\n\t  //                      phase shift availability added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 15.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  // 03.00.02 15.12.2023  Simatic Systems Support\n\t  //                      Fix callculation of 'phaseShift'\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Get sample time\n\t  // get sample time, according to the cyclic interrupt OB number\n\t  #tempReadTimeStatus := QRY_CINT(OB_NR := #callOB, CYCLE => #tempCycleTime,\n\t                                  PHASE => #tempCyclePhase, STATUS => #tempCycleStatus);\n\t  \n\t  REGION Error handling\n\t    // Generate error message of the QRY_CINT function\n\t    IF #tempReadTimeStatus <> #ZERO THEN\n\t      #error := TRUE;\n\t      #status := #ERR_QRY_CINT;\n\t      #subFunctionStatus := INT_TO_WORD(#tempReadTimeStatus);\n\t      #value := #ZERO;\n\t      RETURN;\n\t      \n\t      // Generate error message when OB unavailable\n\t    ELSIF (#tempCycleStatus = #QRY_CINT_OB_UNAVAILABLE) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_OB_UNAVAILABLE;\n\t      #subFunctionStatus := #SUB_STATUS_NO_ERROR;\n\t      #value := #ZERO;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\tEND_REGION\n\t\n\tREGION Caluclations and outputs assigment\n\t  IF #reset THEN\n\t    #statCounter := 0;\n\t    #value := #ZERO;\n\t  ELSE\n\t    // Increment Counter with each call of \"OB_Cyclic_interrupt\"\n\t    #statCounter += (#tempCycleTime) / #SECOND_IN_MS;\n\t    #statCounter := #statCounter MOD (#periode);\n\t    \n\t    // Transfer to radians\n\t    #statRad := UDINT_TO_REAL(#statCounter) * #TWO_PI / (UDINT_TO_REAL(#periode));\n\t    #statPhaseShift := (#phaseShift * #TWO_PI) / UDINT_TO_REAL(#periode);\n\t    \n\t    // Calculate output value\n\t    #value := SIN(#statRad + #statPhaseShift) * #amplitude + #offset;\n\t  END_IF;\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subFunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "Random", "description": "This function generates a random value with each call. The random number has the data type Real in the range from 0.0 to 1.0.", "type": "FUNCTION", "name": "LGF_Random_Real", "vars": [{"name": "Ret_Val", "type": "Real", "description": "Random Real number between 0.0 and 1.0"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "answer": "FUNCTION \"LGF_Random_Real\" : Real\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_Random_Real\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n      subfunctionStatus : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempNanoSecondInDWord : DWord;\n      tempTimeStatus : Word;\n      tempRandomValue : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : Real;\n      MAX_UDINT : UDInt := 4294967295 ;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_RD_SYS_T : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_Random_Real\n\t  // Comment/Function: Generates a random real number between 0.0 and 1.0\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 27.01.2017  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 17.08.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.00.02 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.01.00 13.11.2019  Simatic Systems Support\n\t  //                      Renamed from \"LGF_RandomBasic\" to \"LGF_Random_Real\"\n\t  //                      Regions, comments and constants are added\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 04.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Validation\n\t  // Read system time\n\t  #tempTimeStatus := INT_TO_WORD(RD_SYS_T(#tempTime));\n\t  \n\t  // Check return variable for error\n\t  IF (#tempTimeStatus <> #SUB_STATUS_NO_ERROR) THEN\n\t    #error := true;\n\t    #status := #ERR_RD_SYS_T;\n\t    #subfunctionStatus := #tempTimeStatus;\n\t    #LGF_Random_Real := #ZERO;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating random number\n\t  // Converting to double word so individual bytes can be addressed\n\t  #tempNanoSecondInDWord := UDINT_TO_DWORD(#tempTime.NANOSECOND);\n\t  \n\t  // Calculate a random-start-value depending on the time\n\t  #tempRandomValue.%B3 := #tempNanoSecondInDWord.%B0;\n\t  #tempRandomValue.%B2 := #tempNanoSecondInDWord.%B1;\n\t  #tempRandomValue.%B1 := #tempNanoSecondInDWord.%B2;\n\t  #tempRandomValue.%B0 := #tempNanoSecondInDWord.%B3;\n\t  \n\t  // Norm the calculated random number: 0.0 <= Random_Real <= 1.0\n\t  #LGF_Random_Real := UDINT_TO_REAL(DWORD_TO_UDINT(#tempRandomValue)) / UDINT_TO_REAL(#MAX_UDINT);\n\t  \n\t  #error := false;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #subfunctionStatus := #SUB_STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Real"}]}
{"title": "BitReset", "description": "This block resets a bit at a predefined position in a variable of the data type DWORD. Alternatively, Word and Byte can be used instead of DWord by converting the passed parameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE.", "type": "FUNCTION", "name": "LGF_BitReset", "vars": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be reset"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to reset in \"value\" parameter"}, {"name": "Ret_Val", "type": "DWord", "description": "Tag with reset bit"}], "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be reset"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to reset in \"value\" parameter"}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_BitReset\" : DWord\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_SIMATIC_Systems_Support\nFAMILY : LGF\nNAME : LGF_BitReset\n   VAR_INPUT \n      value : DWord;\n      bitNo : USInt;\n   END_VAR\n\n   VAR CONSTANT \n      BINARY_ONES : DWord := 16#FFFFFFFF;\n      TRUE_BOOL_BIT : DWord := 16#0001;\n      MAX_NO_OF_BITS : USInt := 32;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_BitReset\n\t  // Comment/Function: Reset bit in elementary datatype - DWord\n\t  //                   can be used for Word and Byte as well, by convert\n\t  //                   the passed paramter and the result using for e.g. Dword_to_Byte\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO not in use, set to true, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge         | Changes applied\n\t  // 01.00.00 | 06.06.2015 | Siemens Industry Support | first release\n\t  // 03.00.00 | 23.04.2020 | Siemens Industry Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 19.01.2021 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Logic\n\t  // reset the bit in tag\n\t  // shift one true bit into given position\n\t  // concatenate value then with XOR and biary ones\n\t  // using this result with AND and value will result in the previous value and the reseted bit in position\n\t  #LGF_BitReset := #value AND (#BINARY_ONES XOR SHL(IN := #TRUE_BOOL_BIT, N := (#bitNo MOD #MAX_NO_OF_BITS)));\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "DWord"}]}
{"title": "Histogram_UDInt", "description": "The histogram shows the frequency distribution of a sample by class. A class describes a value interval in which the individual frequencies are added together. After specifying the number of classes, the class width and the respective class center are calculated. The number of classes is limited to 15. The distribution is represented as a rectangle around the class mean with the class width and the cumulated frequency as height. Figure: Distribution WinCC-Control To visualize the Boxplot, the Siemens Industry Online Support offers you a Net-Control, which you can use in conjunction with WinCC Runtime Professional. You can find the controls in the UserFiles folder of this library. Figure: .Net Control “Histogram” Entry ID: 109479728 | V5.2.0 | 08/2025 Generated with Code2Docu © Siemens 2025 | 334 Program blocks", "type": "FUNCTION_BLOCK", "name": "LGF_Histogram_UDInt", "vars": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#\nCLASSES_COUNTE\nR_\nUP_LIMIT] of L\nReal", "description": "Outputs the calculated values in a two-dimensional array.\n• `histValues[0,0..14]` displays the relative frequency of the individual\nclasses.\n• `histValues[1,0..14]` displays the class centers.\n• If fewer than 15 classes are desired, the array elements that are not\nrequired are output with 0."}, {"name": "axis", "type": "Array[0..3] of L\nReal", "description": "Specifies the axis values:\n• Lower X axis value\n• Upper X axis value\n• Lower Y axis value\n• Upper Y axis value"}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}, {"name": "values", "type": "Array[*] of UDInt", "description": "The array containing the data series that is to be used for the\ncalculation"}], "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#\nCLASSES_COUNTE\nR_\nUP_LIMIT] of L\nReal", "description": "Outputs the calculated values in a two-dimensional array.\n• `histValues[0,0..14]` displays the relative frequency of the individual\nclasses.\n• `histValues[1,0..14]` displays the class centers.\n• If fewer than 15 classes are desired, the array elements that are not\nrequired are output with 0."}, {"name": "axis", "type": "Array[0..3] of L\nReal", "description": "Specifies the axis values:\n• Lower X axis value\n• Upper X axis value\n• Lower Y axis value\n• Upper Y axis value"}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "The array containing the data series that is to be used for the\ncalculation"}], "answer": "FUNCTION_BLOCK \"LGF_Histogram_UDInt\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_Histogram_UDInt\n   VAR_INPUT \n      execute : Bool;\n      numberOfClasses : UInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;\n      subfunctionStatus { ExternalWritable := 'False'} : Word := 16#0;\n      histValues { ExternalWritable := 'False'} : Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal;\n      axis { ExternalWritable := 'False'} : Array[0..3] of LReal;\n      classWidth { ExternalWritable := 'False'} : LReal;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of UDInt;\n   END_VAR\n\n   VAR \n      statArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#MAX_ARRAY_ELEMENTS] of UDInt;\n      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statSubfuncStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;\n      statExecuteOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;\n      instShellSort { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : \"LGF_ShellSort_UDInt\";\n      statMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statCounter { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statWidth { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statFrequencyValues { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statIndex { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;\n      statIndexOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := 0;\n      statBound { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;\n      statMaxFrequency { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;\n      statHistFrequencyAbs { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#CLASSES_COUNTER_UP_LIMIT] of Int;\n      statHistFrequencyRel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#CLASSES_COUNTER_UP_LIMIT] of LReal;\n      statHistMiddleOfClass { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#CLASSES_COUNTER_UP_LIMIT] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempNumberOfElements : DInt;\n      tempLowerBound : DInt;\n      tempUpperBound : DInt;\n      tempValueUDInt : UDInt;\n      tempMinUDInt : UDInt;\n      tempMaxUDInt : UDInt;\n      tempLoopIndex : DInt;\n      tempArrayOffset : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_INT : Int := 0;\n      ZERO_LREAL : LReal := 0.0;\n      DIMENSION_ONE : UInt := 1;\n      ARRAY_START_INDEX : DInt := 0;\n      ELEMENTS_COUNT_CORRECTION : DInt := 1;\n      INCREMENT : DInt := 1;\n      COUNTER_CORRECTION : DInt := 1;\n      MIN_CLASSES_NUMBER : DInt := 1;\n      MAX_CLASSES_NUMBER : DInt := 15;\n      CLASSES_COUNTER_LOW_LIMIT : DInt := 0;\n      CLASSES_COUNTER_UP_LIMIT : DInt := 14;\n      RATIO : Int := 2;\n      PERCENT_CORRECTION : Int := 100;\n      MAX_ARRAY_ELEMENTS : DInt := 999;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_EXECUTION_FINISHED : Word := 16#0000;\n      STATUS_NO_CALL : Word := 16#7000;\n      STATUS_FIRST_CALL : Word := 16#7001;\n      ERR_SHELL_SORT : Word := 16#8600;\n      ERR_WRONG_NO_CLASSES : Word := 16#9101;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2025\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_Histogram_UDInt\n\t  // Comment/Function: This function block calculates from measurement list all UDInt\n\t  //                   values for creating a histogram with WinCC\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU 1515F-2 PN FW:V2.6\n\t  // Engineering:      TIA Portal V17\n\t  // Restrictions:     ENO disabled, forced to true - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 23.11.2018 | Siemens Industry Online Support\n\t  //                       | First released version\n\t  // 02.00.00 | 06.11.2019 | Simatic Systems Support\n\t  //                       | Code refactoring, comments added\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support\n\t  //                       | Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 | 06.04.2021 | Simatic Systems Support\n\t  //                       | Insert documentation\n\t  // 03.00.02 | 19.11.2024 | Simatic Systems Support\n\t  //                       | Fixed bug for histValues Array\n\t  // 03.00.03 | 16.07.2025 | Simatic Systems Support\n\t  //                       | Fixed comments and block info header\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Detect execution bit\n\t  //Positive edge\n\t  IF #execute AND NOT #statExecuteOld THEN\n\t    //Get array boundaries\n\t    #tempLowerBound := LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t    #tempUpperBound := UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t    \n\t    //Reset and initialize tags\n\t    FOR #statCounter := #CLASSES_COUNTER_LOW_LIMIT TO #CLASSES_COUNTER_UP_LIMIT DO\n\t      #statHistFrequencyAbs[#statCounter] := #ZERO_INT;\n\t      #statHistFrequencyRel[#statCounter] := #ZERO_LREAL;\n\t      #statHistMiddleOfClass[#statCounter] := #ZERO_LREAL;\n\t    END_FOR;\n\t    \n\t    #statStatus := #STATUS_FIRST_CALL;\n\t    #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t    #statFrequencyValues := #ZERO_INT;\n\t    #statMaxFrequency := #ZERO_INT;\n\t    #statIndex := #ZERO_INT;\n\t    #statIndexOld := #ZERO_INT;\n\t    \n\t    //FB is currently inactive\n\t  ELSIF NOT #execute  THEN\n\t    #statStatus := #STATUS_NO_CALL;\n\t    #statSubfuncStatus := #SUB_STATUS_NO_ERROR;\n\t  END_IF;\n\t  #statExecuteOld := #execute;\n\tEND_REGION\n\t\n\tREGION Validation\n\t  IF #statStatus = #STATUS_FIRST_CALL THEN\n\t    //check number of classes\n\t    IF ((#numberOfClasses > #MAX_CLASSES_NUMBER) OR (#numberOfClasses < #MIN_CLASSES_NUMBER)) THEN\n\t      #statStatus := #ERR_WRONG_NO_CLASSES;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Histogram calculation \n\t  IF #statStatus = #STATUS_FIRST_CALL THEN\n\t    // Array elements calculation\n\t    // (for example: 6 - 2 = 4; but real number of elements is 5)\n\t    #tempNumberOfElements := #tempUpperBound - #tempLowerBound + #ELEMENTS_COUNT_CORRECTION;\n\t    \n\t    // Shift array index to range 0..n\n\t    #tempArrayOffset := - #tempLowerBound;\n\t    \n\t    //Sort array\n\t    #instShellSort(array := #values);\n\t    \n\t    IF #instShellSort.error THEN\n\t      #statStatus := #ERR_SHELL_SORT;\n\t      #statSubfuncStatus := #instShellSort.status;\n\t    ELSE\n\t      //Identify max and min value\n\t      #tempMinUDInt := #values[#tempLowerBound];\n\t      #tempMaxUDInt := #values[#tempUpperBound];\n\t      \n\t      #statMin := UDINT_TO_REAL(#tempMinUDInt);\n\t      #statMax := UDINT_TO_REAL(#tempMaxUDInt);\n\t      \n\t      //calculate classwidth\n\t      #statWidth := (#statMax - #statMin) / #numberOfClasses;\n\t      #statBound := (#statMin + #statWidth);\n\t      \n\t      // Fill temporary array\n\t      FOR #tempLoopIndex := #tempLowerBound TO #tempUpperBound DO\n\t        #statArray[#tempLoopIndex + #tempArrayOffset] := #values[#tempLoopIndex];\n\t      END_FOR;\n\t      \n\t      //Starting value for tempValueUDint\n\t      #tempValueUDInt := #statArray[#ARRAY_START_INDEX];\n\t      \n\t      //search for all values\n\t      FOR #statCounter := #ZERO_INT TO UINT_TO_INT(#numberOfClasses) - #COUNTER_CORRECTION DO\n\t        \n\t        //Count Values for Class \n\t          WHILE (#tempValueUDInt <= LREAL_TO_UDINT(#statBound)) AND #statIndex < (#tempNumberOfElements) DO\n\t          \n\t          IF #statIndex = #tempNumberOfElements THEN\n\t            EXIT;\n\t          END_IF;\n\t          #statIndex := #statIndex + #INCREMENT;\n\t          #tempValueUDInt := #statArray[#statIndex];\n\t        END_WHILE;\n\t        \n\t        //the last value is not counted, because of rounding errors\n\t        IF #statIndex = #tempNumberOfElements - #COUNTER_CORRECTION THEN\n\t          #statIndex := #statIndex + #INCREMENT;\n\t        END_IF;\n\t        \n\t        // Evaluate frequency values\n\t        #statFrequencyValues := DINT_TO_INT(#statIndex - #statIndexOld);\n\t        \n\t        #statHistFrequencyAbs[#statCounter] := #statFrequencyValues;\n\t        #statHistFrequencyRel[#statCounter] := INT_TO_REAL(#statFrequencyValues) / DINT_TO_REAL(#tempNumberOfElements) * #PERCENT_CORRECTION;\n\t        \n\t        //Max values in one class for y-axis \n\t        IF #statMaxFrequency < #statFrequencyValues THEN\n\t          #statMaxFrequency := #statFrequencyValues;\n\t        END_IF;\n\t        \n\t        #statBound := #statBound + #statWidth;\n\t        #statIndexOld := #statIndex;\n\t      END_FOR;\n\t    END_IF;\n\t    \n\t    //find the middle of each class\n\t    FOR #statCounter := #ZERO_INT TO UINT_TO_INT(#numberOfClasses) - #COUNTER_CORRECTION DO\n\t      #statHistMiddleOfClass[#statCounter] := #statMin + (DINT_TO_REAL(#statCounter) * #statWidth) + #statWidth / #RATIO;\n\t    END_FOR;\n\t    \n\t    //Keeping those outputs in this IF statement and not in the out region\n\t    //because filling of the array is needed only once on first call\n\t    //copy values to output array\n\t    FOR #statCounter := #CLASSES_COUNTER_LOW_LIMIT TO #CLASSES_COUNTER_UP_LIMIT DO\n\t      #histValues[0, #statCounter] := #statHistFrequencyRel[#statCounter];\n\t      #histValues[1, #statCounter] := #statHistMiddleOfClass[#statCounter];\n\t    END_FOR;\n\t    #statStatus := #STATUS_EXECUTION_FINISHED;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Write outputs \n\t  // Aassign Axis values\n\t  #axis[0] := #statMin;\n\t  #axis[1] := #statMax;\n\t  #axis[2] := #ZERO_LREAL;\n\t  #axis[3] := INT_TO_LREAL(#statMaxFrequency);\n\t  \n\t  // Write class width\n\t  #classWidth := #statWidth;\n\t  \n\t  #error := #statStatus.%X15;\n\t  #status := #statStatus;\n\t  #subfunctionStatus := #statSubfuncStatus;\n\t  \n\t  // ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "TimerSwitch", "description": "This block is a timer. It is possible to define daily, weekly, monthly, yearly time switch points and time switch points for working days or weekend days. Mode: Permanently off: 0, Daily: 1, Weekly: 2, Monthly: 3, Yearly: 4, Workday: 5, Weekend: 6, Permanently on: 10 The time value is always compared with the local time of the PLC, therefore the time value specified at the On and Off parameters must be specified as local time.", "type": "FUNCTION_BLOCK", "name": "LGF_TimerSwitch", "vars": [{"name": "onMonth", "type": "USInt", "description": "Month, in which the signal shall be set."}, {"name": "onDay", "type": "USInt", "description": "Day, at which the signal shall be set."}, {"name": "onWeekday", "type": "USInt", "description": "Day of the week on which the signal will be set;\nSunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "onHour", "type": "USInt", "description": "Hour, at which the signal shall be set."}, {"name": "onMinute", "type": "USInt", "description": "Minute, at which the signal shall be set."}, {"name": "offMonth", "type": "USInt", "description": "Month, in which the signal shall be reset."}, {"name": "offDay", "type": "USInt", "description": "Day, at which the signal shall be reset."}, {"name": "offWeekday", "type": "USInt", "description": "Day of the week on which the signal will be reset;\nSunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "offHour", "type": "USInt", "description": "Hour, at which the signal shall be reset."}, {"name": "offMinute", "type": "USInt", "description": "Minute, at which the signal shall be reset."}, {"name": "mode", "type": "USInt", "description": "Specifies the mode (see Principle of operation);\nPermanently off: 0, Daily: 1, Weekly: 2, Monthly: 3,\nYearly: 4, Workday: 5, Weekend: 6, Permanently on:\n10"}, {"name": "signal", "type": "Bool", "description": "Output signal"}, {"name": "actLocalTime", "type": "DTL", "description": "Current local time"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Sub function status code"}], "input": [{"name": "onMonth", "type": "USInt", "description": "Month, in which the signal shall be set."}, {"name": "onDay", "type": "USInt", "description": "Day, at which the signal shall be set."}, {"name": "onWeekday", "type": "USInt", "description": "Day of the week on which the signal will be set;\nSunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "onHour", "type": "USInt", "description": "Hour, at which the signal shall be set."}, {"name": "onMinute", "type": "USInt", "description": "Minute, at which the signal shall be set."}, {"name": "offMonth", "type": "USInt", "description": "Month, in which the signal shall be reset."}, {"name": "offDay", "type": "USInt", "description": "Day, at which the signal shall be reset."}, {"name": "offWeekday", "type": "USInt", "description": "Day of the week on which the signal will be reset;\nSunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "offHour", "type": "USInt", "description": "Hour, at which the signal shall be reset."}, {"name": "offMinute", "type": "USInt", "description": "Minute, at which the signal shall be reset."}, {"name": "mode", "type": "USInt", "description": "Specifies the mode (see Principle of operation);\nPermanently off: 0, Daily: 1, Weekly: 2, Monthly: 3,\nYearly: 4, Workday: 5, Weekend: 6, Permanently on:\n10"}], "output": [{"name": "signal", "type": "Bool", "description": "Output signal"}, {"name": "actLocalTime", "type": "DTL", "description": "Current local time"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of\nthe FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error\nidentification (see following Table)"}, {"name": "subFunctionStatus", "type": "Word", "description": "Sub function status code"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_TimerSwitch\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_TimerSwitch\n   VAR_INPUT \n      onMonth : USInt;\n      onDay : USInt;\n      onWeekday : USInt;\n      onHour : USInt;\n      onMinute : USInt;\n      offMonth : USInt;\n      offDay : USInt;\n      offWeekday : USInt;\n      offHour : USInt;\n      offMinute : USInt;\n      mode : USInt;\n   END_VAR\n\n   VAR_OUTPUT \n      signal { ExternalWritable := 'False'} : Bool;\n      actLocalTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;\n      error { ExternalWritable := 'False'} : Bool;\n      status { ExternalWritable := 'False'} : Word;\n      subFunctionStatus { ExternalWritable := 'False'} : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempReadTimeStatus : Word;\n      tempOnTimeDtl {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempOnTimeTod : Time_Of_Day;\n      tempOffTimeDtl {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempOffTimeTod : Time_Of_Day;\n      tempActTimeDtl {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      tempActTimeTod : Time_Of_Day;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : USInt := 0;\n      CLEAR_DTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_MODE_SELECTED : Word := 16#8200;\n      ERR_RD_LOC_T : Word := 16#8600;\n      MODE_PERMANENTLY_OFF : UInt := 0;\n      MODE_DAILY : UInt := 1;\n      MODE_WEEKLY : UInt := 2;\n      MODE_MONTHLY : UInt := 3;\n      MODE_YEARLY : UInt := 4;\n      MODE_WEEK_DAYS : UInt := 5;\n      MODE_WEEKEND_DAYS : UInt := 6;\n      MODE_PERMANENTLY_ON : UInt := 10;\n      MONTH_JANUARY : USInt := 1;\n      MONTH_DECEMBER : USInt := 12;\n      DAY_MONDAY : USInt := 2;\n      DAY_FRIDAY : USInt := 6;\n      DAY_SATURDAY : USInt := 7;\n      DAY_SUNDAY : USInt := 1;\n      DAY_NEXT_SUNDAY : USInt := 8;\n      DAY_NEXT_MONDAY : USInt := 9;\n      DATE_INCREMENT : USInt := 1;\n      DAY_INCREMENT : Time := T#1d;\n      WEEK_INCREMENT : Time := T#7d;\n      DAYS_PER_WEEK : USInt := 7;\n      DEFAULT_YEAR : UInt := 2015;\n      DEFAULT_MONTH : USInt := 2;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_TimerSwitch\n\t  // Comment/Function: Timer Switch (daily, weekly, monthly, working days, ...)\n\t  //                   Mode: Daily: 1, weekly: 2, monthly: 3, yearly: 4, workday: 5, weekend: 6\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V14 Update 1\n\t  // Restrictions:     ENO disabled - error handling done with error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 19.08.2015  Siemens Industry Online Support\n\t  //                      First released version\n\t  // 01.00.01 16.11.2015  Siemens Industry Online Support\n\t  //                      Fix in mode 2\n\t  // 01.01.00 23.05.2016  Siemens Industry Online Support\n\t  //                      New mode 5 + 6\n\t  //                      New output: actLocalTime\n\t  // 01.01.01 02.01.2017  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V14 Update 1\n\t  // 01.01.02 14.09.2018  Siemens Industry Online Support\n\t  //                      Fix in modes 1, 3, 5, 6                    \n\t  // 01.01.03 17.09.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15 Update 2\n\t  // 01.01.04 10.10.2018  Siemens Industry Online Support\n\t  //                      Connection to type restored\n\t  // 01.01.05 23.11.2018  Siemens Industry Online Support\n\t  //                      Upgrade: TIA V15.1\n\t  // 01.01.10 13.11.2019  Simatic Systems Support\n\t  //                      Magic numbers removed, tag naming added, code reworked\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 19.01.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  // 03.01.00 03.06.2022  Simatic Systems Support\n\t  //                      Insert mode `permanently On`: `10`, `permanently Off`: `0`\n\t  //=============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION\n\t  // Time ON init\n\t  #tempOnTimeDtl.HOUR := #onHour;\n\t  #tempOnTimeDtl.MINUTE := #onMinute;\n\t  #tempOnTimeDtl.SECOND := #ZERO;\n\t  #tempOnTimeDtl.NANOSECOND := #ZERO;\n\t  // Time OFF init\n\t  #tempOffTimeDtl.HOUR := #offHour;\n\t  #tempOffTimeDtl.MINUTE := #offMinute;\n\t  #tempOffTimeDtl.SECOND := #ZERO;\n\t  #tempOffTimeDtl.NANOSECOND := #ZERO;\n\tEND_REGION\n\t\n\tREGION READ LOCAL TIME\n\t  #tempReadTimeStatus := INT_TO_WORD(RD_LOC_T(#tempTime));\n\t  \n\t  // check result for error --> 16#8000 / MSB .X15\n\t  IF #tempReadTimeStatus.%X15 THEN\n\t    #error := TRUE;\n\t    #status := #ERR_RD_LOC_T;\n\t    #subFunctionStatus := #tempReadTimeStatus;\n\t    #actLocalTime := #CLEAR_DTL;\n\t    #signal := FALSE;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Store time of the current day\n\t  #tempActTimeDtl := #tempTime;\n\t  #tempActTimeTod := DTL_TO_TOD(#tempTime);\n\tEND_REGION\n\t\n\tREGION TIMER SWITCH LOGIC\n\t  CASE #mode OF\n\t    #MODE_DAILY:\n\t      REGION DAILY MODE\n\t        #tempOnTimeDtl.YEAR := #tempActTimeDtl.YEAR;\n\t        #tempOnTimeDtl.MONTH := #tempActTimeDtl.MONTH;\n\t        #tempOnTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;\n\t        #tempOnTimeDtl.DAY := #tempActTimeDtl.DAY;\n\t        // Store time of the on day\n\t        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);\n\t        \n\t        #tempOffTimeDtl.YEAR := #tempActTimeDtl.YEAR;\n\t        #tempOffTimeDtl.MONTH := #tempActTimeDtl.MONTH;\n\t        #tempOffTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;\n\t        #tempOffTimeDtl.DAY := #tempActTimeDtl.DAY;\n\t        // Store time of the off day\n\t        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);\n\t        \n\t        // Timer setting - overnight\n\t        IF #tempOnTimeTod > #tempOffTimeTod THEN\n\t          // Increase the day of the timeOff when midnight happens\n\t          IF #tempActTimeTod > #tempOffTimeTod THEN\n\t            #tempOffTimeDtl := #tempOffTimeDtl + #DAY_INCREMENT;\n\t          ELSE\n\t            // Decrease the day of the timeOn when midnight happens\n\t            // Activate signal from the midnight\n\t            #tempOnTimeDtl := #tempOnTimeDtl - #DAY_INCREMENT;\n\t          END_IF;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    #MODE_WEEKLY:\n\t      REGION WEEKLY MODE\n\t        // Set the default date\n\t        #tempOnTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempOnTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempOnTimeDtl.DAY := #onWeekday;  // Synchronize DTL.WEEKDAY with date\n\t        \n\t        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);\n\t        \n\t        #tempOffTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempOffTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempOffTimeDtl.DAY := #offWeekday;\n\t        \n\t        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);\n\t        \n\t        #tempActTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempActTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempActTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;\n\t        \n\t        IF #onWeekday > #offWeekday OR\n\t          (#onWeekday = #offWeekday AND #tempOnTimeTod > #tempOffTimeTod) THEN\n\t          #tempOffTimeDtl.DAY := #offWeekday + #DAYS_PER_WEEK;\n\t          \n\t          IF #onWeekday > #tempActTimeDtl.WEEKDAY OR\n\t            (#onWeekday = #offWeekday AND #tempActTimeTod < #tempOffTimeTod) THEN\n\t            #tempActTimeDtl.DAY := #tempActTimeDtl.WEEKDAY + #DAYS_PER_WEEK;\n\t          END_IF;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    #MODE_MONTHLY:\n\t      REGION MONTHLY MODE\n\t        #tempOnTimeDtl.YEAR := #tempActTimeDtl.YEAR;\n\t        #tempOnTimeDtl.MONTH := #tempActTimeDtl.MONTH;\n\t        #tempOnTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;\n\t        #tempOnTimeDtl.DAY := #onDay;\n\t        \n\t        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);\n\t        \n\t        #tempOffTimeDtl.YEAR := #tempActTimeDtl.YEAR;\n\t        #tempOffTimeDtl.MONTH := #tempActTimeDtl.MONTH;\n\t        #tempOffTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;\n\t        #tempOffTimeDtl.DAY := #offDay;\n\t        \n\t        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);\n\t        \n\t        // Timer setting - over new year\n\t        IF #onDay > #offDay OR\n\t          (#onDay = #offDay AND #tempOnTimeTod > #tempOffTimeTod) THEN\n\t          IF #tempActTimeDtl.DAY > #offDay OR\n\t            (#tempActTimeDtl.DAY = #offDay AND #tempActTimeTod > #tempOffTimeTod) THEN\n\t            // Increase the month of the timeOff over new year\n\t            IF #tempOffTimeDtl.MONTH = #MONTH_DECEMBER THEN\n\t              #tempOffTimeDtl.MONTH := #MONTH_JANUARY;\n\t              #tempOffTimeDtl.YEAR := #tempOffTimeDtl.YEAR + #DATE_INCREMENT;\n\t            ELSE\n\t              #tempOffTimeDtl.MONTH := #tempOffTimeDtl.MONTH + #DATE_INCREMENT;\n\t            END_IF;\n\t          ELSE\n\t            // Decrease the month of the timeOn over new year\n\t            IF #tempOnTimeDtl.MONTH = #MONTH_JANUARY THEN\n\t              #tempOnTimeDtl.MONTH := #MONTH_DECEMBER;\n\t              #tempOnTimeDtl.YEAR := #tempOnTimeDtl.YEAR - #DATE_INCREMENT;\n\t            ELSE\n\t              #tempOnTimeDtl.MONTH := #tempOnTimeDtl.MONTH - #DATE_INCREMENT;\n\t            END_IF;\n\t            \n\t          END_IF;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    #MODE_YEARLY:\n\t      REGION YEARLY MODE\n\t        #tempOnTimeDtl.YEAR := #tempActTimeDtl.YEAR;\n\t        #tempOnTimeDtl.MONTH := #onMonth;\n\t        #tempOnTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;\n\t        #tempOnTimeDtl.DAY := #onDay;\n\t        \n\t        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);\n\t        \n\t        #tempOffTimeDtl.YEAR := #tempActTimeDtl.YEAR;\n\t        #tempOffTimeDtl.MONTH := #offMonth;\n\t        #tempOffTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;\n\t        #tempOffTimeDtl.DAY := #offDay;\n\t        \n\t        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);\n\t        \n\t        // Timer setting - over new year\n\t        IF #onMonth > #offMonth OR\n\t          (#onMonth = #offMonth AND #tempOnTimeTod > #tempOffTimeTod) THEN\n\t          IF #tempActTimeDtl.MONTH > #offMonth OR\n\t            (#tempActTimeDtl.MONTH = #offMonth AND #tempActTimeTod > #tempOffTimeTod) THEN\n\t            // Increase the year of the timeOff when new year happens\n\t            #tempOffTimeDtl.YEAR := #tempOffTimeDtl.YEAR + #DATE_INCREMENT;\n\t          ELSE\n\t            // Decrease the year of the timeOn when new year happens\n\t            #tempOnTimeDtl.YEAR := #tempOnTimeDtl.YEAR - #DATE_INCREMENT;\n\t          END_IF;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    #MODE_WEEK_DAYS:  // Working days (Monday - Friday)\n\t      REGION WEEK DAYS MODE  \n\t        #tempOnTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempOnTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempOnTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;\n\t        \n\t        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);\n\t        \n\t        #tempOffTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempOffTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempOffTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;\n\t        \n\t        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);\n\t        \n\t        #tempActTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempActTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempActTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;\n\t        \n\t        // Timer setting - overnight\n\t        IF #tempOnTimeTod > #tempOffTimeTod THEN\n\t          IF #tempActTimeTod > #tempOffTimeTod THEN\n\t            #tempOffTimeDtl := #tempOffTimeDtl + #DAY_INCREMENT;\n\t          ELSE\n\t            #tempOnTimeDtl := #tempOnTimeDtl - #DAY_INCREMENT;\n\t          END_IF;\n\t        END_IF;\n\t        \n\t        IF #tempOnTimeDtl.DAY <= #DAY_MONDAY THEN\n\t          #tempOnTimeDtl.DAY := #DAY_MONDAY;\n\t        ELSIF #tempOnTimeDtl.DAY > #DAY_FRIDAY THEN\n\t          #tempOnTimeDtl.DAY := #DAY_FRIDAY;\n\t        END_IF;\n\t        \n\t        IF #tempOffTimeDtl.DAY > #DAY_FRIDAY AND\n\t          #tempOnTimeTod > #tempOffTimeTod THEN // #tempOffTime > Friday AND crossed midnight\n\t          #tempOffTimeDtl.DAY := #DAY_SATURDAY;\n\t        ELSIF #tempOffTimeDtl.DAY > #DAY_FRIDAY THEN\n\t          #tempOffTimeDtl.DAY := #DAY_FRIDAY;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    #MODE_WEEKEND_DAYS:  // Weekend (Saturday and Sunday)    \n\t      REGION WEEKEND DAYS MODE\n\t        #tempOnTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempOnTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempOnTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;\n\t        \n\t        IF #tempOnTimeDtl.DAY < #DAY_SATURDAY THEN\n\t          #tempOnTimeDtl := #tempOnTimeDtl + #WEEK_INCREMENT;\n\t        END_IF;\n\t        \n\t        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);\n\t        \n\t        #tempOffTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempOffTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempOffTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;\n\t        \n\t        IF #tempOffTimeDtl.DAY < #DAY_SATURDAY THEN\n\t          #tempOffTimeDtl := #tempOffTimeDtl + #WEEK_INCREMENT;\n\t        END_IF;\n\t        \n\t        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);\n\t        \n\t        #tempActTimeDtl.YEAR := #DEFAULT_YEAR;\n\t        #tempActTimeDtl.MONTH := #DEFAULT_MONTH;\n\t        #tempActTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;\n\t        \n\t        IF #tempActTimeDtl.DAY < #DAY_SATURDAY THEN\n\t          #tempActTimeDtl := #tempActTimeDtl + #WEEK_INCREMENT;\n\t        END_IF;\n\t        \n\t        #tempActTimeTod := DTL_TO_TOD(#tempTime);\n\t        \n\t        // Timer setting - overnight\n\t        IF #tempOnTimeTod > #tempOffTimeTod THEN\n\t          IF #tempActTimeTod > #tempOffTimeTod THEN\n\t            #tempOffTimeDtl := #tempOffTimeDtl + #DAY_INCREMENT;\n\t          ELSE\n\t            #tempOnTimeDtl := #tempOnTimeDtl - #DAY_INCREMENT;\n\t          END_IF;\n\t        END_IF;\n\t        \n\t        IF #tempOnTimeDtl.DAY < #DAY_SATURDAY THEN\n\t          #tempOnTimeDtl.DAY := #DAY_SATURDAY;\n\t        ELSIF #tempOnTimeDtl.DAY > #DAY_NEXT_SUNDAY THEN\n\t          #tempOnTimeDtl.DAY := #DAY_NEXT_SUNDAY;\n\t        END_IF;\n\t        \n\t        IF #tempOffTimeDtl.DAY > #DAY_NEXT_SUNDAY AND\n\t          #tempOnTimeTod > #tempOffTimeTod THEN // #tempOffTime.DAY > Sunday AND crossed midnight\n\t          #tempOffTimeDtl.DAY := #DAY_NEXT_MONDAY;\n\t        ELSIF #tempOffTimeDtl.DAY > #DAY_NEXT_SUNDAY THEN\n\t          #tempOffTimeDtl.DAY := #DAY_NEXT_SUNDAY;\n\t        END_IF;\n\t      END_REGION\n\t      \n\t    #MODE_PERMANENTLY_ON:\n\t      REGION PERMANENTLY ON\n\t        ;\n\t      END_REGION\n\t      \n\t    #MODE_PERMANENTLY_OFF:\n\t      REGION PERMANENTLY ON\n\t        ;\n\t      END_REGION\n\t      \n\t    ELSE\n\t      #signal := FALSE;\n\t      #actLocalTime := #CLEAR_DTL;\n\t      #error := TRUE;\n\t      #status := #ERR_NO_MODE_SELECTED;\n\t      #subFunctionStatus := USINT_TO_WORD(#mode);\n\t      RETURN;\n\t  END_CASE;\n\tEND_REGION\n\t\n\tREGION OUTPUT\n\t  #actLocalTime := #tempTime;\n\t  #signal := ((#tempActTimeDtl >= #tempOnTimeDtl) AND (#tempActTimeDtl < #tempOffTimeDtl) AND ((#mode <> #MODE_PERMANENTLY_OFF))) OR (#mode = #MODE_PERMANENTLY_ON);\n\t  \n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  #subFunctionStatus := #STATUS_NO_ERROR;\n\t  \n\t  // ENO is not used, forced to TRUE\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "IsParityOdd", "description": "The function checks whether the parity of the input variable of type DWord is odd. The return value is set to TRUE if the number of bits that are assigned TRUE in the sequence is odd.", "type": "FUNCTION", "name": "LGF_IsParityOdd", "vars": [{"name": "doubleWord", "type": "DWord", "description": "Variable for which the parity is to be determined."}, {"name": "Ret_Val", "type": "Bool", "description": "TRUE: When the number of bits that are assigned `TRUE` is odd"}], "input": [{"name": "doubleWord", "type": "DWord", "description": "Variable for which the parity is to be determined."}], "output": [], "in/out": [], "answer": "FUNCTION \"LGF_IsParityOdd\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_SIMATIC_Systems_Support\nFAMILY : LGF\nNAME : LGF_IsParityOdd\n   VAR_INPUT \n      doubleWord : DWord;\n   END_VAR\n\n   VAR_TEMP \n      tempDword : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      SHIFT_ONE_BIT : USInt := 1;\n      SHIFT_TWO_BIT : USInt := 2;\n      SHIFT_TO_RESULT : USInt := 28;\n      MASK_FOR_RESULT : DWord := 16#11111111;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //============================================================================\n\t  // SIEMENS AG / (c)Copyright 2018\n\t  //----------------------------------------------------------------------------\n\t  // Title:            LGF_IsParityOdd\n\t  // Comment/Function: check if parity in input tag is odd\n\t  //                   if number of bits is odd, return TRUE\n\t  //                   https://graphics.stanford.edu/~seander/bithacks.html#ParityMultiply\n\t  //                   ENO not needed, no error possible\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO not needed, no error possible\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 | 2019.11.28 | Simatic Systems Support\n\t  //                         First released version\n\t  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0\n\t  //                         harmonize the version of the whole library\n\t  // 03.00.01 | 12.11.2020 | Simatic Systems Support\n\t  //                         Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Logic\n\t  #tempDword := #doubleWord; // 32-bit word\n\t  #tempDword := #tempDword XOR SHR(IN := #tempDword, N := #SHIFT_ONE_BIT);\n\t  #tempDword := #tempDword XOR SHR(IN := #tempDword, N := #SHIFT_TWO_BIT);\n\t  \n\t  #tempDword := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempDword AND #MASK_FOR_RESULT) * DWORD_TO_UDINT(#MASK_FOR_RESULT));\n\t  \n\t  #tempDword := SHR(IN := #tempDword, N := #SHIFT_TO_RESULT);\n\t  \n\t  // result is stored in LSB\n\t  #LGF_IsParityOdd := #tempDword.%X0;\n\t  \n\t  // eno not needed, no error possible\n\t  ENO := FALSE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "IsValueInLimits", "description": "The function checks whether a value is within a defined value range. The value range is defined with a lower and an upper limit.", "type": "FUNCTION", "name": "LGF_IsValueInLimits", "vars": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined\nvalue range"}, {"name": "lowLimit", "type": "LReal", "description": "Low limit where the value is checked against to be greater"}, {"name": "highLimit", "type": "LReal", "description": "High limit where the value is checked against to to be less"}, {"name": "Ret_Val", "type": "Bool", "description": "Return: TRUE if the “value” is in the value range (range of the setpoint)"}, {"name": "overHighLimit", "type": "Bool", "description": "TRUE if the “value” is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the “value” is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "input": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined\nvalue range"}, {"name": "lowLimit", "type": "LReal", "description": "Low limit where the value is checked against to be greater"}, {"name": "highLimit", "type": "LReal", "description": "High limit where the value is checked against to to be less"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the “value” is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the “value” is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error\nTRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB\n16#8000-16#FFFF: Error identification (see following Table)"}], "in/out": [], "answer": "FUNCTION \"LGF_IsValueInLimits\" : Bool\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_IsValueInLimits\n   VAR_INPUT \n      value : LReal;\n      lowLimit : LReal;\n      highLimit : LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      overHighLimit : Bool;\n      belowLowLimit : Bool;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempValueOverHighLimit : Bool;\n      tempValueUnderLowLimit : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_RANGE_HIGH_BELOW_LOW_LIMIT : Word := 16#8401;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // SIEMENS AG / (c)Copyright 2017\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_IsValueInLimits\n\t  // Comment/Function: Checks if a given value is within specified limits\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 10.12.2019  Siemens Industry Support\n\t  //                      First released version\n\t  //                      Copied from \"IsValueInRange\"\n\t  // 03.00.00 23.04.2020  Siemens Industry Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 12.11.2020  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and limits check\n\t  // check if high limit is less then low limit\n\t  IF #highLimit < #lowLimit THEN\n\t    #error := true;\n\t    #status := #ERR_RANGE_HIGH_BELOW_LOW_LIMIT;\n\t    #overHighLimit := false;\n\t    #belowLowLimit := false;\n\t    #LGF_IsValueInLimits := false;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Limits evaluation\n\t  // Check if the value is higher then the high limit\n\t  #tempValueOverHighLimit := #value > #highLimit;\n\t  \n\t  // Check if the value is lower then the low limit\n\t  #tempValueUnderLowLimit := #value < #lowLimit;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t  // Check if the value is in range and write outputs\n\t  #LGF_IsValueInLimits := NOT (#tempValueOverHighLimit OR #tempValueUnderLowLimit);\n\t  #overHighLimit := #tempValueOverHighLimit;\n\t  #belowLowLimit := #tempValueUnderLowLimit;\n\t  \n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Bool"}]}
{"title": "PulseRelay", "description": "This block corresponds to an impulse relay or a toggle flip-flop including set and reset input. Pulse relay, Surge relay, Toggle-Flip-Flop, Frequency divider reset is leading / prior to set or trigger", "type": "FUNCTION_BLOCK", "name": "LGF_PulseRelay", "vars": [{"name": "trigger", "type": "Bool", "description": "Trigger to toggle output signal (rising edge)"}, {"name": "set", "type": "Bool", "description": "Set output signal. rising edge"}, {"name": "reset", "type": "Bool", "description": "Reset signal, rising edge (prior to set)"}, {"name": "out", "type": "Bool", "description": "Ooutput signal"}], "input": [{"name": "trigger", "type": "Bool", "description": "Trigger to toggle output signal (rising edge)"}, {"name": "set", "type": "Bool", "description": "Set output signal. rising edge"}, {"name": "reset", "type": "Bool", "description": "Reset signal, rising edge (prior to set)"}], "output": [{"name": "out", "type": "Bool", "description": "Ooutput signal"}], "in/out": [], "answer": "FUNCTION_BLOCK \"LGF_PulseRelay\"\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_PulseRelay\n   VAR_INPUT \n      trigger : Bool;\n      set : Bool;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      out { ExternalWritable := 'False'} : Bool;\n   END_VAR\n\n   VAR \n      statTriggerOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;\n      statSetOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;\n      statResetOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;\n      statOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_PulseRelay\n\t  // Comment/Function: Pulse relay, Surge relay, Toggle-Flip-Flop, Frequency divider\n\t  //                   Reset is leading / prior to Set or Trigger\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry\n\t  // Tested with:      CPU1212C DC/DC/DC FW:V4.2\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO not in use, set to true, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  // 01.00.00 06.06.2015 Siemens Industry Online Support\n\t  //                     First released version\n\t  // 01.00.01 02.01.2017 Siemens Industry Online Support\n\t  //                     Upgrade: TIA V14 Update 1\n\t  // 01.00.02 02.01.2017 Siemens Industry Online Support\n\t  //                     Comment correction                  \n\t  // 01.00.03 17.08.2018 Siemens Industry Online Support\n\t  //                     Upgrade: TIA V15 Update 2\n\t  // 01.00.04 23.11.2018 Siemens Industry Online Support\n\t  //                     Upgrade: TIA V15.1\n\t  // 01.00.05 24.05.2019 Simatic Systems Support\n\t  //                     Refactoring and performance improvement\n\t  //                     add ENO handling\n\t  // 03.00.00 23.04.2020 Simatic Systems Support\n\t  //                     Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 19.01.2021 Simatic Systems Support\n\t  //                     Insert documentation\n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION PROGRAM LOGIC\n\t  REGION toggle output\n\t    // Scan for rising edge \"trigger\"  - toggle static Output\n\t    IF #trigger AND NOT #statTriggerOld THEN\n\t      // toggle static output memory\n\t      #statOut := NOT #statOut;\n\t    END_IF;\n\t    // store trigger input for edge dedection\n\t    #statTriggerOld := #trigger;\n\t  END_REGION\n\t  \n\t  REGION set output\n\t    // Scan for rising edge \"set\" - static Output: set\n\t    IF #set AND NOT #statSetOld THEN\n\t      // set static output memory\n\t      #statOut := TRUE;\n\t    END_IF;\n\t    // store set input for edge dedection\n\t    #statSetOld := #set;\n\t  END_REGION\n\t  \n\t  REGION reset output    \n\t    // Scan for rising edge \"reset\" - static Output: reset\n\t    IF #reset AND NOT #statResetOld THEN\n\t      // store trigger input for edge dedection\n\t      #statOut := FALSE;\n\t    END_IF;\n\t    // store reset input for edge dedection\n\t    #statResetOld := #reset;\n\t  END_REGION\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  // write the Output value\n\t  #out := #statOut;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK", "return_value": []}
{"title": "SearchMinMax", "description": "This function searches, in an array of the data type UDInt, for the maximum and minimum value and the respective index in the array.", "type": "FUNCTION", "name": "LGF_SearchMinMax_UDInt", "vars": [{"name": "Ret_Val", "type": "Void", "description": "Void - Function has no return value"}, {"name": "minValue", "type": "UDInt", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array.\nThe start index of the array plus `minValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "maxValue", "type": "UDInt", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array.\nThe start index of the array plus `maxValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "values", "type": "Array[*] of UDInt", "description": "Array in whose fields the maximum and minimum are searched"}], "input": [], "output": [{"name": "minValue", "type": "UDInt", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array.\nThe start index of the array plus `minValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}, {"name": "maxValue", "type": "UDInt", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array.\nThe start index of the array plus `maxValueIndex` results in the array\nindex of the smallest value. The index starts with 0."}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "Array in whose fields the maximum and minimum are searched"}], "answer": "FUNCTION \"LGF_SearchMinMax_UDInt\" : Void\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industries\nFAMILY : LGF\nNAME : LGF_SearchMinMax_DInt\n   VAR_OUTPUT \n      minValue : UDInt;\n      minValueIndex : DInt;\n      maxValue : UDInt;\n      maxValueIndex : DInt;\n   END_VAR\n\n   VAR_IN_OUT \n      values : Array[*] of UDInt;\n   END_VAR\n\n   VAR_TEMP \n      tempArrayLowerBound : DInt;\n      tempArrayUpperBound : DInt;\n      tempCounter : DInt;\n      tempArrayIndexMax : DInt;\n      tempArrayIndexMin : DInt;\n      tempActValue : UDInt;\n      tempMinValue : UDInt;\n      tempMaxValue : UDInt;\n   END_VAR\n\n   VAR CONSTANT \n      START_FROM_SECOND_ELEMENT : Int := 1;\n      DIMENSION_ONE : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Siemens AG / (c)Copyright 2019\n\t  //-----------------------------------------------------------------------------\n\t  // Title:            LGF_SearchMinMax_DInt\n\t  // Comment/Function: Searches an array for the minimum and maximum number and\n\t  //                   outputs the position and values of those numbers for\n\t  //                   array of unsigned double integers\n\t  // Library/Family:   LGF(Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15 Update 2\n\t  // Restrictions:     ENO disabled - Error handling not needed, using whole array\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  // Change log table:\n\t  // Version  | Date       | Expert in charge       | Changes applied\n\t  //----------|------------|------------------------|------------------------------\n\t  // 01.00.00 11.11.2019  Simatic Systems Support\n\t  //                      First release\n\t  //                      copied from \"LGF_SearchMinMax\" and reworked to array[*]\n\t  // 03.00.00 23.04.2020  Simatic Systems Support\n\t  //                      Set version to V3.0.0, harmonize the version of the whole library\n\t  // 03.00.01 09.02.2021  Simatic Systems Support\n\t  //                      Insert documentation\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Validation of inputs and outputs \n\t  // Lower bound\n\t  #tempArrayLowerBound := LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t  // Upper bound \n\t  #tempArrayUpperBound := UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\tEND_REGION\n\t\n\tREGION Searching the array \n\t  //Assign first value as min / max\n\t  #tempMaxValue := #values[#tempArrayLowerBound];\n\t  #tempMinValue := #tempMaxValue;\n\t  \n\t  //Search the Array for min/max values\n\t  FOR #tempCounter := (#tempArrayLowerBound + #START_FROM_SECOND_ELEMENT) TO #tempArrayUpperBound DO\n\t    \n\t    #tempActValue := #values[#tempCounter];\n\t    \n\t    // check for min\n\t    IF #tempActValue < #tempMinValue THEN\n\t      #tempMinValue := #tempActValue;\n\t      #tempArrayIndexMin := #tempCounter;\n\t      // check for max\n\t    ELSIF #tempActValue > #tempMaxValue THEN\n\t      #tempMaxValue := #tempActValue;\n\t      #tempArrayIndexMax := #tempCounter;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  //Copy found values to outputs\n\t  //Copy Minimum value\n\t  #minValue := #values[#tempArrayIndexMin];\n\t  //Copy Maximum value\n\t  #maxValue := #values[#tempArrayIndexMax];\n\t  \n\t  //Write found indexes to outputs\n\t  #minValueIndex := #tempArrayIndexMin;\n\t  #maxValueIndex := #tempArrayIndexMax;\n\t  \n\t  //ENO mechanism is not used, no error possible\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION", "return_value": [{"type": "Void"}]}
